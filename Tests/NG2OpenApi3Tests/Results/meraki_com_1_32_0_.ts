import { Injectable, Inject } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse } from '@angular/common/http';
import { Observable } from 'rxjs';
import { FormControl, FormGroup, Validators } from '@angular/forms';
export namespace MyNS {
	export interface CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterface {

		/** The next hop for any traffic that isn't going to a directly connected subnet or over a static route.         This IP address must exist in a subnet with a routed interface. Required if this is the first IPv4 interface. */
		defaultGateway?: string | null;

		/** The IP address this switch will use for layer 3 routing on this VLAN or subnet. This cannot be the same         as the switch's management IP. */
		interfaceIp?: string | null;

		/** The IPv6 settings of the interface. */
		ipv6?: CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceIpv6;

		/** Enable multicast support if, multicast routing between VLANs is required. Options are:         'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'. */
		multicastRouting?: CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceMulticastRouting | null;

		/** A friendly name or description for the interface or VLAN. */
		name?: string | null;

		/** The OSPF routing settings of the interface. */
		ospfSettings?: CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfSettings;

		/** The OSPFv3 routing settings of the interface. */
		ospfV3?: CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfV3;

		/** The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24). */
		subnet?: string | null;

		/** The VLAN this routed interface is on. VLAN must be between 1 and 4094. */
		vlanId?: number | null;
	}
	export interface CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceFormProperties {

		/** The next hop for any traffic that isn't going to a directly connected subnet or over a static route.         This IP address must exist in a subnet with a routed interface. Required if this is the first IPv4 interface. */
		defaultGateway: FormControl<string | null | undefined>,

		/** The IP address this switch will use for layer 3 routing on this VLAN or subnet. This cannot be the same         as the switch's management IP. */
		interfaceIp: FormControl<string | null | undefined>,

		/** Enable multicast support if, multicast routing between VLANs is required. Options are:         'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'. */
		multicastRouting: FormControl<CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceMulticastRouting | null | undefined>,

		/** A friendly name or description for the interface or VLAN. */
		name: FormControl<string | null | undefined>,

		/** The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24). */
		subnet: FormControl<string | null | undefined>,

		/** The VLAN this routed interface is on. VLAN must be between 1 and 4094. */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateCreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceFormGroup() {
		return new FormGroup<CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceFormProperties>({
			defaultGateway: new FormControl<string | null | undefined>(undefined),
			interfaceIp: new FormControl<string | null | undefined>(undefined),
			multicastRouting: new FormControl<CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceMulticastRouting | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceIpv6 {

		/** The IPv6 address of the interface. Required if assignmentMode is 'static'. Must not be included if           assignmentMode is 'eui-64'. */
		address?: string | null;

		/** The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'. */
		assignmentMode?: string | null;

		/** The IPv6 default gateway of the interface. Required if prefix is defined and this is the first           interface with IPv6 configured for the switch. */
		gateway?: string | null;

		/** The IPv6 prefix of the interface. Required if IPv6 object is included. */
		prefix?: string | null;
	}
	export interface CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceIpv6FormProperties {

		/** The IPv6 address of the interface. Required if assignmentMode is 'static'. Must not be included if           assignmentMode is 'eui-64'. */
		address: FormControl<string | null | undefined>,

		/** The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'. */
		assignmentMode: FormControl<string | null | undefined>,

		/** The IPv6 default gateway of the interface. Required if prefix is defined and this is the first           interface with IPv6 configured for the switch. */
		gateway: FormControl<string | null | undefined>,

		/** The IPv6 prefix of the interface. Required if IPv6 object is included. */
		prefix: FormControl<string | null | undefined>,
	}
	export function CreateCreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceIpv6FormGroup() {
		return new FormGroup<CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<string | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceMulticastRouting { 'IGMP snooping querier' = 'IGMP snooping querier', disabled = 'disabled', enabled = 'enabled' }

	export interface CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfSettings {

		/** The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPF area. Defaults to 'disabled'. */
		area?: string | null;

		/** The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority. */
		cost?: number | null;

		/** When enabled, OSPF will not run on the interface, but the subnet will still be advertised. */
		isPassiveEnabled?: boolean | null;
	}
	export interface CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfSettingsFormProperties {

		/** The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPF area. Defaults to 'disabled'. */
		area: FormControl<string | null | undefined>,

		/** The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority. */
		cost: FormControl<number | null | undefined>,

		/** When enabled, OSPF will not run on the interface, but the subnet will still be advertised. */
		isPassiveEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfSettingsFormGroup() {
		return new FormGroup<CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfSettingsFormProperties>({
			area: new FormControl<string | null | undefined>(undefined),
			cost: new FormControl<number | null | undefined>(undefined),
			isPassiveEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfV3 {

		/** The OSPFv3 area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPFv3 area. Defaults to 'disabled'. */
		area?: string | null;

		/** The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority. */
		cost?: number | null;

		/** When enabled, OSPFv3 will not run on the interface, but the subnet will still be advertised. */
		isPassiveEnabled?: boolean | null;
	}
	export interface CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfV3FormProperties {

		/** The OSPFv3 area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPFv3 area. Defaults to 'disabled'. */
		area: FormControl<string | null | undefined>,

		/** The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority. */
		cost: FormControl<number | null | undefined>,

		/** When enabled, OSPFv3 will not run on the interface, but the subnet will still be advertised. */
		isPassiveEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfV3FormGroup() {
		return new FormGroup<CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfV3FormProperties>({
			area: new FormControl<string | null | undefined>(undefined),
			cost: new FormControl<number | null | undefined>(undefined),
			isPassiveEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface CreateDeviceSwitchRoutingStaticRouteCreatedeviceswitchroutingstaticroute {

		/** Option to advertise static route via OSPF */
		advertiseViaOspfEnabled?: boolean | null;

		/** Name or description for layer 3 static route */
		name?: string | null;

		/**
		 * IP address of the next hop device to which the device sends its traffic for the subnet
		 * Required
		 */
		nextHopIp: string;

		/** Option to prefer static route over OSPF routes */
		preferOverOspfRoutesEnabled?: boolean | null;

		/**
		 * The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)
		 * Required
		 */
		subnet: string;
	}
	export interface CreateDeviceSwitchRoutingStaticRouteCreatedeviceswitchroutingstaticrouteFormProperties {

		/** Option to advertise static route via OSPF */
		advertiseViaOspfEnabled: FormControl<boolean | null | undefined>,

		/** Name or description for layer 3 static route */
		name: FormControl<string | null | undefined>,

		/**
		 * IP address of the next hop device to which the device sends its traffic for the subnet
		 * Required
		 */
		nextHopIp: FormControl<string | null | undefined>,

		/** Option to prefer static route over OSPF routes */
		preferOverOspfRoutesEnabled: FormControl<boolean | null | undefined>,

		/**
		 * The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)
		 * Required
		 */
		subnet: FormControl<string | null | undefined>,
	}
	export function CreateCreateDeviceSwitchRoutingStaticRouteCreatedeviceswitchroutingstaticrouteFormGroup() {
		return new FormGroup<CreateDeviceSwitchRoutingStaticRouteCreatedeviceswitchroutingstaticrouteFormProperties>({
			advertiseViaOspfEnabled: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			nextHopIp: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			preferOverOspfRoutesEnabled: new FormControl<boolean | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroup {

		/** The devices and Switch Stacks assigned to the Group */
		assignedDevices?: CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevices;

		/** Description of the Staged Upgrade Group. Length must be 1 to 255 characters */
		description?: string | null;

		/**
		 * Boolean indicating the default Group. Any device that does not have a group explicitly assigned will upgrade with this group
		 * Required
		 */
		isDefault: boolean;

		/**
		 * Name of the Staged Upgrade Group. Length must be 1 to 255 characters
		 * Required
		 */
		name: string;
	}
	export interface CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupFormProperties {

		/** Description of the Staged Upgrade Group. Length must be 1 to 255 characters */
		description: FormControl<string | null | undefined>,

		/**
		 * Boolean indicating the default Group. Any device that does not have a group explicitly assigned will upgrade with this group
		 * Required
		 */
		isDefault: FormControl<boolean | null | undefined>,

		/**
		 * Name of the Staged Upgrade Group. Length must be 1 to 255 characters
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			isDefault: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevices {

		/** Data Array of Devices containing the name and serial */
		CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesDevices?: Array<CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesDevices>;

		/** Data Array of Switch Stacks containing the name and id */
		CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesSwitchStacks?: Array<CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesSwitchStacks>;
	}
	export interface CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesFormProperties {
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesFormProperties>({
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesDevices {

		/** Name of the device */
		name?: string | null;

		/**
		 * Serial of the device
		 * Required
		 */
		serial: string;
	}
	export interface CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesDevicesFormProperties {

		/** Name of the device */
		name: FormControl<string | null | undefined>,

		/**
		 * Serial of the device
		 * Required
		 */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesDevicesFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesDevicesFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesSwitchStacks {

		/**
		 * ID of the Switch Stack
		 * Required
		 */
		id: string;

		/** Name of the Switch Stack */
		name?: string | null;
	}
	export interface CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesSwitchStacksFormProperties {

		/**
		 * ID of the Switch Stack
		 * Required
		 */
		id: FormControl<string | null | undefined>,

		/** Name of the Switch Stack */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesSwitchStacksFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesSwitchStacksFormProperties>({
			id: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSmTargetGroupCreatenetworksmtargetgroup {

		/** The name of this target group */
		name?: string | null;

		/** The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty. */
		scope?: string | null;
	}
	export interface CreateNetworkSmTargetGroupCreatenetworksmtargetgroupFormProperties {

		/** The name of this target group */
		name: FormControl<string | null | undefined>,

		/** The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty. */
		scope: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSmTargetGroupCreatenetworksmtargetgroupFormGroup() {
		return new FormGroup<CreateNetworkSmTargetGroupCreatenetworksmtargetgroupFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			scope: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceSwitchRoutingStaticRouteUpdatedeviceswitchroutingstaticroute {

		/** Option to advertise static route via OSPF */
		advertiseViaOspfEnabled?: boolean | null;

		/** Name or description for layer 3 static route */
		name?: string | null;

		/** IP address of the next hop device to which the device sends its traffic for the subnet */
		nextHopIp?: string | null;

		/** Option to prefer static route over OSPF routes */
		preferOverOspfRoutesEnabled?: boolean | null;

		/** The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24) */
		subnet?: string | null;
	}
	export interface UpdateDeviceSwitchRoutingStaticRouteUpdatedeviceswitchroutingstaticrouteFormProperties {

		/** Option to advertise static route via OSPF */
		advertiseViaOspfEnabled: FormControl<boolean | null | undefined>,

		/** Name or description for layer 3 static route */
		name: FormControl<string | null | undefined>,

		/** IP address of the next hop device to which the device sends its traffic for the subnet */
		nextHopIp: FormControl<string | null | undefined>,

		/** Option to prefer static route over OSPF routes */
		preferOverOspfRoutesEnabled: FormControl<boolean | null | undefined>,

		/** The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24) */
		subnet: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchRoutingStaticRouteUpdatedeviceswitchroutingstaticrouteFormGroup() {
		return new FormGroup<UpdateDeviceSwitchRoutingStaticRouteUpdatedeviceswitchroutingstaticrouteFormProperties>({
			advertiseViaOspfEnabled: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			nextHopIp: new FormControl<string | null | undefined>(undefined),
			preferOverOspfRoutesEnabled: new FormControl<boolean | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrules {

		/** An ordered array of the firewall rules (not including the default rule) */
		UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRules?: Array<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRules>;
	}
	export interface UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesFormProperties {
	}
	export function CreateUpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRules {

		/** Description of the rule (optional) */
		comment?: string | null;

		/**
		 * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
		 * Required
		 */
		destCidr: string;

		/** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */
		destPort?: string | null;

		/**
		 * 'allow' or 'deny' traffic specified by this rule
		 * Required
		 */
		policy: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy;

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		 * Required
		 */
		protocol: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol;

		/**
		 * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
		 * Required
		 */
		srcCidr: string;

		/** Comma-separated list of source port(s) (integer in the range 1-65535), or 'any' */
		srcPort?: string | null;

		/** Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional) */
		syslogEnabled?: boolean | null;
	}
	export interface UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesFormProperties {

		/** Description of the rule (optional) */
		comment: FormControl<string | null | undefined>,

		/**
		 * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
		 * Required
		 */
		destCidr: FormControl<string | null | undefined>,

		/** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */
		destPort: FormControl<string | null | undefined>,

		/**
		 * 'allow' or 'deny' traffic specified by this rule
		 * Required
		 */
		policy: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>,

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		 * Required
		 */
		protocol: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>,

		/**
		 * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
		 * Required
		 */
		srcCidr: FormControl<string | null | undefined>,

		/** Comma-separated list of source port(s) (integer in the range 1-65535), or 'any' */
		srcPort: FormControl<string | null | undefined>,

		/** Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional) */
		syslogEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			destCidr: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			destPort: new FormControl<string | null | undefined>(undefined),
			policy: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>(undefined, [Validators.required]),
			protocol: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>(undefined, [Validators.required]),
			srcCidr: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			srcPort: new FormControl<string | null | undefined>(undefined),
			syslogEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy { allow = 'allow', deny = 'deny' }

	export enum UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol { any = 'any', icmp = 'icmp', icmp6 = 'icmp6', tcp = 'tcp', udp = 'udp' }

	export interface UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrules {

		/** An ordered array of the firewall rules (not including the default rule) */
		UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRules?: Array<UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRules>;

		/** Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional) */
		syslogDefaultRule?: boolean | null;
	}
	export interface UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesFormProperties {

		/** Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional) */
		syslogDefaultRule: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesFormProperties>({
			syslogDefaultRule: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRules {

		/** Description of the rule (optional) */
		comment?: string | null;

		/**
		 * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
		 * Required
		 */
		destCidr: string;

		/** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */
		destPort?: string | null;

		/**
		 * 'allow' or 'deny' traffic specified by this rule
		 * Required
		 */
		policy: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy;

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		 * Required
		 */
		protocol: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol;

		/**
		 * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
		 * Required
		 */
		srcCidr: string;

		/** Comma-separated list of source port(s) (integer in the range 1-65535), or 'any' */
		srcPort?: string | null;

		/** Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional) */
		syslogEnabled?: boolean | null;
	}
	export interface UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesFormProperties {

		/** Description of the rule (optional) */
		comment: FormControl<string | null | undefined>,

		/**
		 * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
		 * Required
		 */
		destCidr: FormControl<string | null | undefined>,

		/** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */
		destPort: FormControl<string | null | undefined>,

		/**
		 * 'allow' or 'deny' traffic specified by this rule
		 * Required
		 */
		policy: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>,

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		 * Required
		 */
		protocol: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>,

		/**
		 * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
		 * Required
		 */
		srcCidr: FormControl<string | null | undefined>,

		/** Comma-separated list of source port(s) (integer in the range 1-65535), or 'any' */
		srcPort: FormControl<string | null | undefined>,

		/** Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional) */
		syslogEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRulesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			destCidr: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			destPort: new FormControl<string | null | undefined>(undefined),
			policy: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>(undefined, [Validators.required]),
			protocol: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>(undefined, [Validators.required]),
			srcCidr: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			srcPort: new FormControl<string | null | undefined>(undefined),
			syslogEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	@Injectable()
	export class MyClient {
		constructor(@Inject('baseUri') private baseUri: string = location.protocol + '//' + location.hostname + (location.port ? ':' + location.port : '') + '/', private http: HttpClient) {
		}

		/**
		 * Returns the identity of the current user.
		 * Returns the identity of the current user.
		 * Get administered/identities/me
		 * @return {GetAdministeredIdentitiesMeReturn} Successful operation
		 */
		GetAdministeredIdentitiesMe(): Observable<GetAdministeredIdentitiesMeReturn> {
			return this.http.get<GetAdministeredIdentitiesMeReturn>(this.baseUri + 'administered/identities/me', {});
		}

		/**
		 * Return a single device
		 * Return a single device
		 * Get devices/{serial}
		 * @return {string} Successful operation
		 */
		GetDevice(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)), { responseType: 'text' });
		}

		/**
		 * Update the attributes of a device
		 * Update the attributes of a device
		 * Put devices/{serial}
		 * @return {string} Successful operation
		 */
		UpdateDevice(serial: string, requestBody: UpdateDevicePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the DHCP subnet information for an appliance
		 * Return the DHCP subnet information for an appliance
		 * Get devices/{serial}/appliance/dhcp/subnets
		 * @return {Array<string>} Successful operation
		 */
		GetDeviceApplianceDhcpSubnets(serial: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/appliance/dhcp/subnets', {});
		}

		/**
		 * Return the performance score for a single MX
		 * Return the performance score for a single MX. Only primary MX devices supported. If no data is available, a 204 error code is returned.
		 * Get devices/{serial}/appliance/performance
		 * @return {string} Successful operation
		 */
		GetDeviceAppliancePerformance(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/appliance/performance', { responseType: 'text' });
		}

		/**
		 * Return current delegated IPv6 prefixes on an appliance.
		 * Return current delegated IPv6 prefixes on an appliance.
		 * Get devices/{serial}/appliance/prefixes/delegated
		 * @return {Array<string>} Successful operation
		 */
		GetDeviceAppliancePrefixesDelegated(serial: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/appliance/prefixes/delegated', {});
		}

		/**
		 * Return prefixes assigned to all IPv6 enabled VLANs on an appliance.
		 * Return prefixes assigned to all IPv6 enabled VLANs on an appliance.
		 * Get devices/{serial}/appliance/prefixes/delegated/vlanAssignments
		 * @return {Array<string>} Successful operation
		 */
		GetDeviceAppliancePrefixesDelegatedVlanAssignments(serial: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/appliance/prefixes/delegated/vlanAssignments', {});
		}

		/**
		 * Return the uplink settings for an MX appliance
		 * Return the uplink settings for an MX appliance
		 * Get devices/{serial}/appliance/uplinks/settings
		 * @return {GetDeviceApplianceUplinksSettingsReturn} Successful operation
		 */
		GetDeviceApplianceUplinksSettings(serial: string): Observable<GetDeviceApplianceUplinksSettingsReturn> {
			return this.http.get<GetDeviceApplianceUplinksSettingsReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/appliance/uplinks/settings', {});
		}

		/**
		 * Update the uplink settings for an MX appliance
		 * Update the uplink settings for an MX appliance
		 * Put devices/{serial}/appliance/uplinks/settings
		 * @return {UpdateDeviceApplianceUplinksSettingsReturn} Successful operation
		 */
		UpdateDeviceApplianceUplinksSettings(serial: string, requestBody: UpdateDeviceApplianceUplinksSettingsPutBody): Observable<UpdateDeviceApplianceUplinksSettingsReturn> {
			return this.http.put<UpdateDeviceApplianceUplinksSettingsReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/appliance/uplinks/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Generate a new vMX authentication token
		 * Generate a new vMX authentication token
		 * Post devices/{serial}/appliance/vmx/authenticationToken
		 * @return {void} 
		 */
		CreateDeviceApplianceVmxAuthenticationToken(serial: string): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/appliance/vmx/authenticationToken', null, { observe: 'response', responseType: 'text' });
		}

		/**
		 * Blink the LEDs on a device
		 * Blink the LEDs on a device
		 * Post devices/{serial}/blinkLeds
		 * @return {void} 
		 */
		BlinkDeviceLeds(serial: string, requestBody: BlinkDeviceLedsPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/blinkLeds', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Returns live state from camera of analytics zones
		 * Returns live state from camera of analytics zones
		 * Get devices/{serial}/camera/analytics/live
		 * @return {string} Successful operation
		 */
		GetDeviceCameraAnalyticsLive(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/analytics/live', { responseType: 'text' });
		}

		/**
		 * Returns an overview of aggregate analytics data for a timespan
		 * Returns an overview of aggregate analytics data for a timespan
		 * Get devices/{serial}/camera/analytics/overview
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour.
		 * @param {GetDeviceCameraAnalyticsOverviewObjectType} objectType [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].
		 * @return {Array<string>} Successful operation
		 */
		GetDeviceCameraAnalyticsOverview(serial: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, objectType: GetDeviceCameraAnalyticsOverviewObjectType | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/analytics/overview&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&objectType=' + objectType, {});
		}

		/**
		 * Returns most recent record for analytics zones
		 * Returns most recent record for analytics zones
		 * Get devices/{serial}/camera/analytics/recent
		 * @param {GetDeviceCameraAnalyticsOverviewObjectType} objectType [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].
		 * @return {Array<string>} Successful operation
		 */
		GetDeviceCameraAnalyticsRecent(serial: string, objectType: GetDeviceCameraAnalyticsOverviewObjectType | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/analytics/recent&objectType=' + objectType, {});
		}

		/**
		 * Returns all configured analytic zones for this camera
		 * Returns all configured analytic zones for this camera
		 * Get devices/{serial}/camera/analytics/zones
		 * @return {Array<string>} Successful operation
		 */
		GetDeviceCameraAnalyticsZones(serial: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/analytics/zones', {});
		}

		/**
		 * Return historical records for analytic zones
		 * Return historical records for analytic zones
		 * Get devices/{serial}/camera/analytics/zones/{zoneId}/history
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 14 hours after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 hours. The default is 1 hour.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 60. The default is 60.
		 * @param {GetDeviceCameraAnalyticsOverviewObjectType} objectType [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].
		 * @return {Array<string>} Successful operation
		 */
		GetDeviceCameraAnalyticsZoneHistory(serial: string, zoneId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined, objectType: GetDeviceCameraAnalyticsOverviewObjectType | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/analytics/zones/' + (zoneId == null ? '' : encodeURIComponent(zoneId)) + '/history&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution + '&objectType=' + objectType, {});
		}

		/**
		 * Return custom analytics settings for a camera
		 * Return custom analytics settings for a camera
		 * Get devices/{serial}/camera/customAnalytics
		 * @return {string} Successful operation
		 */
		GetDeviceCameraCustomAnalytics(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/customAnalytics', { responseType: 'text' });
		}

		/**
		 * Update custom analytics settings for a camera
		 * Update custom analytics settings for a camera
		 * Put devices/{serial}/camera/customAnalytics
		 * @return {string} Successful operation
		 */
		UpdateDeviceCameraCustomAnalytics(serial: string, requestBody: UpdateDeviceCameraCustomAnalyticsPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/customAnalytics', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Generate a snapshot of what the camera sees at the specified time and return a link to that image.
		 * Generate a snapshot of what the camera sees at the specified time and return a link to that image.
		 * Post devices/{serial}/camera/generateSnapshot
		 * @return {void} 
		 */
		GenerateDeviceCameraSnapshot(serial: string, requestBody: GenerateDeviceCameraSnapshotPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/generateSnapshot', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Returns quality and retention settings for the given camera
		 * Returns quality and retention settings for the given camera
		 * Get devices/{serial}/camera/qualityAndRetention
		 * @return {string} Successful operation
		 */
		GetDeviceCameraQualityAndRetention(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/qualityAndRetention', { responseType: 'text' });
		}

		/**
		 * Update quality and retention settings for the given camera
		 * Update quality and retention settings for the given camera
		 * Put devices/{serial}/camera/qualityAndRetention
		 * @return {string} Successful operation
		 */
		UpdateDeviceCameraQualityAndRetention(serial: string, requestBody: UpdateDeviceCameraQualityAndRetentionPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/qualityAndRetention', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns sense settings for a given camera
		 * Returns sense settings for a given camera
		 * Get devices/{serial}/camera/sense
		 * @return {string} Successful operation
		 */
		GetDeviceCameraSense(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/sense', { responseType: 'text' });
		}

		/**
		 * Update sense settings for the given camera
		 * Update sense settings for the given camera
		 * Put devices/{serial}/camera/sense
		 * @return {string} Successful operation
		 */
		UpdateDeviceCameraSense(serial: string, requestBody: UpdateDeviceCameraSensePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/sense', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns the MV Sense object detection model list for the given camera
		 * Returns the MV Sense object detection model list for the given camera
		 * Get devices/{serial}/camera/sense/objectDetectionModels
		 * @return {Array<string>} Successful operation
		 */
		GetDeviceCameraSenseObjectDetectionModels(serial: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/sense/objectDetectionModels', {});
		}

		/**
		 * Returns video settings for the given camera
		 * Returns video settings for the given camera
		 * Get devices/{serial}/camera/video/settings
		 * @return {string} Successful operation
		 */
		GetDeviceCameraVideoSettings(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/video/settings', { responseType: 'text' });
		}

		/**
		 * Update video settings for the given camera
		 * Update video settings for the given camera
		 * Put devices/{serial}/camera/video/settings
		 * @return {string} Successful operation
		 */
		UpdateDeviceCameraVideoSettings(serial: string, requestBody: UpdateDeviceCameraVideoSettingsPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/video/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns video link to the specified camera
		 * Returns video link to the specified camera. If a timestamp is supplied, it links to that timestamp.
		 * Get devices/{serial}/camera/videoLink
		 * @param {Date} timestamp [optional] The video link will start at this time. The timestamp should be a string in ISO8601 format. If no timestamp is specified, we will assume current time.
		 * @return {string} Successful operation
		 */
		GetDeviceCameraVideoLink(serial: string, timestamp: Date | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/videoLink&timestamp=' + timestamp?.toISOString(), { responseType: 'text' });
		}

		/**
		 * Returns wireless profile assigned to the given camera
		 * Returns wireless profile assigned to the given camera
		 * Get devices/{serial}/camera/wirelessProfiles
		 * @return {string} Successful operation
		 */
		GetDeviceCameraWirelessProfiles(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/wirelessProfiles', { responseType: 'text' });
		}

		/**
		 * Assign wireless profiles to the given camera
		 * Assign wireless profiles to the given camera. Incremental updates are not supported, all profile assignment need to be supplied at once.
		 * Put devices/{serial}/camera/wirelessProfiles
		 * @return {string} Successful operation
		 */
		UpdateDeviceCameraWirelessProfiles(serial: string, requestBody: UpdateDeviceCameraWirelessProfilesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/camera/wirelessProfiles', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the SIM and APN configurations for a cellular device.
		 * Return the SIM and APN configurations for a cellular device.
		 * Get devices/{serial}/cellular/sims
		 * @return {string} Successful operation
		 */
		GetDeviceCellularSims(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/cellular/sims', { responseType: 'text' });
		}

		/**
		 * Updates the SIM and APN configurations for a cellular device.
		 * Updates the SIM and APN configurations for a cellular device.
		 * Put devices/{serial}/cellular/sims
		 * @return {string} Successful operation
		 */
		UpdateDeviceCellularSims(serial: string, requestBody: UpdateDeviceCellularSimsPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/cellular/sims', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Show the LAN Settings of a MG
		 * Show the LAN Settings of a MG
		 * Get devices/{serial}/cellularGateway/lan
		 * @return {string} Successful operation
		 */
		GetDeviceCellularGatewayLan(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/cellularGateway/lan', { responseType: 'text' });
		}

		/**
		 * Update the LAN Settings for a single MG.
		 * Update the LAN Settings for a single MG.
		 * Put devices/{serial}/cellularGateway/lan
		 * @return {string} Successful operation
		 */
		UpdateDeviceCellularGatewayLan(serial: string, requestBody: UpdateDeviceCellularGatewayLanPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/cellularGateway/lan', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns the port forwarding rules for a single MG.
		 * Returns the port forwarding rules for a single MG.
		 * Get devices/{serial}/cellularGateway/portForwardingRules
		 * @return {string} Successful operation
		 */
		GetDeviceCellularGatewayPortForwardingRules(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/cellularGateway/portForwardingRules', { responseType: 'text' });
		}

		/**
		 * Updates the port forwarding rules for a single MG.
		 * Updates the port forwarding rules for a single MG.
		 * Put devices/{serial}/cellularGateway/portForwardingRules
		 * @return {string} Successful operation
		 */
		UpdateDeviceCellularGatewayPortForwardingRules(serial: string, requestBody: UpdateDeviceCellularGatewayPortForwardingRulesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/cellularGateway/portForwardingRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the clients of a device, up to a maximum of a month ago
		 * List the clients of a device, up to a maximum of a month ago. The usage of each client is returned in kilobytes. If the device is a switch, the switchport is returned; otherwise the switchport field is null.
		 * Get devices/{serial}/clients
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<string>} Successful operation
		 */
		GetDeviceClients(serial: string, t0: string | null | undefined, timespan: number | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/clients&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&timespan=' + timespan, {});
		}

		/**
		 * Enqueue a job to ping a target host from the device
		 * Enqueue a job to ping a target host from the device
		 * Post devices/{serial}/liveTools/ping
		 * @return {void} 
		 */
		CreateDeviceLiveToolsPing(serial: string, requestBody: CreateDeviceLiveToolsPingPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/liveTools/ping', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a ping job
		 * Return a ping job. Latency unit in response is in milliseconds. Size is in bytes.
		 * Get devices/{serial}/liveTools/ping/{id}
		 * @return {GetDeviceLiveToolsPingReturn} Successful operation
		 */
		GetDeviceLiveToolsPing(serial: string, id: string): Observable<GetDeviceLiveToolsPingReturn> {
			return this.http.get<GetDeviceLiveToolsPingReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/liveTools/ping/' + (id == null ? '' : encodeURIComponent(id)), {});
		}

		/**
		 * Enqueue a job to check connectivity status to the device
		 * Enqueue a job to check connectivity status to the device
		 * Post devices/{serial}/liveTools/pingDevice
		 * @return {void} 
		 */
		CreateDeviceLiveToolsPingDevice(serial: string, requestBody: CreateDeviceLiveToolsPingDevicePostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/liveTools/pingDevice', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a ping device job
		 * Return a ping device job. Latency unit in response is in milliseconds. Size is in bytes.
		 * Get devices/{serial}/liveTools/pingDevice/{id}
		 * @return {GetDeviceLiveToolsPingDeviceReturn} Successful operation
		 */
		GetDeviceLiveToolsPingDevice(serial: string, id: string): Observable<GetDeviceLiveToolsPingDeviceReturn> {
			return this.http.get<GetDeviceLiveToolsPingDeviceReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/liveTools/pingDevice/' + (id == null ? '' : encodeURIComponent(id)), {});
		}

		/**
		 * List LLDP and CDP information for a device
		 * List LLDP and CDP information for a device
		 * Get devices/{serial}/lldpCdp
		 * @return {string} Successful operation
		 */
		GetDeviceLldpCdp(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/lldpCdp', { responseType: 'text' });
		}

		/**
		 * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for a wired network device.
		 * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for a wired network device.
		 * Get devices/{serial}/lossAndLatencyHistory
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60.
		 * @param {GetDeviceLossAndLatencyHistoryUplink} uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, cellular. The default is wan1.
		 * @param {string} ip The destination IP used to obtain the requested stats. This is required.
		 * @return {Array<string>} Successful operation
		 */
		GetDeviceLossAndLatencyHistory(serial: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined, uplink: GetDeviceLossAndLatencyHistoryUplink | null | undefined, ip: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/lossAndLatencyHistory&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution + '&uplink=' + uplink + '&ip=' + (ip == null ? '' : encodeURIComponent(ip)), {});
		}

		/**
		 * Return the management interface settings for a device
		 * Return the management interface settings for a device
		 * Get devices/{serial}/managementInterface
		 * @return {string} Successful operation
		 */
		GetDeviceManagementInterface(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/managementInterface', { responseType: 'text' });
		}

		/**
		 * Update the management interface settings for a device
		 * Update the management interface settings for a device
		 * Put devices/{serial}/managementInterface
		 * @return {string} Successful operation
		 */
		UpdateDeviceManagementInterface(serial: string, requestBody: UpdateDeviceManagementInterfacePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/managementInterface', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Reboot a device
		 * Reboot a device
		 * Post devices/{serial}/reboot
		 * @return {void} 
		 */
		RebootDevice(serial: string): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/reboot', null, { observe: 'response', responseType: 'text' });
		}

		/**
		 * List the sensor roles for a given sensor or camera device.
		 * List the sensor roles for a given sensor or camera device.
		 * Get devices/{serial}/sensor/relationships
		 * @return {Array<GetDeviceSensorRelationshipsReturn>} Successful operation
		 */
		GetDeviceSensorRelationships(serial: string): Observable<Array<GetDeviceSensorRelationshipsReturn>> {
			return this.http.get<Array<GetDeviceSensorRelationshipsReturn>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/sensor/relationships', {});
		}

		/**
		 * Assign one or more sensor roles to a given sensor or camera device.
		 * Assign one or more sensor roles to a given sensor or camera device.
		 * Put devices/{serial}/sensor/relationships
		 * @return {UpdateDeviceSensorRelationshipsReturn} Successful operation
		 */
		UpdateDeviceSensorRelationships(serial: string, requestBody: UpdateDeviceSensorRelationshipsPutBody): Observable<UpdateDeviceSensorRelationshipsReturn> {
			return this.http.put<UpdateDeviceSensorRelationshipsReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/sensor/relationships', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the switch ports for a switch
		 * List the switch ports for a switch
		 * Get devices/{serial}/switch/ports
		 * @return {Array<GetDeviceSwitchPortsReturn>} Successful operation
		 */
		GetDeviceSwitchPorts(serial: string): Observable<Array<GetDeviceSwitchPortsReturn>> {
			return this.http.get<Array<GetDeviceSwitchPortsReturn>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/ports', {});
		}

		/**
		 * Cycle a set of switch ports
		 * Cycle a set of switch ports
		 * Post devices/{serial}/switch/ports/cycle
		 * @return {string} Successful operation
		 */
		CycleDeviceSwitchPorts(serial: string, requestBody: CycleDeviceSwitchPortsPostBody): Observable<string> {
			return this.http.post(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/ports/cycle', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the status for all the ports of a switch
		 * Return the status for all the ports of a switch
		 * Get devices/{serial}/switch/ports/statuses
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<GetDeviceSwitchPortsStatusesReturn>} Successful operation
		 */
		GetDeviceSwitchPortsStatuses(serial: string, t0: string | null | undefined, timespan: number | null | undefined): Observable<Array<GetDeviceSwitchPortsStatusesReturn>> {
			return this.http.get<Array<GetDeviceSwitchPortsStatusesReturn>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/ports/statuses&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return the packet counters for all the ports of a switch
		 * Return the packet counters for all the ports of a switch
		 * Get devices/{serial}/switch/ports/statuses/packets
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 1 day. The default is 1 day.
		 * @return {Array<string>} Successful operation
		 */
		GetDeviceSwitchPortsStatusesPackets(serial: string, t0: string | null | undefined, timespan: number | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/ports/statuses/packets&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return a switch port
		 * Return a switch port
		 * Get devices/{serial}/switch/ports/{portId}
		 * @return {GetDeviceSwitchPortReturn} Successful operation
		 */
		GetDeviceSwitchPort(serial: string, portId: string): Observable<GetDeviceSwitchPortReturn> {
			return this.http.get<GetDeviceSwitchPortReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/ports/' + (portId == null ? '' : encodeURIComponent(portId)), {});
		}

		/**
		 * Update a switch port
		 * Update a switch port
		 * Put devices/{serial}/switch/ports/{portId}
		 * @return {UpdateDeviceSwitchPortReturn} Successful operation
		 */
		UpdateDeviceSwitchPort(serial: string, portId: string, requestBody: UpdateDeviceSwitchPortPutBody): Observable<UpdateDeviceSwitchPortReturn> {
			return this.http.put<UpdateDeviceSwitchPortReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/ports/' + (portId == null ? '' : encodeURIComponent(portId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List layer 3 interfaces for a switch
		 * List layer 3 interfaces for a switch. Those for a stack may be found under switch stack routing.
		 * Get devices/{serial}/switch/routing/interfaces
		 * @return {Array<GetDeviceSwitchRoutingInterfacesReturn>} Successful operation
		 */
		GetDeviceSwitchRoutingInterfaces(serial: string): Observable<Array<GetDeviceSwitchRoutingInterfacesReturn>> {
			return this.http.get<Array<GetDeviceSwitchRoutingInterfacesReturn>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/routing/interfaces', {});
		}

		/**
		 * Create a layer 3 interface for a switch
		 * Create a layer 3 interface for a switch
		 * Post devices/{serial}/switch/routing/interfaces
		 * @return {void} 
		 */
		CreateDeviceSwitchRoutingInterface(serial: string, requestBody: CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterface): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/routing/interfaces', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a layer 3 interface from the switch
		 * Delete a layer 3 interface from the switch
		 * Delete devices/{serial}/switch/routing/interfaces/{interfaceId}
		 * @return {void} 
		 */
		DeleteDeviceSwitchRoutingInterface(serial: string, interfaceId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/routing/interfaces/' + (interfaceId == null ? '' : encodeURIComponent(interfaceId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a layer 3 interface for a switch
		 * Return a layer 3 interface for a switch
		 * Get devices/{serial}/switch/routing/interfaces/{interfaceId}
		 * @return {GetDeviceSwitchRoutingInterfaceReturn} Successful operation
		 */
		GetDeviceSwitchRoutingInterface(serial: string, interfaceId: string): Observable<GetDeviceSwitchRoutingInterfaceReturn> {
			return this.http.get<GetDeviceSwitchRoutingInterfaceReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/routing/interfaces/' + (interfaceId == null ? '' : encodeURIComponent(interfaceId)), {});
		}

		/**
		 * Update a layer 3 interface for a switch
		 * Update a layer 3 interface for a switch
		 * Put devices/{serial}/switch/routing/interfaces/{interfaceId}
		 * @return {UpdateDeviceSwitchRoutingInterfaceReturn} Successful operation
		 */
		UpdateDeviceSwitchRoutingInterface(serial: string, interfaceId: string, requestBody: CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterface): Observable<UpdateDeviceSwitchRoutingInterfaceReturn> {
			return this.http.put<UpdateDeviceSwitchRoutingInterfaceReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/routing/interfaces/' + (interfaceId == null ? '' : encodeURIComponent(interfaceId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return a layer 3 interface DHCP configuration for a switch
		 * Return a layer 3 interface DHCP configuration for a switch
		 * Get devices/{serial}/switch/routing/interfaces/{interfaceId}/dhcp
		 * @return {string} Successful operation
		 */
		GetDeviceSwitchRoutingInterfaceDhcp(serial: string, interfaceId: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/routing/interfaces/' + (interfaceId == null ? '' : encodeURIComponent(interfaceId)) + '/dhcp', { responseType: 'text' });
		}

		/**
		 * Update a layer 3 interface DHCP configuration for a switch
		 * Update a layer 3 interface DHCP configuration for a switch
		 * Put devices/{serial}/switch/routing/interfaces/{interfaceId}/dhcp
		 * @return {string} Successful operation
		 */
		UpdateDeviceSwitchRoutingInterfaceDhcp(serial: string, interfaceId: string, requestBody: UpdateDeviceSwitchRoutingInterfaceDhcpPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/routing/interfaces/' + (interfaceId == null ? '' : encodeURIComponent(interfaceId)) + '/dhcp', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List layer 3 static routes for a switch
		 * List layer 3 static routes for a switch
		 * Get devices/{serial}/switch/routing/staticRoutes
		 * @return {Array<string>} Successful operation
		 */
		GetDeviceSwitchRoutingStaticRoutes(serial: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/routing/staticRoutes', {});
		}

		/**
		 * Create a layer 3 static route for a switch
		 * Create a layer 3 static route for a switch
		 * Post devices/{serial}/switch/routing/staticRoutes
		 * @return {void} 
		 */
		CreateDeviceSwitchRoutingStaticRoute(serial: string, requestBody: CreateDeviceSwitchRoutingStaticRouteCreatedeviceswitchroutingstaticroute): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/routing/staticRoutes', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a layer 3 static route for a switch
		 * Delete a layer 3 static route for a switch
		 * Delete devices/{serial}/switch/routing/staticRoutes/{staticRouteId}
		 * @return {void} 
		 */
		DeleteDeviceSwitchRoutingStaticRoute(serial: string, staticRouteId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/routing/staticRoutes/' + (staticRouteId == null ? '' : encodeURIComponent(staticRouteId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a layer 3 static route for a switch
		 * Return a layer 3 static route for a switch
		 * Get devices/{serial}/switch/routing/staticRoutes/{staticRouteId}
		 * @return {GetDeviceSwitchRoutingStaticRouteReturn} Successful operation
		 */
		GetDeviceSwitchRoutingStaticRoute(serial: string, staticRouteId: string): Observable<GetDeviceSwitchRoutingStaticRouteReturn> {
			return this.http.get<GetDeviceSwitchRoutingStaticRouteReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/routing/staticRoutes/' + (staticRouteId == null ? '' : encodeURIComponent(staticRouteId)), {});
		}

		/**
		 * Update a layer 3 static route for a switch
		 * Update a layer 3 static route for a switch
		 * Put devices/{serial}/switch/routing/staticRoutes/{staticRouteId}
		 * @return {string} Successful operation
		 */
		UpdateDeviceSwitchRoutingStaticRoute(serial: string, staticRouteId: string, requestBody: UpdateDeviceSwitchRoutingStaticRouteUpdatedeviceswitchroutingstaticroute): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/routing/staticRoutes/' + (staticRouteId == null ? '' : encodeURIComponent(staticRouteId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return warm spare configuration for a switch
		 * Return warm spare configuration for a switch
		 * Get devices/{serial}/switch/warmSpare
		 * @return {string} Successful operation
		 */
		GetDeviceSwitchWarmSpare(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/warmSpare', { responseType: 'text' });
		}

		/**
		 * Update warm spare configuration for a switch
		 * Update warm spare configuration for a switch. The spare will use the same L3 configuration as the primary. Note that this will irreversibly destroy any existing L3 configuration on the spare.
		 * Put devices/{serial}/switch/warmSpare
		 * @return {string} Successful operation
		 */
		UpdateDeviceSwitchWarmSpare(serial: string, requestBody: UpdateDeviceSwitchWarmSparePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/switch/warmSpare', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the bluetooth settings for a wireless device
		 * Return the bluetooth settings for a wireless device
		 * Get devices/{serial}/wireless/bluetooth/settings
		 * @return {GetDeviceWirelessBluetoothSettingsReturn} Successful operation
		 */
		GetDeviceWirelessBluetoothSettings(serial: string): Observable<GetDeviceWirelessBluetoothSettingsReturn> {
			return this.http.get<GetDeviceWirelessBluetoothSettingsReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/wireless/bluetooth/settings', {});
		}

		/**
		 * Update the bluetooth settings for a wireless device
		 * Update the bluetooth settings for a wireless device
		 * Put devices/{serial}/wireless/bluetooth/settings
		 * @return {UpdateDeviceWirelessBluetoothSettingsReturn} Successful operation
		 */
		UpdateDeviceWirelessBluetoothSettings(serial: string, requestBody: UpdateDeviceWirelessBluetoothSettingsPutBody): Observable<UpdateDeviceWirelessBluetoothSettingsReturn> {
			return this.http.put<UpdateDeviceWirelessBluetoothSettingsReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/wireless/bluetooth/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Aggregated connectivity info for a given AP on this network
		 * Aggregated connectivity info for a given AP on this network
		 * Get devices/{serial}/wireless/connectionStats
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
		 * @param {number} ssid Filter results by SSID
		 * @param {number} vlan Filter results by VLAN
		 * @param {string} apTag Filter results by AP Tag
		 * @return {GetDeviceWirelessConnectionStatsReturn} Successful operation
		 */
		GetDeviceWirelessConnectionStats(serial: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined, vlan: number | null | undefined, apTag: string | null | undefined): Observable<GetDeviceWirelessConnectionStatsReturn> {
			return this.http.get<GetDeviceWirelessConnectionStatsReturn>(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/wireless/connectionStats&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&band=' + band + '&ssid=' + ssid + '&vlan=' + vlan + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)), {});
		}

		/**
		 * Aggregated latency info for a given AP on this network
		 * Aggregated latency info for a given AP on this network
		 * Get devices/{serial}/wireless/latencyStats
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
		 * @param {number} ssid Filter results by SSID
		 * @param {number} vlan Filter results by VLAN
		 * @param {string} apTag Filter results by AP Tag
		 * @param {string} fields Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
		 * @return {string} Successful operation
		 */
		GetDeviceWirelessLatencyStats(serial: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined, vlan: number | null | undefined, apTag: string | null | undefined, fields: string | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/wireless/latencyStats&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&band=' + band + '&ssid=' + ssid + '&vlan=' + vlan + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)) + '&fields=' + (fields == null ? '' : encodeURIComponent(fields)), { responseType: 'text' });
		}

		/**
		 * Return the radio settings of a device
		 * Return the radio settings of a device
		 * Get devices/{serial}/wireless/radio/settings
		 * @return {string} Successful operation
		 */
		GetDeviceWirelessRadioSettings(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/wireless/radio/settings', { responseType: 'text' });
		}

		/**
		 * Update the radio settings of a device
		 * Update the radio settings of a device
		 * Put devices/{serial}/wireless/radio/settings
		 * @return {string} Successful operation
		 */
		UpdateDeviceWirelessRadioSettings(serial: string, requestBody: UpdateDeviceWirelessRadioSettingsPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/wireless/radio/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the SSID statuses of an access point
		 * Return the SSID statuses of an access point
		 * Get devices/{serial}/wireless/status
		 * @return {string} Successful operation
		 */
		GetDeviceWirelessStatus(serial: string): Observable<string> {
			return this.http.get(this.baseUri + 'devices/' + (serial == null ? '' : encodeURIComponent(serial)) + '/wireless/status', { responseType: 'text' });
		}

		/**
		 * Delete a network
		 * Delete a network
		 * Delete networks/{networkId}
		 * @return {void} 
		 */
		DeleteNetwork(networkId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a network
		 * Return a network
		 * Get networks/{networkId}
		 * @return {GetNetworkReturn} Successful operation
		 */
		GetNetwork(networkId: string): Observable<GetNetworkReturn> {
			return this.http.get<GetNetworkReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)), {});
		}

		/**
		 * Update a network
		 * Update a network
		 * Put networks/{networkId}
		 * @return {UpdateNetworkReturn} Successful operation
		 */
		UpdateNetwork(networkId: string, requestBody: UpdateNetworkPutBody): Observable<UpdateNetworkReturn> {
			return this.http.put<UpdateNetworkReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return the alert history for this network
		 * Return the alert history for this network
		 * Get networks/{networkId}/alerts/history
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<GetNetworkAlertsHistoryReturn>} Successful operation
		 */
		GetNetworkAlertsHistory(networkId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<GetNetworkAlertsHistoryReturn>> {
			return this.http.get<Array<GetNetworkAlertsHistoryReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/alerts/history&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Return the alert configuration for this network
		 * Return the alert configuration for this network
		 * Get networks/{networkId}/alerts/settings
		 * @return {string} Successful operation
		 */
		GetNetworkAlertsSettings(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/alerts/settings', { responseType: 'text' });
		}

		/**
		 * Update the alert configuration for this network
		 * Update the alert configuration for this network
		 * Put networks/{networkId}/alerts/settings
		 * @return {string} Successful operation
		 */
		UpdateNetworkAlertsSettings(networkId: string, requestBody: UpdateNetworkAlertsSettingsPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/alerts/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the security events for a client
		 * List the security events for a client. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		 * Get networks/{networkId}/appliance/clients/{clientId}/security/events
		 * @param {string} t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {GetNetworkApplianceClientSecurityEventsSortOrder} sortOrder Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkApplianceClientSecurityEvents(networkId: string, clientId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, sortOrder: GetNetworkApplianceClientSecurityEventsSortOrder | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/clients/' + (clientId == null ? '' : encodeURIComponent(clientId)) + '/security/events&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&sortOrder=' + sortOrder, {});
		}

		/**
		 * Return the connectivity testing destinations for an MX network
		 * Return the connectivity testing destinations for an MX network
		 * Get networks/{networkId}/appliance/connectivityMonitoringDestinations
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceConnectivityMonitoringDestinations(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/connectivityMonitoringDestinations', { responseType: 'text' });
		}

		/**
		 * Update the connectivity testing destinations for an MX network
		 * Update the connectivity testing destinations for an MX network
		 * Put networks/{networkId}/appliance/connectivityMonitoringDestinations
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceConnectivityMonitoringDestinations(networkId: string, requestBody: UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/connectivityMonitoringDestinations', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the content filtering settings for an MX network
		 * Return the content filtering settings for an MX network
		 * Get networks/{networkId}/appliance/contentFiltering
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceContentFiltering(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/contentFiltering', { responseType: 'text' });
		}

		/**
		 * Update the content filtering settings for an MX network
		 * Update the content filtering settings for an MX network
		 * Put networks/{networkId}/appliance/contentFiltering
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceContentFiltering(networkId: string, requestBody: UpdateNetworkApplianceContentFilteringPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/contentFiltering', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List all available content filtering categories for an MX network
		 * List all available content filtering categories for an MX network
		 * Get networks/{networkId}/appliance/contentFiltering/categories
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceContentFilteringCategories(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/contentFiltering/categories', { responseType: 'text' });
		}

		/**
		 * Return the cellular firewall rules for an MX network
		 * Return the cellular firewall rules for an MX network
		 * Get networks/{networkId}/appliance/firewall/cellularFirewallRules
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceFirewallCellularFirewallRules(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/cellularFirewallRules', { responseType: 'text' });
		}

		/**
		 * Update the cellular firewall rules of an MX network
		 * Update the cellular firewall rules of an MX network
		 * Put networks/{networkId}/appliance/firewall/cellularFirewallRules
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceFirewallCellularFirewallRules(networkId: string, requestBody: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrules): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/cellularFirewallRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the appliance services and their accessibility rules
		 * List the appliance services and their accessibility rules
		 * Get networks/{networkId}/appliance/firewall/firewalledServices
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkApplianceFirewallFirewalledServices(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/firewalledServices', {});
		}

		/**
		 * Return the accessibility settings of the given service ('ICMP', 'web', or 'SNMP')
		 * Return the accessibility settings of the given service ('ICMP', 'web', or 'SNMP')
		 * Get networks/{networkId}/appliance/firewall/firewalledServices/{service}
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceFirewallFirewalledService(networkId: string, service: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/firewalledServices/' + (service == null ? '' : encodeURIComponent(service)), { responseType: 'text' });
		}

		/**
		 * Updates the accessibility settings for the given service ('ICMP', 'web', or 'SNMP')
		 * Updates the accessibility settings for the given service ('ICMP', 'web', or 'SNMP')
		 * Put networks/{networkId}/appliance/firewall/firewalledServices/{service}
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceFirewallFirewalledService(networkId: string, service: string, requestBody: UpdateNetworkApplianceFirewallFirewalledServicePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/firewalledServices/' + (service == null ? '' : encodeURIComponent(service)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the inbound cellular firewall rules for an MX network
		 * Return the inbound cellular firewall rules for an MX network
		 * Get networks/{networkId}/appliance/firewall/inboundCellularFirewallRules
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkApplianceFirewallInboundCellularFirewallRules(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/inboundCellularFirewallRules', {});
		}

		/**
		 * Update the inbound cellular firewall rules of an MX network
		 * Update the inbound cellular firewall rules of an MX network
		 * Put networks/{networkId}/appliance/firewall/inboundCellularFirewallRules
		 * @return {Array<string>} Successful operation
		 */
		UpdateNetworkApplianceFirewallInboundCellularFirewallRules(networkId: string, requestBody: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrules): Observable<Array<string>> {
			return this.http.put<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/inboundCellularFirewallRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return the inbound firewall rules for an MX network
		 * Return the inbound firewall rules for an MX network
		 * Get networks/{networkId}/appliance/firewall/inboundFirewallRules
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceFirewallInboundFirewallRules(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/inboundFirewallRules', { responseType: 'text' });
		}

		/**
		 * Update the inbound firewall rules of an MX network
		 * Update the inbound firewall rules of an MX network
		 * Put networks/{networkId}/appliance/firewall/inboundFirewallRules
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceFirewallInboundFirewallRules(networkId: string, requestBody: UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrules): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/inboundFirewallRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the L3 firewall rules for an MX network
		 * Return the L3 firewall rules for an MX network
		 * Get networks/{networkId}/appliance/firewall/l3FirewallRules
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceFirewallL3FirewallRules(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/l3FirewallRules', { responseType: 'text' });
		}

		/**
		 * Update the L3 firewall rules of an MX network
		 * Update the L3 firewall rules of an MX network
		 * Put networks/{networkId}/appliance/firewall/l3FirewallRules
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceFirewallL3FirewallRules(networkId: string, requestBody: UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrules): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/l3FirewallRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the MX L7 firewall rules for an MX network
		 * List the MX L7 firewall rules for an MX network
		 * Get networks/{networkId}/appliance/firewall/l7FirewallRules
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceFirewallL7FirewallRules(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/l7FirewallRules', { responseType: 'text' });
		}

		/**
		 * Update the MX L7 firewall rules for an MX network
		 * Update the MX L7 firewall rules for an MX network
		 * Put networks/{networkId}/appliance/firewall/l7FirewallRules
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceFirewallL7FirewallRules(networkId: string, requestBody: UpdateNetworkApplianceFirewallL7FirewallRulesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/l7FirewallRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the L7 firewall application categories and their associated applications for an MX network
		 * Return the L7 firewall application categories and their associated applications for an MX network
		 * Get networks/{networkId}/appliance/firewall/l7FirewallRules/applicationCategories
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceFirewallL7FirewallRulesApplicationCategories(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/l7FirewallRules/applicationCategories', { responseType: 'text' });
		}

		/**
		 * Return the 1:Many NAT mapping rules for an MX network
		 * Return the 1:Many NAT mapping rules for an MX network
		 * Get networks/{networkId}/appliance/firewall/oneToManyNatRules
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceFirewallOneToManyNatRules(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/oneToManyNatRules', { responseType: 'text' });
		}

		/**
		 * Set the 1:Many NAT mapping rules for an MX network
		 * Set the 1:Many NAT mapping rules for an MX network
		 * Put networks/{networkId}/appliance/firewall/oneToManyNatRules
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceFirewallOneToManyNatRules(networkId: string, requestBody: UpdateNetworkApplianceFirewallOneToManyNatRulesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/oneToManyNatRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the 1:1 NAT mapping rules for an MX network
		 * Return the 1:1 NAT mapping rules for an MX network
		 * Get networks/{networkId}/appliance/firewall/oneToOneNatRules
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceFirewallOneToOneNatRules(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/oneToOneNatRules', { responseType: 'text' });
		}

		/**
		 * Set the 1:1 NAT mapping rules for an MX network
		 * Set the 1:1 NAT mapping rules for an MX network
		 * Put networks/{networkId}/appliance/firewall/oneToOneNatRules
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceFirewallOneToOneNatRules(networkId: string, requestBody: UpdateNetworkApplianceFirewallOneToOneNatRulesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/oneToOneNatRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the port forwarding rules for an MX network
		 * Return the port forwarding rules for an MX network
		 * Get networks/{networkId}/appliance/firewall/portForwardingRules
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceFirewallPortForwardingRules(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/portForwardingRules', { responseType: 'text' });
		}

		/**
		 * Update the port forwarding rules for an MX network
		 * Update the port forwarding rules for an MX network
		 * Put networks/{networkId}/appliance/firewall/portForwardingRules
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceFirewallPortForwardingRules(networkId: string, requestBody: UpdateNetworkApplianceFirewallPortForwardingRulesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/portForwardingRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the firewall settings for this network
		 * Return the firewall settings for this network
		 * Get networks/{networkId}/appliance/firewall/settings
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceFirewallSettings(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/settings', { responseType: 'text' });
		}

		/**
		 * Update the firewall settings for this network
		 * Update the firewall settings for this network
		 * Put networks/{networkId}/appliance/firewall/settings
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceFirewallSettings(networkId: string, requestBody: UpdateNetworkApplianceFirewallSettingsPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/firewall/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List per-port VLAN settings for all ports of a MX.
		 * List per-port VLAN settings for all ports of a MX.
		 * Get networks/{networkId}/appliance/ports
		 * @return {Array<GetNetworkAppliancePortsReturn>} Successful operation
		 */
		GetNetworkAppliancePorts(networkId: string): Observable<Array<GetNetworkAppliancePortsReturn>> {
			return this.http.get<Array<GetNetworkAppliancePortsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/ports', {});
		}

		/**
		 * Return per-port VLAN settings for a single MX port.
		 * Return per-port VLAN settings for a single MX port.
		 * Get networks/{networkId}/appliance/ports/{portId}
		 * @return {GetNetworkAppliancePortReturn} Successful operation
		 */
		GetNetworkAppliancePort(networkId: string, portId: string): Observable<GetNetworkAppliancePortReturn> {
			return this.http.get<GetNetworkAppliancePortReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/ports/' + (portId == null ? '' : encodeURIComponent(portId)), {});
		}

		/**
		 * Update the per-port VLAN settings for a single MX port.
		 * Update the per-port VLAN settings for a single MX port.
		 * Put networks/{networkId}/appliance/ports/{portId}
		 * @return {UpdateNetworkAppliancePortReturn} Successful operation
		 */
		UpdateNetworkAppliancePort(networkId: string, portId: string, requestBody: UpdateNetworkAppliancePortPutBody): Observable<UpdateNetworkAppliancePortReturn> {
			return this.http.put<UpdateNetworkAppliancePortReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/ports/' + (portId == null ? '' : encodeURIComponent(portId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List static delegated prefixes for a network
		 * List static delegated prefixes for a network
		 * Get networks/{networkId}/appliance/prefixes/delegated/statics
		 * @return {Array<GetNetworkAppliancePrefixesDelegatedStaticsReturn>} Successful operation
		 */
		GetNetworkAppliancePrefixesDelegatedStatics(networkId: string): Observable<Array<GetNetworkAppliancePrefixesDelegatedStaticsReturn>> {
			return this.http.get<Array<GetNetworkAppliancePrefixesDelegatedStaticsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/prefixes/delegated/statics', {});
		}

		/**
		 * Add a static delegated prefix from a network
		 * Add a static delegated prefix from a network
		 * Post networks/{networkId}/appliance/prefixes/delegated/statics
		 * @return {void} 
		 */
		CreateNetworkAppliancePrefixesDelegatedStatic(networkId: string, requestBody: CreateNetworkAppliancePrefixesDelegatedStaticPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/prefixes/delegated/statics', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a static delegated prefix from a network
		 * Delete a static delegated prefix from a network
		 * Delete networks/{networkId}/appliance/prefixes/delegated/statics/{staticDelegatedPrefixId}
		 * @return {void} 
		 */
		DeleteNetworkAppliancePrefixesDelegatedStatic(networkId: string, staticDelegatedPrefixId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/prefixes/delegated/statics/' + (staticDelegatedPrefixId == null ? '' : encodeURIComponent(staticDelegatedPrefixId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a static delegated prefix from a network
		 * Return a static delegated prefix from a network
		 * Get networks/{networkId}/appliance/prefixes/delegated/statics/{staticDelegatedPrefixId}
		 * @return {GetNetworkAppliancePrefixesDelegatedStaticReturn} Successful operation
		 */
		GetNetworkAppliancePrefixesDelegatedStatic(networkId: string, staticDelegatedPrefixId: string): Observable<GetNetworkAppliancePrefixesDelegatedStaticReturn> {
			return this.http.get<GetNetworkAppliancePrefixesDelegatedStaticReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/prefixes/delegated/statics/' + (staticDelegatedPrefixId == null ? '' : encodeURIComponent(staticDelegatedPrefixId)), {});
		}

		/**
		 * Update a static delegated prefix from a network
		 * Update a static delegated prefix from a network
		 * Put networks/{networkId}/appliance/prefixes/delegated/statics/{staticDelegatedPrefixId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkAppliancePrefixesDelegatedStatic(networkId: string, staticDelegatedPrefixId: string, requestBody: UpdateNetworkAppliancePrefixesDelegatedStaticPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/prefixes/delegated/statics/' + (staticDelegatedPrefixId == null ? '' : encodeURIComponent(staticDelegatedPrefixId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the security events for a network
		 * List the security events for a network
		 * Get networks/{networkId}/appliance/security/events
		 * @param {string} t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {GetNetworkApplianceClientSecurityEventsSortOrder} sortOrder Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkApplianceSecurityEvents(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, sortOrder: GetNetworkApplianceClientSecurityEventsSortOrder | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/security/events&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&sortOrder=' + sortOrder, {});
		}

		/**
		 * Returns all supported intrusion settings for an MX network
		 * Returns all supported intrusion settings for an MX network
		 * Get networks/{networkId}/appliance/security/intrusion
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceSecurityIntrusion(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/security/intrusion', { responseType: 'text' });
		}

		/**
		 * Set the supported intrusion settings for an MX network
		 * Set the supported intrusion settings for an MX network
		 * Put networks/{networkId}/appliance/security/intrusion
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceSecurityIntrusion(networkId: string, requestBody: UpdateNetworkApplianceSecurityIntrusionPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/security/intrusion', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns all supported malware settings for an MX network
		 * Returns all supported malware settings for an MX network
		 * Get networks/{networkId}/appliance/security/malware
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceSecurityMalware(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/security/malware', { responseType: 'text' });
		}

		/**
		 * Set the supported malware settings for an MX network
		 * Set the supported malware settings for an MX network
		 * Put networks/{networkId}/appliance/security/malware
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceSecurityMalware(networkId: string, requestBody: UpdateNetworkApplianceSecurityMalwarePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/security/malware', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the appliance settings for a network
		 * Return the appliance settings for a network
		 * Get networks/{networkId}/appliance/settings
		 * @return {GetNetworkApplianceSettingsReturn} Successful operation
		 */
		GetNetworkApplianceSettings(networkId: string): Observable<GetNetworkApplianceSettingsReturn> {
			return this.http.get<GetNetworkApplianceSettingsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/settings', {});
		}

		/**
		 * Update the appliance settings for a network
		 * Update the appliance settings for a network
		 * Put networks/{networkId}/appliance/settings
		 * @return {UpdateNetworkApplianceSettingsReturn} Successful operation
		 */
		UpdateNetworkApplianceSettings(networkId: string, requestBody: UpdateNetworkApplianceSettingsPutBody): Observable<UpdateNetworkApplianceSettingsReturn> {
			return this.http.put<UpdateNetworkApplianceSettingsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return single LAN configuration
		 * Return single LAN configuration
		 * Get networks/{networkId}/appliance/singleLan
		 * @return {GetNetworkApplianceSingleLanReturn} Successful operation
		 */
		GetNetworkApplianceSingleLan(networkId: string): Observable<GetNetworkApplianceSingleLanReturn> {
			return this.http.get<GetNetworkApplianceSingleLanReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/singleLan', {});
		}

		/**
		 * Update single LAN configuration
		 * Update single LAN configuration
		 * Put networks/{networkId}/appliance/singleLan
		 * @return {UpdateNetworkApplianceSingleLanReturn} Successful operation
		 */
		UpdateNetworkApplianceSingleLan(networkId: string, requestBody: UpdateNetworkApplianceSingleLanPutBody): Observable<UpdateNetworkApplianceSingleLanReturn> {
			return this.http.put<UpdateNetworkApplianceSingleLanReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/singleLan', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the MX SSIDs in a network
		 * List the MX SSIDs in a network
		 * Get networks/{networkId}/appliance/ssids
		 * @return {Array<GetNetworkApplianceSsidsReturn>} Successful operation
		 */
		GetNetworkApplianceSsids(networkId: string): Observable<Array<GetNetworkApplianceSsidsReturn>> {
			return this.http.get<Array<GetNetworkApplianceSsidsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/ssids', {});
		}

		/**
		 * Return a single MX SSID
		 * Return a single MX SSID
		 * Get networks/{networkId}/appliance/ssids/{number}
		 * @return {GetNetworkApplianceSsidReturn} Successful operation
		 */
		GetNetworkApplianceSsid(networkId: string, number: string): Observable<GetNetworkApplianceSsidReturn> {
			return this.http.get<GetNetworkApplianceSsidReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/ssids/' + (number == null ? '' : encodeURIComponent(number)), {});
		}

		/**
		 * Update the attributes of an MX SSID
		 * Update the attributes of an MX SSID
		 * Put networks/{networkId}/appliance/ssids/{number}
		 * @return {UpdateNetworkApplianceSsidReturn} Successful operation
		 */
		UpdateNetworkApplianceSsid(networkId: string, number: string, requestBody: UpdateNetworkApplianceSsidPutBody): Observable<UpdateNetworkApplianceSsidReturn> {
			return this.http.put<UpdateNetworkApplianceSsidReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/ssids/' + (number == null ? '' : encodeURIComponent(number)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the static routes for an MX or teleworker network
		 * List the static routes for an MX or teleworker network
		 * Get networks/{networkId}/appliance/staticRoutes
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkApplianceStaticRoutes(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/staticRoutes', {});
		}

		/**
		 * Add a static route for an MX or teleworker network
		 * Add a static route for an MX or teleworker network
		 * Post networks/{networkId}/appliance/staticRoutes
		 * @return {void} 
		 */
		CreateNetworkApplianceStaticRoute(networkId: string, requestBody: CreateNetworkApplianceStaticRoutePostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/staticRoutes', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a static route from an MX or teleworker network
		 * Delete a static route from an MX or teleworker network
		 * Delete networks/{networkId}/appliance/staticRoutes/{staticRouteId}
		 * @return {void} 
		 */
		DeleteNetworkApplianceStaticRoute(networkId: string, staticRouteId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/staticRoutes/' + (staticRouteId == null ? '' : encodeURIComponent(staticRouteId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a static route for an MX or teleworker network
		 * Return a static route for an MX or teleworker network
		 * Get networks/{networkId}/appliance/staticRoutes/{staticRouteId}
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceStaticRoute(networkId: string, staticRouteId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/staticRoutes/' + (staticRouteId == null ? '' : encodeURIComponent(staticRouteId)), { responseType: 'text' });
		}

		/**
		 * Update a static route for an MX or teleworker network
		 * Update a static route for an MX or teleworker network
		 * Put networks/{networkId}/appliance/staticRoutes/{staticRouteId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceStaticRoute(networkId: string, staticRouteId: string, requestBody: UpdateNetworkApplianceStaticRoutePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/staticRoutes/' + (staticRouteId == null ? '' : encodeURIComponent(staticRouteId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Display the traffic shaping settings for an MX network
		 * Display the traffic shaping settings for an MX network
		 * Get networks/{networkId}/appliance/trafficShaping
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceTrafficShaping(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping', { responseType: 'text' });
		}

		/**
		 * Update the traffic shaping settings for an MX network
		 * Update the traffic shaping settings for an MX network
		 * Put networks/{networkId}/appliance/trafficShaping
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceTrafficShaping(networkId: string, requestBody: UpdateNetworkApplianceTrafficShapingPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List all custom performance classes for an MX network
		 * List all custom performance classes for an MX network
		 * Get networks/{networkId}/appliance/trafficShaping/customPerformanceClasses
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkApplianceTrafficShapingCustomPerformanceClasses(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping/customPerformanceClasses', {});
		}

		/**
		 * Add a custom performance class for an MX network
		 * Add a custom performance class for an MX network
		 * Post networks/{networkId}/appliance/trafficShaping/customPerformanceClasses
		 * @return {void} 
		 */
		CreateNetworkApplianceTrafficShapingCustomPerformanceClass(networkId: string, requestBody: CreateNetworkApplianceTrafficShapingCustomPerformanceClassPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping/customPerformanceClasses', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a custom performance class from an MX network
		 * Delete a custom performance class from an MX network
		 * Delete networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}
		 * @return {void} 
		 */
		DeleteNetworkApplianceTrafficShapingCustomPerformanceClass(networkId: string, customPerformanceClassId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping/customPerformanceClasses/' + (customPerformanceClassId == null ? '' : encodeURIComponent(customPerformanceClassId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a custom performance class for an MX network
		 * Return a custom performance class for an MX network
		 * Get networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceTrafficShapingCustomPerformanceClass(networkId: string, customPerformanceClassId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping/customPerformanceClasses/' + (customPerformanceClassId == null ? '' : encodeURIComponent(customPerformanceClassId)), { responseType: 'text' });
		}

		/**
		 * Update a custom performance class for an MX network
		 * Update a custom performance class for an MX network
		 * Put networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceTrafficShapingCustomPerformanceClass(networkId: string, customPerformanceClassId: string, requestBody: UpdateNetworkApplianceTrafficShapingCustomPerformanceClassPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping/customPerformanceClasses/' + (customPerformanceClassId == null ? '' : encodeURIComponent(customPerformanceClassId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Display the traffic shaping settings rules for an MX network
		 * Display the traffic shaping settings rules for an MX network
		 * Get networks/{networkId}/appliance/trafficShaping/rules
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceTrafficShapingRules(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping/rules', { responseType: 'text' });
		}

		/**
		 * Update the traffic shaping settings rules for an MX network
		 * Update the traffic shaping settings rules for an MX network
		 * Put networks/{networkId}/appliance/trafficShaping/rules
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceTrafficShapingRules(networkId: string, requestBody: UpdateNetworkApplianceTrafficShapingRulesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping/rules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns the uplink bandwidth limits for your MX network
		 * Returns the uplink bandwidth limits for your MX network. This may not reflect the affected device's hardware capabilities.  For more information on your device's hardware capabilities, please consult our MX Family Datasheet - [https://meraki.cisco.com/product-collateral/mx-family-datasheet/?file]
		 * Get networks/{networkId}/appliance/trafficShaping/uplinkBandwidth
		 * @return {GetNetworkApplianceTrafficShapingUplinkBandwidthReturn} Successful operation
		 */
		GetNetworkApplianceTrafficShapingUplinkBandwidth(networkId: string): Observable<GetNetworkApplianceTrafficShapingUplinkBandwidthReturn> {
			return this.http.get<GetNetworkApplianceTrafficShapingUplinkBandwidthReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping/uplinkBandwidth', {});
		}

		/**
		 * Updates the uplink bandwidth settings for your MX network.
		 * Updates the uplink bandwidth settings for your MX network.
		 * Put networks/{networkId}/appliance/trafficShaping/uplinkBandwidth
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceTrafficShapingUplinkBandwidth(networkId: string, requestBody: UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping/uplinkBandwidth', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Show uplink selection settings for an MX network
		 * Show uplink selection settings for an MX network
		 * Get networks/{networkId}/appliance/trafficShaping/uplinkSelection
		 * @return {GetNetworkApplianceTrafficShapingUplinkSelectionReturn} Successful operation
		 */
		GetNetworkApplianceTrafficShapingUplinkSelection(networkId: string): Observable<GetNetworkApplianceTrafficShapingUplinkSelectionReturn> {
			return this.http.get<GetNetworkApplianceTrafficShapingUplinkSelectionReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping/uplinkSelection', {});
		}

		/**
		 * Update uplink selection settings for an MX network
		 * Update uplink selection settings for an MX network
		 * Put networks/{networkId}/appliance/trafficShaping/uplinkSelection
		 * @return {UpdateNetworkApplianceTrafficShapingUplinkSelectionReturn} Successful operation
		 */
		UpdateNetworkApplianceTrafficShapingUplinkSelection(networkId: string, requestBody: UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBody): Observable<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturn> {
			return this.http.put<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/trafficShaping/uplinkSelection', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Get the sent and received bytes for each uplink of a network.
		 * Get the sent and received bytes for each uplink of a network.
		 * Get networks/{networkId}/appliance/uplinks/usageHistory
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 10 minutes.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 600, 1800, 3600, 86400. The default is 60.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkApplianceUplinksUsageHistory(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/uplinks/usageHistory&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution, {});
		}

		/**
		 * List the VLANs for an MX network
		 * List the VLANs for an MX network
		 * Get networks/{networkId}/appliance/vlans
		 * @return {Array<GetNetworkApplianceVlansReturn>} Successful operation
		 */
		GetNetworkApplianceVlans(networkId: string): Observable<Array<GetNetworkApplianceVlansReturn>> {
			return this.http.get<Array<GetNetworkApplianceVlansReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/vlans', {});
		}

		/**
		 * Add a VLAN
		 * Add a VLAN
		 * Post networks/{networkId}/appliance/vlans
		 * @return {void} 
		 */
		CreateNetworkApplianceVlan(networkId: string, requestBody: CreateNetworkApplianceVlanPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/vlans', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Returns the enabled status of VLANs for the network
		 * Returns the enabled status of VLANs for the network
		 * Get networks/{networkId}/appliance/vlans/settings
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceVlansSettings(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/vlans/settings', { responseType: 'text' });
		}

		/**
		 * Enable/Disable VLANs for the given network
		 * Enable/Disable VLANs for the given network
		 * Put networks/{networkId}/appliance/vlans/settings
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceVlansSettings(networkId: string, requestBody: UpdateNetworkApplianceVlansSettingsPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/vlans/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Delete a VLAN from a network
		 * Delete a VLAN from a network
		 * Delete networks/{networkId}/appliance/vlans/{vlanId}
		 * @return {void} 
		 */
		DeleteNetworkApplianceVlan(networkId: string, vlanId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/vlans/' + (vlanId == null ? '' : encodeURIComponent(vlanId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a VLAN
		 * Return a VLAN
		 * Get networks/{networkId}/appliance/vlans/{vlanId}
		 * @return {GetNetworkApplianceVlanReturn} Successful operation
		 */
		GetNetworkApplianceVlan(networkId: string, vlanId: string): Observable<GetNetworkApplianceVlanReturn> {
			return this.http.get<GetNetworkApplianceVlanReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/vlans/' + (vlanId == null ? '' : encodeURIComponent(vlanId)), {});
		}

		/**
		 * Update a VLAN
		 * Update a VLAN
		 * Put networks/{networkId}/appliance/vlans/{vlanId}
		 * @return {UpdateNetworkApplianceVlanReturn} Successful operation
		 */
		UpdateNetworkApplianceVlan(networkId: string, vlanId: string, requestBody: UpdateNetworkApplianceVlanPutBody): Observable<UpdateNetworkApplianceVlanReturn> {
			return this.http.put<UpdateNetworkApplianceVlanReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/vlans/' + (vlanId == null ? '' : encodeURIComponent(vlanId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return a Hub BGP Configuration
		 * Return a Hub BGP Configuration
		 * Get networks/{networkId}/appliance/vpn/bgp
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceVpnBgp(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/vpn/bgp', { responseType: 'text' });
		}

		/**
		 * Update a Hub BGP Configuration
		 * Update a Hub BGP Configuration
		 * Put networks/{networkId}/appliance/vpn/bgp
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceVpnBgp(networkId: string, requestBody: UpdateNetworkApplianceVpnBgpPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/vpn/bgp', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the site-to-site VPN settings of a network
		 * Return the site-to-site VPN settings of a network. Only valid for MX networks.
		 * Get networks/{networkId}/appliance/vpn/siteToSiteVpn
		 * @return {GetNetworkApplianceVpnSiteToSiteVpnReturn} Successful operation
		 */
		GetNetworkApplianceVpnSiteToSiteVpn(networkId: string): Observable<GetNetworkApplianceVpnSiteToSiteVpnReturn> {
			return this.http.get<GetNetworkApplianceVpnSiteToSiteVpnReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/vpn/siteToSiteVpn', {});
		}

		/**
		 * Update the site-to-site VPN settings of a network
		 * Update the site-to-site VPN settings of a network. Only valid for MX networks in NAT mode.
		 * Put networks/{networkId}/appliance/vpn/siteToSiteVpn
		 * @return {UpdateNetworkApplianceVpnSiteToSiteVpnReturn} Successful operation
		 */
		UpdateNetworkApplianceVpnSiteToSiteVpn(networkId: string, requestBody: UpdateNetworkApplianceVpnSiteToSiteVpnPutBody): Observable<UpdateNetworkApplianceVpnSiteToSiteVpnReturn> {
			return this.http.put<UpdateNetworkApplianceVpnSiteToSiteVpnReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/vpn/siteToSiteVpn', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return MX warm spare settings
		 * Return MX warm spare settings
		 * Get networks/{networkId}/appliance/warmSpare
		 * @return {string} Successful operation
		 */
		GetNetworkApplianceWarmSpare(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/warmSpare', { responseType: 'text' });
		}

		/**
		 * Update MX warm spare settings
		 * Update MX warm spare settings
		 * Put networks/{networkId}/appliance/warmSpare
		 * @return {string} Successful operation
		 */
		UpdateNetworkApplianceWarmSpare(networkId: string, requestBody: UpdateNetworkApplianceWarmSparePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/warmSpare', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Swap MX primary and warm spare appliances
		 * Swap MX primary and warm spare appliances
		 * Post networks/{networkId}/appliance/warmSpare/swap
		 * @return {string} Successful operation
		 */
		SwapNetworkApplianceWarmSpare(networkId: string): Observable<string> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/appliance/warmSpare/swap', null, { responseType: 'text' });
		}

		/**
		 * Bind a network to a template.
		 * Bind a network to a template.
		 * Post networks/{networkId}/bind
		 * @return {string} Successful operation
		 */
		BindNetwork(networkId: string, requestBody: BindNetworkPostBody): Observable<string> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/bind', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the Bluetooth clients seen by APs in this network
		 * List the Bluetooth clients seen by APs in this network
		 * Get networks/{networkId}/bluetoothClients
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {boolean} includeConnectivityHistory Include the connectivity history for this client
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkBluetoothClients(networkId: string, t0: string | null | undefined, timespan: number | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, includeConnectivityHistory: boolean | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/bluetoothClients&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&timespan=' + timespan + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&includeConnectivityHistory=' + includeConnectivityHistory, {});
		}

		/**
		 * Return a Bluetooth client
		 * Return a Bluetooth client. Bluetooth clients can be identified by their ID or their MAC.
		 * Get networks/{networkId}/bluetoothClients/{bluetoothClientId}
		 * @param {boolean} includeConnectivityHistory Include the connectivity history for this client
		 * @param {number} connectivityHistoryTimespan The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used.
		 * @return {string} Successful operation
		 */
		GetNetworkBluetoothClient(networkId: string, bluetoothClientId: string, includeConnectivityHistory: boolean | null | undefined, connectivityHistoryTimespan: number | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/bluetoothClients/' + (bluetoothClientId == null ? '' : encodeURIComponent(bluetoothClientId)) + '&includeConnectivityHistory=' + includeConnectivityHistory + '&connectivityHistoryTimespan=' + connectivityHistoryTimespan, { responseType: 'text' });
		}

		/**
		 * List the quality retention profiles for this network
		 * List the quality retention profiles for this network
		 * Get networks/{networkId}/camera/qualityRetentionProfiles
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkCameraQualityRetentionProfiles(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/camera/qualityRetentionProfiles', {});
		}

		/**
		 * Creates new quality retention profile for this network.
		 * Creates new quality retention profile for this network.
		 * Post networks/{networkId}/camera/qualityRetentionProfiles
		 * @return {string} Successful operation
		 */
		CreateNetworkCameraQualityRetentionProfile(networkId: string, requestBody: CreateNetworkCameraQualityRetentionProfilePostBody): Observable<string> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/camera/qualityRetentionProfiles', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Delete an existing quality retention profile for this network.
		 * Delete an existing quality retention profile for this network.
		 * Delete networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}
		 * @return {void} 
		 */
		DeleteNetworkCameraQualityRetentionProfile(networkId: string, qualityRetentionProfileId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/camera/qualityRetentionProfiles/' + (qualityRetentionProfileId == null ? '' : encodeURIComponent(qualityRetentionProfileId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Retrieve a single quality retention profile
		 * Retrieve a single quality retention profile
		 * Get networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}
		 * @return {string} Successful operation
		 */
		GetNetworkCameraQualityRetentionProfile(networkId: string, qualityRetentionProfileId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/camera/qualityRetentionProfiles/' + (qualityRetentionProfileId == null ? '' : encodeURIComponent(qualityRetentionProfileId)), { responseType: 'text' });
		}

		/**
		 * Update an existing quality retention profile for this network.
		 * Update an existing quality retention profile for this network.
		 * Put networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkCameraQualityRetentionProfile(networkId: string, qualityRetentionProfileId: string, requestBody: UpdateNetworkCameraQualityRetentionProfilePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/camera/qualityRetentionProfiles/' + (qualityRetentionProfileId == null ? '' : encodeURIComponent(qualityRetentionProfileId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns a list of all camera recording schedules.
		 * Returns a list of all camera recording schedules.
		 * Get networks/{networkId}/camera/schedules
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkCameraSchedules(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/camera/schedules', {});
		}

		/**
		 * List the camera wireless profiles for this network.
		 * List the camera wireless profiles for this network.
		 * Get networks/{networkId}/camera/wirelessProfiles
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkCameraWirelessProfiles(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/camera/wirelessProfiles', {});
		}

		/**
		 * Creates a new camera wireless profile for this network.
		 * Creates a new camera wireless profile for this network.
		 * Post networks/{networkId}/camera/wirelessProfiles
		 * @return {string} Successful operation
		 */
		CreateNetworkCameraWirelessProfile(networkId: string, requestBody: CreateNetworkCameraWirelessProfilePostBody): Observable<string> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/camera/wirelessProfiles', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Delete an existing camera wireless profile for this network.
		 * Delete an existing camera wireless profile for this network.
		 * Delete networks/{networkId}/camera/wirelessProfiles/{wirelessProfileId}
		 * @return {void} 
		 */
		DeleteNetworkCameraWirelessProfile(networkId: string, wirelessProfileId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/camera/wirelessProfiles/' + (wirelessProfileId == null ? '' : encodeURIComponent(wirelessProfileId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Retrieve a single camera wireless profile.
		 * Retrieve a single camera wireless profile.
		 * Get networks/{networkId}/camera/wirelessProfiles/{wirelessProfileId}
		 * @return {string} Successful operation
		 */
		GetNetworkCameraWirelessProfile(networkId: string, wirelessProfileId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/camera/wirelessProfiles/' + (wirelessProfileId == null ? '' : encodeURIComponent(wirelessProfileId)), { responseType: 'text' });
		}

		/**
		 * Update an existing camera wireless profile in this network.
		 * Update an existing camera wireless profile in this network.
		 * Put networks/{networkId}/camera/wirelessProfiles/{wirelessProfileId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkCameraWirelessProfile(networkId: string, wirelessProfileId: string, requestBody: UpdateNetworkCameraWirelessProfilePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/camera/wirelessProfiles/' + (wirelessProfileId == null ? '' : encodeURIComponent(wirelessProfileId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the connectivity testing destinations for an MG network
		 * Return the connectivity testing destinations for an MG network
		 * Get networks/{networkId}/cellularGateway/connectivityMonitoringDestinations
		 * @return {string} Successful operation
		 */
		GetNetworkCellularGatewayConnectivityMonitoringDestinations(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/cellularGateway/connectivityMonitoringDestinations', { responseType: 'text' });
		}

		/**
		 * Update the connectivity testing destinations for an MG network
		 * Update the connectivity testing destinations for an MG network
		 * Put networks/{networkId}/cellularGateway/connectivityMonitoringDestinations
		 * @return {string} Successful operation
		 */
		UpdateNetworkCellularGatewayConnectivityMonitoringDestinations(networkId: string, requestBody: UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/cellularGateway/connectivityMonitoringDestinations', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List common DHCP settings of MGs
		 * List common DHCP settings of MGs
		 * Get networks/{networkId}/cellularGateway/dhcp
		 * @return {GetNetworkCellularGatewayDhcpReturn} Successful operation
		 */
		GetNetworkCellularGatewayDhcp(networkId: string): Observable<GetNetworkCellularGatewayDhcpReturn> {
			return this.http.get<GetNetworkCellularGatewayDhcpReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/cellularGateway/dhcp', {});
		}

		/**
		 * Update common DHCP settings of MGs
		 * Update common DHCP settings of MGs
		 * Put networks/{networkId}/cellularGateway/dhcp
		 * @return {UpdateNetworkCellularGatewayDhcpReturn} Successful operation
		 */
		UpdateNetworkCellularGatewayDhcp(networkId: string, requestBody: UpdateNetworkCellularGatewayDhcpPutBody): Observable<UpdateNetworkCellularGatewayDhcpReturn> {
			return this.http.put<UpdateNetworkCellularGatewayDhcpReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/cellularGateway/dhcp', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return the subnet pool and mask configured for MGs in the network.
		 * Return the subnet pool and mask configured for MGs in the network.
		 * Get networks/{networkId}/cellularGateway/subnetPool
		 * @return {string} Successful operation
		 */
		GetNetworkCellularGatewaySubnetPool(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/cellularGateway/subnetPool', { responseType: 'text' });
		}

		/**
		 * Update the subnet pool and mask configuration for MGs in the network.
		 * Update the subnet pool and mask configuration for MGs in the network.
		 * Put networks/{networkId}/cellularGateway/subnetPool
		 * @return {string} Successful operation
		 */
		UpdateNetworkCellularGatewaySubnetPool(networkId: string, requestBody: UpdateNetworkCellularGatewaySubnetPoolPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/cellularGateway/subnetPool', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns the uplink settings for your MG network.
		 * Returns the uplink settings for your MG network.
		 * Get networks/{networkId}/cellularGateway/uplink
		 * @return {string} Successful operation
		 */
		GetNetworkCellularGatewayUplink(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/cellularGateway/uplink', { responseType: 'text' });
		}

		/**
		 * Updates the uplink settings for your MG network.
		 * Updates the uplink settings for your MG network.
		 * Put networks/{networkId}/cellularGateway/uplink
		 * @return {string} Successful operation
		 */
		UpdateNetworkCellularGatewayUplink(networkId: string, requestBody: UpdateNetworkCellularGatewayUplinkPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/cellularGateway/uplink', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the clients that have used this network in the timespan
		 * List the clients that have used this network in the timespan
		 * Get networks/{networkId}/clients
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} statuses Filters clients based on status. Can be one of 'Online' or 'Offline'.
		 * @param {string} ip Filters clients based on a partial or full match for the ip address field.
		 * @param {string} ip6 Filters clients based on a partial or full match for the ip6 address field.
		 * @param {string} ip6Local Filters clients based on a partial or full match for the ip6Local address field.
		 * @param {string} mac Filters clients based on a partial or full match for the mac address field.
		 * @param {string} os Filters clients based on a partial or full match for the os (operating system) field.
		 * @param {string} description Filters clients based on a partial or full match for the description field.
		 * @param {string} vlan Filters clients based on the full match for the VLAN field.
		 * @param {Array<string>} recentDeviceConnections Filters clients based on recent connection type. Can be one of 'Wired' or 'Wireless'.
		 * @return {GetNetworkClientsReturn} Successful operation
		 */
		GetNetworkClients(networkId: string, t0: string | null | undefined, timespan: number | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, statuses: Array<string> | null | undefined, ip: string | null | undefined, ip6: string | null | undefined, ip6Local: string | null | undefined, mac: string | null | undefined, os: string | null | undefined, description: string | null | undefined, vlan: string | null | undefined, recentDeviceConnections: Array<string> | null | undefined): Observable<GetNetworkClientsReturn> {
			return this.http.get<GetNetworkClientsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&timespan=' + timespan + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + statuses?.map(z => `statuses=${encodeURIComponent(z)}`).join('&') + '&ip=' + (ip == null ? '' : encodeURIComponent(ip)) + '&ip6=' + (ip6 == null ? '' : encodeURIComponent(ip6)) + '&ip6Local=' + (ip6Local == null ? '' : encodeURIComponent(ip6Local)) + '&mac=' + (mac == null ? '' : encodeURIComponent(mac)) + '&os=' + (os == null ? '' : encodeURIComponent(os)) + '&description=' + (description == null ? '' : encodeURIComponent(description)) + '&vlan=' + (vlan == null ? '' : encodeURIComponent(vlan)) + '&' + recentDeviceConnections?.map(z => `recentDeviceConnections=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * Return the application usage data for clients
		 * Return the application usage data for clients. Usage data is in kilobytes. Clients can be identified by client keys or either the MACs or IPs depending on whether the network uses Track-by-IP.
		 * Get networks/{networkId}/clients/applicationUsage
		 * @param {string} clients A list of client keys, MACs or IPs separated by comma.
		 * @param {GetNetworkClientsApplicationUsageSsidNumber} ssidNumber An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkClientsApplicationUsage(networkId: string, clients: string, ssidNumber: GetNetworkClientsApplicationUsageSsidNumber | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients/applicationUsage&clients=' + (clients == null ? '' : encodeURIComponent(clients)) + '&ssidNumber=' + ssidNumber + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, {});
		}

		/**
		 * Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
		 * Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
		 * Get networks/{networkId}/clients/bandwidthUsageHistory
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkClientsBandwidthUsageHistory(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients/bandwidthUsageHistory&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Return overview statistics for network clients
		 * Return overview statistics for network clients
		 * Get networks/{networkId}/clients/overview
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800.
		 * @return {string} Successful operation
		 */
		GetNetworkClientsOverview(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients/overview&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution, { responseType: 'text' });
		}

		/**
		 * Provisions a client with a name and policy
		 * Provisions a client with a name and policy. Clients can be provisioned before they associate to the network.
		 * Post networks/{networkId}/clients/provision
		 * @return {void} 
		 */
		ProvisionNetworkClients(networkId: string, requestBody: ProvisionNetworkClientsPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients/provision', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Return the usage histories for clients
		 * Return the usage histories for clients. Usage data is in kilobytes. Clients can be identified by client keys or either the MACs or IPs depending on whether the network uses Track-by-IP.
		 * Get networks/{networkId}/clients/usageHistories
		 * @param {string} clients A list of client keys, MACs or IPs separated by comma.
		 * @param {GetNetworkClientsUsageHistoriesSsidNumber} ssidNumber An SSID number to include. If not specified, events for all SSIDs will be returned.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkClientsUsageHistories(networkId: string, clients: string, ssidNumber: GetNetworkClientsUsageHistoriesSsidNumber | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients/usageHistories&clients=' + (clients == null ? '' : encodeURIComponent(clients)) + '&ssidNumber=' + ssidNumber + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return the client associated with the given identifier
		 * Return the client associated with the given identifier. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		 * Get networks/{networkId}/clients/{clientId}
		 * @return {GetNetworkClientReturn} Successful operation
		 */
		GetNetworkClient(networkId: string, clientId: string): Observable<GetNetworkClientReturn> {
			return this.http.get<GetNetworkClientReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients/' + (clientId == null ? '' : encodeURIComponent(clientId)), {});
		}

		/**
		 * Return the policy assigned to a client on the network
		 * Return the policy assigned to a client on the network. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		 * Get networks/{networkId}/clients/{clientId}/policy
		 * @return {string} Successful operation
		 */
		GetNetworkClientPolicy(networkId: string, clientId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients/' + (clientId == null ? '' : encodeURIComponent(clientId)) + '/policy', { responseType: 'text' });
		}

		/**
		 * Update the policy assigned to a client on the network
		 * Update the policy assigned to a client on the network. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		 * Put networks/{networkId}/clients/{clientId}/policy
		 * @return {string} Successful operation
		 */
		UpdateNetworkClientPolicy(networkId: string, clientId: string, requestBody: UpdateNetworkClientPolicyPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients/' + (clientId == null ? '' : encodeURIComponent(clientId)) + '/policy', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the splash authorization for a client, for each SSID they've associated with through splash
		 * Return the splash authorization for a client, for each SSID they've associated with through splash. Only enabled SSIDs with Click-through splash enabled will be included. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		 * Get networks/{networkId}/clients/{clientId}/splashAuthorizationStatus
		 * @return {string} Successful operation
		 */
		GetNetworkClientSplashAuthorizationStatus(networkId: string, clientId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients/' + (clientId == null ? '' : encodeURIComponent(clientId)) + '/splashAuthorizationStatus', { responseType: 'text' });
		}

		/**
		 * Update a client's splash authorization
		 * Update a client's splash authorization. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		 * Put networks/{networkId}/clients/{clientId}/splashAuthorizationStatus
		 * @return {string} Successful operation
		 */
		UpdateNetworkClientSplashAuthorizationStatus(networkId: string, clientId: string, requestBody: UpdateNetworkClientSplashAuthorizationStatusPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients/' + (clientId == null ? '' : encodeURIComponent(clientId)) + '/splashAuthorizationStatus', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the client's network traffic data over time
		 * Return the client's network traffic data over time. Usage data is in kilobytes. This endpoint requires detailed traffic analysis to be enabled on the Network-wide > General page. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		 * Get networks/{networkId}/clients/{clientId}/trafficHistory
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkClientTrafficHistory(networkId: string, clientId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients/' + (clientId == null ? '' : encodeURIComponent(clientId)) + '/trafficHistory&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Return the client's daily usage history
		 * Return the client's daily usage history. Usage data is in kilobytes. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		 * Get networks/{networkId}/clients/{clientId}/usageHistory
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkClientUsageHistory(networkId: string, clientId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/clients/' + (clientId == null ? '' : encodeURIComponent(clientId)) + '/usageHistory', {});
		}

		/**
		 * List the devices in a network
		 * List the devices in a network
		 * Get networks/{networkId}/devices
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkDevices(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/devices', {});
		}

		/**
		 * Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requsts against that device to succeed)
		 * Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requsts against that device to succeed)
		 * Post networks/{networkId}/devices/claim
		 * @return {void} Successful operation
		 */
		ClaimNetworkDevices(networkId: string, requestBody: ClaimNetworkDevicesPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/devices/claim', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Claim a vMX into a network
		 * Claim a vMX into a network
		 * Post networks/{networkId}/devices/claim/vmx
		 * @return {string} Successful operation
		 */
		VmxNetworkDevicesClaim(networkId: string, requestBody: VmxNetworkDevicesClaimPostBody): Observable<string> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/devices/claim/vmx', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Remove a single device
		 * Remove a single device
		 * Post networks/{networkId}/devices/remove
		 * @return {void} 
		 */
		RemoveNetworkDevices(networkId: string, requestBody: RemoveNetworkDevicesPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/devices/remove', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * List the events for the network
		 * List the events for the network
		 * Get networks/{networkId}/events
		 * @param {GetNetworkEventsProductType} productType The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, and cellularGateway
		 * @param {Array<string>} includedEventTypes A list of event types. The returned events will be filtered to only include events with these types.
		 * @param {Array<string>} excludedEventTypes A list of event types. The returned events will be filtered to exclude events with these types.
		 * @param {string} deviceMac The MAC address of the Meraki device which the list of events will be filtered with
		 * @param {string} deviceSerial The serial of the Meraki device which the list of events will be filtered with
		 * @param {string} deviceName The name of the Meraki device which the list of events will be filtered with
		 * @param {string} clientIp The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks.
		 * @param {string} clientMac The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks.
		 * @param {string} clientName The name, or partial name, of the client which the list of events will be filtered with
		 * @param {string} smDeviceMac The MAC address of the Systems Manager device which the list of events will be filtered with
		 * @param {string} smDeviceName The name of the Systems Manager device which the list of events will be filtered with
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {GetNetworkEventsReturn} Successful operation
		 */
		GetNetworkEvents(networkId: string, productType: GetNetworkEventsProductType | null | undefined, includedEventTypes: Array<string> | null | undefined, excludedEventTypes: Array<string> | null | undefined, deviceMac: string | null | undefined, deviceSerial: string | null | undefined, deviceName: string | null | undefined, clientIp: string | null | undefined, clientMac: string | null | undefined, clientName: string | null | undefined, smDeviceMac: string | null | undefined, smDeviceName: string | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<GetNetworkEventsReturn> {
			return this.http.get<GetNetworkEventsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/events&productType=' + productType + '&' + includedEventTypes?.map(z => `includedEventTypes=${encodeURIComponent(z)}`).join('&') + '&' + excludedEventTypes?.map(z => `excludedEventTypes=${encodeURIComponent(z)}`).join('&') + '&deviceMac=' + (deviceMac == null ? '' : encodeURIComponent(deviceMac)) + '&deviceSerial=' + (deviceSerial == null ? '' : encodeURIComponent(deviceSerial)) + '&deviceName=' + (deviceName == null ? '' : encodeURIComponent(deviceName)) + '&clientIp=' + (clientIp == null ? '' : encodeURIComponent(clientIp)) + '&clientMac=' + (clientMac == null ? '' : encodeURIComponent(clientMac)) + '&clientName=' + (clientName == null ? '' : encodeURIComponent(clientName)) + '&smDeviceMac=' + (smDeviceMac == null ? '' : encodeURIComponent(smDeviceMac)) + '&smDeviceName=' + (smDeviceName == null ? '' : encodeURIComponent(smDeviceName)) + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * List the event type to human-readable description
		 * List the event type to human-readable description
		 * Get networks/{networkId}/events/eventTypes
		 * @return {Array<GetNetworkEventsEventTypesReturn>} Successful operation
		 */
		GetNetworkEventsEventTypes(networkId: string): Observable<Array<GetNetworkEventsEventTypesReturn>> {
			return this.http.get<Array<GetNetworkEventsEventTypesReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/events/eventTypes', {});
		}

		/**
		 * Get firmware upgrade information for a network
		 * Get firmware upgrade information for a network
		 * Get networks/{networkId}/firmwareUpgrades
		 * @return {GetNetworkFirmwareUpgradesReturn} Successful operation
		 */
		GetNetworkFirmwareUpgrades(networkId: string): Observable<GetNetworkFirmwareUpgradesReturn> {
			return this.http.get<GetNetworkFirmwareUpgradesReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades', {});
		}

		/**
		 * Update firmware upgrade information for a network
		 * Update firmware upgrade information for a network
		 * Put networks/{networkId}/firmwareUpgrades
		 * @return {UpdateNetworkFirmwareUpgradesReturn} Successful operation
		 */
		UpdateNetworkFirmwareUpgrades(networkId: string, requestBody: UpdateNetworkFirmwareUpgradesPutBody): Observable<UpdateNetworkFirmwareUpgradesReturn> {
			return this.http.put<UpdateNetworkFirmwareUpgradesReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Rollback a Firmware Upgrade For A Network
		 * Rollback a Firmware Upgrade For A Network
		 * Post networks/{networkId}/firmwareUpgrades/rollbacks
		 * @return {CreateNetworkFirmwareUpgradesRollbackReturn} Successful operation
		 */
		CreateNetworkFirmwareUpgradesRollback(networkId: string, requestBody: CreateNetworkFirmwareUpgradesRollbackPostBody): Observable<CreateNetworkFirmwareUpgradesRollbackReturn> {
			return this.http.post<CreateNetworkFirmwareUpgradesRollbackReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/rollbacks', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Get the Staged Upgrade Event from a network
		 * Get the Staged Upgrade Event from a network
		 * Get networks/{networkId}/firmwareUpgrades/staged/events
		 * @return {GetNetworkFirmwareUpgradesStagedEventsReturn} Successful operation
		 */
		GetNetworkFirmwareUpgradesStagedEvents(networkId: string): Observable<GetNetworkFirmwareUpgradesStagedEventsReturn> {
			return this.http.get<GetNetworkFirmwareUpgradesStagedEventsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/staged/events', {});
		}

		/**
		 * Create a Staged Upgrade Event for a network
		 * Create a Staged Upgrade Event for a network
		 * Post networks/{networkId}/firmwareUpgrades/staged/events
		 * @return {CreateNetworkFirmwareUpgradesStagedEventReturn} Successful operation
		 */
		CreateNetworkFirmwareUpgradesStagedEvent(networkId: string, requestBody: CreateNetworkFirmwareUpgradesStagedEventPostBody): Observable<CreateNetworkFirmwareUpgradesStagedEventReturn> {
			return this.http.post<CreateNetworkFirmwareUpgradesStagedEventReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/staged/events', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Update the Staged Upgrade Event for a network
		 * Update the Staged Upgrade Event for a network
		 * Put networks/{networkId}/firmwareUpgrades/staged/events
		 * @return {UpdateNetworkFirmwareUpgradesStagedEventsReturn} Successful operation
		 */
		UpdateNetworkFirmwareUpgradesStagedEvents(networkId: string, requestBody: UpdateNetworkFirmwareUpgradesStagedEventsPutBody): Observable<UpdateNetworkFirmwareUpgradesStagedEventsReturn> {
			return this.http.put<UpdateNetworkFirmwareUpgradesStagedEventsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/staged/events', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Postpone by 1 week all pending staged upgrade stages for a network
		 * Postpone by 1 week all pending staged upgrade stages for a network
		 * Post networks/{networkId}/firmwareUpgrades/staged/events/defer
		 * @return {DeferNetworkFirmwareUpgradesStagedEventsReturn} Successful operation
		 */
		DeferNetworkFirmwareUpgradesStagedEvents(networkId: string): Observable<DeferNetworkFirmwareUpgradesStagedEventsReturn> {
			return this.http.post<DeferNetworkFirmwareUpgradesStagedEventsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/staged/events/defer', null, {});
		}

		/**
		 * Rollback a Staged Upgrade Event for a network
		 * Rollback a Staged Upgrade Event for a network
		 * Post networks/{networkId}/firmwareUpgrades/staged/events/rollbacks
		 * @return {RollbacksNetworkFirmwareUpgradesStagedEventsReturn} Successful operation
		 */
		RollbacksNetworkFirmwareUpgradesStagedEvents(networkId: string, requestBody: RollbacksNetworkFirmwareUpgradesStagedEventsPostBody): Observable<RollbacksNetworkFirmwareUpgradesStagedEventsReturn> {
			return this.http.post<RollbacksNetworkFirmwareUpgradesStagedEventsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/staged/events/rollbacks', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List of Staged Upgrade Groups in a network
		 * List of Staged Upgrade Groups in a network
		 * Get networks/{networkId}/firmwareUpgrades/staged/groups
		 * @return {Array<GetNetworkFirmwareUpgradesStagedGroupsReturn>} Successful operation
		 */
		GetNetworkFirmwareUpgradesStagedGroups(networkId: string): Observable<Array<GetNetworkFirmwareUpgradesStagedGroupsReturn>> {
			return this.http.get<Array<GetNetworkFirmwareUpgradesStagedGroupsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/staged/groups', {});
		}

		/**
		 * Create a Staged Upgrade Group for a network
		 * Create a Staged Upgrade Group for a network
		 * Post networks/{networkId}/firmwareUpgrades/staged/groups
		 * @return {string} Successful operation
		 */
		CreateNetworkFirmwareUpgradesStagedGroup(networkId: string, requestBody: CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroup): Observable<string> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/staged/groups', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Delete a Staged Upgrade Group
		 * Delete a Staged Upgrade Group
		 * Delete networks/{networkId}/firmwareUpgrades/staged/groups/{groupId}
		 * @return {void} 
		 */
		DeleteNetworkFirmwareUpgradesStagedGroup(networkId: string, groupId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/staged/groups/' + (groupId == null ? '' : encodeURIComponent(groupId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Get a Staged Upgrade Group from a network
		 * Get a Staged Upgrade Group from a network
		 * Get networks/{networkId}/firmwareUpgrades/staged/groups/{groupId}
		 * @return {GetNetworkFirmwareUpgradesStagedGroupReturn} Successful operation
		 */
		GetNetworkFirmwareUpgradesStagedGroup(networkId: string, groupId: string): Observable<GetNetworkFirmwareUpgradesStagedGroupReturn> {
			return this.http.get<GetNetworkFirmwareUpgradesStagedGroupReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/staged/groups/' + (groupId == null ? '' : encodeURIComponent(groupId)), {});
		}

		/**
		 * Update a Staged Upgrade Group for a network
		 * Update a Staged Upgrade Group for a network
		 * Put networks/{networkId}/firmwareUpgrades/staged/groups/{groupId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkFirmwareUpgradesStagedGroup(networkId: string, groupId: string, requestBody: CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroup): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/staged/groups/' + (groupId == null ? '' : encodeURIComponent(groupId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Order of Staged Upgrade Groups in a network
		 * Order of Staged Upgrade Groups in a network
		 * Get networks/{networkId}/firmwareUpgrades/staged/stages
		 * @return {Array<GetNetworkFirmwareUpgradesStagedStagesReturn>} Successful operation
		 */
		GetNetworkFirmwareUpgradesStagedStages(networkId: string): Observable<Array<GetNetworkFirmwareUpgradesStagedStagesReturn>> {
			return this.http.get<Array<GetNetworkFirmwareUpgradesStagedStagesReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/staged/stages', {});
		}

		/**
		 * Assign Staged Upgrade Group order in the sequence.
		 * Assign Staged Upgrade Group order in the sequence.
		 * Put networks/{networkId}/firmwareUpgrades/staged/stages
		 * @return {Array<UpdateNetworkFirmwareUpgradesStagedStagesReturn>} Successful operation
		 */
		UpdateNetworkFirmwareUpgradesStagedStages(networkId: string, requestBody: UpdateNetworkFirmwareUpgradesStagedStagesPutBody): Observable<Array<UpdateNetworkFirmwareUpgradesStagedStagesReturn>> {
			return this.http.put<Array<UpdateNetworkFirmwareUpgradesStagedStagesReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/firmwareUpgrades/staged/stages', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the floor plans that belong to your network
		 * List the floor plans that belong to your network
		 * Get networks/{networkId}/floorPlans
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkFloorPlans(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/floorPlans', {});
		}

		/**
		 * Upload a floor plan
		 * Upload a floor plan
		 * Post networks/{networkId}/floorPlans
		 * @return {void} 
		 */
		CreateNetworkFloorPlan(networkId: string, requestBody: CreateNetworkFloorPlanPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/floorPlans', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Destroy a floor plan
		 * Destroy a floor plan
		 * Delete networks/{networkId}/floorPlans/{floorPlanId}
		 * @return {void} 
		 */
		DeleteNetworkFloorPlan(networkId: string, floorPlanId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/floorPlans/' + (floorPlanId == null ? '' : encodeURIComponent(floorPlanId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Find a floor plan by ID
		 * Find a floor plan by ID
		 * Get networks/{networkId}/floorPlans/{floorPlanId}
		 * @return {string} Successful operation
		 */
		GetNetworkFloorPlan(networkId: string, floorPlanId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/floorPlans/' + (floorPlanId == null ? '' : encodeURIComponent(floorPlanId)), { responseType: 'text' });
		}

		/**
		 * Update a floor plan's geolocation and other meta data
		 * Update a floor plan's geolocation and other meta data
		 * Put networks/{networkId}/floorPlans/{floorPlanId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkFloorPlan(networkId: string, floorPlanId: string, requestBody: UpdateNetworkFloorPlanPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/floorPlans/' + (floorPlanId == null ? '' : encodeURIComponent(floorPlanId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the group policies in a network
		 * List the group policies in a network
		 * Get networks/{networkId}/groupPolicies
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkGroupPolicies(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/groupPolicies', {});
		}

		/**
		 * Create a group policy
		 * Create a group policy
		 * Post networks/{networkId}/groupPolicies
		 * @return {void} 
		 */
		CreateNetworkGroupPolicy(networkId: string, requestBody: CreateNetworkGroupPolicyPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/groupPolicies', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a group policy
		 * Delete a group policy
		 * Delete networks/{networkId}/groupPolicies/{groupPolicyId}
		 * @return {void} 
		 */
		DeleteNetworkGroupPolicy(networkId: string, groupPolicyId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/groupPolicies/' + (groupPolicyId == null ? '' : encodeURIComponent(groupPolicyId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Display a group policy
		 * Display a group policy
		 * Get networks/{networkId}/groupPolicies/{groupPolicyId}
		 * @return {string} Successful operation
		 */
		GetNetworkGroupPolicy(networkId: string, groupPolicyId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/groupPolicies/' + (groupPolicyId == null ? '' : encodeURIComponent(groupPolicyId)), { responseType: 'text' });
		}

		/**
		 * Update a group policy
		 * Update a group policy
		 * Put networks/{networkId}/groupPolicies/{groupPolicyId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkGroupPolicy(networkId: string, groupPolicyId: string, requestBody: UpdateNetworkGroupPolicyPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/groupPolicies/' + (groupPolicyId == null ? '' : encodeURIComponent(groupPolicyId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return all global alerts on this network
		 * Return all global alerts on this network
		 * Get networks/{networkId}/health/alerts
		 * @return {Array<GetNetworkHealthAlertsReturn>} Successful operation
		 */
		GetNetworkHealthAlerts(networkId: string): Observable<Array<GetNetworkHealthAlertsReturn>> {
			return this.http.get<Array<GetNetworkHealthAlertsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/health/alerts', {});
		}

		/**
		 * Get application health by time
		 * Get application health by time
		 * Get networks/{networkId}/insight/applications/{applicationId}/healthByTime
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 2 hours.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 3600, 86400. The default is 300.
		 * @return {Array<GetNetworkInsightApplicationHealthByTimeReturn>} Successful operation
		 */
		GetNetworkInsightApplicationHealthByTime(networkId: string, applicationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined): Observable<Array<GetNetworkInsightApplicationHealthByTimeReturn>> {
			return this.http.get<Array<GetNetworkInsightApplicationHealthByTimeReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/insight/applications/' + (applicationId == null ? '' : encodeURIComponent(applicationId)) + '/healthByTime&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution, {});
		}

		/**
		 * List the users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a wired network)
		 * List the users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a wired network)
		 * Get networks/{networkId}/merakiAuthUsers
		 * @return {Array<GetNetworkMerakiAuthUsersReturn>} Successful operation
		 */
		GetNetworkMerakiAuthUsers(networkId: string): Observable<Array<GetNetworkMerakiAuthUsersReturn>> {
			return this.http.get<Array<GetNetworkMerakiAuthUsersReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/merakiAuthUsers', {});
		}

		/**
		 * Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
		 * Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
		 * Post networks/{networkId}/merakiAuthUsers
		 * @return {void} 
		 */
		CreateNetworkMerakiAuthUser(networkId: string, requestBody: CreateNetworkMerakiAuthUserPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/merakiAuthUsers', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Deauthorize a user
		 * Deauthorize a user. To reauthorize a user after deauthorizing them, POST to this endpoint. (Currently, 802.1X RADIUS, splash guest, and client VPN users can be deauthorized.)
		 * Delete networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}
		 * @return {void} 
		 */
		DeleteNetworkMerakiAuthUser(networkId: string, merakiAuthUserId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/merakiAuthUsers/' + (merakiAuthUserId == null ? '' : encodeURIComponent(merakiAuthUserId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return the Meraki Auth splash guest, RADIUS, or client VPN user
		 * Return the Meraki Auth splash guest, RADIUS, or client VPN user
		 * Get networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}
		 * @return {GetNetworkMerakiAuthUserReturn} Successful operation
		 */
		GetNetworkMerakiAuthUser(networkId: string, merakiAuthUserId: string): Observable<GetNetworkMerakiAuthUserReturn> {
			return this.http.get<GetNetworkMerakiAuthUserReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/merakiAuthUsers/' + (merakiAuthUserId == null ? '' : encodeURIComponent(merakiAuthUserId)), {});
		}

		/**
		 * Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
		 * Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
		 * Put networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}
		 * @return {UpdateNetworkMerakiAuthUserReturn} Successful operation
		 */
		UpdateNetworkMerakiAuthUser(networkId: string, merakiAuthUserId: string, requestBody: UpdateNetworkMerakiAuthUserPutBody): Observable<UpdateNetworkMerakiAuthUserReturn> {
			return this.http.put<UpdateNetworkMerakiAuthUserReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/merakiAuthUsers/' + (merakiAuthUserId == null ? '' : encodeURIComponent(merakiAuthUserId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the MQTT brokers for this network
		 * List the MQTT brokers for this network
		 * Get networks/{networkId}/mqttBrokers
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkMqttBrokers(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/mqttBrokers', {});
		}

		/**
		 * Add an MQTT broker
		 * Add an MQTT broker
		 * Post networks/{networkId}/mqttBrokers
		 * @return {void} 
		 */
		CreateNetworkMqttBroker(networkId: string, requestBody: CreateNetworkMqttBrokerPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/mqttBrokers', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete an MQTT broker
		 * Delete an MQTT broker
		 * Delete networks/{networkId}/mqttBrokers/{mqttBrokerId}
		 * @return {void} 
		 */
		DeleteNetworkMqttBroker(networkId: string, mqttBrokerId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/mqttBrokers/' + (mqttBrokerId == null ? '' : encodeURIComponent(mqttBrokerId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return an MQTT broker
		 * Return an MQTT broker
		 * Get networks/{networkId}/mqttBrokers/{mqttBrokerId}
		 * @return {string} Successful operation
		 */
		GetNetworkMqttBroker(networkId: string, mqttBrokerId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/mqttBrokers/' + (mqttBrokerId == null ? '' : encodeURIComponent(mqttBrokerId)), { responseType: 'text' });
		}

		/**
		 * Update an MQTT broker
		 * Update an MQTT broker
		 * Put networks/{networkId}/mqttBrokers/{mqttBrokerId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkMqttBroker(networkId: string, mqttBrokerId: string, requestBody: UpdateNetworkMqttBrokerPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/mqttBrokers/' + (mqttBrokerId == null ? '' : encodeURIComponent(mqttBrokerId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the NetFlow traffic reporting settings for a network
		 * Return the NetFlow traffic reporting settings for a network
		 * Get networks/{networkId}/netflow
		 * @return {string} Successful operation
		 */
		GetNetworkNetflow(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/netflow', { responseType: 'text' });
		}

		/**
		 * Update the NetFlow traffic reporting settings for a network
		 * Update the NetFlow traffic reporting settings for a network
		 * Put networks/{networkId}/netflow
		 * @return {string} Successful operation
		 */
		UpdateNetworkNetflow(networkId: string, requestBody: UpdateNetworkNetflowPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/netflow', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Get the channel utilization over each radio for all APs in a network.
		 * Get the channel utilization over each radio for all APs in a network.
		 * Get networks/{networkId}/networkHealth/channelUtilization
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 100. Default is 10.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkNetworkHealthChannelUtilization(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/networkHealth/channelUtilization&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * List the keys required to access Personally Identifiable Information (PII) for a given identifier
		 * List the keys required to access Personally Identifiable Information (PII) for a given identifier. Exactly one identifier will be accepted. If the organization contains org-wide Systems Manager users matching the key provided then there will be an entry with the key "0" containing the applicable keys.
		 * ## ALTERNATE PATH
		 * ```
		 * /organizations/{organizationId}/pii/piiKeys
		 * ```
		 * Get networks/{networkId}/pii/piiKeys
		 * @param {string} username The username of a Systems Manager user
		 * @param {string} email The email of a network user account or a Systems Manager device
		 * @param {string} mac The MAC of a network client device or a Systems Manager device
		 * @param {string} serial The serial of a Systems Manager device
		 * @param {string} imei The IMEI of a Systems Manager device
		 * @param {string} bluetoothMac The MAC of a Bluetooth client
		 * @return {string} Successful operation
		 */
		GetNetworkPiiPiiKeys(networkId: string, username: string | null | undefined, email: string | null | undefined, mac: string | null | undefined, serial: string | null | undefined, imei: string | null | undefined, bluetoothMac: string | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/pii/piiKeys&username=' + (username == null ? '' : encodeURIComponent(username)) + '&email=' + (email == null ? '' : encodeURIComponent(email)) + '&mac=' + (mac == null ? '' : encodeURIComponent(mac)) + '&serial=' + (serial == null ? '' : encodeURIComponent(serial)) + '&imei=' + (imei == null ? '' : encodeURIComponent(imei)) + '&bluetoothMac=' + (bluetoothMac == null ? '' : encodeURIComponent(bluetoothMac)), { responseType: 'text' });
		}

		/**
		 * List the PII requests for this network or organization
		 * List the PII requests for this network or organization
		 * ## ALTERNATE PATH
		 * ```
		 * /organizations/{organizationId}/pii/requests
		 * ```
		 * Get networks/{networkId}/pii/requests
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkPiiRequests(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/pii/requests', {});
		}

		/**
		 * Submit a new delete or restrict processing PII request
		 * Submit a new delete or restrict processing PII request
		 * ## ALTERNATE PATH
		 * ```
		 * /organizations/{organizationId}/pii/requests
		 * ```
		 * Post networks/{networkId}/pii/requests
		 * @return {void} 
		 */
		CreateNetworkPiiRequest(networkId: string, requestBody: CreateNetworkPiiRequestPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/pii/requests', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a restrict processing PII request
		 * Delete a restrict processing PII request
		 * ## ALTERNATE PATH
		 * ```
		 * /organizations/{organizationId}/pii/requests/{requestId}
		 * ```
		 * Delete networks/{networkId}/pii/requests/{requestId}
		 * @return {void} 
		 */
		DeleteNetworkPiiRequest(networkId: string, requestId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/pii/requests/' + (requestId == null ? '' : encodeURIComponent(requestId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a PII request
		 * Return a PII request
		 * ## ALTERNATE PATH
		 * ```
		 * /organizations/{organizationId}/pii/requests/{requestId}
		 * ```
		 * Get networks/{networkId}/pii/requests/{requestId}
		 * @return {string} Successful operation
		 */
		GetNetworkPiiRequest(networkId: string, requestId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/pii/requests/' + (requestId == null ? '' : encodeURIComponent(requestId)), { responseType: 'text' });
		}

		/**
		 * Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier
		 * Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier. These device IDs can be used with the Systems Manager API endpoints to retrieve device details. Exactly one identifier will be accepted.
		 * ## ALTERNATE PATH
		 * ```
		 * /organizations/{organizationId}/pii/smDevicesForKey
		 * ```
		 * Get networks/{networkId}/pii/smDevicesForKey
		 * @param {string} username The username of a Systems Manager user
		 * @param {string} email The email of a network user account or a Systems Manager device
		 * @param {string} mac The MAC of a network client device or a Systems Manager device
		 * @param {string} serial The serial of a Systems Manager device
		 * @param {string} imei The IMEI of a Systems Manager device
		 * @param {string} bluetoothMac The MAC of a Bluetooth client
		 * @return {string} Successful operation
		 */
		GetNetworkPiiSmDevicesForKey(networkId: string, username: string | null | undefined, email: string | null | undefined, mac: string | null | undefined, serial: string | null | undefined, imei: string | null | undefined, bluetoothMac: string | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/pii/smDevicesForKey&username=' + (username == null ? '' : encodeURIComponent(username)) + '&email=' + (email == null ? '' : encodeURIComponent(email)) + '&mac=' + (mac == null ? '' : encodeURIComponent(mac)) + '&serial=' + (serial == null ? '' : encodeURIComponent(serial)) + '&imei=' + (imei == null ? '' : encodeURIComponent(imei)) + '&bluetoothMac=' + (bluetoothMac == null ? '' : encodeURIComponent(bluetoothMac)), { responseType: 'text' });
		}

		/**
		 * Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier
		 * Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier. These owner IDs can be used with the Systems Manager API endpoints to retrieve owner details. Exactly one identifier will be accepted.
		 * ## ALTERNATE PATH
		 * ```
		 * /organizations/{organizationId}/pii/smOwnersForKey
		 * ```
		 * Get networks/{networkId}/pii/smOwnersForKey
		 * @param {string} username The username of a Systems Manager user
		 * @param {string} email The email of a network user account or a Systems Manager device
		 * @param {string} mac The MAC of a network client device or a Systems Manager device
		 * @param {string} serial The serial of a Systems Manager device
		 * @param {string} imei The IMEI of a Systems Manager device
		 * @param {string} bluetoothMac The MAC of a Bluetooth client
		 * @return {string} Successful operation
		 */
		GetNetworkPiiSmOwnersForKey(networkId: string, username: string | null | undefined, email: string | null | undefined, mac: string | null | undefined, serial: string | null | undefined, imei: string | null | undefined, bluetoothMac: string | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/pii/smOwnersForKey&username=' + (username == null ? '' : encodeURIComponent(username)) + '&email=' + (email == null ? '' : encodeURIComponent(email)) + '&mac=' + (mac == null ? '' : encodeURIComponent(mac)) + '&serial=' + (serial == null ? '' : encodeURIComponent(serial)) + '&imei=' + (imei == null ? '' : encodeURIComponent(imei)) + '&bluetoothMac=' + (bluetoothMac == null ? '' : encodeURIComponent(bluetoothMac)), { responseType: 'text' });
		}

		/**
		 * Get policies for all clients with policies
		 * Get policies for all clients with policies
		 * Get networks/{networkId}/policies/byClient
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<GetNetworkPoliciesByClientReturn>} Successful operation
		 */
		GetNetworkPoliciesByClient(networkId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, t0: string | null | undefined, timespan: number | null | undefined): Observable<Array<GetNetworkPoliciesByClientReturn>> {
			return this.http.get<Array<GetNetworkPoliciesByClientReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/policies/byClient&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return an overview of currently alerting sensors by metric
		 * Return an overview of currently alerting sensors by metric
		 * Get networks/{networkId}/sensor/alerts/current/overview/byMetric
		 * @return {GetNetworkSensorAlertsCurrentOverviewByMetricReturn} Successful operation
		 */
		GetNetworkSensorAlertsCurrentOverviewByMetric(networkId: string): Observable<GetNetworkSensorAlertsCurrentOverviewByMetricReturn> {
			return this.http.get<GetNetworkSensorAlertsCurrentOverviewByMetricReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sensor/alerts/current/overview/byMetric', {});
		}

		/**
		 * Return an overview of alert occurrences over a timespan, by metric
		 * Return an overview of alert occurrences over a timespan, by metric
		 * Get networks/{networkId}/sensor/alerts/overview/byMetric
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
		 * @param {number} interval The time interval in seconds for returned data. The valid intervals are: 86400, 604800. The default is 604800.
		 * @return {Array<GetNetworkSensorAlertsOverviewByMetricReturn>} Successful operation
		 */
		GetNetworkSensorAlertsOverviewByMetric(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, interval: number | null | undefined): Observable<Array<GetNetworkSensorAlertsOverviewByMetricReturn>> {
			return this.http.get<Array<GetNetworkSensorAlertsOverviewByMetricReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sensor/alerts/overview/byMetric&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&interval=' + interval, {});
		}

		/**
		 * Lists all sensor alert profiles for a network.
		 * Lists all sensor alert profiles for a network.
		 * Get networks/{networkId}/sensor/alerts/profiles
		 * @return {Array<GetNetworkSensorAlertsProfilesReturn>} Successful operation
		 */
		GetNetworkSensorAlertsProfiles(networkId: string): Observable<Array<GetNetworkSensorAlertsProfilesReturn>> {
			return this.http.get<Array<GetNetworkSensorAlertsProfilesReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sensor/alerts/profiles', {});
		}

		/**
		 * Creates a sensor alert profile for a network.
		 * Creates a sensor alert profile for a network.
		 * Post networks/{networkId}/sensor/alerts/profiles
		 * @return {CreateNetworkSensorAlertsProfileReturn} Successful operation
		 */
		CreateNetworkSensorAlertsProfile(networkId: string, requestBody: CreateNetworkSensorAlertsProfilePostBody): Observable<CreateNetworkSensorAlertsProfileReturn> {
			return this.http.post<CreateNetworkSensorAlertsProfileReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sensor/alerts/profiles', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Deletes a sensor alert profile from a network.
		 * Deletes a sensor alert profile from a network.
		 * Delete networks/{networkId}/sensor/alerts/profiles/{id}
		 * @return {void} 
		 */
		DeleteNetworkSensorAlertsProfile(networkId: string, id: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sensor/alerts/profiles/' + (id == null ? '' : encodeURIComponent(id)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Show details of a sensor alert profile for a network.
		 * Show details of a sensor alert profile for a network.
		 * Get networks/{networkId}/sensor/alerts/profiles/{id}
		 * @return {GetNetworkSensorAlertsProfileReturn} Successful operation
		 */
		GetNetworkSensorAlertsProfile(networkId: string, id: string): Observable<GetNetworkSensorAlertsProfileReturn> {
			return this.http.get<GetNetworkSensorAlertsProfileReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sensor/alerts/profiles/' + (id == null ? '' : encodeURIComponent(id)), {});
		}

		/**
		 * Updates a sensor alert profile for a network.
		 * Updates a sensor alert profile for a network.
		 * Put networks/{networkId}/sensor/alerts/profiles/{id}
		 * @return {UpdateNetworkSensorAlertsProfileReturn} Successful operation
		 */
		UpdateNetworkSensorAlertsProfile(networkId: string, id: string, requestBody: UpdateNetworkSensorAlertsProfilePutBody): Observable<UpdateNetworkSensorAlertsProfileReturn> {
			return this.http.put<UpdateNetworkSensorAlertsProfileReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sensor/alerts/profiles/' + (id == null ? '' : encodeURIComponent(id)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the sensor roles for devices in a given network
		 * List the sensor roles for devices in a given network
		 * Get networks/{networkId}/sensor/relationships
		 * @return {Array<GetNetworkSensorRelationshipsReturn>} Successful operation
		 */
		GetNetworkSensorRelationships(networkId: string): Observable<Array<GetNetworkSensorRelationshipsReturn>> {
			return this.http.get<Array<GetNetworkSensorRelationshipsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sensor/relationships', {});
		}

		/**
		 * Return the settings for a network
		 * Return the settings for a network
		 * Get networks/{networkId}/settings
		 * @return {GetNetworkSettingsReturn} Successful operation
		 */
		GetNetworkSettings(networkId: string): Observable<GetNetworkSettingsReturn> {
			return this.http.get<GetNetworkSettingsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/settings', {});
		}

		/**
		 * Update the settings for a network
		 * Update the settings for a network
		 * Put networks/{networkId}/settings
		 * @return {UpdateNetworkSettingsReturn} Successful operation
		 */
		UpdateNetworkSettings(networkId: string, requestBody: UpdateNetworkSettingsPutBody): Observable<UpdateNetworkSettingsReturn> {
			return this.http.put<UpdateNetworkSettingsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Bypass activation lock attempt
		 * Bypass activation lock attempt
		 * Post networks/{networkId}/sm/bypassActivationLockAttempts
		 * @return {void} 
		 */
		CreateNetworkSmBypassActivationLockAttempt(networkId: string, requestBody: CreateNetworkSmBypassActivationLockAttemptPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/bypassActivationLockAttempts', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Bypass activation lock attempt status
		 * Bypass activation lock attempt status
		 * Get networks/{networkId}/sm/bypassActivationLockAttempts/{attemptId}
		 * @return {string} Successful operation
		 */
		GetNetworkSmBypassActivationLockAttempt(networkId: string, attemptId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/bypassActivationLockAttempts/' + (attemptId == null ? '' : encodeURIComponent(attemptId)), { responseType: 'text' });
		}

		/**
		 * List the devices enrolled in an SM network with various specified fields and filters
		 * List the devices enrolled in an SM network with various specified fields and filters
		 * Get networks/{networkId}/sm/devices
		 * @param {Array<string>} fields Additional fields that will be displayed for each device.
		 *     The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,
		 *     systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,
		 *     ownerEmail, ownerUsername, osBuild, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,
		 *     simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,
		 *     isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,
		 *     hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, androidSecurityPatchVersion, and url.
		 * @param {Array<string>} wifiMacs Filter devices by wifi mac(s).
		 * @param {Array<string>} serials Filter devices by serial(s).
		 * @param {Array<string>} ids Filter devices by id(s).
		 * @param {Array<string>} scope Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<GetNetworkSmDevicesReturn>} Successful operation
		 */
		GetNetworkSmDevices(networkId: string, fields: Array<string> | null | undefined, wifiMacs: Array<string> | null | undefined, serials: Array<string> | null | undefined, ids: Array<string> | null | undefined, scope: Array<string> | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<GetNetworkSmDevicesReturn>> {
			return this.http.get<Array<GetNetworkSmDevicesReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices&' + fields?.map(z => `fields=${encodeURIComponent(z)}`).join('&') + '&' + wifiMacs?.map(z => `wifiMacs=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + ids?.map(z => `ids=${encodeURIComponent(z)}`).join('&') + '&' + scope?.map(z => `scope=${encodeURIComponent(z)}`).join('&') + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Force check-in a set of devices
		 * Force check-in a set of devices
		 * Post networks/{networkId}/sm/devices/checkin
		 * @return {CheckinNetworkSmDevicesReturn} Successful operation
		 */
		CheckinNetworkSmDevices(networkId: string, requestBody: CheckinNetworkSmDevicesPostBody): Observable<CheckinNetworkSmDevicesReturn> {
			return this.http.post<CheckinNetworkSmDevicesReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/checkin', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Modify the fields of a device
		 * Modify the fields of a device
		 * Put networks/{networkId}/sm/devices/fields
		 * @return {Array<UpdateNetworkSmDevicesFieldsReturn>} Successful operation
		 */
		UpdateNetworkSmDevicesFields(networkId: string, requestBody: UpdateNetworkSmDevicesFieldsPutBody): Observable<Array<UpdateNetworkSmDevicesFieldsReturn>> {
			return this.http.put<Array<UpdateNetworkSmDevicesFieldsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/fields', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Lock a set of devices
		 * Lock a set of devices
		 * Post networks/{networkId}/sm/devices/lock
		 * @return {LockNetworkSmDevicesReturn} Successful operation
		 */
		LockNetworkSmDevices(networkId: string, requestBody: LockNetworkSmDevicesPostBody): Observable<LockNetworkSmDevicesReturn> {
			return this.http.post<LockNetworkSmDevicesReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/lock', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Add, delete, or update the tags of a set of devices
		 * Add, delete, or update the tags of a set of devices
		 * Post networks/{networkId}/sm/devices/modifyTags
		 * @return {Array<ModifyNetworkSmDevicesTagsReturn>} Successful operation
		 */
		ModifyNetworkSmDevicesTags(networkId: string, requestBody: ModifyNetworkSmDevicesTagsPostBody): Observable<Array<ModifyNetworkSmDevicesTagsReturn>> {
			return this.http.post<Array<ModifyNetworkSmDevicesTagsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/modifyTags', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Move a set of devices to a new network
		 * Move a set of devices to a new network
		 * Post networks/{networkId}/sm/devices/move
		 * @return {MoveNetworkSmDevicesReturn} Successful operation
		 */
		MoveNetworkSmDevices(networkId: string, requestBody: MoveNetworkSmDevicesPostBody): Observable<MoveNetworkSmDevicesReturn> {
			return this.http.post<MoveNetworkSmDevicesReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/move', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Wipe a device
		 * Wipe a device
		 * Post networks/{networkId}/sm/devices/wipe
		 * @return {WipeNetworkSmDevicesReturn} Successful operation
		 */
		WipeNetworkSmDevices(networkId: string, requestBody: WipeNetworkSmDevicesPostBody): Observable<WipeNetworkSmDevicesReturn> {
			return this.http.post<WipeNetworkSmDevicesReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/wipe', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return the client's daily cellular data usage history
		 * Return the client's daily cellular data usage history. Usage data is in kilobytes.
		 * Get networks/{networkId}/sm/devices/{deviceId}/cellularUsageHistory
		 * @return {Array<GetNetworkSmDeviceCellularUsageHistoryReturn>} Successful operation
		 */
		GetNetworkSmDeviceCellularUsageHistory(networkId: string, deviceId: string): Observable<Array<GetNetworkSmDeviceCellularUsageHistoryReturn>> {
			return this.http.get<Array<GetNetworkSmDeviceCellularUsageHistoryReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/cellularUsageHistory', {});
		}

		/**
		 * List the certs on a device
		 * List the certs on a device
		 * Get networks/{networkId}/sm/devices/{deviceId}/certs
		 * @return {Array<GetNetworkSmDeviceCertsReturn>} Successful operation
		 */
		GetNetworkSmDeviceCerts(networkId: string, deviceId: string): Observable<Array<GetNetworkSmDeviceCertsReturn>> {
			return this.http.get<Array<GetNetworkSmDeviceCertsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/certs', {});
		}

		/**
		 * Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
		 * Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
		 * Get networks/{networkId}/sm/devices/{deviceId}/connectivity
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<GetNetworkSmDeviceConnectivityReturn>} Successful operation
		 */
		GetNetworkSmDeviceConnectivity(networkId: string, deviceId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<GetNetworkSmDeviceConnectivityReturn>> {
			return this.http.get<Array<GetNetworkSmDeviceConnectivityReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/connectivity&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Return historical records of various Systems Manager network connection details for desktop devices.
		 * Return historical records of various Systems Manager network connection details for desktop devices.
		 * Get networks/{networkId}/sm/devices/{deviceId}/desktopLogs
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<GetNetworkSmDeviceDesktopLogsReturn>} Successful operation
		 */
		GetNetworkSmDeviceDesktopLogs(networkId: string, deviceId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<GetNetworkSmDeviceDesktopLogsReturn>> {
			return this.http.get<Array<GetNetworkSmDeviceDesktopLogsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/desktopLogs&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Return historical records of commands sent to Systems Manager devices
		 * Return historical records of commands sent to Systems Manager devices. Note that this will include the name of the Dashboard user who initiated the command if it was generated by a Dashboard admin rather than the automatic behavior of the system; you may wish to filter this out of any reports.
		 * Get networks/{networkId}/sm/devices/{deviceId}/deviceCommandLogs
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<GetNetworkSmDeviceDeviceCommandLogsReturn>} Successful operation
		 */
		GetNetworkSmDeviceDeviceCommandLogs(networkId: string, deviceId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<GetNetworkSmDeviceDeviceCommandLogsReturn>> {
			return this.http.get<Array<GetNetworkSmDeviceDeviceCommandLogsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/deviceCommandLogs&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Get the installed profiles associated with a device
		 * Get the installed profiles associated with a device
		 * Get networks/{networkId}/sm/devices/{deviceId}/deviceProfiles
		 * @return {Array<GetNetworkSmDeviceDeviceProfilesReturn>} Successful operation
		 */
		GetNetworkSmDeviceDeviceProfiles(networkId: string, deviceId: string): Observable<Array<GetNetworkSmDeviceDeviceProfilesReturn>> {
			return this.http.get<Array<GetNetworkSmDeviceDeviceProfilesReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/deviceProfiles', {});
		}

		/**
		 * List the network adapters of a device
		 * List the network adapters of a device
		 * Get networks/{networkId}/sm/devices/{deviceId}/networkAdapters
		 * @return {Array<GetNetworkSmDeviceNetworkAdaptersReturn>} Successful operation
		 */
		GetNetworkSmDeviceNetworkAdapters(networkId: string, deviceId: string): Observable<Array<GetNetworkSmDeviceNetworkAdaptersReturn>> {
			return this.http.get<Array<GetNetworkSmDeviceNetworkAdaptersReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/networkAdapters', {});
		}

		/**
		 * Return historical records of various Systems Manager client metrics for desktop devices.
		 * Return historical records of various Systems Manager client metrics for desktop devices.
		 * Get networks/{networkId}/sm/devices/{deviceId}/performanceHistory
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<GetNetworkSmDevicePerformanceHistoryReturn>} Successful operation
		 */
		GetNetworkSmDevicePerformanceHistory(networkId: string, deviceId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<GetNetworkSmDevicePerformanceHistoryReturn>> {
			return this.http.get<Array<GetNetworkSmDevicePerformanceHistoryReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/performanceHistory&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Refresh the details of a device
		 * Refresh the details of a device
		 * Post networks/{networkId}/sm/devices/{deviceId}/refreshDetails
		 * @return {void} Successful operation
		 */
		RefreshNetworkSmDeviceDetails(networkId: string, deviceId: string): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/refreshDetails', null, { observe: 'response', responseType: 'text' });
		}

		/**
		 * List the restrictions on a device
		 * List the restrictions on a device
		 * Get networks/{networkId}/sm/devices/{deviceId}/restrictions
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkSmDeviceRestrictions(networkId: string, deviceId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/restrictions', {});
		}

		/**
		 * List the security centers on a device
		 * List the security centers on a device
		 * Get networks/{networkId}/sm/devices/{deviceId}/securityCenters
		 * @return {Array<GetNetworkSmDeviceSecurityCentersReturn>} Successful operation
		 */
		GetNetworkSmDeviceSecurityCenters(networkId: string, deviceId: string): Observable<Array<GetNetworkSmDeviceSecurityCentersReturn>> {
			return this.http.get<Array<GetNetworkSmDeviceSecurityCentersReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/securityCenters', {});
		}

		/**
		 * Get a list of softwares associated with a device
		 * Get a list of softwares associated with a device
		 * Get networks/{networkId}/sm/devices/{deviceId}/softwares
		 * @return {Array<GetNetworkSmDeviceSoftwaresReturn>} Successful operation
		 */
		GetNetworkSmDeviceSoftwares(networkId: string, deviceId: string): Observable<Array<GetNetworkSmDeviceSoftwaresReturn>> {
			return this.http.get<Array<GetNetworkSmDeviceSoftwaresReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/softwares', {});
		}

		/**
		 * Unenroll a device
		 * Unenroll a device
		 * Post networks/{networkId}/sm/devices/{deviceId}/unenroll
		 * @return {string} Successful operation
		 */
		UnenrollNetworkSmDevice(networkId: string, deviceId: string): Observable<string> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/unenroll', null, { responseType: 'text' });
		}

		/**
		 * List the saved SSID names on a device
		 * List the saved SSID names on a device
		 * Get networks/{networkId}/sm/devices/{deviceId}/wlanLists
		 * @return {Array<GetNetworkSmDeviceWlanListsReturn>} Successful operation
		 */
		GetNetworkSmDeviceWlanLists(networkId: string, deviceId: string): Observable<Array<GetNetworkSmDeviceWlanListsReturn>> {
			return this.http.get<Array<GetNetworkSmDeviceWlanListsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/devices/' + (deviceId == null ? '' : encodeURIComponent(deviceId)) + '/wlanLists', {});
		}

		/**
		 * List all profiles in a network
		 * List all profiles in a network
		 * Get networks/{networkId}/sm/profiles
		 * @return {Array<GetNetworkSmProfilesReturn>} Successful operation
		 */
		GetNetworkSmProfiles(networkId: string): Observable<Array<GetNetworkSmProfilesReturn>> {
			return this.http.get<Array<GetNetworkSmProfilesReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/profiles', {});
		}

		/**
		 * List the target groups in this network
		 * List the target groups in this network
		 * Get networks/{networkId}/sm/targetGroups
		 * @param {boolean} withDetails Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkSmTargetGroups(networkId: string, withDetails: boolean | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/targetGroups&withDetails=' + withDetails, {});
		}

		/**
		 * Add a target group
		 * Add a target group
		 * Post networks/{networkId}/sm/targetGroups
		 * @return {void} 
		 */
		CreateNetworkSmTargetGroup(networkId: string, requestBody: CreateNetworkSmTargetGroupCreatenetworksmtargetgroup): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/targetGroups', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a target group from a network
		 * Delete a target group from a network
		 * Delete networks/{networkId}/sm/targetGroups/{targetGroupId}
		 * @return {void} 
		 */
		DeleteNetworkSmTargetGroup(networkId: string, targetGroupId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/targetGroups/' + (targetGroupId == null ? '' : encodeURIComponent(targetGroupId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a target group
		 * Return a target group
		 * Get networks/{networkId}/sm/targetGroups/{targetGroupId}
		 * @param {boolean} withDetails Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response
		 * @return {string} Successful operation
		 */
		GetNetworkSmTargetGroup(networkId: string, targetGroupId: string, withDetails: boolean | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/targetGroups/' + (targetGroupId == null ? '' : encodeURIComponent(targetGroupId)) + '&withDetails=' + withDetails, { responseType: 'text' });
		}

		/**
		 * Update a target group
		 * Update a target group
		 * Put networks/{networkId}/sm/targetGroups/{targetGroupId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkSmTargetGroup(networkId: string, targetGroupId: string, requestBody: CreateNetworkSmTargetGroupCreatenetworksmtargetgroup): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/targetGroups/' + (targetGroupId == null ? '' : encodeURIComponent(targetGroupId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List Trusted Access Configs
		 * List Trusted Access Configs
		 * Get networks/{networkId}/sm/trustedAccessConfigs
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<GetNetworkSmTrustedAccessConfigsReturn>} Successful operation
		 */
		GetNetworkSmTrustedAccessConfigs(networkId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<GetNetworkSmTrustedAccessConfigsReturn>> {
			return this.http.get<Array<GetNetworkSmTrustedAccessConfigsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/trustedAccessConfigs&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * List User Access Devices and its Trusted Access Connections
		 * List User Access Devices and its Trusted Access Connections
		 * Get networks/{networkId}/sm/userAccessDevices
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<GetNetworkSmUserAccessDevicesReturn>} Successful operation
		 */
		GetNetworkSmUserAccessDevices(networkId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<GetNetworkSmUserAccessDevicesReturn>> {
			return this.http.get<Array<GetNetworkSmUserAccessDevicesReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/userAccessDevices&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Delete a User Access Device
		 * Delete a User Access Device
		 * Delete networks/{networkId}/sm/userAccessDevices/{userAccessDeviceId}
		 * @return {void} 
		 */
		DeleteNetworkSmUserAccessDevice(networkId: string, userAccessDeviceId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/userAccessDevices/' + (userAccessDeviceId == null ? '' : encodeURIComponent(userAccessDeviceId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * List the owners in an SM network with various specified fields and filters
		 * List the owners in an SM network with various specified fields and filters
		 * Get networks/{networkId}/sm/users
		 * @param {Array<string>} ids Filter users by id(s).
		 * @param {Array<string>} usernames Filter users by username(s).
		 * @param {Array<string>} emails Filter users by email(s).
		 * @param {Array<string>} scope Specifiy a scope (one of all, none, withAny, withAll, withoutAny, withoutAll) and a set of tags.
		 * @return {Array<GetNetworkSmUsersReturn>} Successful operation
		 */
		GetNetworkSmUsers(networkId: string, ids: Array<string> | null | undefined, usernames: Array<string> | null | undefined, emails: Array<string> | null | undefined, scope: Array<string> | null | undefined): Observable<Array<GetNetworkSmUsersReturn>> {
			return this.http.get<Array<GetNetworkSmUsersReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/users&' + ids?.map(z => `ids=${encodeURIComponent(z)}`).join('&') + '&' + usernames?.map(z => `usernames=${encodeURIComponent(z)}`).join('&') + '&' + emails?.map(z => `emails=${encodeURIComponent(z)}`).join('&') + '&' + scope?.map(z => `scope=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * Get the profiles associated with a user
		 * Get the profiles associated with a user
		 * Get networks/{networkId}/sm/users/{userId}/deviceProfiles
		 * @return {Array<GetNetworkSmUserDeviceProfilesReturn>} Successful operation
		 */
		GetNetworkSmUserDeviceProfiles(networkId: string, userId: string): Observable<Array<GetNetworkSmUserDeviceProfilesReturn>> {
			return this.http.get<Array<GetNetworkSmUserDeviceProfilesReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/users/' + (userId == null ? '' : encodeURIComponent(userId)) + '/deviceProfiles', {});
		}

		/**
		 * Get a list of softwares associated with a user
		 * Get a list of softwares associated with a user
		 * Get networks/{networkId}/sm/users/{userId}/softwares
		 * @return {Array<GetNetworkSmUserSoftwaresReturn>} Successful operation
		 */
		GetNetworkSmUserSoftwares(networkId: string, userId: string): Observable<Array<GetNetworkSmUserSoftwaresReturn>> {
			return this.http.get<Array<GetNetworkSmUserSoftwaresReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/sm/users/' + (userId == null ? '' : encodeURIComponent(userId)) + '/softwares', {});
		}

		/**
		 * Return the SNMP settings for a network
		 * Return the SNMP settings for a network
		 * Get networks/{networkId}/snmp
		 * @return {string} Successful operation
		 */
		GetNetworkSnmp(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/snmp', { responseType: 'text' });
		}

		/**
		 * Update the SNMP settings for a network
		 * Update the SNMP settings for a network
		 * Put networks/{networkId}/snmp
		 * @return {string} Successful operation
		 */
		UpdateNetworkSnmp(networkId: string, requestBody: UpdateNetworkSnmpPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/snmp', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the splash login attempts for a network
		 * List the splash login attempts for a network
		 * Get networks/{networkId}/splashLoginAttempts
		 * @param {GetNetworkSplashLoginAttemptsSsidNumber} ssidNumber Only return the login attempts for the specified SSID
		 * @param {string} loginIdentifier The username, email, or phone number used during login
		 * @param {number} timespan The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkSplashLoginAttempts(networkId: string, ssidNumber: GetNetworkSplashLoginAttemptsSsidNumber | null | undefined, loginIdentifier: string | null | undefined, timespan: number | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/splashLoginAttempts&ssidNumber=' + ssidNumber + '&loginIdentifier=' + (loginIdentifier == null ? '' : encodeURIComponent(loginIdentifier)) + '&timespan=' + timespan, {});
		}

		/**
		 * Split a combined network into individual networks for each type of device
		 * Split a combined network into individual networks for each type of device
		 * Post networks/{networkId}/split
		 * @return {SplitNetworkReturn} Successful operation
		 */
		SplitNetwork(networkId: string): Observable<SplitNetworkReturn> {
			return this.http.post<SplitNetworkReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/split', null, {});
		}

		/**
		 * Return the access control lists for a MS network
		 * Return the access control lists for a MS network
		 * Get networks/{networkId}/switch/accessControlLists
		 * @return {GetNetworkSwitchAccessControlListsReturn} Successful operation
		 */
		GetNetworkSwitchAccessControlLists(networkId: string): Observable<GetNetworkSwitchAccessControlListsReturn> {
			return this.http.get<GetNetworkSwitchAccessControlListsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/accessControlLists', {});
		}

		/**
		 * Update the access control lists for a MS network
		 * Update the access control lists for a MS network
		 * Put networks/{networkId}/switch/accessControlLists
		 * @return {UpdateNetworkSwitchAccessControlListsReturn} Successful operation
		 */
		UpdateNetworkSwitchAccessControlLists(networkId: string, requestBody: UpdateNetworkSwitchAccessControlListsPutBody): Observable<UpdateNetworkSwitchAccessControlListsReturn> {
			return this.http.put<UpdateNetworkSwitchAccessControlListsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/accessControlLists', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the access policies for a switch network
		 * List the access policies for a switch network. Only returns access policies with 'my RADIUS server' as authentication method
		 * Get networks/{networkId}/switch/accessPolicies
		 * @return {Array<GetNetworkSwitchAccessPoliciesReturn>} Successful operation
		 */
		GetNetworkSwitchAccessPolicies(networkId: string): Observable<Array<GetNetworkSwitchAccessPoliciesReturn>> {
			return this.http.get<Array<GetNetworkSwitchAccessPoliciesReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/accessPolicies', {});
		}

		/**
		 * Create an access policy for a switch network
		 * Create an access policy for a switch network. If you would like to enable Meraki Authentication, set radiusServers to empty array.
		 * Post networks/{networkId}/switch/accessPolicies
		 * @return {void} 
		 */
		CreateNetworkSwitchAccessPolicy(networkId: string, requestBody: CreateNetworkSwitchAccessPolicyPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/accessPolicies', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete an access policy for a switch network
		 * Delete an access policy for a switch network
		 * Delete networks/{networkId}/switch/accessPolicies/{accessPolicyNumber}
		 * @return {void} 
		 */
		DeleteNetworkSwitchAccessPolicy(networkId: string, accessPolicyNumber: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/accessPolicies/' + (accessPolicyNumber == null ? '' : encodeURIComponent(accessPolicyNumber)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a specific access policy for a switch network
		 * Return a specific access policy for a switch network
		 * Get networks/{networkId}/switch/accessPolicies/{accessPolicyNumber}
		 * @return {GetNetworkSwitchAccessPolicyReturn} Successful operation
		 */
		GetNetworkSwitchAccessPolicy(networkId: string, accessPolicyNumber: string): Observable<GetNetworkSwitchAccessPolicyReturn> {
			return this.http.get<GetNetworkSwitchAccessPolicyReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/accessPolicies/' + (accessPolicyNumber == null ? '' : encodeURIComponent(accessPolicyNumber)), {});
		}

		/**
		 * Update an access policy for a switch network
		 * Update an access policy for a switch network. If you would like to enable Meraki Authentication, set radiusServers to empty array.
		 * Put networks/{networkId}/switch/accessPolicies/{accessPolicyNumber}
		 * @return {UpdateNetworkSwitchAccessPolicyReturn} Successful operation
		 */
		UpdateNetworkSwitchAccessPolicy(networkId: string, accessPolicyNumber: string, requestBody: UpdateNetworkSwitchAccessPolicyPutBody): Observable<UpdateNetworkSwitchAccessPolicyReturn> {
			return this.http.put<UpdateNetworkSwitchAccessPolicyReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/accessPolicies/' + (accessPolicyNumber == null ? '' : encodeURIComponent(accessPolicyNumber)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return the switch alternate management interface for the network
		 * Return the switch alternate management interface for the network
		 * Get networks/{networkId}/switch/alternateManagementInterface
		 * @return {string} Successful operation
		 */
		GetNetworkSwitchAlternateManagementInterface(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/alternateManagementInterface', { responseType: 'text' });
		}

		/**
		 * Update the switch alternate management interface for the network
		 * Update the switch alternate management interface for the network
		 * Put networks/{networkId}/switch/alternateManagementInterface
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchAlternateManagementInterface(networkId: string, requestBody: UpdateNetworkSwitchAlternateManagementInterfacePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/alternateManagementInterface', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the network's DHCPv4 servers seen within the selected timeframe (default 1 day)
		 * Return the network's DHCPv4 servers seen within the selected timeframe (default 1 day)
		 * Get networks/{networkId}/switch/dhcp/v4/servers/seen
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<GetNetworkSwitchDhcpV4ServersSeenReturn>} Successful operation
		 */
		GetNetworkSwitchDhcpV4ServersSeen(networkId: string, t0: string | null | undefined, timespan: number | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<GetNetworkSwitchDhcpV4ServersSeenReturn>> {
			return this.http.get<Array<GetNetworkSwitchDhcpV4ServersSeenReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/dhcp/v4/servers/seen&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&timespan=' + timespan + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Return the DHCP server settings
		 * Return the DHCP server settings. Blocked/allowed servers are only applied when default policy is allow/block, respectively
		 * Get networks/{networkId}/switch/dhcpServerPolicy
		 * @return {string} Successful operation
		 */
		GetNetworkSwitchDhcpServerPolicy(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/dhcpServerPolicy', { responseType: 'text' });
		}

		/**
		 * Update the DHCP server settings
		 * Update the DHCP server settings. Blocked/allowed servers are only applied when default policy is allow/block, respectively
		 * Put networks/{networkId}/switch/dhcpServerPolicy
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchDhcpServerPolicy(networkId: string, requestBody: UpdateNetworkSwitchDhcpServerPolicyPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/dhcpServerPolicy', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the list of servers trusted by Dynamic ARP Inspection on this network
		 * Return the list of servers trusted by Dynamic ARP Inspection on this network. These are also known as whitelisted snoop entries
		 * Get networks/{networkId}/switch/dhcpServerPolicy/arpInspection/trustedServers
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturn>} Successful operation
		 */
		GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServers(networkId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturn>> {
			return this.http.get<Array<GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/dhcpServerPolicy/arpInspection/trustedServers&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Add a server to be trusted by Dynamic ARP Inspection on this network
		 * Add a server to be trusted by Dynamic ARP Inspection on this network
		 * Post networks/{networkId}/switch/dhcpServerPolicy/arpInspection/trustedServers
		 * @return {void} 
		 */
		CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServer(networkId: string, requestBody: CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/dhcpServerPolicy/arpInspection/trustedServers', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Remove a server from being trusted by Dynamic ARP Inspection on this network
		 * Remove a server from being trusted by Dynamic ARP Inspection on this network
		 * Delete networks/{networkId}/switch/dhcpServerPolicy/arpInspection/trustedServers/{trustedServerId}
		 * @return {void} 
		 */
		DeleteNetworkSwitchDhcpServerPolicyArpInspectionTrustedServer(networkId: string, trustedServerId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/dhcpServerPolicy/arpInspection/trustedServers/' + (trustedServerId == null ? '' : encodeURIComponent(trustedServerId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Update a server that is trusted by Dynamic ARP Inspection on this network
		 * Update a server that is trusted by Dynamic ARP Inspection on this network
		 * Put networks/{networkId}/switch/dhcpServerPolicy/arpInspection/trustedServers/{trustedServerId}
		 * @return {UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturn} Successful operation
		 */
		UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServer(networkId: string, trustedServerId: string, requestBody: UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBody): Observable<UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturn> {
			return this.http.put<UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/dhcpServerPolicy/arpInspection/trustedServers/' + (trustedServerId == null ? '' : encodeURIComponent(trustedServerId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return the devices that have a Dynamic ARP Inspection warning and their warnings
		 * Return the devices that have a Dynamic ARP Inspection warning and their warnings
		 * Get networks/{networkId}/switch/dhcpServerPolicy/arpInspection/warnings/byDevice
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceReturn>} Successful operation
		 */
		GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDevice(networkId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceReturn>> {
			return this.http.get<Array<GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/dhcpServerPolicy/arpInspection/warnings/byDevice&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Return the DSCP to CoS mappings
		 * Return the DSCP to CoS mappings
		 * Get networks/{networkId}/switch/dscpToCosMappings
		 * @return {string} Successful operation
		 */
		GetNetworkSwitchDscpToCosMappings(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/dscpToCosMappings', { responseType: 'text' });
		}

		/**
		 * Update the DSCP to CoS mappings
		 * Update the DSCP to CoS mappings
		 * Put networks/{networkId}/switch/dscpToCosMappings
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchDscpToCosMappings(networkId: string, requestBody: UpdateNetworkSwitchDscpToCosMappingsPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/dscpToCosMappings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List link aggregation groups
		 * List link aggregation groups
		 * Get networks/{networkId}/switch/linkAggregations
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkSwitchLinkAggregations(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/linkAggregations', {});
		}

		/**
		 * Create a link aggregation group
		 * Create a link aggregation group
		 * Post networks/{networkId}/switch/linkAggregations
		 * @return {void} 
		 */
		CreateNetworkSwitchLinkAggregation(networkId: string, requestBody: CreateNetworkSwitchLinkAggregationPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/linkAggregations', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Split a link aggregation group into separate ports
		 * Split a link aggregation group into separate ports
		 * Delete networks/{networkId}/switch/linkAggregations/{linkAggregationId}
		 * @return {void} 
		 */
		DeleteNetworkSwitchLinkAggregation(networkId: string, linkAggregationId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/linkAggregations/' + (linkAggregationId == null ? '' : encodeURIComponent(linkAggregationId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Update a link aggregation group
		 * Update a link aggregation group
		 * Put networks/{networkId}/switch/linkAggregations/{linkAggregationId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchLinkAggregation(networkId: string, linkAggregationId: string, requestBody: UpdateNetworkSwitchLinkAggregationPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/linkAggregations/' + (linkAggregationId == null ? '' : encodeURIComponent(linkAggregationId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the MTU configuration
		 * Return the MTU configuration
		 * Get networks/{networkId}/switch/mtu
		 * @return {GetNetworkSwitchMtuReturn} Successful operation
		 */
		GetNetworkSwitchMtu(networkId: string): Observable<GetNetworkSwitchMtuReturn> {
			return this.http.get<GetNetworkSwitchMtuReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/mtu', {});
		}

		/**
		 * Update the MTU configuration
		 * Update the MTU configuration
		 * Put networks/{networkId}/switch/mtu
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchMtu(networkId: string, requestBody: UpdateNetworkSwitchMtuPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/mtu', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List switch port schedules
		 * List switch port schedules
		 * Get networks/{networkId}/switch/portSchedules
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkSwitchPortSchedules(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/portSchedules', {});
		}

		/**
		 * Add a switch port schedule
		 * Add a switch port schedule
		 * Post networks/{networkId}/switch/portSchedules
		 * @return {void} 
		 */
		CreateNetworkSwitchPortSchedule(networkId: string, requestBody: CreateNetworkSwitchPortSchedulePostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/portSchedules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a switch port schedule
		 * Delete a switch port schedule
		 * Delete networks/{networkId}/switch/portSchedules/{portScheduleId}
		 * @return {void} 
		 */
		DeleteNetworkSwitchPortSchedule(networkId: string, portScheduleId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/portSchedules/' + (portScheduleId == null ? '' : encodeURIComponent(portScheduleId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Update a switch port schedule
		 * Update a switch port schedule
		 * Put networks/{networkId}/switch/portSchedules/{portScheduleId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchPortSchedule(networkId: string, portScheduleId: string, requestBody: UpdateNetworkSwitchPortSchedulePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/portSchedules/' + (portScheduleId == null ? '' : encodeURIComponent(portScheduleId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List quality of service rules
		 * List quality of service rules
		 * Get networks/{networkId}/switch/qosRules
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkSwitchQosRules(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/qosRules', {});
		}

		/**
		 * Add a quality of service rule
		 * Add a quality of service rule
		 * Post networks/{networkId}/switch/qosRules
		 * @return {void} 
		 */
		CreateNetworkSwitchQosRule(networkId: string, requestBody: CreateNetworkSwitchQosRulePostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/qosRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Return the quality of service rule IDs by order in which they will be processed by the switch
		 * Return the quality of service rule IDs by order in which they will be processed by the switch
		 * Get networks/{networkId}/switch/qosRules/order
		 * @return {string} Successful operation
		 */
		GetNetworkSwitchQosRulesOrder(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/qosRules/order', { responseType: 'text' });
		}

		/**
		 * Update the order in which the rules should be processed by the switch
		 * Update the order in which the rules should be processed by the switch
		 * Put networks/{networkId}/switch/qosRules/order
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchQosRulesOrder(networkId: string, requestBody: UpdateNetworkSwitchQosRulesOrderPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/qosRules/order', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Delete a quality of service rule
		 * Delete a quality of service rule
		 * Delete networks/{networkId}/switch/qosRules/{qosRuleId}
		 * @return {void} 
		 */
		DeleteNetworkSwitchQosRule(networkId: string, qosRuleId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/qosRules/' + (qosRuleId == null ? '' : encodeURIComponent(qosRuleId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a quality of service rule
		 * Return a quality of service rule
		 * Get networks/{networkId}/switch/qosRules/{qosRuleId}
		 * @return {string} Successful operation
		 */
		GetNetworkSwitchQosRule(networkId: string, qosRuleId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/qosRules/' + (qosRuleId == null ? '' : encodeURIComponent(qosRuleId)), { responseType: 'text' });
		}

		/**
		 * Update a quality of service rule
		 * Update a quality of service rule
		 * Put networks/{networkId}/switch/qosRules/{qosRuleId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchQosRule(networkId: string, qosRuleId: string, requestBody: UpdateNetworkSwitchQosRulePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/qosRules/' + (qosRuleId == null ? '' : encodeURIComponent(qosRuleId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return multicast settings for a network
		 * Return multicast settings for a network
		 * Get networks/{networkId}/switch/routing/multicast
		 * @return {string} Successful operation
		 */
		GetNetworkSwitchRoutingMulticast(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/routing/multicast', { responseType: 'text' });
		}

		/**
		 * Update multicast settings for a network
		 * Update multicast settings for a network
		 * Put networks/{networkId}/switch/routing/multicast
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchRoutingMulticast(networkId: string, requestBody: UpdateNetworkSwitchRoutingMulticastPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/routing/multicast', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List multicast rendezvous points
		 * List multicast rendezvous points
		 * Get networks/{networkId}/switch/routing/multicast/rendezvousPoints
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkSwitchRoutingMulticastRendezvousPoints(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/routing/multicast/rendezvousPoints', {});
		}

		/**
		 * Create a multicast rendezvous point
		 * Create a multicast rendezvous point
		 * Post networks/{networkId}/switch/routing/multicast/rendezvousPoints
		 * @return {void} 
		 */
		CreateNetworkSwitchRoutingMulticastRendezvousPoint(networkId: string, requestBody: CreateNetworkSwitchRoutingMulticastRendezvousPointPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/routing/multicast/rendezvousPoints', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a multicast rendezvous point
		 * Delete a multicast rendezvous point
		 * Delete networks/{networkId}/switch/routing/multicast/rendezvousPoints/{rendezvousPointId}
		 * @return {void} 
		 */
		DeleteNetworkSwitchRoutingMulticastRendezvousPoint(networkId: string, rendezvousPointId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/routing/multicast/rendezvousPoints/' + (rendezvousPointId == null ? '' : encodeURIComponent(rendezvousPointId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a multicast rendezvous point
		 * Return a multicast rendezvous point
		 * Get networks/{networkId}/switch/routing/multicast/rendezvousPoints/{rendezvousPointId}
		 * @return {string} Successful operation
		 */
		GetNetworkSwitchRoutingMulticastRendezvousPoint(networkId: string, rendezvousPointId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/routing/multicast/rendezvousPoints/' + (rendezvousPointId == null ? '' : encodeURIComponent(rendezvousPointId)), { responseType: 'text' });
		}

		/**
		 * Update a multicast rendezvous point
		 * Update a multicast rendezvous point
		 * Put networks/{networkId}/switch/routing/multicast/rendezvousPoints/{rendezvousPointId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchRoutingMulticastRendezvousPoint(networkId: string, rendezvousPointId: string, requestBody: UpdateNetworkSwitchRoutingMulticastRendezvousPointPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/routing/multicast/rendezvousPoints/' + (rendezvousPointId == null ? '' : encodeURIComponent(rendezvousPointId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return layer 3 OSPF routing configuration
		 * Return layer 3 OSPF routing configuration
		 * Get networks/{networkId}/switch/routing/ospf
		 * @return {string} Successful operation
		 */
		GetNetworkSwitchRoutingOspf(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/routing/ospf', { responseType: 'text' });
		}

		/**
		 * Update layer 3 OSPF routing configuration
		 * Update layer 3 OSPF routing configuration
		 * Put networks/{networkId}/switch/routing/ospf
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchRoutingOspf(networkId: string, requestBody: UpdateNetworkSwitchRoutingOspfPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/routing/ospf', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns the switch network settings
		 * Returns the switch network settings
		 * Get networks/{networkId}/switch/settings
		 * @return {GetNetworkSwitchSettingsReturn} Successful operation
		 */
		GetNetworkSwitchSettings(networkId: string): Observable<GetNetworkSwitchSettingsReturn> {
			return this.http.get<GetNetworkSwitchSettingsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/settings', {});
		}

		/**
		 * Update switch network settings
		 * Update switch network settings
		 * Put networks/{networkId}/switch/settings
		 * @return {UpdateNetworkSwitchSettingsReturn} Successful operation
		 */
		UpdateNetworkSwitchSettings(networkId: string, requestBody: UpdateNetworkSwitchSettingsPutBody): Observable<UpdateNetworkSwitchSettingsReturn> {
			return this.http.put<UpdateNetworkSwitchSettingsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the switch stacks in a network
		 * List the switch stacks in a network
		 * Get networks/{networkId}/switch/stacks
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkSwitchStacks(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks', {});
		}

		/**
		 * Create a stack
		 * Create a stack
		 * Post networks/{networkId}/switch/stacks
		 * @return {void} 
		 */
		CreateNetworkSwitchStack(networkId: string, requestBody: CreateNetworkSwitchStackPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a stack
		 * Delete a stack
		 * Delete networks/{networkId}/switch/stacks/{switchStackId}
		 * @return {void} 
		 */
		DeleteNetworkSwitchStack(networkId: string, switchStackId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Show a switch stack
		 * Show a switch stack
		 * Get networks/{networkId}/switch/stacks/{switchStackId}
		 * @return {GetNetworkSwitchStackReturn} Successful operation
		 */
		GetNetworkSwitchStack(networkId: string, switchStackId: string): Observable<GetNetworkSwitchStackReturn> {
			return this.http.get<GetNetworkSwitchStackReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)), {});
		}

		/**
		 * Add a switch to a stack
		 * Add a switch to a stack
		 * Post networks/{networkId}/switch/stacks/{switchStackId}/add
		 * @return {string} Successful operation
		 */
		AddNetworkSwitchStack(networkId: string, switchStackId: string, requestBody: AddNetworkSwitchStackPostBody): Observable<string> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/add', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Remove a switch from a stack
		 * Remove a switch from a stack
		 * Post networks/{networkId}/switch/stacks/{switchStackId}/remove
		 * @return {string} Successful operation
		 */
		RemoveNetworkSwitchStack(networkId: string, switchStackId: string, requestBody: RemoveNetworkSwitchStackPostBody): Observable<string> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/remove', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List layer 3 interfaces for a switch stack
		 * List layer 3 interfaces for a switch stack
		 * Get networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkSwitchStackRoutingInterfaces(networkId: string, switchStackId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/routing/interfaces', {});
		}

		/**
		 * Create a layer 3 interface for a switch stack
		 * Create a layer 3 interface for a switch stack
		 * Post networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces
		 * @return {void} 
		 */
		CreateNetworkSwitchStackRoutingInterface(networkId: string, switchStackId: string, requestBody: CreateNetworkSwitchStackRoutingInterfacePostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/routing/interfaces', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a layer 3 interface from a switch stack
		 * Delete a layer 3 interface from a switch stack
		 * Delete networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}
		 * @return {void} 
		 */
		DeleteNetworkSwitchStackRoutingInterface(networkId: string, switchStackId: string, interfaceId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/routing/interfaces/' + (interfaceId == null ? '' : encodeURIComponent(interfaceId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a layer 3 interface from a switch stack
		 * Return a layer 3 interface from a switch stack
		 * Get networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}
		 * @return {string} Successful operation
		 */
		GetNetworkSwitchStackRoutingInterface(networkId: string, switchStackId: string, interfaceId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/routing/interfaces/' + (interfaceId == null ? '' : encodeURIComponent(interfaceId)), { responseType: 'text' });
		}

		/**
		 * Update a layer 3 interface for a switch stack
		 * Update a layer 3 interface for a switch stack
		 * Put networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchStackRoutingInterface(networkId: string, switchStackId: string, interfaceId: string, requestBody: UpdateNetworkSwitchStackRoutingInterfacePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/routing/interfaces/' + (interfaceId == null ? '' : encodeURIComponent(interfaceId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return a layer 3 interface DHCP configuration for a switch stack
		 * Return a layer 3 interface DHCP configuration for a switch stack
		 * Get networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}/dhcp
		 * @return {string} Successful operation
		 */
		GetNetworkSwitchStackRoutingInterfaceDhcp(networkId: string, switchStackId: string, interfaceId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/routing/interfaces/' + (interfaceId == null ? '' : encodeURIComponent(interfaceId)) + '/dhcp', { responseType: 'text' });
		}

		/**
		 * Update a layer 3 interface DHCP configuration for a switch stack
		 * Update a layer 3 interface DHCP configuration for a switch stack
		 * Put networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}/dhcp
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchStackRoutingInterfaceDhcp(networkId: string, switchStackId: string, interfaceId: string, requestBody: UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/routing/interfaces/' + (interfaceId == null ? '' : encodeURIComponent(interfaceId)) + '/dhcp', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List layer 3 static routes for a switch stack
		 * List layer 3 static routes for a switch stack
		 * Get networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkSwitchStackRoutingStaticRoutes(networkId: string, switchStackId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/routing/staticRoutes', {});
		}

		/**
		 * Create a layer 3 static route for a switch stack
		 * Create a layer 3 static route for a switch stack
		 * Post networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes
		 * @return {void} 
		 */
		CreateNetworkSwitchStackRoutingStaticRoute(networkId: string, switchStackId: string, requestBody: CreateDeviceSwitchRoutingStaticRouteCreatedeviceswitchroutingstaticroute): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/routing/staticRoutes', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a layer 3 static route for a switch stack
		 * Delete a layer 3 static route for a switch stack
		 * Delete networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes/{staticRouteId}
		 * @return {void} 
		 */
		DeleteNetworkSwitchStackRoutingStaticRoute(networkId: string, switchStackId: string, staticRouteId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/routing/staticRoutes/' + (staticRouteId == null ? '' : encodeURIComponent(staticRouteId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a layer 3 static route for a switch stack
		 * Return a layer 3 static route for a switch stack
		 * Get networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes/{staticRouteId}
		 * @return {string} Successful operation
		 */
		GetNetworkSwitchStackRoutingStaticRoute(networkId: string, switchStackId: string, staticRouteId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/routing/staticRoutes/' + (staticRouteId == null ? '' : encodeURIComponent(staticRouteId)), { responseType: 'text' });
		}

		/**
		 * Update a layer 3 static route for a switch stack
		 * Update a layer 3 static route for a switch stack
		 * Put networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes/{staticRouteId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchStackRoutingStaticRoute(networkId: string, switchStackId: string, staticRouteId: string, requestBody: UpdateDeviceSwitchRoutingStaticRouteUpdatedeviceswitchroutingstaticroute): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stacks/' + (switchStackId == null ? '' : encodeURIComponent(switchStackId)) + '/routing/staticRoutes/' + (staticRouteId == null ? '' : encodeURIComponent(staticRouteId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the storm control configuration for a switch network
		 * Return the storm control configuration for a switch network
		 * Get networks/{networkId}/switch/stormControl
		 * @return {GetNetworkSwitchStormControlReturn} Successful operation
		 */
		GetNetworkSwitchStormControl(networkId: string): Observable<GetNetworkSwitchStormControlReturn> {
			return this.http.get<GetNetworkSwitchStormControlReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stormControl', {});
		}

		/**
		 * Update the storm control configuration for a switch network
		 * Update the storm control configuration for a switch network
		 * Put networks/{networkId}/switch/stormControl
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchStormControl(networkId: string, requestBody: UpdateNetworkSwitchStormControlPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stormControl', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns STP settings
		 * Returns STP settings
		 * Get networks/{networkId}/switch/stp
		 * @return {string} Successful operation
		 */
		GetNetworkSwitchStp(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stp', { responseType: 'text' });
		}

		/**
		 * Updates STP settings
		 * Updates STP settings
		 * Put networks/{networkId}/switch/stp
		 * @return {string} Successful operation
		 */
		UpdateNetworkSwitchStp(networkId: string, requestBody: UpdateNetworkSwitchStpPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/switch/stp', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the syslog servers for a network
		 * List the syslog servers for a network
		 * Get networks/{networkId}/syslogServers
		 * @return {GetNetworkSyslogServersReturn} Successful operation
		 */
		GetNetworkSyslogServers(networkId: string): Observable<GetNetworkSyslogServersReturn> {
			return this.http.get<GetNetworkSyslogServersReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/syslogServers', {});
		}

		/**
		 * Update the syslog servers for a network
		 * Update the syslog servers for a network
		 * Put networks/{networkId}/syslogServers
		 * @return {UpdateNetworkSyslogServersReturn} Successful operation
		 */
		UpdateNetworkSyslogServers(networkId: string, requestBody: UpdateNetworkSyslogServersPutBody): Observable<UpdateNetworkSyslogServersReturn> {
			return this.http.put<UpdateNetworkSyslogServersReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/syslogServers', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the LLDP and CDP information for all discovered devices and connections in a network.
		 * List the LLDP and CDP information for all discovered devices and connections in a network.
		 * Get networks/{networkId}/topology/linkLayer
		 * @return {string} Successful operation
		 */
		GetNetworkTopologyLinkLayer(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/topology/linkLayer', { responseType: 'text' });
		}

		/**
		 * Return the traffic analysis data for this network
		 * Return the traffic analysis data for this network. Traffic analysis with hostname visibility must be enabled on the network.
		 * Get networks/{networkId}/traffic
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days.
		 * @param {GetNetworkTrafficDeviceType} deviceType Filter the data by device type: 'combined', 'wireless', 'switch' or 'appliance'. Defaults to 'combined'. When using 'combined', for each rule the data will come from the device type with the most usage.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkTraffic(networkId: string, t0: string | null | undefined, timespan: number | null | undefined, deviceType: GetNetworkTrafficDeviceType | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/traffic&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&timespan=' + timespan + '&deviceType=' + deviceType, {});
		}

		/**
		 * Return the traffic analysis settings for a network
		 * Return the traffic analysis settings for a network
		 * Get networks/{networkId}/trafficAnalysis
		 * @return {string} Successful operation
		 */
		GetNetworkTrafficAnalysis(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/trafficAnalysis', { responseType: 'text' });
		}

		/**
		 * Update the traffic analysis settings for a network
		 * Update the traffic analysis settings for a network
		 * Put networks/{networkId}/trafficAnalysis
		 * @return {string} Successful operation
		 */
		UpdateNetworkTrafficAnalysis(networkId: string, requestBody: UpdateNetworkTrafficAnalysisPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/trafficAnalysis', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns the application categories for traffic shaping rules.
		 * Returns the application categories for traffic shaping rules.
		 * Get networks/{networkId}/trafficShaping/applicationCategories
		 * @return {string} Successful operation
		 */
		GetNetworkTrafficShapingApplicationCategories(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/trafficShaping/applicationCategories', { responseType: 'text' });
		}

		/**
		 * Returns the available DSCP tagging options for your traffic shaping rules.
		 * Returns the available DSCP tagging options for your traffic shaping rules.
		 * Get networks/{networkId}/trafficShaping/dscpTaggingOptions
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkTrafficShapingDscpTaggingOptions(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/trafficShaping/dscpTaggingOptions', {});
		}

		/**
		 * Unbind a network from a template.
		 * Unbind a network from a template.
		 * Post networks/{networkId}/unbind
		 * @return {UnbindNetworkReturn} Successful operation
		 */
		UnbindNetwork(networkId: string, requestBody: UnbindNetworkPostBody): Observable<UnbindNetworkReturn> {
			return this.http.post<UnbindNetworkReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/unbind', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the HTTP servers for a network
		 * List the HTTP servers for a network
		 * Get networks/{networkId}/webhooks/httpServers
		 * @return {Array<GetNetworkWebhooksHttpServersReturn>} Successful operation
		 */
		GetNetworkWebhooksHttpServers(networkId: string): Observable<Array<GetNetworkWebhooksHttpServersReturn>> {
			return this.http.get<Array<GetNetworkWebhooksHttpServersReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/webhooks/httpServers', {});
		}

		/**
		 * Add an HTTP server to a network
		 * Add an HTTP server to a network
		 * Post networks/{networkId}/webhooks/httpServers
		 * @return {void} 
		 */
		CreateNetworkWebhooksHttpServer(networkId: string, requestBody: CreateNetworkWebhooksHttpServerPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/webhooks/httpServers', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete an HTTP server from a network
		 * Delete an HTTP server from a network
		 * Delete networks/{networkId}/webhooks/httpServers/{httpServerId}
		 * @return {void} 
		 */
		DeleteNetworkWebhooksHttpServer(networkId: string, httpServerId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/webhooks/httpServers/' + (httpServerId == null ? '' : encodeURIComponent(httpServerId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return an HTTP server for a network
		 * Return an HTTP server for a network
		 * Get networks/{networkId}/webhooks/httpServers/{httpServerId}
		 * @return {GetNetworkWebhooksHttpServerReturn} Successful operation
		 */
		GetNetworkWebhooksHttpServer(networkId: string, httpServerId: string): Observable<GetNetworkWebhooksHttpServerReturn> {
			return this.http.get<GetNetworkWebhooksHttpServerReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/webhooks/httpServers/' + (httpServerId == null ? '' : encodeURIComponent(httpServerId)), {});
		}

		/**
		 * Update an HTTP server
		 * Update an HTTP server. To change a URL, create a new HTTP server.
		 * Put networks/{networkId}/webhooks/httpServers/{httpServerId}
		 * @return {UpdateNetworkWebhooksHttpServerReturn} Successful operation
		 */
		UpdateNetworkWebhooksHttpServer(networkId: string, httpServerId: string, requestBody: UpdateNetworkWebhooksHttpServerPutBody): Observable<UpdateNetworkWebhooksHttpServerReturn> {
			return this.http.put<UpdateNetworkWebhooksHttpServerReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/webhooks/httpServers/' + (httpServerId == null ? '' : encodeURIComponent(httpServerId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the webhook payload templates for a network
		 * List the webhook payload templates for a network
		 * Get networks/{networkId}/webhooks/payloadTemplates
		 * @return {Array<GetNetworkWebhooksPayloadTemplatesReturn>} Successful operation
		 */
		GetNetworkWebhooksPayloadTemplates(networkId: string): Observable<Array<GetNetworkWebhooksPayloadTemplatesReturn>> {
			return this.http.get<Array<GetNetworkWebhooksPayloadTemplatesReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/webhooks/payloadTemplates', {});
		}

		/**
		 * Create a webhook payload template for a network
		 * Create a webhook payload template for a network
		 * Post networks/{networkId}/webhooks/payloadTemplates
		 * @return {void} 
		 */
		CreateNetworkWebhooksPayloadTemplate(networkId: string, requestBody: CreateNetworkWebhooksPayloadTemplatePostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/webhooks/payloadTemplates', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Destroy a webhook payload template for a network
		 * Destroy a webhook payload template for a network. Does not work for included templates ('wpt_00001', 'wpt_00002', 'wpt_00003', 'wpt_00004', 'wpt_00005' or 'wpt_00006')
		 * Delete networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}
		 * @return {void} 
		 */
		DeleteNetworkWebhooksPayloadTemplate(networkId: string, payloadTemplateId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/webhooks/payloadTemplates/' + (payloadTemplateId == null ? '' : encodeURIComponent(payloadTemplateId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Get the webhook payload template for a network
		 * Get the webhook payload template for a network
		 * Get networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}
		 * @return {GetNetworkWebhooksPayloadTemplateReturn} Successful operation
		 */
		GetNetworkWebhooksPayloadTemplate(networkId: string, payloadTemplateId: string): Observable<GetNetworkWebhooksPayloadTemplateReturn> {
			return this.http.get<GetNetworkWebhooksPayloadTemplateReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/webhooks/payloadTemplates/' + (payloadTemplateId == null ? '' : encodeURIComponent(payloadTemplateId)), {});
		}

		/**
		 * Update a webhook payload template for a network
		 * Update a webhook payload template for a network
		 * Put networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}
		 * @return {UpdateNetworkWebhooksPayloadTemplateReturn} Successful operation
		 */
		UpdateNetworkWebhooksPayloadTemplate(networkId: string, payloadTemplateId: string, requestBody: UpdateNetworkWebhooksPayloadTemplatePutBody): Observable<UpdateNetworkWebhooksPayloadTemplateReturn> {
			return this.http.put<UpdateNetworkWebhooksPayloadTemplateReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/webhooks/payloadTemplates/' + (payloadTemplateId == null ? '' : encodeURIComponent(payloadTemplateId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Send a test webhook for a network
		 * Send a test webhook for a network
		 * Post networks/{networkId}/webhooks/webhookTests
		 * @return {void} 
		 */
		CreateNetworkWebhooksWebhookTest(networkId: string, requestBody: CreateNetworkWebhooksWebhookTestPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/webhooks/webhookTests', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Return the status of a webhook test for a network
		 * Return the status of a webhook test for a network
		 * Get networks/{networkId}/webhooks/webhookTests/{webhookTestId}
		 * @return {GetNetworkWebhooksWebhookTestReturn} Successful operation
		 */
		GetNetworkWebhooksWebhookTest(networkId: string, webhookTestId: string): Observable<GetNetworkWebhooksWebhookTestReturn> {
			return this.http.get<GetNetworkWebhooksWebhookTestReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/webhooks/webhookTests/' + (webhookTestId == null ? '' : encodeURIComponent(webhookTestId)), {});
		}

		/**
		 * List Air Marshal scan results from a network
		 * List Air Marshal scan results from a network
		 * Get networks/{networkId}/wireless/airMarshal
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkWirelessAirMarshal(networkId: string, t0: string | null | undefined, timespan: number | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/airMarshal&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return alternate management interface and devices with IP assigned
		 * Return alternate management interface and devices with IP assigned
		 * Get networks/{networkId}/wireless/alternateManagementInterface
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessAlternateManagementInterface(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/alternateManagementInterface', { responseType: 'text' });
		}

		/**
		 * Update alternate management interface and device static IP
		 * Update alternate management interface and device static IP
		 * Put networks/{networkId}/wireless/alternateManagementInterface
		 * @return {string} Successful operation
		 */
		UpdateNetworkWirelessAlternateManagementInterface(networkId: string, requestBody: UpdateNetworkWirelessAlternateManagementInterfacePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/alternateManagementInterface', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the billing settings of this network
		 * Return the billing settings of this network
		 * Get networks/{networkId}/wireless/billing
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessBilling(networkId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/billing', { responseType: 'text' });
		}

		/**
		 * Update the billing settings
		 * Update the billing settings
		 * Put networks/{networkId}/wireless/billing
		 * @return {string} Successful operation
		 */
		UpdateNetworkWirelessBilling(networkId: string, requestBody: UpdateNetworkWirelessBillingPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/billing', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the Bluetooth settings for a network. <a href="https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a> must be enabled on the network.
		 * Return the Bluetooth settings for a network. <a href="https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a> must be enabled on the network.
		 * Get networks/{networkId}/wireless/bluetooth/settings
		 * @return {GetNetworkWirelessBluetoothSettingsReturn} Successful operation
		 */
		GetNetworkWirelessBluetoothSettings(networkId: string): Observable<GetNetworkWirelessBluetoothSettingsReturn> {
			return this.http.get<GetNetworkWirelessBluetoothSettingsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/bluetooth/settings', {});
		}

		/**
		 * Update the Bluetooth settings for a network
		 * Update the Bluetooth settings for a network. See the docs page for <a href="https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a>.
		 * Put networks/{networkId}/wireless/bluetooth/settings
		 * @return {UpdateNetworkWirelessBluetoothSettingsReturn} Successful operation
		 */
		UpdateNetworkWirelessBluetoothSettings(networkId: string, requestBody: UpdateNetworkWirelessBluetoothSettingsPutBody): Observable<UpdateNetworkWirelessBluetoothSettingsReturn> {
			return this.http.put<UpdateNetworkWirelessBluetoothSettingsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/bluetooth/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return AP channel utilization over time for a device or network client
		 * Return AP channel utilization over time for a device or network client
		 * Get networks/{networkId}/wireless/channelUtilizationHistory
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400.
		 * @param {boolean} autoResolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
		 * @param {string} clientId Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client's connection history.
		 * @param {string} deviceSerial Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified.
		 * @param {string} apTag Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6').
		 * @return {Array<GetNetworkWirelessChannelUtilizationHistoryReturn>} Successful operation
		 */
		GetNetworkWirelessChannelUtilizationHistory(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined, autoResolution: boolean | null | undefined, clientId: string | null | undefined, deviceSerial: string | null | undefined, apTag: string | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined): Observable<Array<GetNetworkWirelessChannelUtilizationHistoryReturn>> {
			return this.http.get<Array<GetNetworkWirelessChannelUtilizationHistoryReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/channelUtilizationHistory&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution + '&autoResolution=' + autoResolution + '&clientId=' + (clientId == null ? '' : encodeURIComponent(clientId)) + '&deviceSerial=' + (deviceSerial == null ? '' : encodeURIComponent(deviceSerial)) + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)) + '&band=' + band, {});
		}

		/**
		 * Return wireless client counts over time for a network, device, or network client
		 * Return wireless client counts over time for a network, device, or network client
		 * Get networks/{networkId}/wireless/clientCountHistory
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
		 * @param {boolean} autoResolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
		 * @param {string} clientId Filter results by network client to return per-device client counts over time inner joined by the queried client's connection history.
		 * @param {string} deviceSerial Filter results by device.
		 * @param {string} apTag Filter results by AP tag.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6').
		 * @param {number} ssid Filter results by SSID number.
		 * @return {Array<GetNetworkWirelessClientCountHistoryReturn>} Successful operation
		 */
		GetNetworkWirelessClientCountHistory(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined, autoResolution: boolean | null | undefined, clientId: string | null | undefined, deviceSerial: string | null | undefined, apTag: string | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined): Observable<Array<GetNetworkWirelessClientCountHistoryReturn>> {
			return this.http.get<Array<GetNetworkWirelessClientCountHistoryReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/clientCountHistory&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution + '&autoResolution=' + autoResolution + '&clientId=' + (clientId == null ? '' : encodeURIComponent(clientId)) + '&deviceSerial=' + (deviceSerial == null ? '' : encodeURIComponent(deviceSerial)) + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)) + '&band=' + band + '&ssid=' + ssid, {});
		}

		/**
		 * Aggregated connectivity info for this network, grouped by clients
		 * Aggregated connectivity info for this network, grouped by clients
		 * Get networks/{networkId}/wireless/clients/connectionStats
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
		 * @param {number} ssid Filter results by SSID
		 * @param {number} vlan Filter results by VLAN
		 * @param {string} apTag Filter results by AP Tag
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkWirelessClientsConnectionStats(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined, vlan: number | null | undefined, apTag: string | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/clients/connectionStats&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&band=' + band + '&ssid=' + ssid + '&vlan=' + vlan + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)), {});
		}

		/**
		 * Aggregated latency info for this network, grouped by clients
		 * Aggregated latency info for this network, grouped by clients
		 * Get networks/{networkId}/wireless/clients/latencyStats
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
		 * @param {number} ssid Filter results by SSID
		 * @param {number} vlan Filter results by VLAN
		 * @param {string} apTag Filter results by AP Tag
		 * @param {string} fields Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkWirelessClientsLatencyStats(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined, vlan: number | null | undefined, apTag: string | null | undefined, fields: string | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/clients/latencyStats&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&band=' + band + '&ssid=' + ssid + '&vlan=' + vlan + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)) + '&fields=' + (fields == null ? '' : encodeURIComponent(fields)), {});
		}

		/**
		 * Aggregated connectivity info for a given client on this network
		 * Aggregated connectivity info for a given client on this network. Clients are identified by their MAC.
		 * Get networks/{networkId}/wireless/clients/{clientId}/connectionStats
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
		 * @param {number} ssid Filter results by SSID
		 * @param {number} vlan Filter results by VLAN
		 * @param {string} apTag Filter results by AP Tag
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessClientConnectionStats(networkId: string, clientId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined, vlan: number | null | undefined, apTag: string | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/clients/' + (clientId == null ? '' : encodeURIComponent(clientId)) + '/connectionStats&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&band=' + band + '&ssid=' + ssid + '&vlan=' + vlan + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)), { responseType: 'text' });
		}

		/**
		 * List the wireless connectivity events for a client within a network in the timespan.
		 * List the wireless connectivity events for a client within a network in the timespan.
		 * Get networks/{networkId}/wireless/clients/{clientId}/connectivityEvents
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @param {Array<string>} types A list of event types to include. If not specified, events of all types will be returned. Valid types are 'assoc', 'disassoc', 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'.
		 * @param {Array<string>} includedSeverities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are 'good', 'info', 'warn' and/or 'bad'.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5', '6').
		 * @param {GetNetworkWirelessClientConnectivityEventsSsidNumber} ssidNumber An SSID number to include. If not specified, events for all SSIDs will be returned.
		 * @param {string} deviceSerial Filter results by an AP's serial number.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkWirelessClientConnectivityEvents(networkId: string, clientId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, types: Array<string> | null | undefined, includedSeverities: Array<string> | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssidNumber: GetNetworkWirelessClientConnectivityEventsSsidNumber | null | undefined, deviceSerial: string | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/clients/' + (clientId == null ? '' : encodeURIComponent(clientId)) + '/connectivityEvents&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&' + types?.map(z => `types=${encodeURIComponent(z)}`).join('&') + '&' + includedSeverities?.map(z => `includedSeverities=${encodeURIComponent(z)}`).join('&') + '&band=' + band + '&ssidNumber=' + ssidNumber + '&deviceSerial=' + (deviceSerial == null ? '' : encodeURIComponent(deviceSerial)), {});
		}

		/**
		 * Return the latency history for a client
		 * Return the latency history for a client. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP. The latency data is from a sample of 2% of packets and is grouped into 4 traffic categories: background, best effort, video, voice. Within these categories the sampled packet counters are bucketed by latency in milliseconds.
		 * Get networks/{networkId}/wireless/clients/{clientId}/latencyHistory
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkWirelessClientLatencyHistory(networkId: string, clientId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/clients/' + (clientId == null ? '' : encodeURIComponent(clientId)) + '/latencyHistory&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution, {});
		}

		/**
		 * Aggregated latency info for a given client on this network
		 * Aggregated latency info for a given client on this network. Clients are identified by their MAC.
		 * Get networks/{networkId}/wireless/clients/{clientId}/latencyStats
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
		 * @param {number} ssid Filter results by SSID
		 * @param {number} vlan Filter results by VLAN
		 * @param {string} apTag Filter results by AP Tag
		 * @param {string} fields Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessClientLatencyStats(networkId: string, clientId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined, vlan: number | null | undefined, apTag: string | null | undefined, fields: string | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/clients/' + (clientId == null ? '' : encodeURIComponent(clientId)) + '/latencyStats&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&band=' + band + '&ssid=' + ssid + '&vlan=' + vlan + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)) + '&fields=' + (fields == null ? '' : encodeURIComponent(fields)), { responseType: 'text' });
		}

		/**
		 * Aggregated connectivity info for this network
		 * Aggregated connectivity info for this network
		 * Get networks/{networkId}/wireless/connectionStats
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
		 * @param {number} ssid Filter results by SSID
		 * @param {number} vlan Filter results by VLAN
		 * @param {string} apTag Filter results by AP Tag
		 * @return {GetNetworkWirelessConnectionStatsReturn} Successful operation
		 */
		GetNetworkWirelessConnectionStats(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined, vlan: number | null | undefined, apTag: string | null | undefined): Observable<GetNetworkWirelessConnectionStatsReturn> {
			return this.http.get<GetNetworkWirelessConnectionStatsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/connectionStats&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&band=' + band + '&ssid=' + ssid + '&vlan=' + vlan + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)), {});
		}

		/**
		 * Return PHY data rates over time for a network, device, or network client
		 * Return PHY data rates over time for a network, device, or network client
		 * Get networks/{networkId}/wireless/dataRateHistory
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
		 * @param {boolean} autoResolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
		 * @param {string} clientId Filter results by network client.
		 * @param {string} deviceSerial Filter results by device.
		 * @param {string} apTag Filter results by AP tag.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6').
		 * @param {number} ssid Filter results by SSID number.
		 * @return {Array<GetNetworkWirelessDataRateHistoryReturn>} Successful operation
		 */
		GetNetworkWirelessDataRateHistory(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined, autoResolution: boolean | null | undefined, clientId: string | null | undefined, deviceSerial: string | null | undefined, apTag: string | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined): Observable<Array<GetNetworkWirelessDataRateHistoryReturn>> {
			return this.http.get<Array<GetNetworkWirelessDataRateHistoryReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/dataRateHistory&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution + '&autoResolution=' + autoResolution + '&clientId=' + (clientId == null ? '' : encodeURIComponent(clientId)) + '&deviceSerial=' + (deviceSerial == null ? '' : encodeURIComponent(deviceSerial)) + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)) + '&band=' + band + '&ssid=' + ssid, {});
		}

		/**
		 * Aggregated connectivity info for this network, grouped by node
		 * Aggregated connectivity info for this network, grouped by node
		 * Get networks/{networkId}/wireless/devices/connectionStats
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
		 * @param {number} ssid Filter results by SSID
		 * @param {number} vlan Filter results by VLAN
		 * @param {string} apTag Filter results by AP Tag
		 * @return {Array<GetNetworkWirelessDevicesConnectionStatsReturn>} Successful operation
		 */
		GetNetworkWirelessDevicesConnectionStats(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined, vlan: number | null | undefined, apTag: string | null | undefined): Observable<Array<GetNetworkWirelessDevicesConnectionStatsReturn>> {
			return this.http.get<Array<GetNetworkWirelessDevicesConnectionStatsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/devices/connectionStats&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&band=' + band + '&ssid=' + ssid + '&vlan=' + vlan + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)), {});
		}

		/**
		 * Aggregated latency info for this network, grouped by node
		 * Aggregated latency info for this network, grouped by node
		 * Get networks/{networkId}/wireless/devices/latencyStats
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
		 * @param {number} ssid Filter results by SSID
		 * @param {number} vlan Filter results by VLAN
		 * @param {string} apTag Filter results by AP Tag
		 * @param {string} fields Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkWirelessDevicesLatencyStats(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined, vlan: number | null | undefined, apTag: string | null | undefined, fields: string | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/devices/latencyStats&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&band=' + band + '&ssid=' + ssid + '&vlan=' + vlan + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)) + '&fields=' + (fields == null ? '' : encodeURIComponent(fields)), {});
		}

		/**
		 * List of all failed client connection events on this network in a given time range
		 * List of all failed client connection events on this network in a given time range
		 * Get networks/{networkId}/wireless/failedConnections
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
		 * @param {number} ssid Filter results by SSID
		 * @param {number} vlan Filter results by VLAN
		 * @param {string} apTag Filter results by AP Tag
		 * @param {string} serial Filter by AP
		 * @param {string} clientId Filter by client MAC
		 * @return {Array<GetNetworkWirelessFailedConnectionsReturn>} Successful operation
		 */
		GetNetworkWirelessFailedConnections(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined, vlan: number | null | undefined, apTag: string | null | undefined, serial: string | null | undefined, clientId: string | null | undefined): Observable<Array<GetNetworkWirelessFailedConnectionsReturn>> {
			return this.http.get<Array<GetNetworkWirelessFailedConnectionsReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/failedConnections&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&band=' + band + '&ssid=' + ssid + '&vlan=' + vlan + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)) + '&serial=' + (serial == null ? '' : encodeURIComponent(serial)) + '&clientId=' + (clientId == null ? '' : encodeURIComponent(clientId)), {});
		}

		/**
		 * Return average wireless latency over time for a network, device, or network client
		 * Return average wireless latency over time for a network, device, or network client
		 * Get networks/{networkId}/wireless/latencyHistory
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
		 * @param {boolean} autoResolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
		 * @param {string} clientId Filter results by network client.
		 * @param {string} deviceSerial Filter results by device.
		 * @param {string} apTag Filter results by AP tag.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6').
		 * @param {number} ssid Filter results by SSID number.
		 * @param {GetNetworkWirelessLatencyHistoryAccessCategory} accessCategory Filter by access category.
		 * @return {Array<GetNetworkWirelessLatencyHistoryReturn>} Successful operation
		 */
		GetNetworkWirelessLatencyHistory(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined, autoResolution: boolean | null | undefined, clientId: string | null | undefined, deviceSerial: string | null | undefined, apTag: string | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined, accessCategory: GetNetworkWirelessLatencyHistoryAccessCategory | null | undefined): Observable<Array<GetNetworkWirelessLatencyHistoryReturn>> {
			return this.http.get<Array<GetNetworkWirelessLatencyHistoryReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/latencyHistory&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution + '&autoResolution=' + autoResolution + '&clientId=' + (clientId == null ? '' : encodeURIComponent(clientId)) + '&deviceSerial=' + (deviceSerial == null ? '' : encodeURIComponent(deviceSerial)) + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)) + '&band=' + band + '&ssid=' + ssid + '&accessCategory=' + accessCategory, {});
		}

		/**
		 * Aggregated latency info for this network
		 * Aggregated latency info for this network
		 * Get networks/{networkId}/wireless/latencyStats
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
		 * @param {number} ssid Filter results by SSID
		 * @param {number} vlan Filter results by VLAN
		 * @param {string} apTag Filter results by AP Tag
		 * @param {string} fields Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessLatencyStats(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined, vlan: number | null | undefined, apTag: string | null | undefined, fields: string | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/latencyStats&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&band=' + band + '&ssid=' + ssid + '&vlan=' + vlan + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)) + '&fields=' + (fields == null ? '' : encodeURIComponent(fields)), { responseType: 'text' });
		}

		/**
		 * List wireless mesh statuses for repeaters
		 * List wireless mesh statuses for repeaters
		 * Get networks/{networkId}/wireless/meshStatuses
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 500. Default is 50.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessMeshStatuses(networkId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/meshStatuses&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), { responseType: 'text' });
		}

		/**
		 * List the non-basic RF profiles for this network
		 * List the non-basic RF profiles for this network
		 * Get networks/{networkId}/wireless/rfProfiles
		 * @param {boolean} includeTemplateProfiles If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false.
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkWirelessRfProfiles(networkId: string, includeTemplateProfiles: boolean | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/rfProfiles&includeTemplateProfiles=' + includeTemplateProfiles, {});
		}

		/**
		 * Creates new RF profile for this network
		 * Creates new RF profile for this network
		 * Post networks/{networkId}/wireless/rfProfiles
		 * @return {void} 
		 */
		CreateNetworkWirelessRfProfile(networkId: string, requestBody: CreateNetworkWirelessRfProfilePostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/rfProfiles', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a RF Profile
		 * Delete a RF Profile
		 * Delete networks/{networkId}/wireless/rfProfiles/{rfProfileId}
		 * @return {void} 
		 */
		DeleteNetworkWirelessRfProfile(networkId: string, rfProfileId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/rfProfiles/' + (rfProfileId == null ? '' : encodeURIComponent(rfProfileId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a RF profile
		 * Return a RF profile
		 * Get networks/{networkId}/wireless/rfProfiles/{rfProfileId}
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessRfProfile(networkId: string, rfProfileId: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/rfProfiles/' + (rfProfileId == null ? '' : encodeURIComponent(rfProfileId)), { responseType: 'text' });
		}

		/**
		 * Updates specified RF profile for this network
		 * Updates specified RF profile for this network
		 * Put networks/{networkId}/wireless/rfProfiles/{rfProfileId}
		 * @return {UpdateNetworkWirelessRfProfileReturn} Successful operation
		 */
		UpdateNetworkWirelessRfProfile(networkId: string, rfProfileId: string, requestBody: UpdateNetworkWirelessRfProfilePutBody): Observable<UpdateNetworkWirelessRfProfileReturn> {
			return this.http.put<UpdateNetworkWirelessRfProfileReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/rfProfiles/' + (rfProfileId == null ? '' : encodeURIComponent(rfProfileId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return the wireless settings for a network
		 * Return the wireless settings for a network
		 * Get networks/{networkId}/wireless/settings
		 * @return {GetNetworkWirelessSettingsReturn} Successful operation
		 */
		GetNetworkWirelessSettings(networkId: string): Observable<GetNetworkWirelessSettingsReturn> {
			return this.http.get<GetNetworkWirelessSettingsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/settings', {});
		}

		/**
		 * Update the wireless settings for a network
		 * Update the wireless settings for a network
		 * Put networks/{networkId}/wireless/settings
		 * @return {UpdateNetworkWirelessSettingsReturn} Successful operation
		 */
		UpdateNetworkWirelessSettings(networkId: string, requestBody: UpdateNetworkWirelessSettingsPutBody): Observable<UpdateNetworkWirelessSettingsReturn> {
			return this.http.put<UpdateNetworkWirelessSettingsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return signal quality (SNR/RSSI) over time for a device or network client
		 * Return signal quality (SNR/RSSI) over time for a device or network client
		 * Get networks/{networkId}/wireless/signalQualityHistory
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
		 * @param {boolean} autoResolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
		 * @param {string} clientId Filter results by network client.
		 * @param {string} deviceSerial Filter results by device.
		 * @param {string} apTag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6').
		 * @param {number} ssid Filter results by SSID number.
		 * @return {Array<GetNetworkWirelessSignalQualityHistoryReturn>} Successful operation
		 */
		GetNetworkWirelessSignalQualityHistory(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined, autoResolution: boolean | null | undefined, clientId: string | null | undefined, deviceSerial: string | null | undefined, apTag: string | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined): Observable<Array<GetNetworkWirelessSignalQualityHistoryReturn>> {
			return this.http.get<Array<GetNetworkWirelessSignalQualityHistoryReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/signalQualityHistory&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution + '&autoResolution=' + autoResolution + '&clientId=' + (clientId == null ? '' : encodeURIComponent(clientId)) + '&deviceSerial=' + (deviceSerial == null ? '' : encodeURIComponent(deviceSerial)) + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)) + '&band=' + band + '&ssid=' + ssid, {});
		}

		/**
		 * List the MR SSIDs in a network
		 * List the MR SSIDs in a network
		 * Get networks/{networkId}/wireless/ssids
		 * @return {Array<string>} Successful operation
		 */
		GetNetworkWirelessSsids(networkId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids', {});
		}

		/**
		 * Return a single MR SSID
		 * Return a single MR SSID
		 * Get networks/{networkId}/wireless/ssids/{number}
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessSsid(networkId: string, number: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)), { responseType: 'text' });
		}

		/**
		 * Update the attributes of an MR SSID
		 * Update the attributes of an MR SSID
		 * Put networks/{networkId}/wireless/ssids/{number}
		 * @return {string} Successful operation
		 */
		UpdateNetworkWirelessSsid(networkId: string, number: string, requestBody: UpdateNetworkWirelessSsidPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the Bonjour forwarding setting and rules for the SSID
		 * List the Bonjour forwarding setting and rules for the SSID
		 * Get networks/{networkId}/wireless/ssids/{number}/bonjourForwarding
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessSsidBonjourForwarding(networkId: string, number: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/bonjourForwarding', { responseType: 'text' });
		}

		/**
		 * Update the bonjour forwarding setting and rules for the SSID
		 * Update the bonjour forwarding setting and rules for the SSID
		 * Put networks/{networkId}/wireless/ssids/{number}/bonjourForwarding
		 * @return {string} Successful operation
		 */
		UpdateNetworkWirelessSsidBonjourForwarding(networkId: string, number: string, requestBody: UpdateNetworkWirelessSsidBonjourForwardingPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/bonjourForwarding', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the device type group policies for the SSID
		 * List the device type group policies for the SSID
		 * Get networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessSsidDeviceTypeGroupPolicies(networkId: string, number: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/deviceTypeGroupPolicies', { responseType: 'text' });
		}

		/**
		 * Update the device type group policies for the SSID
		 * Update the device type group policies for the SSID
		 * Put networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies
		 * @return {string} Successful operation
		 */
		UpdateNetworkWirelessSsidDeviceTypeGroupPolicies(networkId: string, number: string, requestBody: UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/deviceTypeGroupPolicies', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the EAP overridden parameters for an SSID
		 * Return the EAP overridden parameters for an SSID
		 * Get networks/{networkId}/wireless/ssids/{number}/eapOverride
		 * @return {GetNetworkWirelessSsidEapOverrideReturn} Successful operation
		 */
		GetNetworkWirelessSsidEapOverride(networkId: string, number: string): Observable<GetNetworkWirelessSsidEapOverrideReturn> {
			return this.http.get<GetNetworkWirelessSsidEapOverrideReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/eapOverride', {});
		}

		/**
		 * Update the EAP overridden parameters for an SSID.
		 * Update the EAP overridden parameters for an SSID.
		 * Put networks/{networkId}/wireless/ssids/{number}/eapOverride
		 * @return {UpdateNetworkWirelessSsidEapOverrideReturn} Successful operation
		 */
		UpdateNetworkWirelessSsidEapOverride(networkId: string, number: string, requestBody: UpdateNetworkWirelessSsidEapOverridePutBody): Observable<UpdateNetworkWirelessSsidEapOverrideReturn> {
			return this.http.put<UpdateNetworkWirelessSsidEapOverrideReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/eapOverride', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return the L3 firewall rules for an SSID on an MR network
		 * Return the L3 firewall rules for an SSID on an MR network
		 * Get networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessSsidFirewallL3FirewallRules(networkId: string, number: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/firewall/l3FirewallRules', { responseType: 'text' });
		}

		/**
		 * Update the L3 firewall rules of an SSID on an MR network
		 * Update the L3 firewall rules of an SSID on an MR network
		 * Put networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules
		 * @return {string} Successful operation
		 */
		UpdateNetworkWirelessSsidFirewallL3FirewallRules(networkId: string, number: string, requestBody: UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/firewall/l3FirewallRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the L7 firewall rules for an SSID on an MR network
		 * Return the L7 firewall rules for an SSID on an MR network
		 * Get networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessSsidFirewallL7FirewallRules(networkId: string, number: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/firewall/l7FirewallRules', { responseType: 'text' });
		}

		/**
		 * Update the L7 firewall rules of an SSID on an MR network
		 * Update the L7 firewall rules of an SSID on an MR network
		 * Put networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules
		 * @return {string} Successful operation
		 */
		UpdateNetworkWirelessSsidFirewallL7FirewallRules(networkId: string, number: string, requestBody: UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/firewall/l7FirewallRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the Hotspot 2.0 settings for an SSID
		 * Return the Hotspot 2.0 settings for an SSID
		 * Get networks/{networkId}/wireless/ssids/{number}/hotspot20
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessSsidHotspot20(networkId: string, number: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/hotspot20', { responseType: 'text' });
		}

		/**
		 * Update the Hotspot 2.0 settings of an SSID
		 * Update the Hotspot 2.0 settings of an SSID
		 * Put networks/{networkId}/wireless/ssids/{number}/hotspot20
		 * @return {string} Successful operation
		 */
		UpdateNetworkWirelessSsidHotspot20(networkId: string, number: string, requestBody: UpdateNetworkWirelessSsidHotspot20PutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/hotspot20', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List all Identity PSKs in a wireless network
		 * List all Identity PSKs in a wireless network
		 * Get networks/{networkId}/wireless/ssids/{number}/identityPsks
		 * @return {Array<GetNetworkWirelessSsidIdentityPsksReturn>} Successful operation
		 */
		GetNetworkWirelessSsidIdentityPsks(networkId: string, number: string): Observable<Array<GetNetworkWirelessSsidIdentityPsksReturn>> {
			return this.http.get<Array<GetNetworkWirelessSsidIdentityPsksReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/identityPsks', {});
		}

		/**
		 * Create an Identity PSK
		 * Create an Identity PSK
		 * Post networks/{networkId}/wireless/ssids/{number}/identityPsks
		 * @return {void} 
		 */
		CreateNetworkWirelessSsidIdentityPsk(networkId: string, number: string, requestBody: CreateNetworkWirelessSsidIdentityPskPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/identityPsks', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete an Identity PSK
		 * Delete an Identity PSK
		 * Delete networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}
		 * @return {void} 
		 */
		DeleteNetworkWirelessSsidIdentityPsk(networkId: string, number: string, identityPskId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/identityPsks/' + (identityPskId == null ? '' : encodeURIComponent(identityPskId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return an Identity PSK
		 * Return an Identity PSK
		 * Get networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}
		 * @return {GetNetworkWirelessSsidIdentityPskReturn} Successful operation
		 */
		GetNetworkWirelessSsidIdentityPsk(networkId: string, number: string, identityPskId: string): Observable<GetNetworkWirelessSsidIdentityPskReturn> {
			return this.http.get<GetNetworkWirelessSsidIdentityPskReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/identityPsks/' + (identityPskId == null ? '' : encodeURIComponent(identityPskId)), {});
		}

		/**
		 * Update an Identity PSK
		 * Update an Identity PSK
		 * Put networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}
		 * @return {string} Successful operation
		 */
		UpdateNetworkWirelessSsidIdentityPsk(networkId: string, number: string, identityPskId: string, requestBody: UpdateNetworkWirelessSsidIdentityPskPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/identityPsks/' + (identityPskId == null ? '' : encodeURIComponent(identityPskId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the outage schedule for the SSID
		 * List the outage schedule for the SSID
		 * Get networks/{networkId}/wireless/ssids/{number}/schedules
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessSsidSchedules(networkId: string, number: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/schedules', { responseType: 'text' });
		}

		/**
		 * Update the outage schedule for the SSID
		 * Update the outage schedule for the SSID
		 * Put networks/{networkId}/wireless/ssids/{number}/schedules
		 * @return {string} Successful operation
		 */
		UpdateNetworkWirelessSsidSchedules(networkId: string, number: string, requestBody: UpdateNetworkWirelessSsidSchedulesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/schedules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Display the splash page settings for the given SSID
		 * Display the splash page settings for the given SSID
		 * Get networks/{networkId}/wireless/ssids/{number}/splash/settings
		 * @return {GetNetworkWirelessSsidSplashSettingsReturn} Successful operation
		 */
		GetNetworkWirelessSsidSplashSettings(networkId: string, number: string): Observable<GetNetworkWirelessSsidSplashSettingsReturn> {
			return this.http.get<GetNetworkWirelessSsidSplashSettingsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/splash/settings', {});
		}

		/**
		 * Modify the splash page settings for the given SSID
		 * Modify the splash page settings for the given SSID
		 * Put networks/{networkId}/wireless/ssids/{number}/splash/settings
		 * @return {UpdateNetworkWirelessSsidSplashSettingsReturn} Successful operation
		 */
		UpdateNetworkWirelessSsidSplashSettings(networkId: string, number: string, requestBody: UpdateNetworkWirelessSsidSplashSettingsPutBody): Observable<UpdateNetworkWirelessSsidSplashSettingsReturn> {
			return this.http.put<UpdateNetworkWirelessSsidSplashSettingsReturn>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/splash/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Display the traffic shaping settings for a SSID on an MR network
		 * Display the traffic shaping settings for a SSID on an MR network
		 * Get networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessSsidTrafficShapingRules(networkId: string, number: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/trafficShaping/rules', { responseType: 'text' });
		}

		/**
		 * Update the traffic shaping settings for an SSID on an MR network
		 * Update the traffic shaping settings for an SSID on an MR network
		 * Put networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules
		 * @return {string} Successful operation
		 */
		UpdateNetworkWirelessSsidTrafficShapingRules(networkId: string, number: string, requestBody: UpdateNetworkWirelessSsidTrafficShapingRulesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/trafficShaping/rules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the VPN settings for the SSID.
		 * List the VPN settings for the SSID.
		 * Get networks/{networkId}/wireless/ssids/{number}/vpn
		 * @return {string} Successful operation
		 */
		GetNetworkWirelessSsidVpn(networkId: string, number: string): Observable<string> {
			return this.http.get(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/vpn', { responseType: 'text' });
		}

		/**
		 * Update the VPN settings for the SSID
		 * Update the VPN settings for the SSID
		 * Put networks/{networkId}/wireless/ssids/{number}/vpn
		 * @return {string} Successful operation
		 */
		UpdateNetworkWirelessSsidVpn(networkId: string, number: string, requestBody: UpdateNetworkWirelessSsidVpnPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/ssids/' + (number == null ? '' : encodeURIComponent(number)) + '/vpn', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return AP usage over time for a device or network client
		 * Return AP usage over time for a device or network client
		 * Get networks/{networkId}/wireless/usageHistory
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
		 * @param {number} resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
		 * @param {boolean} autoResolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
		 * @param {string} clientId Filter results by network client to return per-device AP usage over time inner joined by the queried client's connection history.
		 * @param {string} deviceSerial Filter results by device. Requires :band.
		 * @param {string} apTag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.
		 * @param {GetDeviceWirelessConnectionStatsBand} band Filter results by band (either '2.4', '5' or '6').
		 * @param {number} ssid Filter results by SSID number.
		 * @return {Array<GetNetworkWirelessUsageHistoryReturn>} Successful operation
		 */
		GetNetworkWirelessUsageHistory(networkId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, resolution: number | null | undefined, autoResolution: boolean | null | undefined, clientId: string | null | undefined, deviceSerial: string | null | undefined, apTag: string | null | undefined, band: GetDeviceWirelessConnectionStatsBand | null | undefined, ssid: number | null | undefined): Observable<Array<GetNetworkWirelessUsageHistoryReturn>> {
			return this.http.get<Array<GetNetworkWirelessUsageHistoryReturn>>(this.baseUri + 'networks/' + (networkId == null ? '' : encodeURIComponent(networkId)) + '/wireless/usageHistory&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&resolution=' + resolution + '&autoResolution=' + autoResolution + '&clientId=' + (clientId == null ? '' : encodeURIComponent(clientId)) + '&deviceSerial=' + (deviceSerial == null ? '' : encodeURIComponent(deviceSerial)) + '&apTag=' + (apTag == null ? '' : encodeURIComponent(apTag)) + '&band=' + band + '&ssid=' + ssid, {});
		}

		/**
		 * List the organizations that the user has privileges on
		 * List the organizations that the user has privileges on
		 * Get organizations
		 * @return {Array<GetOrganizationsReturn>} Successful operation
		 */
		GetOrganizations(): Observable<Array<GetOrganizationsReturn>> {
			return this.http.get<Array<GetOrganizationsReturn>>(this.baseUri + 'organizations', {});
		}

		/**
		 * Create a new organization
		 * Create a new organization
		 * Post organizations
		 * @return {void} 
		 */
		CreateOrganization(requestBody: CreateOrganizationPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete an organization
		 * Delete an organization
		 * Delete organizations/{organizationId}
		 * @return {void} 
		 */
		DeleteOrganization(organizationId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return an organization
		 * Return an organization
		 * Get organizations/{organizationId}
		 * @return {GetOrganizationReturn} Successful operation
		 */
		GetOrganization(organizationId: string): Observable<GetOrganizationReturn> {
			return this.http.get<GetOrganizationReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)), {});
		}

		/**
		 * Update an organization
		 * Update an organization
		 * Put organizations/{organizationId}
		 * @return {UpdateOrganizationReturn} Successful operation
		 */
		UpdateOrganization(organizationId: string, requestBody: UpdateOrganizationPutBody): Observable<UpdateOrganizationReturn> {
			return this.http.put<UpdateOrganizationReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return the list of action batches in the organization
		 * Return the list of action batches in the organization
		 * Get organizations/{organizationId}/actionBatches
		 * @param {GetOrganizationActionBatchesStatus} status Filter batches by status. Valid types are pending, completed, and failed.
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationActionBatches(organizationId: string, status: GetOrganizationActionBatchesStatus | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/actionBatches&status=' + status, {});
		}

		/**
		 * Create an action batch
		 * Create an action batch
		 * Post organizations/{organizationId}/actionBatches
		 * @return {void} 
		 */
		CreateOrganizationActionBatch(organizationId: string, requestBody: CreateOrganizationActionBatchPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/actionBatches', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete an action batch
		 * Delete an action batch
		 * Delete organizations/{organizationId}/actionBatches/{actionBatchId}
		 * @return {void} 
		 */
		DeleteOrganizationActionBatch(organizationId: string, actionBatchId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/actionBatches/' + (actionBatchId == null ? '' : encodeURIComponent(actionBatchId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return an action batch
		 * Return an action batch
		 * Get organizations/{organizationId}/actionBatches/{actionBatchId}
		 * @return {GetOrganizationActionBatchReturn} Successful operation
		 */
		GetOrganizationActionBatch(organizationId: string, actionBatchId: string): Observable<GetOrganizationActionBatchReturn> {
			return this.http.get<GetOrganizationActionBatchReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/actionBatches/' + (actionBatchId == null ? '' : encodeURIComponent(actionBatchId)), {});
		}

		/**
		 * Update an action batch
		 * Update an action batch
		 * Put organizations/{organizationId}/actionBatches/{actionBatchId}
		 * @return {string} Successful operation
		 */
		UpdateOrganizationActionBatch(organizationId: string, actionBatchId: string, requestBody: UpdateOrganizationActionBatchPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/actionBatches/' + (actionBatchId == null ? '' : encodeURIComponent(actionBatchId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List adaptive policy ACLs in a organization
		 * List adaptive policy ACLs in a organization
		 * Get organizations/{organizationId}/adaptivePolicy/acls
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationAdaptivePolicyAcls(organizationId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/acls', {});
		}

		/**
		 * Creates new adaptive policy ACL
		 * Creates new adaptive policy ACL
		 * Post organizations/{organizationId}/adaptivePolicy/acls
		 * @return {string} Successful operation
		 */
		CreateOrganizationAdaptivePolicyAcl(organizationId: string, requestBody: CreateOrganizationAdaptivePolicyAclPostBody): Observable<string> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/acls', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Deletes the specified adaptive policy ACL
		 * Deletes the specified adaptive policy ACL. Note this adaptive policy ACL will also be removed from policies using it.
		 * Delete organizations/{organizationId}/adaptivePolicy/acls/{aclId}
		 * @return {void} 
		 */
		DeleteOrganizationAdaptivePolicyAcl(organizationId: string, aclId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/acls/' + (aclId == null ? '' : encodeURIComponent(aclId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Returns the adaptive policy ACL information
		 * Returns the adaptive policy ACL information
		 * Get organizations/{organizationId}/adaptivePolicy/acls/{aclId}
		 * @return {string} Successful operation
		 */
		GetOrganizationAdaptivePolicyAcl(organizationId: string, aclId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/acls/' + (aclId == null ? '' : encodeURIComponent(aclId)), { responseType: 'text' });
		}

		/**
		 * Updates an adaptive policy ACL
		 * Updates an adaptive policy ACL
		 * Put organizations/{organizationId}/adaptivePolicy/acls/{aclId}
		 * @return {string} Successful operation
		 */
		UpdateOrganizationAdaptivePolicyAcl(organizationId: string, aclId: string, requestBody: UpdateOrganizationAdaptivePolicyAclPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/acls/' + (aclId == null ? '' : encodeURIComponent(aclId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List adaptive policy groups in a organization
		 * List adaptive policy groups in a organization
		 * Get organizations/{organizationId}/adaptivePolicy/groups
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationAdaptivePolicyGroups(organizationId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/groups', {});
		}

		/**
		 * Creates a new adaptive policy group
		 * Creates a new adaptive policy group
		 * Post organizations/{organizationId}/adaptivePolicy/groups
		 * @return {void} 
		 */
		CreateOrganizationAdaptivePolicyGroup(organizationId: string, requestBody: CreateOrganizationAdaptivePolicyGroupPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/groups', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Deletes the specified adaptive policy group and any associated policies and references
		 * Deletes the specified adaptive policy group and any associated policies and references
		 * Delete organizations/{organizationId}/adaptivePolicy/groups/{id}
		 * @return {void} 
		 */
		DeleteOrganizationAdaptivePolicyGroup(organizationId: string, id: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/groups/' + (id == null ? '' : encodeURIComponent(id)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Returns an adaptive policy group
		 * Returns an adaptive policy group
		 * Get organizations/{organizationId}/adaptivePolicy/groups/{id}
		 * @return {string} Successful operation
		 */
		GetOrganizationAdaptivePolicyGroup(organizationId: string, id: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/groups/' + (id == null ? '' : encodeURIComponent(id)), { responseType: 'text' });
		}

		/**
		 * Updates an adaptive policy group
		 * Updates an adaptive policy group. If updating "Infrastructure", only the SGT is allowed. Cannot update "Unknown".
		 * Put organizations/{organizationId}/adaptivePolicy/groups/{id}
		 * @return {string} Successful operation
		 */
		UpdateOrganizationAdaptivePolicyGroup(organizationId: string, id: string, requestBody: UpdateOrganizationAdaptivePolicyGroupPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/groups/' + (id == null ? '' : encodeURIComponent(id)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns adaptive policy aggregate statistics for an organization
		 * Returns adaptive policy aggregate statistics for an organization
		 * Get organizations/{organizationId}/adaptivePolicy/overview
		 * @return {GetOrganizationAdaptivePolicyOverviewReturn} Successful operation
		 */
		GetOrganizationAdaptivePolicyOverview(organizationId: string): Observable<GetOrganizationAdaptivePolicyOverviewReturn> {
			return this.http.get<GetOrganizationAdaptivePolicyOverviewReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/overview', {});
		}

		/**
		 * List adaptive policies in an organization
		 * List adaptive policies in an organization
		 * Get organizations/{organizationId}/adaptivePolicy/policies
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationAdaptivePolicyPolicies(organizationId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/policies', {});
		}

		/**
		 * Add an Adaptive Policy
		 * Add an Adaptive Policy
		 * Post organizations/{organizationId}/adaptivePolicy/policies
		 * @return {void} 
		 */
		CreateOrganizationAdaptivePolicyPolicy(organizationId: string, requestBody: CreateOrganizationAdaptivePolicyPolicyPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/policies', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete an Adaptive Policy
		 * Delete an Adaptive Policy
		 * Delete organizations/{organizationId}/adaptivePolicy/policies/{id}
		 * @return {void} 
		 */
		DeleteOrganizationAdaptivePolicyPolicy(organizationId: string, id: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/policies/' + (id == null ? '' : encodeURIComponent(id)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return an adaptive policy
		 * Return an adaptive policy
		 * Get organizations/{organizationId}/adaptivePolicy/policies/{id}
		 * @return {string} Successful operation
		 */
		GetOrganizationAdaptivePolicyPolicy(organizationId: string, id: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/policies/' + (id == null ? '' : encodeURIComponent(id)), { responseType: 'text' });
		}

		/**
		 * Update an Adaptive Policy
		 * Update an Adaptive Policy
		 * Put organizations/{organizationId}/adaptivePolicy/policies/{id}
		 * @return {string} Successful operation
		 */
		UpdateOrganizationAdaptivePolicyPolicy(organizationId: string, id: string, requestBody: UpdateOrganizationAdaptivePolicyPolicyPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/policies/' + (id == null ? '' : encodeURIComponent(id)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns global adaptive policy settings in an organization
		 * Returns global adaptive policy settings in an organization
		 * Get organizations/{organizationId}/adaptivePolicy/settings
		 * @return {string} Successful operation
		 */
		GetOrganizationAdaptivePolicySettings(organizationId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/settings', { responseType: 'text' });
		}

		/**
		 * Update global adaptive policy settings
		 * Update global adaptive policy settings
		 * Put organizations/{organizationId}/adaptivePolicy/settings
		 * @return {string} Successful operation
		 */
		UpdateOrganizationAdaptivePolicySettings(organizationId: string, requestBody: UpdateOrganizationAdaptivePolicySettingsPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/adaptivePolicy/settings', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the dashboard administrators in this organization
		 * List the dashboard administrators in this organization
		 * Get organizations/{organizationId}/admins
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationAdmins(organizationId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/admins', {});
		}

		/**
		 * Create a new dashboard administrator
		 * Create a new dashboard administrator
		 * Post organizations/{organizationId}/admins
		 * @return {void} 
		 */
		CreateOrganizationAdmin(organizationId: string, requestBody: CreateOrganizationAdminPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/admins', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Revoke all access for a dashboard administrator within this organization
		 * Revoke all access for a dashboard administrator within this organization
		 * Delete organizations/{organizationId}/admins/{adminId}
		 * @return {void} 
		 */
		DeleteOrganizationAdmin(organizationId: string, adminId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/admins/' + (adminId == null ? '' : encodeURIComponent(adminId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Update an administrator
		 * Update an administrator
		 * Put organizations/{organizationId}/admins/{adminId}
		 * @return {string} Successful operation
		 */
		UpdateOrganizationAdmin(organizationId: string, adminId: string, requestBody: UpdateOrganizationAdminPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/admins/' + (adminId == null ? '' : encodeURIComponent(adminId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List all organization-wide alert configurations
		 * List all organization-wide alert configurations
		 * Get organizations/{organizationId}/alerts/profiles
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationAlertsProfiles(organizationId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/alerts/profiles', {});
		}

		/**
		 * Create an organization-wide alert configuration
		 * Create an organization-wide alert configuration
		 * Post organizations/{organizationId}/alerts/profiles
		 * @return {void} 
		 */
		CreateOrganizationAlertsProfile(organizationId: string, requestBody: CreateOrganizationAlertsProfilePostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/alerts/profiles', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Removes an organization-wide alert config
		 * Removes an organization-wide alert config
		 * Delete organizations/{organizationId}/alerts/profiles/{alertConfigId}
		 * @return {void} 
		 */
		DeleteOrganizationAlertsProfile(organizationId: string, alertConfigId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/alerts/profiles/' + (alertConfigId == null ? '' : encodeURIComponent(alertConfigId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Update an organization-wide alert config
		 * Update an organization-wide alert config
		 * Put organizations/{organizationId}/alerts/profiles/{alertConfigId}
		 * @return {string} Successful operation
		 */
		UpdateOrganizationAlertsProfile(organizationId: string, alertConfigId: string, requestBody: UpdateOrganizationAlertsProfilePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/alerts/profiles/' + (alertConfigId == null ? '' : encodeURIComponent(alertConfigId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the API requests made by an organization
		 * List the API requests made by an organization
		 * Get organizations/{organizationId}/apiRequests
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} adminId Filter the results by the ID of the admin who made the API requests
		 * @param {string} path Filter the results by the path of the API requests
		 * @param {GetOrganizationApiRequestsMethod} method Filter the results by the method of the API requests (must be 'GET', 'PUT', 'POST' or 'DELETE')
		 * @param {number} responseCode Filter the results by the response code of the API requests
		 * @param {string} sourceIp Filter the results by the IP address of the originating API request
		 * @param {string} userAgent Filter the results by the user agent string of the API request
		 * @param {GetOrganizationApiRequestsVersion} version Filter the results by the API version of the API request
		 * @param {Array<string>} operationIds Filter the results by one or more operation IDs for the API request
		 * @return {Array<GetOrganizationApiRequestsReturn>} Successful operation
		 */
		GetOrganizationApiRequests(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, adminId: string | null | undefined, path: string | null | undefined, method: GetOrganizationApiRequestsMethod | null | undefined, responseCode: number | null | undefined, sourceIp: string | null | undefined, userAgent: string | null | undefined, version: GetOrganizationApiRequestsVersion | null | undefined, operationIds: Array<string> | null | undefined): Observable<Array<GetOrganizationApiRequestsReturn>> {
			return this.http.get<Array<GetOrganizationApiRequestsReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/apiRequests&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&adminId=' + (adminId == null ? '' : encodeURIComponent(adminId)) + '&path=' + (path == null ? '' : encodeURIComponent(path)) + '&method=' + method + '&responseCode=' + responseCode + '&sourceIp=' + (sourceIp == null ? '' : encodeURIComponent(sourceIp)) + '&userAgent=' + (userAgent == null ? '' : encodeURIComponent(userAgent)) + '&version=' + version + '&' + operationIds?.map(z => `operationIds=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * Return an aggregated overview of API requests data
		 * Return an aggregated overview of API requests data
		 * Get organizations/{organizationId}/apiRequests/overview
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days.
		 * @return {string} Successful operation
		 */
		GetOrganizationApiRequestsOverview(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/apiRequests/overview&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, { responseType: 'text' });
		}

		/**
		 * Tracks organizations' API requests by response code across a given time period
		 * Tracks organizations' API requests by response code across a given time period
		 * Get organizations/{organizationId}/apiRequests/overview/responseCodes/byInterval
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. If interval is provided, the timespan will be autocalculated.
		 * @param {number} interval The time interval in seconds for returned data. The valid intervals are: 120, 3600, 14400, 21600. The default is 21600. Interval is calculated if time params are provided.
		 * @param {GetOrganizationApiRequestsOverviewResponseCodesByIntervalVersion} version Filter by API version of the endpoint. Allowable values are: [0, 1]
		 * @param {Array<string>} operationIds Filter by operation ID of the endpoint
		 * @param {Array<string>} sourceIps Filter by source IP that made the API request
		 * @param {Array<string>} adminIds Filter by admin ID of user that made the API request
		 * @param {string} userAgent Filter by user agent string for API request. This will filter by a complete or partial match.
		 * @return {Array<GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturn>} Successful operation
		 */
		GetOrganizationApiRequestsOverviewResponseCodesByInterval(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, interval: number | null | undefined, version: GetOrganizationApiRequestsOverviewResponseCodesByIntervalVersion | null | undefined, operationIds: Array<string> | null | undefined, sourceIps: Array<string> | null | undefined, adminIds: Array<string> | null | undefined, userAgent: string | null | undefined): Observable<Array<GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturn>> {
			return this.http.get<Array<GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/apiRequests/overview/responseCodes/byInterval&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&interval=' + interval + '&version=' + version + '&' + operationIds?.map(z => `operationIds=${encodeURIComponent(z)}`).join('&') + '&' + sourceIps?.map(z => `sourceIps=${encodeURIComponent(z)}`).join('&') + '&' + adminIds?.map(z => `adminIds=${encodeURIComponent(z)}`).join('&') + '&userAgent=' + (userAgent == null ? '' : encodeURIComponent(userAgent)), {});
		}

		/**
		 * List the security events for an organization
		 * List the security events for an organization
		 * Get organizations/{organizationId}/appliance/security/events
		 * @param {string} t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {GetNetworkApplianceClientSecurityEventsSortOrder} sortOrder Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationApplianceSecurityEvents(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, sortOrder: GetNetworkApplianceClientSecurityEventsSortOrder | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/appliance/security/events&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&sortOrder=' + sortOrder, {});
		}

		/**
		 * Returns all supported intrusion settings for an organization
		 * Returns all supported intrusion settings for an organization
		 * Get organizations/{organizationId}/appliance/security/intrusion
		 * @return {string} Successful operation
		 */
		GetOrganizationApplianceSecurityIntrusion(organizationId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/appliance/security/intrusion', { responseType: 'text' });
		}

		/**
		 * Sets supported intrusion settings for an organization
		 * Sets supported intrusion settings for an organization
		 * Put organizations/{organizationId}/appliance/security/intrusion
		 * @return {string} Successful operation
		 */
		UpdateOrganizationApplianceSecurityIntrusion(organizationId: string, requestBody: UpdateOrganizationApplianceSecurityIntrusionPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/appliance/security/intrusion', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the uplink status of every Meraki MX and Z series appliances in the organization
		 * List the uplink status of every Meraki MX and Z series appliances in the organization
		 * Get organizations/{organizationId}/appliance/uplink/statuses
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds A list of network IDs. The returned devices will be filtered to only include these networks.
		 * @param {Array<string>} serials A list of serial numbers. The returned devices will be filtered to only include these serials.
		 * @param {Array<string>} iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs.
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationApplianceUplinkStatuses(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined, serials: Array<string> | null | undefined, iccids: Array<string> | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/appliance/uplink/statuses&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + iccids?.map(z => `iccids=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * Show VPN history stat for networks in an organization
		 * Show VPN history stat for networks in an organization
		 * Get organizations/{organizationId}/appliance/vpn/stats
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 300. Default is 300.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationApplianceVpnStats(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/appliance/vpn/stats&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, {});
		}

		/**
		 * Show VPN status for networks in an organization
		 * Show VPN status for networks in an organization
		 * Get organizations/{organizationId}/appliance/vpn/statuses
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 300. Default is 300.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationApplianceVpnStatuses(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/appliance/vpn/statuses&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * Return the third party VPN peers for an organization
		 * Return the third party VPN peers for an organization
		 * Get organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers
		 * @return {GetOrganizationApplianceVpnThirdPartyVPNPeersReturn} Successful operation
		 */
		GetOrganizationApplianceVpnThirdPartyVPNPeers(organizationId: string): Observable<GetOrganizationApplianceVpnThirdPartyVPNPeersReturn> {
			return this.http.get<GetOrganizationApplianceVpnThirdPartyVPNPeersReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/appliance/vpn/thirdPartyVPNPeers', {});
		}

		/**
		 * Update the third party VPN peers for an organization
		 * Update the third party VPN peers for an organization
		 * Put organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers
		 * @return {UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturn} Successful operation
		 */
		UpdateOrganizationApplianceVpnThirdPartyVPNPeers(organizationId: string, requestBody: UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBody): Observable<UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturn> {
			return this.http.put<UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/appliance/vpn/thirdPartyVPNPeers', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return the firewall rules for an organization's site-to-site VPN
		 * Return the firewall rules for an organization's site-to-site VPN
		 * Get organizations/{organizationId}/appliance/vpn/vpnFirewallRules
		 * @return {string} Successful operation
		 */
		GetOrganizationApplianceVpnVpnFirewallRules(organizationId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/appliance/vpn/vpnFirewallRules', { responseType: 'text' });
		}

		/**
		 * Update the firewall rules of an organization's site-to-site VPN
		 * Update the firewall rules of an organization's site-to-site VPN
		 * Put organizations/{organizationId}/appliance/vpn/vpnFirewallRules
		 * @return {string} Successful operation
		 */
		UpdateOrganizationApplianceVpnVpnFirewallRules(organizationId: string, requestBody: UpdateOrganizationApplianceVpnVpnFirewallRulesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/appliance/vpn/vpnFirewallRules', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the branding policies of an organization
		 * List the branding policies of an organization
		 * Get organizations/{organizationId}/brandingPolicies
		 * @return {Array<GetOrganizationBrandingPoliciesReturn>} Successful operation
		 */
		GetOrganizationBrandingPolicies(organizationId: string): Observable<Array<GetOrganizationBrandingPoliciesReturn>> {
			return this.http.get<Array<GetOrganizationBrandingPoliciesReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/brandingPolicies', {});
		}

		/**
		 * Add a new branding policy to an organization
		 * Add a new branding policy to an organization
		 * Post organizations/{organizationId}/brandingPolicies
		 * @return {void} 
		 */
		CreateOrganizationBrandingPolicy(organizationId: string, requestBody: CreateOrganizationBrandingPolicyPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/brandingPolicies', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Return the branding policy IDs of an organization in priority order
		 * Return the branding policy IDs of an organization in priority order. IDs are ordered in ascending order of priority (IDs later in the array have higher priority).
		 * Get organizations/{organizationId}/brandingPolicies/priorities
		 * @return {GetOrganizationBrandingPoliciesPrioritiesReturn} Successful operation
		 */
		GetOrganizationBrandingPoliciesPriorities(organizationId: string): Observable<GetOrganizationBrandingPoliciesPrioritiesReturn> {
			return this.http.get<GetOrganizationBrandingPoliciesPrioritiesReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/brandingPolicies/priorities', {});
		}

		/**
		 * Update the priority ordering of an organization's branding policies.
		 * Update the priority ordering of an organization's branding policies.
		 * Put organizations/{organizationId}/brandingPolicies/priorities
		 * @return {UpdateOrganizationBrandingPoliciesPrioritiesReturn} Successful operation
		 */
		UpdateOrganizationBrandingPoliciesPriorities(organizationId: string, requestBody: UpdateOrganizationBrandingPoliciesPrioritiesPutBody): Observable<UpdateOrganizationBrandingPoliciesPrioritiesReturn> {
			return this.http.put<UpdateOrganizationBrandingPoliciesPrioritiesReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/brandingPolicies/priorities', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Delete a branding policy
		 * Delete a branding policy
		 * Delete organizations/{organizationId}/brandingPolicies/{brandingPolicyId}
		 * @return {void} 
		 */
		DeleteOrganizationBrandingPolicy(organizationId: string, brandingPolicyId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/brandingPolicies/' + (brandingPolicyId == null ? '' : encodeURIComponent(brandingPolicyId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a branding policy
		 * Return a branding policy
		 * Get organizations/{organizationId}/brandingPolicies/{brandingPolicyId}
		 * @return {GetOrganizationBrandingPolicyReturn} Successful operation
		 */
		GetOrganizationBrandingPolicy(organizationId: string, brandingPolicyId: string): Observable<GetOrganizationBrandingPolicyReturn> {
			return this.http.get<GetOrganizationBrandingPolicyReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/brandingPolicies/' + (brandingPolicyId == null ? '' : encodeURIComponent(brandingPolicyId)), {});
		}

		/**
		 * Update a branding policy
		 * Update a branding policy
		 * Put organizations/{organizationId}/brandingPolicies/{brandingPolicyId}
		 * @return {UpdateOrganizationBrandingPolicyReturn} Successful operation
		 */
		UpdateOrganizationBrandingPolicy(organizationId: string, brandingPolicyId: string, requestBody: UpdateOrganizationBrandingPolicyPutBody): Observable<UpdateOrganizationBrandingPolicyReturn> {
			return this.http.put<UpdateOrganizationBrandingPolicyReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/brandingPolicies/' + (brandingPolicyId == null ? '' : encodeURIComponent(brandingPolicyId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List Custom Analytics Artifacts
		 * List Custom Analytics Artifacts
		 * Get organizations/{organizationId}/camera/customAnalytics/artifacts
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationCameraCustomAnalyticsArtifacts(organizationId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/camera/customAnalytics/artifacts', {});
		}

		/**
		 * Create custom analytics artifact
		 * Create custom analytics artifact. Returns an artifact upload URL with expiry time. Upload the artifact file with a put request to the returned upload URL before its expiry.
		 * Post organizations/{organizationId}/camera/customAnalytics/artifacts
		 * @return {void} 
		 */
		CreateOrganizationCameraCustomAnalyticsArtifact(organizationId: string, requestBody: CreateOrganizationCameraCustomAnalyticsArtifactPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/camera/customAnalytics/artifacts', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete Custom Analytics Artifact
		 * Delete Custom Analytics Artifact
		 * Delete organizations/{organizationId}/camera/customAnalytics/artifacts/{artifactId}
		 * @return {void} 
		 */
		DeleteOrganizationCameraCustomAnalyticsArtifact(organizationId: string, artifactId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/camera/customAnalytics/artifacts/' + (artifactId == null ? '' : encodeURIComponent(artifactId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Get Custom Analytics Artifact
		 * Get Custom Analytics Artifact
		 * Get organizations/{organizationId}/camera/customAnalytics/artifacts/{artifactId}
		 * @return {string} Successful operation
		 */
		GetOrganizationCameraCustomAnalyticsArtifact(organizationId: string, artifactId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/camera/customAnalytics/artifacts/' + (artifactId == null ? '' : encodeURIComponent(artifactId)), { responseType: 'text' });
		}

		/**
		 * Fetch onboarding status of cameras
		 * Fetch onboarding status of cameras
		 * Get organizations/{organizationId}/camera/onboarding/statuses
		 * @param {Array<string>} serials A list of serial numbers. The returned cameras will be filtered to only include these serials.
		 * @param {Array<string>} networkIds A list of network IDs. The returned cameras will be filtered to only include these networks.
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationCameraOnboardingStatuses(organizationId: string, serials: Array<string> | null | undefined, networkIds: Array<string> | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/camera/onboarding/statuses&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * Notify that credential handoff to camera has completed
		 * Notify that credential handoff to camera has completed
		 * Put organizations/{organizationId}/camera/onboarding/statuses
		 * @return {string} Successful operation
		 */
		UpdateOrganizationCameraOnboardingStatuses(organizationId: string, requestBody: UpdateOrganizationCameraOnboardingStatusesPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/camera/onboarding/statuses', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the uplink status of every Meraki MG cellular gateway in the organization
		 * List the uplink status of every Meraki MG cellular gateway in the organization
		 * Get organizations/{organizationId}/cellularGateway/uplink/statuses
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds A list of network IDs. The returned devices will be filtered to only include these networks.
		 * @param {Array<string>} serials A list of serial numbers. The returned devices will be filtered to only include these serials.
		 * @param {Array<string>} iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs.
		 * @return {Array<GetOrganizationCellularGatewayUplinkStatusesReturn>} Successful operation
		 */
		GetOrganizationCellularGatewayUplinkStatuses(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined, serials: Array<string> | null | undefined, iccids: Array<string> | null | undefined): Observable<Array<GetOrganizationCellularGatewayUplinkStatusesReturn>> {
			return this.http.get<Array<GetOrganizationCellularGatewayUplinkStatusesReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/cellularGateway/uplink/statuses&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + iccids?.map(z => `iccids=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * Claim a list of devices, licenses, and/or orders into an organization
		 * Claim a list of devices, licenses, and/or orders into an organization. When claiming by order, all devices and licenses in the order will be claimed; licenses will be added to the organization and devices will be placed in the organization's inventory.
		 * Post organizations/{organizationId}/claim
		 * @return {string} Successful operation
		 */
		ClaimIntoOrganization(organizationId: string, requestBody: ClaimIntoOrganizationPostBody): Observable<string> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/claim', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return data usage (in megabits per second) over time for all clients in the given organization within a given time range.
		 * Return data usage (in megabits per second) over time for all clients in the given organization within a given time range.
		 * Get organizations/{organizationId}/clients/bandwidthUsageHistory
		 * @param {string} t0 The beginning of the timespan for the data.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<GetOrganizationClientsBandwidthUsageHistoryReturn>} Successful operation
		 */
		GetOrganizationClientsBandwidthUsageHistory(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<Array<GetOrganizationClientsBandwidthUsageHistoryReturn>> {
			return this.http.get<Array<GetOrganizationClientsBandwidthUsageHistoryReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/clients/bandwidthUsageHistory&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return summary information around client data usage (in mb) across the given organization.
		 * Return summary information around client data usage (in mb) across the given organization.
		 * Get organizations/{organizationId}/clients/overview
		 * @param {string} t0 The beginning of the timespan for the data.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {GetOrganizationClientsOverviewReturn} Successful operation
		 */
		GetOrganizationClientsOverview(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<GetOrganizationClientsOverviewReturn> {
			return this.http.get<GetOrganizationClientsOverviewReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/clients/overview&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return the client details in an organization
		 * Return the client details in an organization
		 * Get organizations/{organizationId}/clients/search
		 * @param {string} mac The MAC address of the client. Required.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 5. Default is 5.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {string} Successful operation
		 */
		GetOrganizationClientsSearch(organizationId: string, mac: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/clients/search&mac=' + (mac == null ? '' : encodeURIComponent(mac)) + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), { responseType: 'text' });
		}

		/**
		 * Create a new organization by cloning the addressed organization
		 * Create a new organization by cloning the addressed organization
		 * Post organizations/{organizationId}/clone
		 * @return {void} 
		 */
		CloneOrganization(organizationId: string, requestBody: CloneOrganizationPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/clone', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * List the configuration templates for this organization
		 * List the configuration templates for this organization
		 * Get organizations/{organizationId}/configTemplates
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationConfigTemplates(organizationId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/configTemplates', {});
		}

		/**
		 * Create a new configuration template
		 * Create a new configuration template
		 * Post organizations/{organizationId}/configTemplates
		 * @return {void} 
		 */
		CreateOrganizationConfigTemplate(organizationId: string, requestBody: CreateOrganizationConfigTemplatePostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/configTemplates', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Remove a configuration template
		 * Remove a configuration template
		 * Delete organizations/{organizationId}/configTemplates/{configTemplateId}
		 * @return {void} 
		 */
		DeleteOrganizationConfigTemplate(organizationId: string, configTemplateId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/configTemplates/' + (configTemplateId == null ? '' : encodeURIComponent(configTemplateId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a single configuration template
		 * Return a single configuration template
		 * Get organizations/{organizationId}/configTemplates/{configTemplateId}
		 * @return {string} Successful operation
		 */
		GetOrganizationConfigTemplate(organizationId: string, configTemplateId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/configTemplates/' + (configTemplateId == null ? '' : encodeURIComponent(configTemplateId)), { responseType: 'text' });
		}

		/**
		 * Update a configuration template
		 * Update a configuration template
		 * Put organizations/{organizationId}/configTemplates/{configTemplateId}
		 * @return {string} Successful operation
		 */
		UpdateOrganizationConfigTemplate(organizationId: string, configTemplateId: string, requestBody: UpdateOrganizationConfigTemplatePutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/configTemplates/' + (configTemplateId == null ? '' : encodeURIComponent(configTemplateId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the switch profiles for your switch template configuration
		 * List the switch profiles for your switch template configuration
		 * Get organizations/{organizationId}/configTemplates/{configTemplateId}/switch/profiles
		 * @return {GetOrganizationConfigTemplateSwitchProfilesReturn} Successful operation
		 */
		GetOrganizationConfigTemplateSwitchProfiles(organizationId: string, configTemplateId: string): Observable<GetOrganizationConfigTemplateSwitchProfilesReturn> {
			return this.http.get<GetOrganizationConfigTemplateSwitchProfilesReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/configTemplates/' + (configTemplateId == null ? '' : encodeURIComponent(configTemplateId)) + '/switch/profiles', {});
		}

		/**
		 * Return all the ports of a switch profile
		 * Return all the ports of a switch profile
		 * Get organizations/{organizationId}/configTemplates/{configTemplateId}/switch/profiles/{profileId}/ports
		 * @return {Array<GetOrganizationConfigTemplateSwitchProfilePortsReturn>} Successful operation
		 */
		GetOrganizationConfigTemplateSwitchProfilePorts(organizationId: string, configTemplateId: string, profileId: string): Observable<Array<GetOrganizationConfigTemplateSwitchProfilePortsReturn>> {
			return this.http.get<Array<GetOrganizationConfigTemplateSwitchProfilePortsReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/configTemplates/' + (configTemplateId == null ? '' : encodeURIComponent(configTemplateId)) + '/switch/profiles/' + (profileId == null ? '' : encodeURIComponent(profileId)) + '/ports', {});
		}

		/**
		 * Return a switch profile port
		 * Return a switch profile port
		 * Get organizations/{organizationId}/configTemplates/{configTemplateId}/switch/profiles/{profileId}/ports/{portId}
		 * @return {GetOrganizationConfigTemplateSwitchProfilePortReturn} Successful operation
		 */
		GetOrganizationConfigTemplateSwitchProfilePort(organizationId: string, configTemplateId: string, profileId: string, portId: string): Observable<GetOrganizationConfigTemplateSwitchProfilePortReturn> {
			return this.http.get<GetOrganizationConfigTemplateSwitchProfilePortReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/configTemplates/' + (configTemplateId == null ? '' : encodeURIComponent(configTemplateId)) + '/switch/profiles/' + (profileId == null ? '' : encodeURIComponent(profileId)) + '/ports/' + (portId == null ? '' : encodeURIComponent(portId)), {});
		}

		/**
		 * Update a switch profile port
		 * Update a switch profile port
		 * Put organizations/{organizationId}/configTemplates/{configTemplateId}/switch/profiles/{profileId}/ports/{portId}
		 * @return {UpdateOrganizationConfigTemplateSwitchProfilePortReturn} Successful operation
		 */
		UpdateOrganizationConfigTemplateSwitchProfilePort(organizationId: string, configTemplateId: string, profileId: string, portId: string, requestBody: UpdateOrganizationConfigTemplateSwitchProfilePortPutBody): Observable<UpdateOrganizationConfigTemplateSwitchProfilePortReturn> {
			return this.http.put<UpdateOrganizationConfigTemplateSwitchProfilePortReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/configTemplates/' + (configTemplateId == null ? '' : encodeURIComponent(configTemplateId)) + '/switch/profiles/' + (profileId == null ? '' : encodeURIComponent(profileId)) + '/ports/' + (portId == null ? '' : encodeURIComponent(portId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * View the Change Log for your organization
		 * View the Change Log for your organization
		 * Get organizations/{organizationId}/configurationChanges
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 365 days.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 5000. Default is 5000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} networkId Filters on the given network
		 * @param {string} adminId Filters on the given Admin
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationConfigurationChanges(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkId: string | null | undefined, adminId: string | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/configurationChanges&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&networkId=' + (networkId == null ? '' : encodeURIComponent(networkId)) + '&adminId=' + (adminId == null ? '' : encodeURIComponent(adminId)), {});
		}

		/**
		 * List the devices in an organization
		 * List the devices in an organization
		 * Get organizations/{organizationId}/devices
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} configurationUpdatedAfter Filter results by whether or not the device's configuration has been updated after the given timestamp
		 * @param {Array<string>} networkIds Optional parameter to filter devices by network.
		 * @param {Array<string>} productTypes Optional parameter to filter devices by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and sensor.
		 * @param {Array<string>} tags Optional parameter to filter devices by tags.
		 * @param {GetOrganizationDevicesTagsFilterType} tagsFilterType Optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.
		 * @param {string} name Optional parameter to filter devices by name. All returned devices will have a name that contains the search term or is an exact match.
		 * @param {string} mac Optional parameter to filter devices by MAC address. All returned devices will have a MAC address that contains the search term or is an exact match.
		 * @param {string} serial Optional parameter to filter devices by serial number. All returned devices will have a serial number that contains the search term or is an exact match.
		 * @param {string} model Optional parameter to filter devices by model. All returned devices will have a model that contains the search term or is an exact match.
		 * @param {Array<string>} macs Optional parameter to filter devices by one or more MAC addresses. All returned devices will have a MAC address that is an exact match.
		 * @param {Array<string>} serials Optional parameter to filter devices by one or more serial numbers. All returned devices will have a serial number that is an exact match.
		 * @param {Array<string>} sensorMetrics Optional parameter to filter devices by the metrics that they provide. Only applies to sensor devices.
		 * @param {Array<string>} sensorAlertProfileIds Optional parameter to filter devices by the alert profiles that are bound to them. Only applies to sensor devices.
		 * @param {Array<string>} models Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match.
		 * @return {Array<GetOrganizationDevicesReturn>} Successful operation
		 */
		GetOrganizationDevices(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, configurationUpdatedAfter: string | null | undefined, networkIds: Array<string> | null | undefined, productTypes: Array<string> | null | undefined, tags: Array<string> | null | undefined, tagsFilterType: GetOrganizationDevicesTagsFilterType | null | undefined, name: string | null | undefined, mac: string | null | undefined, serial: string | null | undefined, model: string | null | undefined, macs: Array<string> | null | undefined, serials: Array<string> | null | undefined, sensorMetrics: Array<string> | null | undefined, sensorAlertProfileIds: Array<string> | null | undefined, models: Array<string> | null | undefined): Observable<Array<GetOrganizationDevicesReturn>> {
			return this.http.get<Array<GetOrganizationDevicesReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/devices&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&configurationUpdatedAfter=' + (configurationUpdatedAfter == null ? '' : encodeURIComponent(configurationUpdatedAfter)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + productTypes?.map(z => `productTypes=${encodeURIComponent(z)}`).join('&') + '&' + tags?.map(z => `tags=${encodeURIComponent(z)}`).join('&') + '&tagsFilterType=' + tagsFilterType + '&name=' + (name == null ? '' : encodeURIComponent(name)) + '&mac=' + (mac == null ? '' : encodeURIComponent(mac)) + '&serial=' + (serial == null ? '' : encodeURIComponent(serial)) + '&model=' + (model == null ? '' : encodeURIComponent(model)) + '&' + macs?.map(z => `macs=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + sensorMetrics?.map(z => `sensorMetrics=${encodeURIComponent(z)}`).join('&') + '&' + sensorAlertProfileIds?.map(z => `sensorAlertProfileIds=${encodeURIComponent(z)}`).join('&') + '&' + models?.map(z => `models=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * List the availability information for devices in an organization
		 * List the availability information for devices in an organization. The data returned by this endpoint is updated every 5 minutes.
		 * Get organizations/{organizationId}/devices/availabilities
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches.
		 * @param {Array<string>} productTypes Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches.
		 * @param {Array<string>} serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches.
		 * @param {Array<string>} tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below). This filter uses multiple exact matches.
		 * @param {GetOrganizationDevicesTagsFilterType} tagsFilterType An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.
		 * @return {Array<GetOrganizationDevicesAvailabilitiesReturn>} Successful operation
		 */
		GetOrganizationDevicesAvailabilities(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined, productTypes: Array<string> | null | undefined, serials: Array<string> | null | undefined, tags: Array<string> | null | undefined, tagsFilterType: GetOrganizationDevicesTagsFilterType | null | undefined): Observable<Array<GetOrganizationDevicesAvailabilitiesReturn>> {
			return this.http.get<Array<GetOrganizationDevicesAvailabilitiesReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/devices/availabilities&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + productTypes?.map(z => `productTypes=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + tags?.map(z => `tags=${encodeURIComponent(z)}`).join('&') + '&tagsFilterType=' + tagsFilterType, {});
		}

		/**
		 * List the power status information for devices in an organization
		 * List the power status information for devices in an organization. The data returned by this endpoint is updated every 5 minutes.
		 * Get organizations/{organizationId}/devices/powerModules/statuses/byDevice
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches.
		 * @param {Array<string>} productTypes Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches.
		 * @param {Array<string>} serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches.
		 * @param {Array<string>} tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below). This filter uses multiple exact matches.
		 * @param {GetOrganizationDevicesTagsFilterType} tagsFilterType An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.
		 * @return {Array<GetOrganizationDevicesPowerModulesStatusesByDeviceReturn>} Successful operation
		 */
		GetOrganizationDevicesPowerModulesStatusesByDevice(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined, productTypes: Array<string> | null | undefined, serials: Array<string> | null | undefined, tags: Array<string> | null | undefined, tagsFilterType: GetOrganizationDevicesTagsFilterType | null | undefined): Observable<Array<GetOrganizationDevicesPowerModulesStatusesByDeviceReturn>> {
			return this.http.get<Array<GetOrganizationDevicesPowerModulesStatusesByDeviceReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/devices/powerModules/statuses/byDevice&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + productTypes?.map(z => `productTypes=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + tags?.map(z => `tags=${encodeURIComponent(z)}`).join('&') + '&tagsFilterType=' + tagsFilterType, {});
		}

		/**
		 * List the status of every Meraki device in the organization
		 * List the status of every Meraki device in the organization
		 * Get organizations/{organizationId}/devices/statuses
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds Optional parameter to filter devices by network ids.
		 * @param {Array<string>} serials Optional parameter to filter devices by serials.
		 * @param {Array<GetOrganizationDevicesAvailabilitiesReturnStatus>} statuses Optional parameter to filter devices by statuses. Valid statuses are ["online", "alerting", "offline", "dormant"].
		 * @param {Array<GetOrganizationDevicesAvailabilitiesReturnProductType>} productTypes An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and sensor.
		 * @param {Array<string>} models Optional parameter to filter devices by models.
		 * @param {Array<string>} tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below).
		 * @param {GetOrganizationDevicesTagsFilterType} tagsFilterType An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.
		 * @return {GetOrganizationDevicesStatusesReturn} Successful operation
		 */
		GetOrganizationDevicesStatuses(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined, serials: Array<string> | null | undefined, statuses: Array<GetOrganizationDevicesAvailabilitiesReturnStatus> | null | undefined, productTypes: Array<GetOrganizationDevicesAvailabilitiesReturnProductType> | null | undefined, models: Array<string> | null | undefined, tags: Array<string> | null | undefined, tagsFilterType: GetOrganizationDevicesTagsFilterType | null | undefined): Observable<GetOrganizationDevicesStatusesReturn> {
			return this.http.get<GetOrganizationDevicesStatusesReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/devices/statuses&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + statuses?.map(z => `statuses=${z}`).join('&') + '&' + productTypes?.map(z => `productTypes=${z}`).join('&') + '&' + models?.map(z => `models=${encodeURIComponent(z)}`).join('&') + '&' + tags?.map(z => `tags=${encodeURIComponent(z)}`).join('&') + '&tagsFilterType=' + tagsFilterType, {});
		}

		/**
		 * Return an overview of current device statuses
		 * Return an overview of current device statuses
		 * Get organizations/{organizationId}/devices/statuses/overview
		 * @param {Array<GetOrganizationDevicesAvailabilitiesReturnProductType>} productTypes An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and sensor.
		 * @param {Array<string>} networkIds An optional parameter to filter device statuses by network.
		 * @return {GetOrganizationDevicesStatusesOverviewReturn} Successful operation
		 */
		GetOrganizationDevicesStatusesOverview(organizationId: string, productTypes: Array<GetOrganizationDevicesAvailabilitiesReturnProductType> | null | undefined, networkIds: Array<string> | null | undefined): Observable<GetOrganizationDevicesStatusesOverviewReturn> {
			return this.http.get<GetOrganizationDevicesStatusesOverviewReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/devices/statuses/overview&' + productTypes?.map(z => `productTypes=${z}`).join('&') + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * List the current uplink addresses for devices in an organization.
		 * List the current uplink addresses for devices in an organization.
		 * Get organizations/{organizationId}/devices/uplinks/addresses/byDevice
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds Optional parameter to filter device uplinks by network ID. This filter uses multiple exact matches.
		 * @param {Array<string>} productTypes Optional parameter to filter device uplinks by device product types. This filter uses multiple exact matches.
		 * @param {Array<string>} serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches.
		 * @param {Array<string>} tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below). This filter uses multiple exact matches.
		 * @param {GetOrganizationDevicesTagsFilterType} tagsFilterType An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.
		 * @return {Array<GetOrganizationDevicesUplinksAddressesByDeviceReturn>} Successful operation
		 */
		GetOrganizationDevicesUplinksAddressesByDevice(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined, productTypes: Array<string> | null | undefined, serials: Array<string> | null | undefined, tags: Array<string> | null | undefined, tagsFilterType: GetOrganizationDevicesTagsFilterType | null | undefined): Observable<Array<GetOrganizationDevicesUplinksAddressesByDeviceReturn>> {
			return this.http.get<Array<GetOrganizationDevicesUplinksAddressesByDeviceReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/devices/uplinks/addresses/byDevice&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + productTypes?.map(z => `productTypes=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + tags?.map(z => `tags=${encodeURIComponent(z)}`).join('&') + '&tagsFilterType=' + tagsFilterType, {});
		}

		/**
		 * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
		 * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
		 * Get organizations/{organizationId}/devices/uplinksLossAndLatency
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes.
		 * @param {GetDeviceLossAndLatencyHistoryUplink} uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, cellular. Default will return all uplinks.
		 * @param {string} ip Optional filter for a specific destination IP. Default will return all destination IPs.
		 * @return {Array<GetOrganizationDevicesUplinksLossAndLatencyReturn>} Successful operation
		 */
		GetOrganizationDevicesUplinksLossAndLatency(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, uplink: GetDeviceLossAndLatencyHistoryUplink | null | undefined, ip: string | null | undefined): Observable<Array<GetOrganizationDevicesUplinksLossAndLatencyReturn>> {
			return this.http.get<Array<GetOrganizationDevicesUplinksLossAndLatencyReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/devices/uplinksLossAndLatency&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&uplink=' + uplink + '&ip=' + (ip == null ? '' : encodeURIComponent(ip)), {});
		}

		/**
		 * List the available early access features for organization
		 * List the available early access features for organization
		 * Get organizations/{organizationId}/earlyAccess/features
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationEarlyAccessFeatures(organizationId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/earlyAccess/features', {});
		}

		/**
		 * List the early access feature opt-ins for an organization
		 * List the early access feature opt-ins for an organization
		 * Get organizations/{organizationId}/earlyAccess/features/optIns
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationEarlyAccessFeaturesOptIns(organizationId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/earlyAccess/features/optIns', {});
		}

		/**
		 * Create a new early access feature opt-in for an organization
		 * Create a new early access feature opt-in for an organization
		 * Post organizations/{organizationId}/earlyAccess/features/optIns
		 * @return {string} Successful operation
		 */
		CreateOrganizationEarlyAccessFeaturesOptIn(organizationId: string, requestBody: CreateOrganizationEarlyAccessFeaturesOptInPostBody): Observable<string> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/earlyAccess/features/optIns', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Delete an early access feature opt-in
		 * Delete an early access feature opt-in
		 * Delete organizations/{organizationId}/earlyAccess/features/optIns/{optInId}
		 * @return {void} 
		 */
		DeleteOrganizationEarlyAccessFeaturesOptIn(organizationId: string, optInId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/earlyAccess/features/optIns/' + (optInId == null ? '' : encodeURIComponent(optInId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Show an early access feature opt-in for an organization
		 * Show an early access feature opt-in for an organization
		 * Get organizations/{organizationId}/earlyAccess/features/optIns/{optInId}
		 * @return {string} Successful operation
		 */
		GetOrganizationEarlyAccessFeaturesOptIn(organizationId: string, optInId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/earlyAccess/features/optIns/' + (optInId == null ? '' : encodeURIComponent(optInId)), { responseType: 'text' });
		}

		/**
		 * Update an early access feature opt-in for an organization
		 * Update an early access feature opt-in for an organization
		 * Put organizations/{organizationId}/earlyAccess/features/optIns/{optInId}
		 * @return {string} Successful operation
		 */
		UpdateOrganizationEarlyAccessFeaturesOptIn(organizationId: string, optInId: string, requestBody: UpdateOrganizationEarlyAccessFeaturesOptInPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/earlyAccess/features/optIns/' + (optInId == null ? '' : encodeURIComponent(optInId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Get firmware upgrade information for an organization
		 * Get firmware upgrade information for an organization
		 * Get organizations/{organizationId}/firmware/upgrades
		 * @param {Array<string>} status The status of an upgrade 
		 * @param {Array<string>} productType The product type in a given upgrade ID
		 * @return {Array<GetOrganizationFirmwareUpgradesReturn>} Successful operation
		 */
		GetOrganizationFirmwareUpgrades(organizationId: string, status: Array<string> | null | undefined, productType: Array<string> | null | undefined): Observable<Array<GetOrganizationFirmwareUpgradesReturn>> {
			return this.http.get<Array<GetOrganizationFirmwareUpgradesReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/firmware/upgrades&' + status?.map(z => `status=${encodeURIComponent(z)}`).join('&') + '&' + productType?.map(z => `productType=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * Get firmware upgrade status for the filtered devices
		 * Get firmware upgrade status for the filtered devices
		 * Get organizations/{organizationId}/firmware/upgrades/byDevice
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 50. Default is 50.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds Optional parameter to filter by network
		 * @param {Array<string>} serials Optional parameter to filter by serial number.  All returned devices will have a serial number that is an exact match.
		 * @param {Array<string>} macs Optional parameter to filter by one or more MAC addresses belonging to devices. All devices returned belong to MAC addresses that are an exact match.
		 * @param {Array<string>} firmwareUpgradeIds Optional parameter to filter by firmware upgrade ids.
		 * @param {Array<string>} firmwareUpgradeBatchIds Optional parameter to filter by firmware upgrade batch ids.
		 * @return {Array<GetOrganizationFirmwareUpgradesByDeviceReturn>} Successful operation
		 */
		GetOrganizationFirmwareUpgradesByDevice(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined, serials: Array<string> | null | undefined, macs: Array<string> | null | undefined, firmwareUpgradeIds: Array<string> | null | undefined, firmwareUpgradeBatchIds: Array<string> | null | undefined): Observable<Array<GetOrganizationFirmwareUpgradesByDeviceReturn>> {
			return this.http.get<Array<GetOrganizationFirmwareUpgradesByDeviceReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/firmware/upgrades/byDevice&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + macs?.map(z => `macs=${encodeURIComponent(z)}`).join('&') + '&' + firmwareUpgradeIds?.map(z => `firmwareUpgradeIds=${encodeURIComponent(z)}`).join('&') + '&' + firmwareUpgradeBatchIds?.map(z => `firmwareUpgradeBatchIds=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * List all Insight tracked applications
		 * List all Insight tracked applications
		 * Get organizations/{organizationId}/insight/applications
		 * @return {Array<GetOrganizationInsightApplicationsReturn>} Successful operation
		 */
		GetOrganizationInsightApplications(organizationId: string): Observable<Array<GetOrganizationInsightApplicationsReturn>> {
			return this.http.get<Array<GetOrganizationInsightApplicationsReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/insight/applications', {});
		}

		/**
		 * List the monitored media servers for this organization
		 * List the monitored media servers for this organization. Only valid for organizations with Meraki Insight.
		 * Get organizations/{organizationId}/insight/monitoredMediaServers
		 * @return {Array<GetOrganizationInsightMonitoredMediaServersReturn>} Successful operation
		 */
		GetOrganizationInsightMonitoredMediaServers(organizationId: string): Observable<Array<GetOrganizationInsightMonitoredMediaServersReturn>> {
			return this.http.get<Array<GetOrganizationInsightMonitoredMediaServersReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/insight/monitoredMediaServers', {});
		}

		/**
		 * Add a media server to be monitored for this organization
		 * Add a media server to be monitored for this organization. Only valid for organizations with Meraki Insight.
		 * Post organizations/{organizationId}/insight/monitoredMediaServers
		 * @return {void} 
		 */
		CreateOrganizationInsightMonitoredMediaServer(organizationId: string, requestBody: CreateOrganizationInsightMonitoredMediaServerPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/insight/monitoredMediaServers', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Delete a monitored media server from this organization
		 * Delete a monitored media server from this organization. Only valid for organizations with Meraki Insight.
		 * Delete organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}
		 * @return {void} 
		 */
		DeleteOrganizationInsightMonitoredMediaServer(organizationId: string, monitoredMediaServerId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/insight/monitoredMediaServers/' + (monitoredMediaServerId == null ? '' : encodeURIComponent(monitoredMediaServerId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a monitored media server for this organization
		 * Return a monitored media server for this organization. Only valid for organizations with Meraki Insight.
		 * Get organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}
		 * @return {string} Successful operation
		 */
		GetOrganizationInsightMonitoredMediaServer(organizationId: string, monitoredMediaServerId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/insight/monitoredMediaServers/' + (monitoredMediaServerId == null ? '' : encodeURIComponent(monitoredMediaServerId)), { responseType: 'text' });
		}

		/**
		 * Update a monitored media server for this organization
		 * Update a monitored media server for this organization. Only valid for organizations with Meraki Insight.
		 * Put organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}
		 * @return {string} Successful operation
		 */
		UpdateOrganizationInsightMonitoredMediaServer(organizationId: string, monitoredMediaServerId: string, requestBody: UpdateOrganizationInsightMonitoredMediaServerPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/insight/monitoredMediaServers/' + (monitoredMediaServerId == null ? '' : encodeURIComponent(monitoredMediaServerId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Claim a list of devices, licenses, and/or orders into an organization inventory
		 * Claim a list of devices, licenses, and/or orders into an organization inventory. When claiming by order, all devices and licenses in the order will be claimed; licenses will be added to the organization and devices will be placed in the organization's inventory. Use /organizations/{organizationId}/inventory/release to release devices from an organization.
		 * Post organizations/{organizationId}/inventory/claim
		 * @return {string} Successful operation
		 */
		ClaimIntoOrganizationInventory(organizationId: string, requestBody: ClaimIntoOrganizationInventoryPostBody): Observable<string> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/inventory/claim', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the device inventory for an organization
		 * Return the device inventory for an organization
		 * Get organizations/{organizationId}/inventory/devices
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {GetOrganizationInventoryDevicesUsedState} usedState Filter results by used or unused inventory. Accepted values are 'used' or 'unused'.
		 * @param {string} search Search for devices in inventory based on serial number, mac address, or model.
		 * @param {Array<string>} macs Search for devices in inventory based on mac addresses.
		 * @param {Array<string>} networkIds Search for devices in inventory based on network ids.
		 * @param {Array<string>} serials Search for devices in inventory based on serials.
		 * @param {Array<string>} models Search for devices in inventory based on model.
		 * @param {Array<string>} orderNumbers Search for devices in inventory based on order numbers.
		 * @param {Array<string>} tags Filter devices by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below).
		 * @param {GetOrganizationDevicesTagsFilterType} tagsFilterType To use with 'tags' parameter, to filter devices which contain ANY or ALL given tags. Accepted values are 'withAnyTags' or 'withAllTags', default is 'withAnyTags'.
		 * @param {Array<GetOrganizationDevicesAvailabilitiesReturnProductType>} productTypes Filter devices by product type. Accepted values are appliance, camera, cellularGateway, sensor, switch, systemsManager, and wireless.
		 * @return {Array<GetOrganizationInventoryDevicesReturn>} Successful operation
		 */
		GetOrganizationInventoryDevices(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, usedState: GetOrganizationInventoryDevicesUsedState | null | undefined, search: string | null | undefined, macs: Array<string> | null | undefined, networkIds: Array<string> | null | undefined, serials: Array<string> | null | undefined, models: Array<string> | null | undefined, orderNumbers: Array<string> | null | undefined, tags: Array<string> | null | undefined, tagsFilterType: GetOrganizationDevicesTagsFilterType | null | undefined, productTypes: Array<GetOrganizationDevicesAvailabilitiesReturnProductType> | null | undefined): Observable<Array<GetOrganizationInventoryDevicesReturn>> {
			return this.http.get<Array<GetOrganizationInventoryDevicesReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/inventory/devices&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&usedState=' + usedState + '&search=' + (search == null ? '' : encodeURIComponent(search)) + '&' + macs?.map(z => `macs=${encodeURIComponent(z)}`).join('&') + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + models?.map(z => `models=${encodeURIComponent(z)}`).join('&') + '&' + orderNumbers?.map(z => `orderNumbers=${encodeURIComponent(z)}`).join('&') + '&' + tags?.map(z => `tags=${encodeURIComponent(z)}`).join('&') + '&tagsFilterType=' + tagsFilterType + '&' + productTypes?.map(z => `productTypes=${z}`).join('&'), {});
		}

		/**
		 * Return a single device from the inventory of an organization
		 * Return a single device from the inventory of an organization
		 * Get organizations/{organizationId}/inventory/devices/{serial}
		 * @return {GetOrganizationInventoryDeviceReturn} Successful operation
		 */
		GetOrganizationInventoryDevice(organizationId: string, serial: string): Observable<GetOrganizationInventoryDeviceReturn> {
			return this.http.get<GetOrganizationInventoryDeviceReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/inventory/devices/' + (serial == null ? '' : encodeURIComponent(serial)), {});
		}

		/**
		 * Imports event logs related to the onboarding app into elastisearch
		 * Imports event logs related to the onboarding app into elastisearch
		 * Post organizations/{organizationId}/inventory/onboarding/cloudMonitoring/exportEvents
		 * @return {void} 
		 */
		CreateOrganizationInventoryOnboardingCloudMonitoringExportEvent(organizationId: string, requestBody: CreateOrganizationInventoryOnboardingCloudMonitoringExportEventPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/inventory/onboarding/cloudMonitoring/exportEvents', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Check the status of a committed Import operation
		 * Check the status of a committed Import operation
		 * Get organizations/{organizationId}/inventory/onboarding/cloudMonitoring/imports
		 * @param {Array<string>} importIds import ids from an imports
		 * @return {Array<GetOrganizationInventoryOnboardingCloudMonitoringImportsReturn>} Successful operation
		 */
		GetOrganizationInventoryOnboardingCloudMonitoringImports(organizationId: string, importIds: Array<string>): Observable<Array<GetOrganizationInventoryOnboardingCloudMonitoringImportsReturn>> {
			return this.http.get<Array<GetOrganizationInventoryOnboardingCloudMonitoringImportsReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/inventory/onboarding/cloudMonitoring/imports&' + importIds.map(z => `importIds=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * Commits the import operation to complete the onboarding of a device into Dashboard for monitoring.
		 * Commits the import operation to complete the onboarding of a device into Dashboard for monitoring.
		 * Post organizations/{organizationId}/inventory/onboarding/cloudMonitoring/imports
		 * @return {void} 
		 */
		CreateOrganizationInventoryOnboardingCloudMonitoringImport(organizationId: string, requestBody: CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/inventory/onboarding/cloudMonitoring/imports', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Returns list of networks eligible for adding cloud monitored device
		 * Returns list of networks eligible for adding cloud monitored device
		 * Get organizations/{organizationId}/inventory/onboarding/cloudMonitoring/networks
		 * @param {GetOrganizationInventoryOnboardingCloudMonitoringNetworksDeviceType} deviceType Device Type switch or wireless controller
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {void} 
		 */
		GetOrganizationInventoryOnboardingCloudMonitoringNetworks(organizationId: string, deviceType: GetOrganizationInventoryOnboardingCloudMonitoringNetworksDeviceType, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<HttpResponse<string>> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/inventory/onboarding/cloudMonitoring/networks&deviceType=' + deviceType + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Initiates or updates an import session
		 * Initiates or updates an import session. An import ID will be generated and used when you are ready to commit the import.
		 * Post organizations/{organizationId}/inventory/onboarding/cloudMonitoring/prepare
		 * @return {void} 
		 */
		CreateOrganizationInventoryOnboardingCloudMonitoringPrepare(organizationId: string, requestBody: CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/inventory/onboarding/cloudMonitoring/prepare', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Release a list of claimed devices from an organization.
		 * Release a list of claimed devices from an organization.
		 * Post organizations/{organizationId}/inventory/release
		 * @return {string} Successful operation
		 */
		ReleaseFromOrganizationInventory(organizationId: string, requestBody: ReleaseFromOrganizationInventoryPostBody): Observable<string> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/inventory/release', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the licenses for an organization
		 * List the licenses for an organization
		 * Get organizations/{organizationId}/licenses
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} deviceSerial Filter the licenses to those assigned to a particular device. Returned in the same order that they are queued to the device.
		 * @param {string} networkId Filter the licenses to those assigned in a particular network
		 * @param {GetOrganizationLicensesState} state Filter the licenses to those in a particular state. Can be one of 'active', 'expired', 'expiring', 'recentlyQueued', 'unused' or 'unusedActive'
		 * @return {Array<GetOrganizationLicensesReturn>} Successful operation
		 */
		GetOrganizationLicenses(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, deviceSerial: string | null | undefined, networkId: string | null | undefined, state: GetOrganizationLicensesState | null | undefined): Observable<Array<GetOrganizationLicensesReturn>> {
			return this.http.get<Array<GetOrganizationLicensesReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/licenses&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&deviceSerial=' + (deviceSerial == null ? '' : encodeURIComponent(deviceSerial)) + '&networkId=' + (networkId == null ? '' : encodeURIComponent(networkId)) + '&state=' + state, {});
		}

		/**
		 * Assign SM seats to a network
		 * Assign SM seats to a network. This will increase the managed SM device limit of the network
		 * Post organizations/{organizationId}/licenses/assignSeats
		 * @return {AssignOrganizationLicensesSeatsReturn} Successful operation
		 */
		AssignOrganizationLicensesSeats(organizationId: string, requestBody: AssignOrganizationLicensesSeatsPostBody): Observable<AssignOrganizationLicensesSeatsReturn> {
			return this.http.post<AssignOrganizationLicensesSeatsReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/licenses/assignSeats', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Move licenses to another organization
		 * Move licenses to another organization. This will also move any devices that the licenses are assigned to
		 * Post organizations/{organizationId}/licenses/move
		 * @return {MoveOrganizationLicensesReturn} Successful operation
		 */
		MoveOrganizationLicenses(organizationId: string, requestBody: MoveOrganizationLicensesPostBody): Observable<MoveOrganizationLicensesReturn> {
			return this.http.post<MoveOrganizationLicensesReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/licenses/move', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Move SM seats to another organization
		 * Move SM seats to another organization
		 * Post organizations/{organizationId}/licenses/moveSeats
		 * @return {MoveOrganizationLicensesSeatsReturn} Successful operation
		 */
		MoveOrganizationLicensesSeats(organizationId: string, requestBody: MoveOrganizationLicensesSeatsPostBody): Observable<MoveOrganizationLicensesSeatsReturn> {
			return this.http.post<MoveOrganizationLicensesSeatsReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/licenses/moveSeats', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return an overview of the license state for an organization
		 * Return an overview of the license state for an organization
		 * Get organizations/{organizationId}/licenses/overview
		 * @return {string} Successful operation
		 */
		GetOrganizationLicensesOverview(organizationId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/licenses/overview', { responseType: 'text' });
		}

		/**
		 * Renew SM seats of a license
		 * Renew SM seats of a license. This will extend the license expiration date of managed SM devices covered by this license
		 * Post organizations/{organizationId}/licenses/renewSeats
		 * @return {RenewOrganizationLicensesSeatsReturn} Successful operation
		 */
		RenewOrganizationLicensesSeats(organizationId: string, requestBody: RenewOrganizationLicensesSeatsPostBody): Observable<RenewOrganizationLicensesSeatsReturn> {
			return this.http.post<RenewOrganizationLicensesSeatsReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/licenses/renewSeats', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Display a license
		 * Display a license
		 * Get organizations/{organizationId}/licenses/{licenseId}
		 * @return {GetOrganizationLicenseReturn} Successful operation
		 */
		GetOrganizationLicense(organizationId: string, licenseId: string): Observable<GetOrganizationLicenseReturn> {
			return this.http.get<GetOrganizationLicenseReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/licenses/' + (licenseId == null ? '' : encodeURIComponent(licenseId)), {});
		}

		/**
		 * Update a license
		 * Update a license
		 * Put organizations/{organizationId}/licenses/{licenseId}
		 * @return {UpdateOrganizationLicenseReturn} Successful operation
		 */
		UpdateOrganizationLicense(organizationId: string, licenseId: string, requestBody: UpdateOrganizationLicensePutBody): Observable<UpdateOrganizationLicenseReturn> {
			return this.http.put<UpdateOrganizationLicenseReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/licenses/' + (licenseId == null ? '' : encodeURIComponent(licenseId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the licenses in a coterm organization
		 * List the licenses in a coterm organization
		 * Get organizations/{organizationId}/licensing/coterm/licenses
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {boolean} invalidated Filter for licenses that are invalidated
		 * @param {boolean} expired Filter for licenses that are expired
		 * @return {Array<GetOrganizationLicensingCotermLicensesReturn>} Successful operation
		 */
		GetOrganizationLicensingCotermLicenses(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, invalidated: boolean | null | undefined, expired: boolean | null | undefined): Observable<Array<GetOrganizationLicensingCotermLicensesReturn>> {
			return this.http.get<Array<GetOrganizationLicensingCotermLicensesReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/licensing/coterm/licenses&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&invalidated=' + invalidated + '&expired=' + expired, {});
		}

		/**
		 * Moves a license to a different organization (coterm only)
		 * Moves a license to a different organization (coterm only)
		 * Post organizations/{organizationId}/licensing/coterm/licenses/move
		 * @return {MoveOrganizationLicensingCotermLicensesReturn} Successful operation
		 */
		MoveOrganizationLicensingCotermLicenses(organizationId: string, requestBody: MoveOrganizationLicensingCotermLicensesPostBody): Observable<MoveOrganizationLicensingCotermLicensesReturn> {
			return this.http.post<MoveOrganizationLicensingCotermLicensesReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/licensing/coterm/licenses/move', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Returns the login security settings for an organization.
		 * Returns the login security settings for an organization.
		 * Get organizations/{organizationId}/loginSecurity
		 * @return {GetOrganizationLoginSecurityReturn} Successful operation
		 */
		GetOrganizationLoginSecurity(organizationId: string): Observable<GetOrganizationLoginSecurityReturn> {
			return this.http.get<GetOrganizationLoginSecurityReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/loginSecurity', {});
		}

		/**
		 * Update the login security settings for an organization
		 * Update the login security settings for an organization
		 * Put organizations/{organizationId}/loginSecurity
		 * @return {UpdateOrganizationLoginSecurityReturn} Successful operation
		 */
		UpdateOrganizationLoginSecurity(organizationId: string, requestBody: UpdateOrganizationLoginSecurityPutBody): Observable<UpdateOrganizationLoginSecurityReturn> {
			return this.http.put<UpdateOrganizationLoginSecurityReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/loginSecurity', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the networks that the user has privileges on in an organization
		 * List the networks that the user has privileges on in an organization
		 * Get organizations/{organizationId}/networks
		 * @param {string} configTemplateId An optional parameter that is the ID of a config template. Will return all networks bound to that template.
		 * @param {boolean} isBoundToConfigTemplate An optional parameter to filter config template bound networks. If configTemplateId is set, this cannot be false.
		 * @param {Array<string>} tags An optional parameter to filter networks by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below).
		 * @param {GetOrganizationDevicesTagsFilterType} tagsFilterType An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<GetOrganizationNetworksReturn>} Successful operation
		 */
		GetOrganizationNetworks(organizationId: string, configTemplateId: string | null | undefined, isBoundToConfigTemplate: boolean | null | undefined, tags: Array<string> | null | undefined, tagsFilterType: GetOrganizationDevicesTagsFilterType | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<GetOrganizationNetworksReturn>> {
			return this.http.get<Array<GetOrganizationNetworksReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/networks&configTemplateId=' + (configTemplateId == null ? '' : encodeURIComponent(configTemplateId)) + '&isBoundToConfigTemplate=' + isBoundToConfigTemplate + '&' + tags?.map(z => `tags=${encodeURIComponent(z)}`).join('&') + '&tagsFilterType=' + tagsFilterType + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Create a network
		 * Create a network
		 * Post organizations/{organizationId}/networks
		 * @return {void} 
		 */
		CreateOrganizationNetwork(organizationId: string, requestBody: CreateOrganizationNetworkPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/networks', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Combine multiple networks into a single network
		 * Combine multiple networks into a single network
		 * Post organizations/{organizationId}/networks/combine
		 * @return {CombineOrganizationNetworksReturn} Successful operation
		 */
		CombineOrganizationNetworks(organizationId: string, requestBody: CombineOrganizationNetworksPostBody): Observable<CombineOrganizationNetworksReturn> {
			return this.http.post<CombineOrganizationNetworksReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/networks/combine', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return the OpenAPI 2.0 Specification of the organization's API documentation in JSON
		 * Return the OpenAPI 2.0 Specification of the organization's API documentation in JSON
		 * Get organizations/{organizationId}/openapiSpec
		 * @return {string} Successful operation
		 */
		GetOrganizationOpenapiSpec(organizationId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/openapiSpec', { responseType: 'text' });
		}

		/**
		 * Lists Policy Objects belonging to the organization.
		 * Lists Policy Objects belonging to the organization.
		 * Get organizations/{organizationId}/policyObjects
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 10 - 5000. Default is 5000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationPolicyObjects(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/policyObjects&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Creates a new Policy Object.
		 * Creates a new Policy Object.
		 * Post organizations/{organizationId}/policyObjects
		 * @return {void} 
		 */
		CreateOrganizationPolicyObject(organizationId: string, requestBody: CreateOrganizationPolicyObjectPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/policyObjects', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Lists Policy Object Groups belonging to the organization.
		 * Lists Policy Object Groups belonging to the organization.
		 * Get organizations/{organizationId}/policyObjects/groups
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 10 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationPolicyObjectsGroups(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/policyObjects/groups&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)), {});
		}

		/**
		 * Creates a new Policy Object Group.
		 * Creates a new Policy Object Group.
		 * Post organizations/{organizationId}/policyObjects/groups
		 * @return {void} 
		 */
		CreateOrganizationPolicyObjectsGroup(organizationId: string, requestBody: CreateOrganizationPolicyObjectsGroupPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/policyObjects/groups', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Deletes a Policy Object Group.
		 * Deletes a Policy Object Group.
		 * Delete organizations/{organizationId}/policyObjects/groups/{policyObjectGroupId}
		 * @return {void} 
		 */
		DeleteOrganizationPolicyObjectsGroup(organizationId: string, policyObjectGroupId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/policyObjects/groups/' + (policyObjectGroupId == null ? '' : encodeURIComponent(policyObjectGroupId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Shows details of a Policy Object Group.
		 * Shows details of a Policy Object Group.
		 * Get organizations/{organizationId}/policyObjects/groups/{policyObjectGroupId}
		 * @return {string} Successful operation
		 */
		GetOrganizationPolicyObjectsGroup(organizationId: string, policyObjectGroupId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/policyObjects/groups/' + (policyObjectGroupId == null ? '' : encodeURIComponent(policyObjectGroupId)), { responseType: 'text' });
		}

		/**
		 * Updates a Policy Object Group.
		 * Updates a Policy Object Group.
		 * Put organizations/{organizationId}/policyObjects/groups/{policyObjectGroupId}
		 * @return {string} Successful operation
		 */
		UpdateOrganizationPolicyObjectsGroup(organizationId: string, policyObjectGroupId: string, requestBody: UpdateOrganizationPolicyObjectsGroupPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/policyObjects/groups/' + (policyObjectGroupId == null ? '' : encodeURIComponent(policyObjectGroupId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Deletes a Policy Object.
		 * Deletes a Policy Object.
		 * Delete organizations/{organizationId}/policyObjects/{policyObjectId}
		 * @return {void} 
		 */
		DeleteOrganizationPolicyObject(organizationId: string, policyObjectId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/policyObjects/' + (policyObjectId == null ? '' : encodeURIComponent(policyObjectId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Shows details of a Policy Object.
		 * Shows details of a Policy Object.
		 * Get organizations/{organizationId}/policyObjects/{policyObjectId}
		 * @return {string} Successful operation
		 */
		GetOrganizationPolicyObject(organizationId: string, policyObjectId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/policyObjects/' + (policyObjectId == null ? '' : encodeURIComponent(policyObjectId)), { responseType: 'text' });
		}

		/**
		 * Updates a Policy Object.
		 * Updates a Policy Object.
		 * Put organizations/{organizationId}/policyObjects/{policyObjectId}
		 * @return {string} Successful operation
		 */
		UpdateOrganizationPolicyObject(organizationId: string, policyObjectId: string, requestBody: UpdateOrganizationPolicyObjectPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/policyObjects/' + (policyObjectId == null ? '' : encodeURIComponent(policyObjectId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Returns the SAML SSO enabled settings for an organization.
		 * Returns the SAML SSO enabled settings for an organization.
		 * Get organizations/{organizationId}/saml
		 * @return {GetOrganizationSamlReturn} Successful operation
		 */
		GetOrganizationSaml(organizationId: string): Observable<GetOrganizationSamlReturn> {
			return this.http.get<GetOrganizationSamlReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/saml', {});
		}

		/**
		 * Updates the SAML SSO enabled settings for an organization.
		 * Updates the SAML SSO enabled settings for an organization.
		 * Put organizations/{organizationId}/saml
		 * @return {UpdateOrganizationSamlReturn} Successful operation
		 */
		UpdateOrganizationSaml(organizationId: string, requestBody: UpdateOrganizationSamlPutBody): Observable<UpdateOrganizationSamlReturn> {
			return this.http.put<UpdateOrganizationSamlReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/saml', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the SAML IdPs in your organization.
		 * List the SAML IdPs in your organization.
		 * Get organizations/{organizationId}/saml/idps
		 * @return {Array<GetOrganizationSamlIdpsReturn>} Successful operation
		 */
		GetOrganizationSamlIdps(organizationId: string): Observable<Array<GetOrganizationSamlIdpsReturn>> {
			return this.http.get<Array<GetOrganizationSamlIdpsReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/saml/idps', {});
		}

		/**
		 * Create a SAML IdP for your organization.
		 * Create a SAML IdP for your organization.
		 * Post organizations/{organizationId}/saml/idps
		 * @return {void} 
		 */
		CreateOrganizationSamlIdp(organizationId: string, requestBody: CreateOrganizationSamlIdpPostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/saml/idps', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Remove a SAML IdP in your organization.
		 * Remove a SAML IdP in your organization.
		 * Delete organizations/{organizationId}/saml/idps/{idpId}
		 * @return {void} 
		 */
		DeleteOrganizationSamlIdp(organizationId: string, idpId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/saml/idps/' + (idpId == null ? '' : encodeURIComponent(idpId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Get a SAML IdP from your organization.
		 * Get a SAML IdP from your organization.
		 * Get organizations/{organizationId}/saml/idps/{idpId}
		 * @return {GetOrganizationSamlIdpReturn} Successful operation
		 */
		GetOrganizationSamlIdp(organizationId: string, idpId: string): Observable<GetOrganizationSamlIdpReturn> {
			return this.http.get<GetOrganizationSamlIdpReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/saml/idps/' + (idpId == null ? '' : encodeURIComponent(idpId)), {});
		}

		/**
		 * Update a SAML IdP in your organization
		 * Update a SAML IdP in your organization
		 * Put organizations/{organizationId}/saml/idps/{idpId}
		 * @return {Array<UpdateOrganizationSamlIdpReturn>} Successful operation
		 */
		UpdateOrganizationSamlIdp(organizationId: string, idpId: string, requestBody: UpdateOrganizationSamlIdpPutBody): Observable<Array<UpdateOrganizationSamlIdpReturn>> {
			return this.http.put<Array<UpdateOrganizationSamlIdpReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/saml/idps/' + (idpId == null ? '' : encodeURIComponent(idpId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * List the SAML roles for this organization
		 * List the SAML roles for this organization
		 * Get organizations/{organizationId}/samlRoles
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationSamlRoles(organizationId: string): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/samlRoles', {});
		}

		/**
		 * Create a SAML role
		 * Create a SAML role
		 * Post organizations/{organizationId}/samlRoles
		 * @return {void} 
		 */
		CreateOrganizationSamlRole(organizationId: string, requestBody: CreateOrganizationSamlRolePostBody): Observable<HttpResponse<string>> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/samlRoles', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, observe: 'response', responseType: 'text' });
		}

		/**
		 * Remove a SAML role
		 * Remove a SAML role
		 * Delete organizations/{organizationId}/samlRoles/{samlRoleId}
		 * @return {void} 
		 */
		DeleteOrganizationSamlRole(organizationId: string, samlRoleId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/samlRoles/' + (samlRoleId == null ? '' : encodeURIComponent(samlRoleId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a SAML role
		 * Return a SAML role
		 * Get organizations/{organizationId}/samlRoles/{samlRoleId}
		 * @return {string} Successful operation
		 */
		GetOrganizationSamlRole(organizationId: string, samlRoleId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/samlRoles/' + (samlRoleId == null ? '' : encodeURIComponent(samlRoleId)), { responseType: 'text' });
		}

		/**
		 * Update a SAML role
		 * Update a SAML role
		 * Put organizations/{organizationId}/samlRoles/{samlRoleId}
		 * @return {UpdateOrganizationSamlRoleReturn} Successful operation
		 */
		UpdateOrganizationSamlRole(organizationId: string, samlRoleId: string, requestBody: UpdateOrganizationSamlRolePutBody): Observable<UpdateOrganizationSamlRoleReturn> {
			return this.http.put<UpdateOrganizationSamlRoleReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/samlRoles/' + (samlRoleId == null ? '' : encodeURIComponent(samlRoleId)), JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' } });
		}

		/**
		 * Return all reported readings from sensors in a given timespan, sorted by timestamp
		 * Return all reported readings from sensors in a given timespan, sorted by timestamp
		 * Get organizations/{organizationId}/sensor/readings/history
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 365 days and 6 hours from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 2 hours.
		 * @param {Array<string>} networkIds Optional parameter to filter readings by network.
		 * @param {Array<string>} serials Optional parameter to filter readings by sensor.
		 * @param {Array<string>} metrics Types of sensor readings to retrieve. If no metrics are supplied, all available types of readings will be retrieved. Allowed values are battery, button, door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * @return {Array<GetOrganizationSensorReadingsHistoryReturn>} Successful operation
		 */
		GetOrganizationSensorReadingsHistory(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, networkIds: Array<string> | null | undefined, serials: Array<string> | null | undefined, metrics: Array<string> | null | undefined): Observable<Array<GetOrganizationSensorReadingsHistoryReturn>> {
			return this.http.get<Array<GetOrganizationSensorReadingsHistoryReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/sensor/readings/history&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + metrics?.map(z => `metrics=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * Return the latest available reading for each metric from each sensor, sorted by sensor serial
		 * Return the latest available reading for each metric from each sensor, sorted by sensor serial
		 * Get organizations/{organizationId}/sensor/readings/latest
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 100. Default is 100.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds Optional parameter to filter readings by network.
		 * @param {Array<string>} serials Optional parameter to filter readings by sensor.
		 * @param {Array<string>} metrics Types of sensor readings to retrieve. If no metrics are supplied, all available types of readings will be retrieved. Allowed values are battery, button, door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * @return {Array<GetOrganizationSensorReadingsLatestReturn>} Successful operation
		 */
		GetOrganizationSensorReadingsLatest(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined, serials: Array<string> | null | undefined, metrics: Array<string> | null | undefined): Observable<Array<GetOrganizationSensorReadingsLatestReturn>> {
			return this.http.get<Array<GetOrganizationSensorReadingsLatestReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/sensor/readings/latest&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + metrics?.map(z => `metrics=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * Get the organization's APNS certificate
		 * Get the organization's APNS certificate
		 * Get organizations/{organizationId}/sm/apnsCert
		 * @return {GetOrganizationSmApnsCertReturn} Successful operation
		 */
		GetOrganizationSmApnsCert(organizationId: string): Observable<GetOrganizationSmApnsCertReturn> {
			return this.http.get<GetOrganizationSmApnsCertReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/sm/apnsCert', {});
		}

		/**
		 * List the VPP accounts in the organization
		 * List the VPP accounts in the organization
		 * Get organizations/{organizationId}/sm/vppAccounts
		 * @return {Array<GetOrganizationSmVppAccountsReturn>} Successful operation
		 */
		GetOrganizationSmVppAccounts(organizationId: string): Observable<Array<GetOrganizationSmVppAccountsReturn>> {
			return this.http.get<Array<GetOrganizationSmVppAccountsReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/sm/vppAccounts', {});
		}

		/**
		 * Get a hash containing the unparsed token of the VPP account with the given ID
		 * Get a hash containing the unparsed token of the VPP account with the given ID
		 * Get organizations/{organizationId}/sm/vppAccounts/{vppAccountId}
		 * @return {GetOrganizationSmVppAccountReturn} Successful operation
		 */
		GetOrganizationSmVppAccount(organizationId: string, vppAccountId: string): Observable<GetOrganizationSmVppAccountReturn> {
			return this.http.get<GetOrganizationSmVppAccountReturn>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/sm/vppAccounts/' + (vppAccountId == null ? '' : encodeURIComponent(vppAccountId)), {});
		}

		/**
		 * Return the SNMP settings for an organization
		 * Return the SNMP settings for an organization
		 * Get organizations/{organizationId}/snmp
		 * @return {string} Successful operation
		 */
		GetOrganizationSnmp(organizationId: string): Observable<string> {
			return this.http.get(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/snmp', { responseType: 'text' });
		}

		/**
		 * Update the SNMP settings for an organization
		 * Update the SNMP settings for an organization
		 * Put organizations/{organizationId}/snmp
		 * @return {string} Successful operation
		 */
		UpdateOrganizationSnmp(organizationId: string, requestBody: UpdateOrganizationSnmpPutBody): Observable<string> {
			return this.http.put(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/snmp', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * Return the top 10 appliances sorted by utilization over given time range.
		 * Return the top 10 appliances sorted by utilization over given time range.
		 * Get organizations/{organizationId}/summary/top/appliances/byUtilization
		 * @param {string} t0 The beginning of the timespan for the data.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<GetOrganizationSummaryTopAppliancesByUtilizationReturn>} Successful operation
		 */
		GetOrganizationSummaryTopAppliancesByUtilization(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<Array<GetOrganizationSummaryTopAppliancesByUtilizationReturn>> {
			return this.http.get<Array<GetOrganizationSummaryTopAppliancesByUtilizationReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/summary/top/appliances/byUtilization&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return metrics for organization's top 10 clients by data usage (in mb) over given time range.
		 * Return metrics for organization's top 10 clients by data usage (in mb) over given time range.
		 * Get organizations/{organizationId}/summary/top/clients/byUsage
		 * @param {string} t0 The beginning of the timespan for the data.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<GetOrganizationSummaryTopClientsByUsageReturn>} Successful operation
		 */
		GetOrganizationSummaryTopClientsByUsage(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<Array<GetOrganizationSummaryTopClientsByUsageReturn>> {
			return this.http.get<Array<GetOrganizationSummaryTopClientsByUsageReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/summary/top/clients/byUsage&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return metrics for organization's top clients by data usage (in mb) over given time range, grouped by manufacturer.
		 * Return metrics for organization's top clients by data usage (in mb) over given time range, grouped by manufacturer.
		 * Get organizations/{organizationId}/summary/top/clients/manufacturers/byUsage
		 * @param {string} t0 The beginning of the timespan for the data.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<GetOrganizationSummaryTopClientsManufacturersByUsageReturn>} Successful operation
		 */
		GetOrganizationSummaryTopClientsManufacturersByUsage(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<Array<GetOrganizationSummaryTopClientsManufacturersByUsageReturn>> {
			return this.http.get<Array<GetOrganizationSummaryTopClientsManufacturersByUsageReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/summary/top/clients/manufacturers/byUsage&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return metrics for organization's top 10 devices sorted by data usage over given time range
		 * Return metrics for organization's top 10 devices sorted by data usage over given time range. Default unit is megabytes.
		 * Get organizations/{organizationId}/summary/top/devices/byUsage
		 * @param {string} t0 The beginning of the timespan for the data.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<GetOrganizationSummaryTopDevicesByUsageReturn>} Successful operation
		 */
		GetOrganizationSummaryTopDevicesByUsage(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<Array<GetOrganizationSummaryTopDevicesByUsageReturn>> {
			return this.http.get<Array<GetOrganizationSummaryTopDevicesByUsageReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/summary/top/devices/byUsage&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return metrics for organization's top 10 device models sorted by data usage over given time range
		 * Return metrics for organization's top 10 device models sorted by data usage over given time range. Default unit is megabytes.
		 * Get organizations/{organizationId}/summary/top/devices/models/byUsage
		 * @param {string} t0 The beginning of the timespan for the data.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<GetOrganizationSummaryTopDevicesModelsByUsageReturn>} Successful operation
		 */
		GetOrganizationSummaryTopDevicesModelsByUsage(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<Array<GetOrganizationSummaryTopDevicesModelsByUsageReturn>> {
			return this.http.get<Array<GetOrganizationSummaryTopDevicesModelsByUsageReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/summary/top/devices/models/byUsage&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return metrics for organization's top 10 ssids by data usage over given time range
		 * Return metrics for organization's top 10 ssids by data usage over given time range. Default unit is megabytes.
		 * Get organizations/{organizationId}/summary/top/ssids/byUsage
		 * @param {string} t0 The beginning of the timespan for the data.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<GetOrganizationSummaryTopSsidsByUsageReturn>} Successful operation
		 */
		GetOrganizationSummaryTopSsidsByUsage(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<Array<GetOrganizationSummaryTopSsidsByUsageReturn>> {
			return this.http.get<Array<GetOrganizationSummaryTopSsidsByUsageReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/summary/top/ssids/byUsage&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, {});
		}

		/**
		 * Return metrics for organization's top 10 switches by energy usage over given time range
		 * Return metrics for organization's top 10 switches by energy usage over given time range. Default unit is joules.
		 * Get organizations/{organizationId}/summary/top/switches/byEnergyUsage
		 * @param {string} t0 The beginning of the timespan for the data.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @return {Array<GetOrganizationSummaryTopSwitchesByEnergyUsageReturn>} Successful operation
		 */
		GetOrganizationSummaryTopSwitchesByEnergyUsage(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined): Observable<Array<GetOrganizationSummaryTopSwitchesByEnergyUsageReturn>> {
			return this.http.get<Array<GetOrganizationSummaryTopSwitchesByEnergyUsageReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/summary/top/switches/byEnergyUsage&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan, {});
		}

		/**
		 * Clone port-level and some switch-level configuration settings from a source switch to one or more target switches
		 * Clone port-level and some switch-level configuration settings from a source switch to one or more target switches. Cloned settings include: Aggregation Groups, Power Settings, Multicast Settings, MTU Configuration, STP Bridge priority, Port Mirroring
		 * Post organizations/{organizationId}/switch/devices/clone
		 * @return {string} Successful operation
		 */
		CloneOrganizationSwitchDevices(organizationId: string, requestBody: CloneOrganizationSwitchDevicesPostBody): Observable<string> {
			return this.http.post(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/switch/devices/clone', JSON.stringify(requestBody), { headers: { 'Content-Type': 'application/json;charset=UTF-8' }, responseType: 'text' });
		}

		/**
		 * List the switchports in an organization by switch
		 * List the switchports in an organization by switch
		 * Get organizations/{organizationId}/switch/ports/bySwitch
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 50. Default is 50.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds Optional parameter to filter switchports by network.
		 * @param {Array<string>} portProfileIds Optional parameter to filter switchports belonging to the specified switchport profiles.
		 * @param {string} name Optional parameter to filter switchports belonging to switches by name. All returned switches will have a name that contains the search term or is an exact match.
		 * @param {string} mac Optional parameter to filter switchports belonging to switches by MAC address. All returned switches will have a MAC address that contains the search term or is an exact match.
		 * @param {Array<string>} macs Optional parameter to filter switchports by one or more MAC addresses belonging to devices. All switchports returned belong to MAC addresses of switches that are an exact match.
		 * @param {string} serial Optional parameter to filter switchports belonging to switches by serial number. All returned switches will have a serial number that contains the search term or is an exact match.
		 * @param {Array<string>} serials Optional parameter to filter switchports belonging to switches with one or more serial numbers. All switchports returned belong to serial numbers of switches that are an exact match.
		 * @param {string} configurationUpdatedAfter Optional parameter to filter results by switches where the configuration has been updated after the given timestamp.
		 * @return {Array<GetOrganizationSwitchPortsBySwitchReturn>} Successful operation
		 */
		GetOrganizationSwitchPortsBySwitch(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined, portProfileIds: Array<string> | null | undefined, name: string | null | undefined, mac: string | null | undefined, macs: Array<string> | null | undefined, serial: string | null | undefined, serials: Array<string> | null | undefined, configurationUpdatedAfter: string | null | undefined): Observable<Array<GetOrganizationSwitchPortsBySwitchReturn>> {
			return this.http.get<Array<GetOrganizationSwitchPortsBySwitchReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/switch/ports/bySwitch&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + portProfileIds?.map(z => `portProfileIds=${encodeURIComponent(z)}`).join('&') + '&name=' + (name == null ? '' : encodeURIComponent(name)) + '&mac=' + (mac == null ? '' : encodeURIComponent(mac)) + '&' + macs?.map(z => `macs=${encodeURIComponent(z)}`).join('&') + '&serial=' + (serial == null ? '' : encodeURIComponent(serial)) + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&configurationUpdatedAfter=' + (configurationUpdatedAfter == null ? '' : encodeURIComponent(configurationUpdatedAfter)), {});
		}

		/**
		 * List the uplink status of every Meraki MX, MG and Z series devices in the organization
		 * List the uplink status of every Meraki MX, MG and Z series devices in the organization
		 * Get organizations/{organizationId}/uplinks/statuses
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds A list of network IDs. The returned devices will be filtered to only include these networks.
		 * @param {Array<string>} serials A list of serial numbers. The returned devices will be filtered to only include these serials.
		 * @param {Array<string>} iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs.
		 * @return {Array<GetOrganizationUplinksStatusesReturn>} Successful operation
		 */
		GetOrganizationUplinksStatuses(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined, serials: Array<string> | null | undefined, iccids: Array<string> | null | undefined): Observable<Array<GetOrganizationUplinksStatusesReturn>> {
			return this.http.get<Array<GetOrganizationUplinksStatusesReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/uplinks/statuses&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&') + '&' + serials?.map(z => `serials=${encodeURIComponent(z)}`).join('&') + '&' + iccids?.map(z => `iccids=${encodeURIComponent(z)}`).join('&'), {});
		}

		/**
		 * Delete a user and all of its authentication methods.
		 * Delete a user and all of its authentication methods.
		 * Delete organizations/{organizationId}/users/{userId}
		 * @return {void} 
		 */
		DeleteOrganizationUser(organizationId: string, userId: string): Observable<HttpResponse<string>> {
			return this.http.delete(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/users/' + (userId == null ? '' : encodeURIComponent(userId)), { observe: 'response', responseType: 'text' });
		}

		/**
		 * Return a list of alert types to be used with managing webhook alerts
		 * Return a list of alert types to be used with managing webhook alerts
		 * Get organizations/{organizationId}/webhooks/alertTypes
		 * @param {GetOrganizationWebhooksAlertTypesProductType} productType Filter sample alerts to a specific product type
		 * @return {Array<string>} Successful operation
		 */
		GetOrganizationWebhooksAlertTypes(organizationId: string, productType: GetOrganizationWebhooksAlertTypesProductType | null | undefined): Observable<Array<string>> {
			return this.http.get<Array<string>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/webhooks/alertTypes&productType=' + productType, {});
		}

		/**
		 * Return the log of webhook POSTs sent
		 * Return the log of webhook POSTs sent
		 * Get organizations/{organizationId}/webhooks/logs
		 * @param {string} t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today.
		 * @param {string} t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
		 * @param {number} timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} url The URL the webhook was sent to
		 * @return {Array<GetOrganizationWebhooksLogsReturn>} Successful operation
		 */
		GetOrganizationWebhooksLogs(organizationId: string, t0: string | null | undefined, t1: string | null | undefined, timespan: number | null | undefined, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, url: string | null | undefined): Observable<Array<GetOrganizationWebhooksLogsReturn>> {
			return this.http.get<Array<GetOrganizationWebhooksLogsReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/webhooks/logs&t0=' + (t0 == null ? '' : encodeURIComponent(t0)) + '&t1=' + (t1 == null ? '' : encodeURIComponent(t1)) + '&timespan=' + timespan + '&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&url=' + (url == null ? '' : encodeURIComponent(url)), {});
		}

		/**
		 * Endpoint to see power status for wireless devices
		 * Endpoint to see power status for wireless devices
		 * Get organizations/{organizationId}/wireless/devices/ethernet/statuses
		 * @param {number} perPage The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
		 * @param {string} startingAfter A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {string} endingBefore A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
		 * @param {Array<string>} networkIds A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
		 * @return {Array<GetOrganizationWirelessDevicesEthernetStatusesReturn>} Successful operation
		 */
		GetOrganizationWirelessDevicesEthernetStatuses(organizationId: string, perPage: number | null | undefined, startingAfter: string | null | undefined, endingBefore: string | null | undefined, networkIds: Array<string> | null | undefined): Observable<Array<GetOrganizationWirelessDevicesEthernetStatusesReturn>> {
			return this.http.get<Array<GetOrganizationWirelessDevicesEthernetStatusesReturn>>(this.baseUri + 'organizations/' + (organizationId == null ? '' : encodeURIComponent(organizationId)) + '/wireless/devices/ethernet/statuses&perPage=' + perPage + '&startingAfter=' + (startingAfter == null ? '' : encodeURIComponent(startingAfter)) + '&endingBefore=' + (endingBefore == null ? '' : encodeURIComponent(endingBefore)) + '&' + networkIds?.map(z => `networkIds=${encodeURIComponent(z)}`).join('&'), {});
		}
	}

	export interface GetAdministeredIdentitiesMeReturn {

		/** Authentication info */
		authentication?: GetAdministeredIdentitiesMeReturnAuthentication;

		/** User email */
		email?: string | null;

		/** Last seen active on Dashboard UI */
		lastUsedDashboardAt?: Date | null;

		/** Username */
		name?: string | null;
	}
	export interface GetAdministeredIdentitiesMeReturnFormProperties {

		/** User email */
		email: FormControl<string | null | undefined>,

		/** Last seen active on Dashboard UI */
		lastUsedDashboardAt: FormControl<Date | null | undefined>,

		/** Username */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetAdministeredIdentitiesMeReturnFormGroup() {
		return new FormGroup<GetAdministeredIdentitiesMeReturnFormProperties>({
			email: new FormControl<string | null | undefined>(undefined),
			lastUsedDashboardAt: new FormControl<Date | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetAdministeredIdentitiesMeReturnAuthentication {

		/** API authentication */
		api?: GetAdministeredIdentitiesMeReturnAuthenticationApi;

		/** Authentication mode */
		mode?: string | null;

		/** SAML authentication */
		saml?: GetAdministeredIdentitiesMeReturnAuthenticationSaml;

		/** TwoFactor authentication */
		twoFactor?: GetAdministeredIdentitiesMeReturnAuthenticationTwoFactor;
	}
	export interface GetAdministeredIdentitiesMeReturnAuthenticationFormProperties {

		/** Authentication mode */
		mode: FormControl<string | null | undefined>,
	}
	export function CreateGetAdministeredIdentitiesMeReturnAuthenticationFormGroup() {
		return new FormGroup<GetAdministeredIdentitiesMeReturnAuthenticationFormProperties>({
			mode: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetAdministeredIdentitiesMeReturnAuthenticationApi {

		/** API key */
		key?: GetAdministeredIdentitiesMeReturnAuthenticationApiKey;
	}
	export interface GetAdministeredIdentitiesMeReturnAuthenticationApiFormProperties {
	}
	export function CreateGetAdministeredIdentitiesMeReturnAuthenticationApiFormGroup() {
		return new FormGroup<GetAdministeredIdentitiesMeReturnAuthenticationApiFormProperties>({
		});

	}

	export interface GetAdministeredIdentitiesMeReturnAuthenticationApiKey {

		/** If API key is created for this user */
		created?: boolean | null;
	}
	export interface GetAdministeredIdentitiesMeReturnAuthenticationApiKeyFormProperties {

		/** If API key is created for this user */
		created: FormControl<boolean | null | undefined>,
	}
	export function CreateGetAdministeredIdentitiesMeReturnAuthenticationApiKeyFormGroup() {
		return new FormGroup<GetAdministeredIdentitiesMeReturnAuthenticationApiKeyFormProperties>({
			created: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetAdministeredIdentitiesMeReturnAuthenticationSaml {

		/** If SAML authentication is enabled for this user */
		enabled?: boolean | null;
	}
	export interface GetAdministeredIdentitiesMeReturnAuthenticationSamlFormProperties {

		/** If SAML authentication is enabled for this user */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetAdministeredIdentitiesMeReturnAuthenticationSamlFormGroup() {
		return new FormGroup<GetAdministeredIdentitiesMeReturnAuthenticationSamlFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetAdministeredIdentitiesMeReturnAuthenticationTwoFactor {

		/** If twoFactor authentication is enabled for this user */
		enabled?: boolean | null;
	}
	export interface GetAdministeredIdentitiesMeReturnAuthenticationTwoFactorFormProperties {

		/** If twoFactor authentication is enabled for this user */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetAdministeredIdentitiesMeReturnAuthenticationTwoFactorFormGroup() {
		return new FormGroup<GetAdministeredIdentitiesMeReturnAuthenticationTwoFactorFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDevicePutBody {

		/** The address of a device */
		address?: string | null;

		/** The floor plan to associate to this device. null disassociates the device from the floorplan. */
		floorPlanId?: string | null;

		/** The latitude of a device */
		lat?: number | null;

		/** The longitude of a device */
		lng?: number | null;

		/** Whether or not to set the latitude and longitude of a device based on the new address. Only applies when lat and lng are not specified. */
		moveMapMarker?: boolean | null;

		/** The name of a device */
		name?: string | null;

		/** The notes for the device. String. Limited to 255 characters. */
		notes?: string | null;

		/** The ID of a switch profile to bind to the device (for available switch profiles, see the 'Switch Profiles' endpoint). Use null to unbind the switch device from the current profile. For a device to be bindable to a switch profile, it must (1) be a switch, and (2) belong to a network that is bound to a configuration template. */
		switchProfileId?: string | null;

		/** The list of tags of a device */
		tags?: Array<string>;
	}
	export interface UpdateDevicePutBodyFormProperties {

		/** The address of a device */
		address: FormControl<string | null | undefined>,

		/** The floor plan to associate to this device. null disassociates the device from the floorplan. */
		floorPlanId: FormControl<string | null | undefined>,

		/** The latitude of a device */
		lat: FormControl<number | null | undefined>,

		/** The longitude of a device */
		lng: FormControl<number | null | undefined>,

		/** Whether or not to set the latitude and longitude of a device based on the new address. Only applies when lat and lng are not specified. */
		moveMapMarker: FormControl<boolean | null | undefined>,

		/** The name of a device */
		name: FormControl<string | null | undefined>,

		/** The notes for the device. String. Limited to 255 characters. */
		notes: FormControl<string | null | undefined>,

		/** The ID of a switch profile to bind to the device (for available switch profiles, see the 'Switch Profiles' endpoint). Use null to unbind the switch device from the current profile. For a device to be bindable to a switch profile, it must (1) be a switch, and (2) belong to a network that is bound to a configuration template. */
		switchProfileId: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDevicePutBodyFormGroup() {
		return new FormGroup<UpdateDevicePutBodyFormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			floorPlanId: new FormControl<string | null | undefined>(undefined),
			lat: new FormControl<number | null | undefined>(undefined),
			lng: new FormControl<number | null | undefined>(undefined),
			moveMapMarker: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
			switchProfileId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturn {

		/** Interface settings. */
		interfaces?: GetDeviceApplianceUplinksSettingsReturnInterfaces;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnFormProperties {
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnFormProperties>({
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfaces {

		/** WAN 1 settings. */
		wan1?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1;

		/** WAN 2 settings. */
		wan2?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan2;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesFormProperties {
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesFormProperties>({
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1 {

		/** Enable or disable the interface. */
		enabled?: boolean | null;

		/** Configuration options for PPPoE. */
		pppoe?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1Pppoe;

		/** SVI settings by protocol. */
		svis?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1Svis;

		/** VLAN tagging settings. */
		vlanTagging?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTagging;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1FormProperties {

		/** Enable or disable the interface. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan1FormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1Pppoe {

		/** Settings for PPPoE Authentication. */
		authentication?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthentication;

		/** Whether PPPoE is enabled. */
		enabled?: boolean | null;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeFormProperties {

		/** Whether PPPoE is enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthentication {

		/** Whether PPPoE authentication is enabled. */
		enabled?: boolean | null;

		/** Username for PPPoE authentication. */
		username?: string | null;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthenticationFormProperties {

		/** Whether PPPoE authentication is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** Username for PPPoE authentication. */
		username: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthenticationFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthenticationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1Svis {

		/** IPv4 settings for static/dynamic mode. */
		ipv4?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4;

		/** IPv6 settings for static/dynamic mode. */
		ipv6?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisFormProperties {
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisFormProperties>({
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4 {

		/** IP address and subnet mask when in static mode. */
		address?: string | null;

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Gateway IP address when in static mode. */
		gateway?: string | null;

		/** The nameserver settings for this SVI. */
		nameservers?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4Nameservers;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4FormProperties {

		/** IP address and subnet mask when in static mode. */
		address: FormControl<string | null | undefined>,

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Gateway IP address when in static mode. */
		gateway: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4FormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode { dynamic = 'dynamic', static = 'static' }

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4Nameservers {

		/** Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority. */
		addresses?: Array<string>;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4NameserversFormProperties {
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4NameserversFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4NameserversFormProperties>({
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6 {

		/** Static address that will override the one(s) received by SLAAC. */
		address?: string | null;

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Static gateway that will override the one received by autoconf. */
		gateway?: string | null;

		/** The nameserver settings for this SVI. */
		nameservers?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6Nameservers;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6FormProperties {

		/** Static address that will override the one(s) received by SLAAC. */
		address: FormControl<string | null | undefined>,

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Static gateway that will override the one received by autoconf. */
		gateway: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6FormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6Nameservers {

		/** Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority. */
		addresses?: Array<string>;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6NameserversFormProperties {
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6NameserversFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6NameserversFormProperties>({
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTagging {

		/** Whether VLAN tagging is enabled. */
		enabled?: boolean | null;

		/** The ID of the VLAN to use for VLAN tagging. */
		vlanId?: number | null;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTaggingFormProperties {

		/** Whether VLAN tagging is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** The ID of the VLAN to use for VLAN tagging. */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTaggingFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTaggingFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2 {

		/** Enable or disable the interface. */
		enabled?: boolean | null;

		/** Configuration options for PPPoE. */
		pppoe?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan2Pppoe;

		/** SVI settings by protocol. */
		svis?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan2Svis;

		/** VLAN tagging settings. */
		vlanTagging?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTagging;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2FormProperties {

		/** Enable or disable the interface. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan2FormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan2FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2Pppoe {

		/** Settings for PPPoE Authentication. */
		authentication?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthentication;

		/** Whether PPPoE is enabled. */
		enabled?: boolean | null;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeFormProperties {

		/** Whether PPPoE is enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthentication {

		/** Whether PPPoE authentication is enabled. */
		enabled?: boolean | null;

		/** Username for PPPoE authentication. */
		username?: string | null;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthenticationFormProperties {

		/** Whether PPPoE authentication is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** Username for PPPoE authentication. */
		username: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthenticationFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthenticationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2Svis {

		/** IPv4 settings for static/dynamic mode. */
		ipv4?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4;

		/** IPv6 settings for static/dynamic mode. */
		ipv6?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisFormProperties {
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisFormProperties>({
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4 {

		/** IP address and subnet mask when in static mode. */
		address?: string | null;

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Gateway IP address when in static mode. */
		gateway?: string | null;

		/** The nameserver settings for this SVI. */
		nameservers?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4Nameservers;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4FormProperties {

		/** IP address and subnet mask when in static mode. */
		address: FormControl<string | null | undefined>,

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Gateway IP address when in static mode. */
		gateway: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4FormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4Nameservers {

		/** Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority. */
		addresses?: Array<string>;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4NameserversFormProperties {
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4NameserversFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4NameserversFormProperties>({
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6 {

		/** Static address that will override the one(s) received by SLAAC. */
		address?: string | null;

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Static gateway that will override the one received by autoconf. */
		gateway?: string | null;

		/** The nameserver settings for this SVI. */
		nameservers?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6Nameservers;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6FormProperties {

		/** Static address that will override the one(s) received by SLAAC. */
		address: FormControl<string | null | undefined>,

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Static gateway that will override the one received by autoconf. */
		gateway: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6FormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6Nameservers {

		/** Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority. */
		addresses?: Array<string>;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6NameserversFormProperties {
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6NameserversFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6NameserversFormProperties>({
		});

	}

	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTagging {

		/** Whether VLAN tagging is enabled. */
		enabled?: boolean | null;

		/** The ID of the VLAN to use for VLAN tagging. */
		vlanId?: number | null;
	}
	export interface GetDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTaggingFormProperties {

		/** Whether VLAN tagging is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** The ID of the VLAN to use for VLAN tagging. */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTaggingFormGroup() {
		return new FormGroup<GetDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTaggingFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBody {

		/**
		 * Interface settings.
		 * Required
		 */
		interfaces: UpdateDeviceApplianceUplinksSettingsPutBodyInterfaces;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfaces {

		/** WAN 1 settings. */
		wan1?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1;

		/** WAN 2 settings. */
		wan2?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1 {

		/** Enable or disable the interface. */
		enabled?: boolean | null;

		/** Configuration options for PPPoE. */
		pppoe?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1Pppoe;

		/** SVI settings by protocol. */
		svis?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1Svis;

		/** VLAN tagging settings. */
		vlanTagging?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1VlanTagging;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1FormProperties {

		/** Enable or disable the interface. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1FormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1Pppoe {

		/** Settings for PPPoE Authentication. */
		authentication?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1PppoeAuthentication;

		/** Whether PPPoE is enabled. */
		enabled?: boolean | null;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1PppoeFormProperties {

		/** Whether PPPoE is enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1PppoeFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1PppoeFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1PppoeAuthentication {

		/** Whether PPPoE authentication is enabled. */
		enabled?: boolean | null;

		/** Password for PPPoE authentication. This parameter is not returned. */
		password?: string | null;

		/** Username for PPPoE authentication. */
		username?: string | null;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1PppoeAuthenticationFormProperties {

		/** Whether PPPoE authentication is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** Password for PPPoE authentication. This parameter is not returned. */
		password: FormControl<string | null | undefined>,

		/** Username for PPPoE authentication. */
		username: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1PppoeAuthenticationFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1PppoeAuthenticationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			password: new FormControl<string | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1Svis {

		/** IPv4 settings for static/dynamic mode. */
		ipv4?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4;

		/** IPv6 settings for static/dynamic mode. */
		ipv6?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4 {

		/** IP address and subnet mask when in static mode. */
		address?: string | null;

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Gateway IP address when in static mode. */
		gateway?: string | null;

		/** The nameserver settings for this SVI. */
		nameservers?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4Nameservers;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4FormProperties {

		/** IP address and subnet mask when in static mode. */
		address: FormControl<string | null | undefined>,

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Gateway IP address when in static mode. */
		gateway: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4FormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4Nameservers {

		/** Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority. */
		addresses?: Array<string>;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4NameserversFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4NameserversFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4NameserversFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6 {

		/** Static address that will override the one(s) received by SLAAC. */
		address?: string | null;

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Static gateway that will override the one received by autoconf. */
		gateway?: string | null;

		/** The nameserver settings for this SVI. */
		nameservers?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6Nameservers;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6FormProperties {

		/** Static address that will override the one(s) received by SLAAC. */
		address: FormControl<string | null | undefined>,

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Static gateway that will override the one received by autoconf. */
		gateway: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6FormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6Nameservers {

		/** Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority. */
		addresses?: Array<string>;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6NameserversFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6NameserversFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6NameserversFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1VlanTagging {

		/** Whether VLAN tagging is enabled. */
		enabled?: boolean | null;

		/** The ID of the VLAN to use for VLAN tagging. */
		vlanId?: number | null;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1VlanTaggingFormProperties {

		/** Whether VLAN tagging is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** The ID of the VLAN to use for VLAN tagging. */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1VlanTaggingFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1VlanTaggingFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2 {

		/** Enable or disable the interface. */
		enabled?: boolean | null;

		/** Configuration options for PPPoE. */
		pppoe?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2Pppoe;

		/** SVI settings by protocol. */
		svis?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2Svis;

		/** VLAN tagging settings. */
		vlanTagging?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2VlanTagging;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2FormProperties {

		/** Enable or disable the interface. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2FormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2Pppoe {

		/** Settings for PPPoE Authentication. */
		authentication?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2PppoeAuthentication;

		/** Whether PPPoE is enabled. */
		enabled?: boolean | null;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2PppoeFormProperties {

		/** Whether PPPoE is enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2PppoeFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2PppoeFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2PppoeAuthentication {

		/** Whether PPPoE authentication is enabled. */
		enabled?: boolean | null;

		/** Password for PPPoE authentication. This parameter is not returned. */
		password?: string | null;

		/** Username for PPPoE authentication. */
		username?: string | null;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2PppoeAuthenticationFormProperties {

		/** Whether PPPoE authentication is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** Password for PPPoE authentication. This parameter is not returned. */
		password: FormControl<string | null | undefined>,

		/** Username for PPPoE authentication. */
		username: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2PppoeAuthenticationFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2PppoeAuthenticationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			password: new FormControl<string | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2Svis {

		/** IPv4 settings for static/dynamic mode. */
		ipv4?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4;

		/** IPv6 settings for static/dynamic mode. */
		ipv6?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4 {

		/** IP address and subnet mask when in static mode. */
		address?: string | null;

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Gateway IP address when in static mode. */
		gateway?: string | null;

		/** The nameserver settings for this SVI. */
		nameservers?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4Nameservers;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4FormProperties {

		/** IP address and subnet mask when in static mode. */
		address: FormControl<string | null | undefined>,

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Gateway IP address when in static mode. */
		gateway: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4FormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4Nameservers {

		/** Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority. */
		addresses?: Array<string>;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4NameserversFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4NameserversFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4NameserversFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6 {

		/** Static address that will override the one(s) received by SLAAC. */
		address?: string | null;

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Static gateway that will override the one received by autoconf. */
		gateway?: string | null;

		/** The nameserver settings for this SVI. */
		nameservers?: UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6Nameservers;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6FormProperties {

		/** Static address that will override the one(s) received by SLAAC. */
		address: FormControl<string | null | undefined>,

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Static gateway that will override the one received by autoconf. */
		gateway: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6FormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6Nameservers {

		/** Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority. */
		addresses?: Array<string>;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6NameserversFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6NameserversFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6NameserversFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2VlanTagging {

		/** Whether VLAN tagging is enabled. */
		enabled?: boolean | null;

		/** The ID of the VLAN to use for VLAN tagging. */
		vlanId?: number | null;
	}
	export interface UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2VlanTaggingFormProperties {

		/** Whether VLAN tagging is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** The ID of the VLAN to use for VLAN tagging. */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2VlanTaggingFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2VlanTaggingFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturn {

		/** Interface settings. */
		interfaces?: UpdateDeviceApplianceUplinksSettingsReturnInterfaces;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfaces {

		/** WAN 1 settings. */
		wan1?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1;

		/** WAN 2 settings. */
		wan2?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1 {

		/** Enable or disable the interface. */
		enabled?: boolean | null;

		/** Configuration options for PPPoE. */
		pppoe?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1Pppoe;

		/** SVI settings by protocol. */
		svis?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1Svis;

		/** VLAN tagging settings. */
		vlanTagging?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTagging;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1FormProperties {

		/** Enable or disable the interface. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1FormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1Pppoe {

		/** Settings for PPPoE Authentication. */
		authentication?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthentication;

		/** Whether PPPoE is enabled. */
		enabled?: boolean | null;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeFormProperties {

		/** Whether PPPoE is enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthentication {

		/** Whether PPPoE authentication is enabled. */
		enabled?: boolean | null;

		/** Username for PPPoE authentication. */
		username?: string | null;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthenticationFormProperties {

		/** Whether PPPoE authentication is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** Username for PPPoE authentication. */
		username: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthenticationFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthenticationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1Svis {

		/** IPv4 settings for static/dynamic mode. */
		ipv4?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4;

		/** IPv6 settings for static/dynamic mode. */
		ipv6?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4 {

		/** IP address and subnet mask when in static mode. */
		address?: string | null;

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Gateway IP address when in static mode. */
		gateway?: string | null;

		/** The nameserver settings for this SVI. */
		nameservers?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4Nameservers;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4FormProperties {

		/** IP address and subnet mask when in static mode. */
		address: FormControl<string | null | undefined>,

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Gateway IP address when in static mode. */
		gateway: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4FormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4Nameservers {

		/** Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority. */
		addresses?: Array<string>;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4NameserversFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4NameserversFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4NameserversFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6 {

		/** Static address that will override the one(s) received by SLAAC. */
		address?: string | null;

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Static gateway that will override the one received by autoconf. */
		gateway?: string | null;

		/** The nameserver settings for this SVI. */
		nameservers?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6Nameservers;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6FormProperties {

		/** Static address that will override the one(s) received by SLAAC. */
		address: FormControl<string | null | undefined>,

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Static gateway that will override the one received by autoconf. */
		gateway: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6FormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6Nameservers {

		/** Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority. */
		addresses?: Array<string>;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6NameserversFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6NameserversFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6NameserversFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTagging {

		/** Whether VLAN tagging is enabled. */
		enabled?: boolean | null;

		/** The ID of the VLAN to use for VLAN tagging. */
		vlanId?: number | null;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTaggingFormProperties {

		/** Whether VLAN tagging is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** The ID of the VLAN to use for VLAN tagging. */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTaggingFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTaggingFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2 {

		/** Enable or disable the interface. */
		enabled?: boolean | null;

		/** Configuration options for PPPoE. */
		pppoe?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2Pppoe;

		/** SVI settings by protocol. */
		svis?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2Svis;

		/** VLAN tagging settings. */
		vlanTagging?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTagging;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2FormProperties {

		/** Enable or disable the interface. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2FormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2Pppoe {

		/** Settings for PPPoE Authentication. */
		authentication?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthentication;

		/** Whether PPPoE is enabled. */
		enabled?: boolean | null;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeFormProperties {

		/** Whether PPPoE is enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthentication {

		/** Whether PPPoE authentication is enabled. */
		enabled?: boolean | null;

		/** Username for PPPoE authentication. */
		username?: string | null;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthenticationFormProperties {

		/** Whether PPPoE authentication is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** Username for PPPoE authentication. */
		username: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthenticationFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthenticationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2Svis {

		/** IPv4 settings for static/dynamic mode. */
		ipv4?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4;

		/** IPv6 settings for static/dynamic mode. */
		ipv6?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4 {

		/** IP address and subnet mask when in static mode. */
		address?: string | null;

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Gateway IP address when in static mode. */
		gateway?: string | null;

		/** The nameserver settings for this SVI. */
		nameservers?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4Nameservers;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4FormProperties {

		/** IP address and subnet mask when in static mode. */
		address: FormControl<string | null | undefined>,

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Gateway IP address when in static mode. */
		gateway: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4FormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4Nameservers {

		/** Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority. */
		addresses?: Array<string>;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4NameserversFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4NameserversFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4NameserversFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6 {

		/** Static address that will override the one(s) received by SLAAC. */
		address?: string | null;

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Static gateway that will override the one received by autoconf. */
		gateway?: string | null;

		/** The nameserver settings for this SVI. */
		nameservers?: UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6Nameservers;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6FormProperties {

		/** Static address that will override the one(s) received by SLAAC. */
		address: FormControl<string | null | undefined>,

		/** The assignment mode for this SVI. Applies only when PPPoE is disabled. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Static gateway that will override the one received by autoconf. */
		gateway: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6FormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6Nameservers {

		/** Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority. */
		addresses?: Array<string>;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6NameserversFormProperties {
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6NameserversFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6NameserversFormProperties>({
		});

	}

	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTagging {

		/** Whether VLAN tagging is enabled. */
		enabled?: boolean | null;

		/** The ID of the VLAN to use for VLAN tagging. */
		vlanId?: number | null;
	}
	export interface UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTaggingFormProperties {

		/** Whether VLAN tagging is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** The ID of the VLAN to use for VLAN tagging. */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTaggingFormGroup() {
		return new FormGroup<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTaggingFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface BlinkDeviceLedsPostBody {

		/** The duration in seconds. Must be between 5 and 120. Default is 20 seconds */
		duration?: number | null;

		/** The duty cycle as the percent active. Must be between 10 and 90. Default is 50. */
		duty?: number | null;

		/** The period in milliseconds. Must be between 100 and 1000. Default is 160 milliseconds */
		period?: number | null;
	}
	export interface BlinkDeviceLedsPostBodyFormProperties {

		/** The duration in seconds. Must be between 5 and 120. Default is 20 seconds */
		duration: FormControl<number | null | undefined>,

		/** The duty cycle as the percent active. Must be between 10 and 90. Default is 50. */
		duty: FormControl<number | null | undefined>,

		/** The period in milliseconds. Must be between 100 and 1000. Default is 160 milliseconds */
		period: FormControl<number | null | undefined>,
	}
	export function CreateBlinkDeviceLedsPostBodyFormGroup() {
		return new FormGroup<BlinkDeviceLedsPostBodyFormProperties>({
			duration: new FormControl<number | null | undefined>(undefined),
			duty: new FormControl<number | null | undefined>(undefined),
			period: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum GetDeviceCameraAnalyticsOverviewObjectType { person = 'person', vehicle = 'vehicle' }

	export interface UpdateDeviceCameraCustomAnalyticsPutBody {

		/** The ID of the custom analytics artifact */
		artifactId?: string | null;

		/** Enable custom analytics */
		enabled?: boolean | null;

		/** Parameters for the custom analytics workload */
		UpdateDeviceCameraCustomAnalyticsPutBodyParameters?: Array<UpdateDeviceCameraCustomAnalyticsPutBodyParameters>;
	}
	export interface UpdateDeviceCameraCustomAnalyticsPutBodyFormProperties {

		/** The ID of the custom analytics artifact */
		artifactId: FormControl<string | null | undefined>,

		/** Enable custom analytics */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceCameraCustomAnalyticsPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceCameraCustomAnalyticsPutBodyFormProperties>({
			artifactId: new FormControl<string | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceCameraCustomAnalyticsPutBodyParameters {

		/**
		 * Name of the parameter
		 * Required
		 */
		name: string;

		/**
		 * Value of the parameter
		 * Required
		 */
		value: string;
	}
	export interface UpdateDeviceCameraCustomAnalyticsPutBodyParametersFormProperties {

		/**
		 * Name of the parameter
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/**
		 * Value of the parameter
		 * Required
		 */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceCameraCustomAnalyticsPutBodyParametersFormGroup() {
		return new FormGroup<UpdateDeviceCameraCustomAnalyticsPutBodyParametersFormProperties>({
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			value: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GenerateDeviceCameraSnapshotPostBody {

		/** [optional] If set to "true" the snapshot will be taken at full sensor resolution. This will error if used with timestamp. */
		fullframe?: boolean | null;

		/** [optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time. */
		timestamp?: Date | null;
	}
	export interface GenerateDeviceCameraSnapshotPostBodyFormProperties {

		/** [optional] If set to "true" the snapshot will be taken at full sensor resolution. This will error if used with timestamp. */
		fullframe: FormControl<boolean | null | undefined>,

		/** [optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time. */
		timestamp: FormControl<Date | null | undefined>,
	}
	export function CreateGenerateDeviceCameraSnapshotPostBodyFormGroup() {
		return new FormGroup<GenerateDeviceCameraSnapshotPostBodyFormProperties>({
			fullframe: new FormControl<boolean | null | undefined>(undefined),
			timestamp: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceCameraQualityAndRetentionPutBody {

		/** Boolean indicating if audio recording is enabled(true) or disabled(false) on the camera */
		audioRecordingEnabled?: boolean | null;

		/** Boolean indicating if motion-based retention is enabled(true) or disabled(false) on the camera. */
		motionBasedRetentionEnabled?: boolean | null;

		/** The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2. */
		motionDetectorVersion?: UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion;

		/** The ID of a quality and retention profile to assign to the camera. The profile's settings will override all of the per-camera quality and retention settings. If the value of this parameter is null, any existing profile will be unassigned from the camera. */
		profileId?: string | null;

		/** Quality of the camera. Can be one of 'Standard', 'High' or 'Enhanced'. Not all qualities are supported by every camera model. */
		quality?: UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null;

		/** Resolution of the camera. Can be one of '1280x720', '1920x1080', '1080x1080', '2058x2058', '2112x2112', '2880x2880', '2688x1512' or '3840x2160'.Not all resolutions are supported by every camera model. */
		resolution?: UpdateDeviceCameraQualityAndRetentionPutBodyResolution | null;

		/** Boolean indicating if restricted bandwidth is enabled(true) or disabled(false) on the camera. This setting does not apply to MV2 cameras. */
		restrictedBandwidthModeEnabled?: boolean | null;
	}
	export interface UpdateDeviceCameraQualityAndRetentionPutBodyFormProperties {

		/** Boolean indicating if audio recording is enabled(true) or disabled(false) on the camera */
		audioRecordingEnabled: FormControl<boolean | null | undefined>,

		/** Boolean indicating if motion-based retention is enabled(true) or disabled(false) on the camera. */
		motionBasedRetentionEnabled: FormControl<boolean | null | undefined>,

		/** The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2. */
		motionDetectorVersion: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion | null | undefined>,

		/** The ID of a quality and retention profile to assign to the camera. The profile's settings will override all of the per-camera quality and retention settings. If the value of this parameter is null, any existing profile will be unassigned from the camera. */
		profileId: FormControl<string | null | undefined>,

		/** Quality of the camera. Can be one of 'Standard', 'High' or 'Enhanced'. Not all qualities are supported by every camera model. */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/** Resolution of the camera. Can be one of '1280x720', '1920x1080', '1080x1080', '2058x2058', '2112x2112', '2880x2880', '2688x1512' or '3840x2160'.Not all resolutions are supported by every camera model. */
		resolution: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyResolution | null | undefined>,

		/** Boolean indicating if restricted bandwidth is enabled(true) or disabled(false) on the camera. This setting does not apply to MV2 cameras. */
		restrictedBandwidthModeEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceCameraQualityAndRetentionPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceCameraQualityAndRetentionPutBodyFormProperties>({
			audioRecordingEnabled: new FormControl<boolean | null | undefined>(undefined),
			motionBasedRetentionEnabled: new FormControl<boolean | null | undefined>(undefined),
			motionDetectorVersion: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion | null | undefined>(undefined),
			profileId: new FormControl<string | null | undefined>(undefined),
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined),
			resolution: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyResolution | null | undefined>(undefined),
			restrictedBandwidthModeEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion { _1 = 0, _2 = 1 }

	export enum UpdateDeviceCameraQualityAndRetentionPutBodyQuality { Enhanced = 'Enhanced', High = 'High', Standard = 'Standard' }

	export enum UpdateDeviceCameraQualityAndRetentionPutBodyResolution { '1080x1080' = '1080x1080', '1280x720' = '1280x720', '1920x1080' = '1920x1080', '2058x2058' = '2058x2058', '2112x2112' = '2112x2112', '2688x1512' = '2688x1512', '2880x2880' = '2880x2880', '3840x2160' = '3840x2160' }

	export interface UpdateDeviceCameraSensePutBody {

		/** The details of the audio detection config. */
		audioDetection?: UpdateDeviceCameraSensePutBodyAudioDetection;

		/** The ID of the object detection model */
		detectionModelId?: string | null;

		/** The ID of the MQTT broker to be enabled on the camera. A value of null will disable MQTT on the camera */
		mqttBrokerId?: string | null;

		/** Boolean indicating if sense(license) is enabled(true) or disabled(false) on the camera */
		senseEnabled?: boolean | null;
	}
	export interface UpdateDeviceCameraSensePutBodyFormProperties {

		/** The ID of the object detection model */
		detectionModelId: FormControl<string | null | undefined>,

		/** The ID of the MQTT broker to be enabled on the camera. A value of null will disable MQTT on the camera */
		mqttBrokerId: FormControl<string | null | undefined>,

		/** Boolean indicating if sense(license) is enabled(true) or disabled(false) on the camera */
		senseEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceCameraSensePutBodyFormGroup() {
		return new FormGroup<UpdateDeviceCameraSensePutBodyFormProperties>({
			detectionModelId: new FormControl<string | null | undefined>(undefined),
			mqttBrokerId: new FormControl<string | null | undefined>(undefined),
			senseEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceCameraSensePutBodyAudioDetection {

		/** Boolean indicating if audio detection is enabled(true) or disabled(false) on the camera */
		enabled?: boolean | null;
	}
	export interface UpdateDeviceCameraSensePutBodyAudioDetectionFormProperties {

		/** Boolean indicating if audio detection is enabled(true) or disabled(false) on the camera */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceCameraSensePutBodyAudioDetectionFormGroup() {
		return new FormGroup<UpdateDeviceCameraSensePutBodyAudioDetectionFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceCameraVideoSettingsPutBody {

		/** Boolean indicating if external rtsp stream is exposed */
		externalRtspEnabled?: boolean | null;
	}
	export interface UpdateDeviceCameraVideoSettingsPutBodyFormProperties {

		/** Boolean indicating if external rtsp stream is exposed */
		externalRtspEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceCameraVideoSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceCameraVideoSettingsPutBodyFormProperties>({
			externalRtspEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceCameraWirelessProfilesPutBody {

		/**
		 * The ids of the wireless profile to assign to the given camera
		 * Required
		 */
		ids: UpdateDeviceCameraWirelessProfilesPutBodyIds;
	}
	export interface UpdateDeviceCameraWirelessProfilesPutBodyFormProperties {
	}
	export function CreateUpdateDeviceCameraWirelessProfilesPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceCameraWirelessProfilesPutBodyFormProperties>({
		});

	}

	export interface UpdateDeviceCameraWirelessProfilesPutBodyIds {

		/** The id of the backup wireless profile */
		backup?: string | null;

		/** The id of the primary wireless profile */
		primary?: string | null;

		/** The id of the secondary wireless profile */
		secondary?: string | null;
	}
	export interface UpdateDeviceCameraWirelessProfilesPutBodyIdsFormProperties {

		/** The id of the backup wireless profile */
		backup: FormControl<string | null | undefined>,

		/** The id of the primary wireless profile */
		primary: FormControl<string | null | undefined>,

		/** The id of the secondary wireless profile */
		secondary: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceCameraWirelessProfilesPutBodyIdsFormGroup() {
		return new FormGroup<UpdateDeviceCameraWirelessProfilesPutBodyIdsFormProperties>({
			backup: new FormControl<string | null | undefined>(undefined),
			primary: new FormControl<string | null | undefined>(undefined),
			secondary: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceCellularSimsPutBody {

		/** SIM Failover settings. */
		simFailover?: UpdateDeviceCellularSimsPutBodySimFailover;

		/** List of SIMs. If a SIM was previously configured and not specified in this request, it will remain unchanged. */
		UpdateDeviceCellularSimsPutBodySims?: Array<UpdateDeviceCellularSimsPutBodySims>;
	}
	export interface UpdateDeviceCellularSimsPutBodyFormProperties {
	}
	export function CreateUpdateDeviceCellularSimsPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceCellularSimsPutBodyFormProperties>({
		});

	}

	export interface UpdateDeviceCellularSimsPutBodySimFailover {

		/** Failover to secondary SIM (optional) */
		enabled?: boolean | null;
	}
	export interface UpdateDeviceCellularSimsPutBodySimFailoverFormProperties {

		/** Failover to secondary SIM (optional) */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceCellularSimsPutBodySimFailoverFormGroup() {
		return new FormGroup<UpdateDeviceCellularSimsPutBodySimFailoverFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceCellularSimsPutBodySims {

		/** APN configurations. If empty, the default APN will be used. */
		UpdateDeviceCellularSimsPutBodySimsApns?: Array<UpdateDeviceCellularSimsPutBodySimsApns>;

		/** If true, this SIM is used for boot. Must be true on single-sim devices. */
		isPrimary?: boolean | null;

		/** SIM slot being configured. Must be 'sim1' on single-sim devices. */
		slot?: UpdateDeviceCellularSimsPutBodySimsSlot | null;
	}
	export interface UpdateDeviceCellularSimsPutBodySimsFormProperties {

		/** If true, this SIM is used for boot. Must be true on single-sim devices. */
		isPrimary: FormControl<boolean | null | undefined>,

		/** SIM slot being configured. Must be 'sim1' on single-sim devices. */
		slot: FormControl<UpdateDeviceCellularSimsPutBodySimsSlot | null | undefined>,
	}
	export function CreateUpdateDeviceCellularSimsPutBodySimsFormGroup() {
		return new FormGroup<UpdateDeviceCellularSimsPutBodySimsFormProperties>({
			isPrimary: new FormControl<boolean | null | undefined>(undefined),
			slot: new FormControl<UpdateDeviceCellularSimsPutBodySimsSlot | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceCellularSimsPutBodySimsApns {

		/**
		 * IP versions to support (permitted values include 'ipv4', 'ipv6').
		 * Required
		 */
		allowedIpTypes: Array<string>;

		/** APN authentication configurations. */
		authentication?: UpdateDeviceCellularSimsPutBodySimsApnsAuthentication;

		/**
		 * APN name.
		 * Required
		 */
		name: string;
	}
	export interface UpdateDeviceCellularSimsPutBodySimsApnsFormProperties {

		/**
		 * APN name.
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceCellularSimsPutBodySimsApnsFormGroup() {
		return new FormGroup<UpdateDeviceCellularSimsPutBodySimsApnsFormProperties>({
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateDeviceCellularSimsPutBodySimsApnsAuthentication {

		/** APN password, if type is set (if APN password is not supplied, the password is left unchanged). */
		password?: string | null;

		/** APN auth type. */
		type?: UpdateDeviceCellularSimsPutBodySimsApnsAuthenticationType | null;

		/** APN username, if type is set. */
		username?: string | null;
	}
	export interface UpdateDeviceCellularSimsPutBodySimsApnsAuthenticationFormProperties {

		/** APN password, if type is set (if APN password is not supplied, the password is left unchanged). */
		password: FormControl<string | null | undefined>,

		/** APN auth type. */
		type: FormControl<UpdateDeviceCellularSimsPutBodySimsApnsAuthenticationType | null | undefined>,

		/** APN username, if type is set. */
		username: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceCellularSimsPutBodySimsApnsAuthenticationFormGroup() {
		return new FormGroup<UpdateDeviceCellularSimsPutBodySimsApnsAuthenticationFormProperties>({
			password: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<UpdateDeviceCellularSimsPutBodySimsApnsAuthenticationType | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum UpdateDeviceCellularSimsPutBodySimsApnsAuthenticationType { chap = 'chap', none = 'none', pap = 'pap' }

	export enum UpdateDeviceCellularSimsPutBodySimsSlot { sim1 = 'sim1', sim2 = 'sim2' }

	export interface UpdateDeviceCellularGatewayLanPutBody {

		/** list of all fixed IP assignments for a single MG */
		UpdateDeviceCellularGatewayLanPutBodyFixedIpAssignments?: Array<UpdateDeviceCellularGatewayLanPutBodyFixedIpAssignments>;

		/** list of all reserved IP ranges for a single MG */
		UpdateDeviceCellularGatewayLanPutBodyReservedIpRanges?: Array<UpdateDeviceCellularGatewayLanPutBodyReservedIpRanges>;
	}
	export interface UpdateDeviceCellularGatewayLanPutBodyFormProperties {
	}
	export function CreateUpdateDeviceCellularGatewayLanPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceCellularGatewayLanPutBodyFormProperties>({
		});

	}

	export interface UpdateDeviceCellularGatewayLanPutBodyFixedIpAssignments {

		/**
		 * The IP address you want to assign to a specific server or device
		 * Required
		 */
		ip: string;

		/**
		 * The MAC address of the server or device that hosts the internal resource that you wish to receive the specified IP address
		 * Required
		 */
		mac: string;

		/** A descriptive name of the assignment */
		name?: string | null;
	}
	export interface UpdateDeviceCellularGatewayLanPutBodyFixedIpAssignmentsFormProperties {

		/**
		 * The IP address you want to assign to a specific server or device
		 * Required
		 */
		ip: FormControl<string | null | undefined>,

		/**
		 * The MAC address of the server or device that hosts the internal resource that you wish to receive the specified IP address
		 * Required
		 */
		mac: FormControl<string | null | undefined>,

		/** A descriptive name of the assignment */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceCellularGatewayLanPutBodyFixedIpAssignmentsFormGroup() {
		return new FormGroup<UpdateDeviceCellularGatewayLanPutBodyFixedIpAssignmentsFormProperties>({
			ip: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			mac: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceCellularGatewayLanPutBodyReservedIpRanges {

		/**
		 * Comment explaining the reserved IP range
		 * Required
		 */
		comment: string;

		/**
		 * Ending IP included in the reserved range of IPs
		 * Required
		 */
		end: string;

		/**
		 * Starting IP included in the reserved range of IPs
		 * Required
		 */
		start: string;
	}
	export interface UpdateDeviceCellularGatewayLanPutBodyReservedIpRangesFormProperties {

		/**
		 * Comment explaining the reserved IP range
		 * Required
		 */
		comment: FormControl<string | null | undefined>,

		/**
		 * Ending IP included in the reserved range of IPs
		 * Required
		 */
		end: FormControl<string | null | undefined>,

		/**
		 * Starting IP included in the reserved range of IPs
		 * Required
		 */
		start: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceCellularGatewayLanPutBodyReservedIpRangesFormGroup() {
		return new FormGroup<UpdateDeviceCellularGatewayLanPutBodyReservedIpRangesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			end: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			start: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateDeviceCellularGatewayPortForwardingRulesPutBody {

		/** An array of port forwarding params */
		UpdateDeviceCellularGatewayPortForwardingRulesPutBodyRules?: Array<UpdateDeviceCellularGatewayPortForwardingRulesPutBodyRules>;
	}
	export interface UpdateDeviceCellularGatewayPortForwardingRulesPutBodyFormProperties {
	}
	export function CreateUpdateDeviceCellularGatewayPortForwardingRulesPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceCellularGatewayPortForwardingRulesPutBodyFormProperties>({
		});

	}

	export interface UpdateDeviceCellularGatewayPortForwardingRulesPutBodyRules {

		/**
		 * `any` or `restricted`. Specify the right to make inbound connections on the specified ports or port ranges. If `restricted`, a list of allowed IPs is mandatory.
		 * Required
		 */
		access: string;

		/** An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges. */
		allowedIps?: Array<string>;

		/**
		 * The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
		 * Required
		 */
		lanIp: string;

		/**
		 * A port or port ranges that will receive the forwarded traffic from the WAN
		 * Required
		 */
		localPort: string;

		/** A descriptive name for the rule */
		name?: string | null;

		/**
		 * TCP or UDP
		 * Required
		 */
		protocol: string;

		/**
		 * A port or port ranges that will be forwarded to the host on the LAN
		 * Required
		 */
		publicPort: string;
	}
	export interface UpdateDeviceCellularGatewayPortForwardingRulesPutBodyRulesFormProperties {

		/**
		 * `any` or `restricted`. Specify the right to make inbound connections on the specified ports or port ranges. If `restricted`, a list of allowed IPs is mandatory.
		 * Required
		 */
		access: FormControl<string | null | undefined>,

		/**
		 * The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
		 * Required
		 */
		lanIp: FormControl<string | null | undefined>,

		/**
		 * A port or port ranges that will receive the forwarded traffic from the WAN
		 * Required
		 */
		localPort: FormControl<string | null | undefined>,

		/** A descriptive name for the rule */
		name: FormControl<string | null | undefined>,

		/**
		 * TCP or UDP
		 * Required
		 */
		protocol: FormControl<string | null | undefined>,

		/**
		 * A port or port ranges that will be forwarded to the host on the LAN
		 * Required
		 */
		publicPort: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceCellularGatewayPortForwardingRulesPutBodyRulesFormGroup() {
		return new FormGroup<UpdateDeviceCellularGatewayPortForwardingRulesPutBodyRulesFormProperties>({
			access: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			lanIp: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			localPort: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined),
			protocol: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			publicPort: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateDeviceLiveToolsPingPostBody {

		/** Count parameter to pass to ping. [1..5], default 5 */
		count?: number | null;

		/**
		 * FQDN, IPv4 or IPv6 address
		 * Required
		 */
		target: string;
	}
	export interface CreateDeviceLiveToolsPingPostBodyFormProperties {

		/** Count parameter to pass to ping. [1..5], default 5 */
		count: FormControl<number | null | undefined>,

		/**
		 * FQDN, IPv4 or IPv6 address
		 * Required
		 */
		target: FormControl<string | null | undefined>,
	}
	export function CreateCreateDeviceLiveToolsPingPostBodyFormGroup() {
		return new FormGroup<CreateDeviceLiveToolsPingPostBodyFormProperties>({
			count: new FormControl<number | null | undefined>(undefined),
			target: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetDeviceLiveToolsPingReturn {

		/** Id to check the status of your ping request. */
		pingId?: string | null;

		/** Ping request parameters */
		request?: GetDeviceLiveToolsPingReturnRequest;

		/** Results of the ping request. */
		results?: GetDeviceLiveToolsPingReturnResults;

		/** Status of the ping request. */
		status?: string | null;

		/** GET this url to check the status of your ping request. */
		url?: string | null;
	}
	export interface GetDeviceLiveToolsPingReturnFormProperties {

		/** Id to check the status of your ping request. */
		pingId: FormControl<string | null | undefined>,

		/** Status of the ping request. */
		status: FormControl<string | null | undefined>,

		/** GET this url to check the status of your ping request. */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceLiveToolsPingReturnFormGroup() {
		return new FormGroup<GetDeviceLiveToolsPingReturnFormProperties>({
			pingId: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceLiveToolsPingReturnRequest {

		/** Number of pings to send */
		count?: number | null;

		/** Device serial number */
		serial?: string | null;

		/** IP address or FQDN to ping */
		target?: string | null;
	}
	export interface GetDeviceLiveToolsPingReturnRequestFormProperties {

		/** Number of pings to send */
		count: FormControl<number | null | undefined>,

		/** Device serial number */
		serial: FormControl<string | null | undefined>,

		/** IP address or FQDN to ping */
		target: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceLiveToolsPingReturnRequestFormGroup() {
		return new FormGroup<GetDeviceLiveToolsPingReturnRequestFormProperties>({
			count: new FormControl<number | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			target: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceLiveToolsPingReturnResults {

		/** Packet latency stats */
		latencies?: GetDeviceLiveToolsPingReturnResultsLatencies;

		/** Lost packets */
		loss?: GetDeviceLiveToolsPingReturnResultsLoss;

		/** Number of packets received */
		received?: number | null;

		/** Received packets */
		GetDeviceLiveToolsPingReturnResultsReplies?: Array<GetDeviceLiveToolsPingReturnResultsReplies>;

		/** Number of packets sent */
		sent?: number | null;
	}
	export interface GetDeviceLiveToolsPingReturnResultsFormProperties {

		/** Number of packets received */
		received: FormControl<number | null | undefined>,

		/** Number of packets sent */
		sent: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceLiveToolsPingReturnResultsFormGroup() {
		return new FormGroup<GetDeviceLiveToolsPingReturnResultsFormProperties>({
			received: new FormControl<number | null | undefined>(undefined),
			sent: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceLiveToolsPingReturnResultsLatencies {

		/** Average latency */
		average?: number | null;

		/** Maximum latency */
		maximum?: number | null;

		/** Minimum latency */
		minimum?: number | null;
	}
	export interface GetDeviceLiveToolsPingReturnResultsLatenciesFormProperties {

		/** Average latency */
		average: FormControl<number | null | undefined>,

		/** Maximum latency */
		maximum: FormControl<number | null | undefined>,

		/** Minimum latency */
		minimum: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceLiveToolsPingReturnResultsLatenciesFormGroup() {
		return new FormGroup<GetDeviceLiveToolsPingReturnResultsLatenciesFormProperties>({
			average: new FormControl<number | null | undefined>(undefined),
			maximum: new FormControl<number | null | undefined>(undefined),
			minimum: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceLiveToolsPingReturnResultsLoss {

		/** Percentage of packets lost */
		percentage?: number | null;
	}
	export interface GetDeviceLiveToolsPingReturnResultsLossFormProperties {

		/** Percentage of packets lost */
		percentage: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceLiveToolsPingReturnResultsLossFormGroup() {
		return new FormGroup<GetDeviceLiveToolsPingReturnResultsLossFormProperties>({
			percentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceLiveToolsPingReturnResultsReplies {

		/** Latency of the packet in milliseconds */
		latency?: number | null;

		/** Sequence ID of the packet */
		sequenceId?: number | null;

		/** Size of the packet in bytes */
		size?: number | null;
	}
	export interface GetDeviceLiveToolsPingReturnResultsRepliesFormProperties {

		/** Latency of the packet in milliseconds */
		latency: FormControl<number | null | undefined>,

		/** Sequence ID of the packet */
		sequenceId: FormControl<number | null | undefined>,

		/** Size of the packet in bytes */
		size: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceLiveToolsPingReturnResultsRepliesFormGroup() {
		return new FormGroup<GetDeviceLiveToolsPingReturnResultsRepliesFormProperties>({
			latency: new FormControl<number | null | undefined>(undefined),
			sequenceId: new FormControl<number | null | undefined>(undefined),
			size: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateDeviceLiveToolsPingDevicePostBody {

		/** Count parameter to pass to ping. [1..5], default 5 */
		count?: number | null;
	}
	export interface CreateDeviceLiveToolsPingDevicePostBodyFormProperties {

		/** Count parameter to pass to ping. [1..5], default 5 */
		count: FormControl<number | null | undefined>,
	}
	export function CreateCreateDeviceLiveToolsPingDevicePostBodyFormGroup() {
		return new FormGroup<CreateDeviceLiveToolsPingDevicePostBodyFormProperties>({
			count: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceLiveToolsPingDeviceReturn {

		/** Id to check the status of your ping request. */
		pingId?: string | null;

		/** Ping request parameters */
		request?: GetDeviceLiveToolsPingDeviceReturnRequest;

		/** Results of the ping request. */
		results?: GetDeviceLiveToolsPingDeviceReturnResults;

		/** Status of the ping request. */
		status?: string | null;

		/** GET this url to check the status of your ping request. */
		url?: string | null;
	}
	export interface GetDeviceLiveToolsPingDeviceReturnFormProperties {

		/** Id to check the status of your ping request. */
		pingId: FormControl<string | null | undefined>,

		/** Status of the ping request. */
		status: FormControl<string | null | undefined>,

		/** GET this url to check the status of your ping request. */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceLiveToolsPingDeviceReturnFormGroup() {
		return new FormGroup<GetDeviceLiveToolsPingDeviceReturnFormProperties>({
			pingId: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceLiveToolsPingDeviceReturnRequest {

		/** Number of pings to send */
		count?: number | null;

		/** Device serial number */
		serial?: string | null;

		/** IP address or FQDN to ping */
		target?: string | null;
	}
	export interface GetDeviceLiveToolsPingDeviceReturnRequestFormProperties {

		/** Number of pings to send */
		count: FormControl<number | null | undefined>,

		/** Device serial number */
		serial: FormControl<string | null | undefined>,

		/** IP address or FQDN to ping */
		target: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceLiveToolsPingDeviceReturnRequestFormGroup() {
		return new FormGroup<GetDeviceLiveToolsPingDeviceReturnRequestFormProperties>({
			count: new FormControl<number | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			target: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceLiveToolsPingDeviceReturnResults {

		/** Packet latency stats */
		latencies?: GetDeviceLiveToolsPingDeviceReturnResultsLatencies;

		/** Lost packets */
		loss?: GetDeviceLiveToolsPingDeviceReturnResultsLoss;

		/** Number of packets received */
		received?: number | null;

		/** Received packets */
		GetDeviceLiveToolsPingDeviceReturnResultsReplies?: Array<GetDeviceLiveToolsPingDeviceReturnResultsReplies>;

		/** Number of packets sent */
		sent?: number | null;
	}
	export interface GetDeviceLiveToolsPingDeviceReturnResultsFormProperties {

		/** Number of packets received */
		received: FormControl<number | null | undefined>,

		/** Number of packets sent */
		sent: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceLiveToolsPingDeviceReturnResultsFormGroup() {
		return new FormGroup<GetDeviceLiveToolsPingDeviceReturnResultsFormProperties>({
			received: new FormControl<number | null | undefined>(undefined),
			sent: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceLiveToolsPingDeviceReturnResultsLatencies {

		/** Average latency */
		average?: number | null;

		/** Maximum latency */
		maximum?: number | null;

		/** Minimum latency */
		minimum?: number | null;
	}
	export interface GetDeviceLiveToolsPingDeviceReturnResultsLatenciesFormProperties {

		/** Average latency */
		average: FormControl<number | null | undefined>,

		/** Maximum latency */
		maximum: FormControl<number | null | undefined>,

		/** Minimum latency */
		minimum: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceLiveToolsPingDeviceReturnResultsLatenciesFormGroup() {
		return new FormGroup<GetDeviceLiveToolsPingDeviceReturnResultsLatenciesFormProperties>({
			average: new FormControl<number | null | undefined>(undefined),
			maximum: new FormControl<number | null | undefined>(undefined),
			minimum: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceLiveToolsPingDeviceReturnResultsLoss {

		/** Percentage of packets lost */
		percentage?: number | null;
	}
	export interface GetDeviceLiveToolsPingDeviceReturnResultsLossFormProperties {

		/** Percentage of packets lost */
		percentage: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceLiveToolsPingDeviceReturnResultsLossFormGroup() {
		return new FormGroup<GetDeviceLiveToolsPingDeviceReturnResultsLossFormProperties>({
			percentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceLiveToolsPingDeviceReturnResultsReplies {

		/** Latency of the packet in milliseconds */
		latency?: number | null;

		/** Sequence ID of the packet */
		sequenceId?: number | null;

		/** Size of the packet in bytes */
		size?: number | null;
	}
	export interface GetDeviceLiveToolsPingDeviceReturnResultsRepliesFormProperties {

		/** Latency of the packet in milliseconds */
		latency: FormControl<number | null | undefined>,

		/** Sequence ID of the packet */
		sequenceId: FormControl<number | null | undefined>,

		/** Size of the packet in bytes */
		size: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceLiveToolsPingDeviceReturnResultsRepliesFormGroup() {
		return new FormGroup<GetDeviceLiveToolsPingDeviceReturnResultsRepliesFormProperties>({
			latency: new FormControl<number | null | undefined>(undefined),
			sequenceId: new FormControl<number | null | undefined>(undefined),
			size: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum GetDeviceLossAndLatencyHistoryUplink { cellular = 'cellular', wan1 = 'wan1', wan2 = 'wan2' }

	export interface UpdateDeviceManagementInterfacePutBody {

		/** WAN 1 settings */
		wan1?: UpdateDeviceManagementInterfacePutBodyWan1;

		/** WAN 2 settings (only for MX devices) */
		wan2?: UpdateDeviceManagementInterfacePutBodyWan2;
	}
	export interface UpdateDeviceManagementInterfacePutBodyFormProperties {
	}
	export function CreateUpdateDeviceManagementInterfacePutBodyFormGroup() {
		return new FormGroup<UpdateDeviceManagementInterfacePutBodyFormProperties>({
		});

	}

	export interface UpdateDeviceManagementInterfacePutBodyWan1 {

		/** Up to two DNS IPs. */
		staticDns?: Array<string>;

		/** The IP of the gateway on the WAN. */
		staticGatewayIp?: string | null;

		/** The IP the device should use on the WAN. */
		staticIp?: string | null;

		/** The subnet mask for the WAN. */
		staticSubnetMask?: string | null;

		/** Configure the interface to have static IP settings or use DHCP. */
		usingStaticIp?: boolean | null;

		/** The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false. */
		vlan?: number | null;

		/** Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'. */
		wanEnabled?: UpdateDeviceManagementInterfacePutBodyWan1WanEnabled | null;
	}
	export interface UpdateDeviceManagementInterfacePutBodyWan1FormProperties {

		/** The IP of the gateway on the WAN. */
		staticGatewayIp: FormControl<string | null | undefined>,

		/** The IP the device should use on the WAN. */
		staticIp: FormControl<string | null | undefined>,

		/** The subnet mask for the WAN. */
		staticSubnetMask: FormControl<string | null | undefined>,

		/** Configure the interface to have static IP settings or use DHCP. */
		usingStaticIp: FormControl<boolean | null | undefined>,

		/** The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false. */
		vlan: FormControl<number | null | undefined>,

		/** Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'. */
		wanEnabled: FormControl<UpdateDeviceManagementInterfacePutBodyWan1WanEnabled | null | undefined>,
	}
	export function CreateUpdateDeviceManagementInterfacePutBodyWan1FormGroup() {
		return new FormGroup<UpdateDeviceManagementInterfacePutBodyWan1FormProperties>({
			staticGatewayIp: new FormControl<string | null | undefined>(undefined),
			staticIp: new FormControl<string | null | undefined>(undefined),
			staticSubnetMask: new FormControl<string | null | undefined>(undefined),
			usingStaticIp: new FormControl<boolean | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
			wanEnabled: new FormControl<UpdateDeviceManagementInterfacePutBodyWan1WanEnabled | null | undefined>(undefined),
		});

	}

	export enum UpdateDeviceManagementInterfacePutBodyWan1WanEnabled { disabled = 'disabled', enabled = 'enabled', 'not configured' = 'not configured' }

	export interface UpdateDeviceManagementInterfacePutBodyWan2 {

		/** Up to two DNS IPs. */
		staticDns?: Array<string>;

		/** The IP of the gateway on the WAN. */
		staticGatewayIp?: string | null;

		/** The IP the device should use on the WAN. */
		staticIp?: string | null;

		/** The subnet mask for the WAN. */
		staticSubnetMask?: string | null;

		/** Configure the interface to have static IP settings or use DHCP. */
		usingStaticIp?: boolean | null;

		/** The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false. */
		vlan?: number | null;

		/** Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'. */
		wanEnabled?: UpdateDeviceManagementInterfacePutBodyWan1WanEnabled | null;
	}
	export interface UpdateDeviceManagementInterfacePutBodyWan2FormProperties {

		/** The IP of the gateway on the WAN. */
		staticGatewayIp: FormControl<string | null | undefined>,

		/** The IP the device should use on the WAN. */
		staticIp: FormControl<string | null | undefined>,

		/** The subnet mask for the WAN. */
		staticSubnetMask: FormControl<string | null | undefined>,

		/** Configure the interface to have static IP settings or use DHCP. */
		usingStaticIp: FormControl<boolean | null | undefined>,

		/** The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false. */
		vlan: FormControl<number | null | undefined>,

		/** Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'. */
		wanEnabled: FormControl<UpdateDeviceManagementInterfacePutBodyWan1WanEnabled | null | undefined>,
	}
	export function CreateUpdateDeviceManagementInterfacePutBodyWan2FormGroup() {
		return new FormGroup<UpdateDeviceManagementInterfacePutBodyWan2FormProperties>({
			staticGatewayIp: new FormControl<string | null | undefined>(undefined),
			staticIp: new FormControl<string | null | undefined>(undefined),
			staticSubnetMask: new FormControl<string | null | undefined>(undefined),
			usingStaticIp: new FormControl<boolean | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
			wanEnabled: new FormControl<UpdateDeviceManagementInterfacePutBodyWan1WanEnabled | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSensorRelationshipsReturn {

		/** A role defined between an MT sensor and an MV camera that adds the camera's livestream to the sensor's details page. Snapshots from the camera will also appear in alert notifications that the sensor triggers. */
		livestream?: GetDeviceSensorRelationshipsReturnLivestream;
	}
	export interface GetDeviceSensorRelationshipsReturnFormProperties {
	}
	export function CreateGetDeviceSensorRelationshipsReturnFormGroup() {
		return new FormGroup<GetDeviceSensorRelationshipsReturnFormProperties>({
		});

	}

	export interface GetDeviceSensorRelationshipsReturnLivestream {

		/** An array of the related devices for the role */
		GetDeviceSensorRelationshipsReturnLivestreamRelatedDevices?: Array<GetDeviceSensorRelationshipsReturnLivestreamRelatedDevices>;
	}
	export interface GetDeviceSensorRelationshipsReturnLivestreamFormProperties {
	}
	export function CreateGetDeviceSensorRelationshipsReturnLivestreamFormGroup() {
		return new FormGroup<GetDeviceSensorRelationshipsReturnLivestreamFormProperties>({
		});

	}

	export interface GetDeviceSensorRelationshipsReturnLivestreamRelatedDevices {

		/** The product type of the related device */
		productType?: GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType | null;

		/** The serial of the related device */
		serial?: string | null;
	}
	export interface GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesFormProperties {

		/** The product type of the related device */
		productType: FormControl<GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType | null | undefined>,

		/** The serial of the related device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesFormGroup() {
		return new FormGroup<GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesFormProperties>({
			productType: new FormControl<GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType { camera = 'camera', sensor = 'sensor' }

	export interface UpdateDeviceSensorRelationshipsPutBody {

		/** A role defined between an MT sensor and an MV camera that adds the camera's livestream to the sensor's details page. Snapshots from the camera will also appear in alert notifications that the sensor triggers. */
		livestream?: UpdateDeviceSensorRelationshipsPutBodyLivestream;
	}
	export interface UpdateDeviceSensorRelationshipsPutBodyFormProperties {
	}
	export function CreateUpdateDeviceSensorRelationshipsPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceSensorRelationshipsPutBodyFormProperties>({
		});

	}

	export interface UpdateDeviceSensorRelationshipsPutBodyLivestream {

		/** An array of the related devices for the role */
		UpdateDeviceSensorRelationshipsPutBodyLivestreamRelatedDevices?: Array<UpdateDeviceSensorRelationshipsPutBodyLivestreamRelatedDevices>;
	}
	export interface UpdateDeviceSensorRelationshipsPutBodyLivestreamFormProperties {
	}
	export function CreateUpdateDeviceSensorRelationshipsPutBodyLivestreamFormGroup() {
		return new FormGroup<UpdateDeviceSensorRelationshipsPutBodyLivestreamFormProperties>({
		});

	}

	export interface UpdateDeviceSensorRelationshipsPutBodyLivestreamRelatedDevices {

		/**
		 * The serial of the related device
		 * Required
		 */
		serial: string;
	}
	export interface UpdateDeviceSensorRelationshipsPutBodyLivestreamRelatedDevicesFormProperties {

		/**
		 * The serial of the related device
		 * Required
		 */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceSensorRelationshipsPutBodyLivestreamRelatedDevicesFormGroup() {
		return new FormGroup<UpdateDeviceSensorRelationshipsPutBodyLivestreamRelatedDevicesFormProperties>({
			serial: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateDeviceSensorRelationshipsReturn {

		/** A role defined between an MT sensor and an MV camera that adds the camera's livestream to the sensor's details page. Snapshots from the camera will also appear in alert notifications that the sensor triggers. */
		livestream?: UpdateDeviceSensorRelationshipsReturnLivestream;
	}
	export interface UpdateDeviceSensorRelationshipsReturnFormProperties {
	}
	export function CreateUpdateDeviceSensorRelationshipsReturnFormGroup() {
		return new FormGroup<UpdateDeviceSensorRelationshipsReturnFormProperties>({
		});

	}

	export interface UpdateDeviceSensorRelationshipsReturnLivestream {

		/** An array of the related devices for the role */
		UpdateDeviceSensorRelationshipsReturnLivestreamRelatedDevices?: Array<UpdateDeviceSensorRelationshipsReturnLivestreamRelatedDevices>;
	}
	export interface UpdateDeviceSensorRelationshipsReturnLivestreamFormProperties {
	}
	export function CreateUpdateDeviceSensorRelationshipsReturnLivestreamFormGroup() {
		return new FormGroup<UpdateDeviceSensorRelationshipsReturnLivestreamFormProperties>({
		});

	}

	export interface UpdateDeviceSensorRelationshipsReturnLivestreamRelatedDevices {

		/** The product type of the related device */
		productType?: GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType | null;

		/** The serial of the related device */
		serial?: string | null;
	}
	export interface UpdateDeviceSensorRelationshipsReturnLivestreamRelatedDevicesFormProperties {

		/** The product type of the related device */
		productType: FormControl<GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType | null | undefined>,

		/** The serial of the related device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceSensorRelationshipsReturnLivestreamRelatedDevicesFormGroup() {
		return new FormGroup<UpdateDeviceSensorRelationshipsReturnLivestreamRelatedDevicesFormProperties>({
			productType: new FormControl<GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchPortsReturn {

		/** The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber?: number | null;

		/** The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType?: GetDeviceSwitchPortsReturnAccessPolicyType | null;

		/** The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile. */
		adaptivePolicyGroupId?: string | null;

		/** The VLANs allowed on the switch port. Only applicable to trunk ports. */
		allowedVlans?: string | null;

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted?: boolean | null;

		/** The status of the switch port. */
		enabled?: boolean | null;

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled?: boolean | null;

		/** The isolation status of the switch port. */
		isolationEnabled?: boolean | null;

		/** The link speed for the switch port. */
		linkNegotiation?: string | null;

		/** Available link speeds for the switch port. */
		linkNegotiationCapabilities?: Array<string>;

		/** Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'. */
		macAllowList?: Array<string>;

		/** The name of the switch port. */
		name?: string | null;

		/** If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile. */
		peerSgtCapable?: boolean | null;

		/** The PoE status of the switch port. */
		poeEnabled?: boolean | null;

		/** The identifier of the switch port. */
		portId?: string | null;

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId?: string | null;

		/** Profile attributes */
		profile?: GetDeviceSwitchPortsReturnProfile;

		/** The rapid spanning tree protocol status. */
		rstpEnabled?: boolean | null;

		/** The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowList?: Array<string>;

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit?: number | null;

		/** The storm control status of the switch port. */
		stormControlEnabled?: boolean | null;

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard?: GetDeviceSwitchPortsReturnStpGuard | null;

		/** The list of tags of the switch port. */
		tags?: Array<string>;

		/** The type of the switch port ('trunk' or 'access'). */
		type?: GetDeviceSwitchPortsReturnType | null;

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld?: GetDeviceSwitchPortsReturnUdld | null;

		/** The VLAN of the switch port. A null value will clear the value set for trunk ports. */
		vlan?: number | null;

		/** The voice VLAN of the switch port. Only applicable to access ports. */
		voiceVlan?: number | null;
	}
	export interface GetDeviceSwitchPortsReturnFormProperties {

		/** The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber: FormControl<number | null | undefined>,

		/** The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType: FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>,

		/** The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile. */
		adaptivePolicyGroupId: FormControl<string | null | undefined>,

		/** The VLANs allowed on the switch port. Only applicable to trunk ports. */
		allowedVlans: FormControl<string | null | undefined>,

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted: FormControl<boolean | null | undefined>,

		/** The status of the switch port. */
		enabled: FormControl<boolean | null | undefined>,

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled: FormControl<boolean | null | undefined>,

		/** The isolation status of the switch port. */
		isolationEnabled: FormControl<boolean | null | undefined>,

		/** The link speed for the switch port. */
		linkNegotiation: FormControl<string | null | undefined>,

		/** The name of the switch port. */
		name: FormControl<string | null | undefined>,

		/** If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile. */
		peerSgtCapable: FormControl<boolean | null | undefined>,

		/** The PoE status of the switch port. */
		poeEnabled: FormControl<boolean | null | undefined>,

		/** The identifier of the switch port. */
		portId: FormControl<string | null | undefined>,

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId: FormControl<string | null | undefined>,

		/** The rapid spanning tree protocol status. */
		rstpEnabled: FormControl<boolean | null | undefined>,

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit: FormControl<number | null | undefined>,

		/** The storm control status of the switch port. */
		stormControlEnabled: FormControl<boolean | null | undefined>,

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard: FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>,

		/** The type of the switch port ('trunk' or 'access'). */
		type: FormControl<GetDeviceSwitchPortsReturnType | null | undefined>,

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld: FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>,

		/** The VLAN of the switch port. A null value will clear the value set for trunk ports. */
		vlan: FormControl<number | null | undefined>,

		/** The voice VLAN of the switch port. Only applicable to access ports. */
		voiceVlan: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceSwitchPortsReturnFormGroup() {
		return new FormGroup<GetDeviceSwitchPortsReturnFormProperties>({
			accessPolicyNumber: new FormControl<number | null | undefined>(undefined),
			accessPolicyType: new FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>(undefined),
			adaptivePolicyGroupId: new FormControl<string | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			daiTrusted: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			flexibleStackingEnabled: new FormControl<boolean | null | undefined>(undefined),
			isolationEnabled: new FormControl<boolean | null | undefined>(undefined),
			linkNegotiation: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			peerSgtCapable: new FormControl<boolean | null | undefined>(undefined),
			poeEnabled: new FormControl<boolean | null | undefined>(undefined),
			portId: new FormControl<string | null | undefined>(undefined),
			portScheduleId: new FormControl<string | null | undefined>(undefined),
			rstpEnabled: new FormControl<boolean | null | undefined>(undefined),
			stickyMacAllowListLimit: new FormControl<number | null | undefined>(undefined),
			stormControlEnabled: new FormControl<boolean | null | undefined>(undefined),
			stpGuard: new FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>(undefined),
			type: new FormControl<GetDeviceSwitchPortsReturnType | null | undefined>(undefined),
			udld: new FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
			voiceVlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum GetDeviceSwitchPortsReturnAccessPolicyType { 'Custom access policy' = 'Custom access policy', 'MAC allow list' = 'MAC allow list', Open = 'Open', 'Sticky MAC allow list' = 'Sticky MAC allow list' }

	export interface GetDeviceSwitchPortsReturnProfile {

		/** When enabled, override this port's configuration with a port profile. */
		enabled?: boolean | null;

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id?: string | null;

		/** When enabled, the IName of the profile. */
		iname?: string | null;
	}
	export interface GetDeviceSwitchPortsReturnProfileFormProperties {

		/** When enabled, override this port's configuration with a port profile. */
		enabled: FormControl<boolean | null | undefined>,

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id: FormControl<string | null | undefined>,

		/** When enabled, the IName of the profile. */
		iname: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceSwitchPortsReturnProfileFormGroup() {
		return new FormGroup<GetDeviceSwitchPortsReturnProfileFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			iname: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetDeviceSwitchPortsReturnStpGuard { 'bpdu guard' = 'bpdu guard', disabled = 'disabled', 'loop guard' = 'loop guard', 'root guard' = 'root guard' }

	export enum GetDeviceSwitchPortsReturnType { access = 'access', trunk = 'trunk' }

	export enum GetDeviceSwitchPortsReturnUdld { 'Alert only' = 'Alert only', Enforce = 'Enforce' }

	export interface CycleDeviceSwitchPortsPostBody {

		/**
		 * List of switch ports. Example: [1, 2-5, 1_MA-MOD-8X10G_1, 1_MA-MOD-8X10G_2-1_MA-MOD-8X10G_8]
		 * Required
		 */
		ports: Array<string>;
	}
	export interface CycleDeviceSwitchPortsPostBodyFormProperties {
	}
	export function CreateCycleDeviceSwitchPortsPostBodyFormGroup() {
		return new FormGroup<CycleDeviceSwitchPortsPostBodyFormProperties>({
		});

	}

	export interface GetDeviceSwitchPortsStatusesReturn {

		/** The Cisco Discovery Protocol (CDP) information of the connected device. */
		cdp?: GetDeviceSwitchPortsStatusesReturnCdp;

		/** The number of clients connected through this port. */
		clientCount?: number | null;

		/** The current duplex of a connected port. */
		duplex?: GetDeviceSwitchPortsStatusesReturnDuplex | null;

		/** Whether the port is configured to be enabled. */
		enabled?: boolean | null;

		/** All errors present on the port. */
		errors?: Array<string>;

		/** Whether the port is the switch's uplink. */
		isUplink?: boolean | null;

		/** The Link Layer Discovery Protocol (LLDP) information of the connected device. */
		lldp?: GetDeviceSwitchPortsStatusesReturnLldp;

		/** The string identifier of this port on the switch. This is commonly just the port number but may contain additional identifying information such as the slot and module-type if the port is located on a port module. */
		portId?: string | null;

		/** How much power (in watt-hours) has been delivered by this port during the timespan. */
		powerUsageInWh?: number | null;

		/** The Secure Port status of the port. */
		securePort?: GetDeviceSwitchPortsStatusesReturnSecurePort;

		/** The current data transfer rate which the port is operating at. */
		speed?: GetDeviceSwitchPortsStatusesReturnSpeed | null;

		/** The current connection status of the port. */
		status?: GetDeviceSwitchPortsStatusesReturnStatus | null;

		/** A breakdown of the average speed of data that has passed through this port during the timespan. */
		trafficInKbps?: GetDeviceSwitchPortsStatusesReturnTrafficInKbps;

		/** A breakdown of how many kilobytes have passed through this port during the timespan. */
		usageInKb?: GetDeviceSwitchPortsStatusesReturnUsageInKb;

		/** All warnings present on the port. */
		warnings?: Array<string>;
	}
	export interface GetDeviceSwitchPortsStatusesReturnFormProperties {

		/** The number of clients connected through this port. */
		clientCount: FormControl<number | null | undefined>,

		/** The current duplex of a connected port. */
		duplex: FormControl<GetDeviceSwitchPortsStatusesReturnDuplex | null | undefined>,

		/** Whether the port is configured to be enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** Whether the port is the switch's uplink. */
		isUplink: FormControl<boolean | null | undefined>,

		/** The string identifier of this port on the switch. This is commonly just the port number but may contain additional identifying information such as the slot and module-type if the port is located on a port module. */
		portId: FormControl<string | null | undefined>,

		/** How much power (in watt-hours) has been delivered by this port during the timespan. */
		powerUsageInWh: FormControl<number | null | undefined>,

		/** The current data transfer rate which the port is operating at. */
		speed: FormControl<GetDeviceSwitchPortsStatusesReturnSpeed | null | undefined>,

		/** The current connection status of the port. */
		status: FormControl<GetDeviceSwitchPortsStatusesReturnStatus | null | undefined>,
	}
	export function CreateGetDeviceSwitchPortsStatusesReturnFormGroup() {
		return new FormGroup<GetDeviceSwitchPortsStatusesReturnFormProperties>({
			clientCount: new FormControl<number | null | undefined>(undefined),
			duplex: new FormControl<GetDeviceSwitchPortsStatusesReturnDuplex | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			isUplink: new FormControl<boolean | null | undefined>(undefined),
			portId: new FormControl<string | null | undefined>(undefined),
			powerUsageInWh: new FormControl<number | null | undefined>(undefined),
			speed: new FormControl<GetDeviceSwitchPortsStatusesReturnSpeed | null | undefined>(undefined),
			status: new FormControl<GetDeviceSwitchPortsStatusesReturnStatus | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchPortsStatusesReturnCdp {

		/** Contains network addresses of both receiving and sending devices. */
		address?: string | null;

		/** Identifies the device type, which indicates the functional capabilities of the device. */
		capabilities?: string | null;

		/** Identifies the device name. */
		deviceId?: string | null;

		/** The device's management IP. */
		managementAddress?: string | null;

		/** Indicates, per interface, the assumed VLAN for untagged packets on the interface. */
		nativeVlan?: number | null;

		/** Identifies the hardware platform of the device. */
		platform?: string | null;

		/** Identifies the port from which the CDP packet was sent. */
		portId?: string | null;

		/** The system name. */
		systemName?: string | null;

		/** Contains the device software release information. */
		version?: string | null;

		/** Advertises the configured VLAN Trunking Protocl (VTP)-management-domain name of the system. */
		vtpManagementDomain?: string | null;
	}
	export interface GetDeviceSwitchPortsStatusesReturnCdpFormProperties {

		/** Contains network addresses of both receiving and sending devices. */
		address: FormControl<string | null | undefined>,

		/** Identifies the device type, which indicates the functional capabilities of the device. */
		capabilities: FormControl<string | null | undefined>,

		/** Identifies the device name. */
		deviceId: FormControl<string | null | undefined>,

		/** The device's management IP. */
		managementAddress: FormControl<string | null | undefined>,

		/** Indicates, per interface, the assumed VLAN for untagged packets on the interface. */
		nativeVlan: FormControl<number | null | undefined>,

		/** Identifies the hardware platform of the device. */
		platform: FormControl<string | null | undefined>,

		/** Identifies the port from which the CDP packet was sent. */
		portId: FormControl<string | null | undefined>,

		/** The system name. */
		systemName: FormControl<string | null | undefined>,

		/** Contains the device software release information. */
		version: FormControl<string | null | undefined>,

		/** Advertises the configured VLAN Trunking Protocl (VTP)-management-domain name of the system. */
		vtpManagementDomain: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceSwitchPortsStatusesReturnCdpFormGroup() {
		return new FormGroup<GetDeviceSwitchPortsStatusesReturnCdpFormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			capabilities: new FormControl<string | null | undefined>(undefined),
			deviceId: new FormControl<string | null | undefined>(undefined),
			managementAddress: new FormControl<string | null | undefined>(undefined),
			nativeVlan: new FormControl<number | null | undefined>(undefined),
			platform: new FormControl<string | null | undefined>(undefined),
			portId: new FormControl<string | null | undefined>(undefined),
			systemName: new FormControl<string | null | undefined>(undefined),
			version: new FormControl<string | null | undefined>(undefined),
			vtpManagementDomain: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetDeviceSwitchPortsStatusesReturnDuplex { '' = '', full = 'full', half = 'half' }

	export interface GetDeviceSwitchPortsStatusesReturnLldp {

		/** The device's chassis ID. */
		chassisId?: string | null;

		/** The device's management IP. */
		managementAddress?: string | null;

		/** The device's management VLAN. */
		managementVlan?: number | null;

		/** Description of the port from which the LLDP packet was sent. */
		portDescription?: string | null;

		/** Identifies the port from which the LLDP packet was sent */
		portId?: string | null;

		/** The port's VLAN. */
		portVlan?: number | null;

		/** Identifies the device type, which indicates the functional capabilities of the device. */
		systemCapabilities?: string | null;

		/** The device's system description. */
		systemDescription?: string | null;

		/** The device's system name. */
		systemName?: string | null;
	}
	export interface GetDeviceSwitchPortsStatusesReturnLldpFormProperties {

		/** The device's chassis ID. */
		chassisId: FormControl<string | null | undefined>,

		/** The device's management IP. */
		managementAddress: FormControl<string | null | undefined>,

		/** The device's management VLAN. */
		managementVlan: FormControl<number | null | undefined>,

		/** Description of the port from which the LLDP packet was sent. */
		portDescription: FormControl<string | null | undefined>,

		/** Identifies the port from which the LLDP packet was sent */
		portId: FormControl<string | null | undefined>,

		/** The port's VLAN. */
		portVlan: FormControl<number | null | undefined>,

		/** Identifies the device type, which indicates the functional capabilities of the device. */
		systemCapabilities: FormControl<string | null | undefined>,

		/** The device's system description. */
		systemDescription: FormControl<string | null | undefined>,

		/** The device's system name. */
		systemName: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceSwitchPortsStatusesReturnLldpFormGroup() {
		return new FormGroup<GetDeviceSwitchPortsStatusesReturnLldpFormProperties>({
			chassisId: new FormControl<string | null | undefined>(undefined),
			managementAddress: new FormControl<string | null | undefined>(undefined),
			managementVlan: new FormControl<number | null | undefined>(undefined),
			portDescription: new FormControl<string | null | undefined>(undefined),
			portId: new FormControl<string | null | undefined>(undefined),
			portVlan: new FormControl<number | null | undefined>(undefined),
			systemCapabilities: new FormControl<string | null | undefined>(undefined),
			systemDescription: new FormControl<string | null | undefined>(undefined),
			systemName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchPortsStatusesReturnSecurePort {

		/** Whether Secure Port is currently active for this port. */
		active?: boolean | null;

		/** The current Secure Port status. */
		authenticationStatus?: GetDeviceSwitchPortsStatusesReturnSecurePortAuthenticationStatus | null;

		/** The configuration overrides applied to this port when Secure Port is active. */
		configOverrides?: GetDeviceSwitchPortsStatusesReturnSecurePortConfigOverrides;

		/** Whether Secure Port is turned on for this port. */
		enabled?: boolean | null;
	}
	export interface GetDeviceSwitchPortsStatusesReturnSecurePortFormProperties {

		/** Whether Secure Port is currently active for this port. */
		active: FormControl<boolean | null | undefined>,

		/** The current Secure Port status. */
		authenticationStatus: FormControl<GetDeviceSwitchPortsStatusesReturnSecurePortAuthenticationStatus | null | undefined>,

		/** Whether Secure Port is turned on for this port. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetDeviceSwitchPortsStatusesReturnSecurePortFormGroup() {
		return new FormGroup<GetDeviceSwitchPortsStatusesReturnSecurePortFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			authenticationStatus: new FormControl<GetDeviceSwitchPortsStatusesReturnSecurePortAuthenticationStatus | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum GetDeviceSwitchPortsStatusesReturnSecurePortAuthenticationStatus { 'Authentication failure' = 'Authentication failure', 'Authentication in progress' = 'Authentication in progress', 'Authentication successful' = 'Authentication successful', 'Authentication timed out' = 'Authentication timed out', Disabled = 'Disabled', Enabled = 'Enabled' }

	export interface GetDeviceSwitchPortsStatusesReturnSecurePortConfigOverrides {

		/** The VLANs allowed on the . Only applicable to trunk ports. */
		allowedVlans?: string | null;

		/** The type of the  ('trunk' or 'access'). */
		type?: GetDeviceSwitchPortsReturnType | null;

		/** The VLAN of the . A null value will clear the value set for trunk ports. */
		vlan?: number | null;

		/** The voice VLAN of the . Only applicable to access ports. */
		voiceVlan?: number | null;
	}
	export interface GetDeviceSwitchPortsStatusesReturnSecurePortConfigOverridesFormProperties {

		/** The VLANs allowed on the . Only applicable to trunk ports. */
		allowedVlans: FormControl<string | null | undefined>,

		/** The type of the  ('trunk' or 'access'). */
		type: FormControl<GetDeviceSwitchPortsReturnType | null | undefined>,

		/** The VLAN of the . A null value will clear the value set for trunk ports. */
		vlan: FormControl<number | null | undefined>,

		/** The voice VLAN of the . Only applicable to access ports. */
		voiceVlan: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceSwitchPortsStatusesReturnSecurePortConfigOverridesFormGroup() {
		return new FormGroup<GetDeviceSwitchPortsStatusesReturnSecurePortConfigOverridesFormProperties>({
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<GetDeviceSwitchPortsReturnType | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
			voiceVlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum GetDeviceSwitchPortsStatusesReturnSpeed { '' = '', '1 Gbps' = '1 Gbps', '10 Gbps' = '10 Gbps', '10 Mbps' = '10 Mbps', '100 Gbps' = '100 Gbps', '100 Mbps' = '100 Mbps', '2.5 Gbps' = '2.5 Gbps', '20 Gbps' = '20 Gbps', '40 Gbps' = '40 Gbps', '5 Gbps' = '5 Gbps' }

	export enum GetDeviceSwitchPortsStatusesReturnStatus { Connected = 'Connected', Disabled = 'Disabled', Disconnected = 'Disconnected' }

	export interface GetDeviceSwitchPortsStatusesReturnTrafficInKbps {

		/** The average speed of the data received (in kilobits-per-second). */
		recv?: number | null;

		/** The average speed of the data sent (in kilobits-per-second). */
		sent?: number | null;

		/** The average speed of the data sent and received (in kilobits-per-second). */
		total?: number | null;
	}
	export interface GetDeviceSwitchPortsStatusesReturnTrafficInKbpsFormProperties {

		/** The average speed of the data received (in kilobits-per-second). */
		recv: FormControl<number | null | undefined>,

		/** The average speed of the data sent (in kilobits-per-second). */
		sent: FormControl<number | null | undefined>,

		/** The average speed of the data sent and received (in kilobits-per-second). */
		total: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceSwitchPortsStatusesReturnTrafficInKbpsFormGroup() {
		return new FormGroup<GetDeviceSwitchPortsStatusesReturnTrafficInKbpsFormProperties>({
			recv: new FormControl<number | null | undefined>(undefined),
			sent: new FormControl<number | null | undefined>(undefined),
			total: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchPortsStatusesReturnUsageInKb {

		/** The amount of data received (in kilobytes). */
		recv?: number | null;

		/** The amount of data sent (in kilobytes). */
		sent?: number | null;

		/** The total amount of data sent and received (in kilobytes). */
		total?: number | null;
	}
	export interface GetDeviceSwitchPortsStatusesReturnUsageInKbFormProperties {

		/** The amount of data received (in kilobytes). */
		recv: FormControl<number | null | undefined>,

		/** The amount of data sent (in kilobytes). */
		sent: FormControl<number | null | undefined>,

		/** The total amount of data sent and received (in kilobytes). */
		total: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceSwitchPortsStatusesReturnUsageInKbFormGroup() {
		return new FormGroup<GetDeviceSwitchPortsStatusesReturnUsageInKbFormProperties>({
			recv: new FormControl<number | null | undefined>(undefined),
			sent: new FormControl<number | null | undefined>(undefined),
			total: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchPortReturn {

		/** The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber?: number | null;

		/** The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType?: GetDeviceSwitchPortsReturnAccessPolicyType | null;

		/** The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile. */
		adaptivePolicyGroupId?: string | null;

		/** The VLANs allowed on the switch port. Only applicable to trunk ports. */
		allowedVlans?: string | null;

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted?: boolean | null;

		/** The status of the switch port. */
		enabled?: boolean | null;

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled?: boolean | null;

		/** The isolation status of the switch port. */
		isolationEnabled?: boolean | null;

		/** The link speed for the switch port. */
		linkNegotiation?: string | null;

		/** Available link speeds for the switch port. */
		linkNegotiationCapabilities?: Array<string>;

		/** Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'. */
		macAllowList?: Array<string>;

		/** The name of the switch port. */
		name?: string | null;

		/** If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile. */
		peerSgtCapable?: boolean | null;

		/** The PoE status of the switch port. */
		poeEnabled?: boolean | null;

		/** The identifier of the switch port. */
		portId?: string | null;

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId?: string | null;

		/** Profile attributes */
		profile?: GetDeviceSwitchPortReturnProfile;

		/** The rapid spanning tree protocol status. */
		rstpEnabled?: boolean | null;

		/** The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowList?: Array<string>;

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit?: number | null;

		/** The storm control status of the switch port. */
		stormControlEnabled?: boolean | null;

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard?: GetDeviceSwitchPortsReturnStpGuard | null;

		/** The list of tags of the switch port. */
		tags?: Array<string>;

		/** The type of the switch port ('trunk' or 'access'). */
		type?: GetDeviceSwitchPortsReturnType | null;

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld?: GetDeviceSwitchPortsReturnUdld | null;

		/** The VLAN of the switch port. A null value will clear the value set for trunk ports. */
		vlan?: number | null;

		/** The voice VLAN of the switch port. Only applicable to access ports. */
		voiceVlan?: number | null;
	}
	export interface GetDeviceSwitchPortReturnFormProperties {

		/** The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber: FormControl<number | null | undefined>,

		/** The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType: FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>,

		/** The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile. */
		adaptivePolicyGroupId: FormControl<string | null | undefined>,

		/** The VLANs allowed on the switch port. Only applicable to trunk ports. */
		allowedVlans: FormControl<string | null | undefined>,

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted: FormControl<boolean | null | undefined>,

		/** The status of the switch port. */
		enabled: FormControl<boolean | null | undefined>,

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled: FormControl<boolean | null | undefined>,

		/** The isolation status of the switch port. */
		isolationEnabled: FormControl<boolean | null | undefined>,

		/** The link speed for the switch port. */
		linkNegotiation: FormControl<string | null | undefined>,

		/** The name of the switch port. */
		name: FormControl<string | null | undefined>,

		/** If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile. */
		peerSgtCapable: FormControl<boolean | null | undefined>,

		/** The PoE status of the switch port. */
		poeEnabled: FormControl<boolean | null | undefined>,

		/** The identifier of the switch port. */
		portId: FormControl<string | null | undefined>,

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId: FormControl<string | null | undefined>,

		/** The rapid spanning tree protocol status. */
		rstpEnabled: FormControl<boolean | null | undefined>,

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit: FormControl<number | null | undefined>,

		/** The storm control status of the switch port. */
		stormControlEnabled: FormControl<boolean | null | undefined>,

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard: FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>,

		/** The type of the switch port ('trunk' or 'access'). */
		type: FormControl<GetDeviceSwitchPortsReturnType | null | undefined>,

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld: FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>,

		/** The VLAN of the switch port. A null value will clear the value set for trunk ports. */
		vlan: FormControl<number | null | undefined>,

		/** The voice VLAN of the switch port. Only applicable to access ports. */
		voiceVlan: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceSwitchPortReturnFormGroup() {
		return new FormGroup<GetDeviceSwitchPortReturnFormProperties>({
			accessPolicyNumber: new FormControl<number | null | undefined>(undefined),
			accessPolicyType: new FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>(undefined),
			adaptivePolicyGroupId: new FormControl<string | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			daiTrusted: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			flexibleStackingEnabled: new FormControl<boolean | null | undefined>(undefined),
			isolationEnabled: new FormControl<boolean | null | undefined>(undefined),
			linkNegotiation: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			peerSgtCapable: new FormControl<boolean | null | undefined>(undefined),
			poeEnabled: new FormControl<boolean | null | undefined>(undefined),
			portId: new FormControl<string | null | undefined>(undefined),
			portScheduleId: new FormControl<string | null | undefined>(undefined),
			rstpEnabled: new FormControl<boolean | null | undefined>(undefined),
			stickyMacAllowListLimit: new FormControl<number | null | undefined>(undefined),
			stormControlEnabled: new FormControl<boolean | null | undefined>(undefined),
			stpGuard: new FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>(undefined),
			type: new FormControl<GetDeviceSwitchPortsReturnType | null | undefined>(undefined),
			udld: new FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
			voiceVlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchPortReturnProfile {

		/** When enabled, override this port's configuration with a port profile. */
		enabled?: boolean | null;

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id?: string | null;

		/** When enabled, the IName of the profile. */
		iname?: string | null;
	}
	export interface GetDeviceSwitchPortReturnProfileFormProperties {

		/** When enabled, override this port's configuration with a port profile. */
		enabled: FormControl<boolean | null | undefined>,

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id: FormControl<string | null | undefined>,

		/** When enabled, the IName of the profile. */
		iname: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceSwitchPortReturnProfileFormGroup() {
		return new FormGroup<GetDeviceSwitchPortReturnProfileFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			iname: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceSwitchPortPutBody {

		/** The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber?: number | null;

		/** The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType?: GetDeviceSwitchPortsReturnAccessPolicyType | null;

		/** The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile. */
		adaptivePolicyGroupId?: string | null;

		/** The VLANs allowed on the switch port. Only applicable to trunk ports. */
		allowedVlans?: string | null;

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted?: boolean | null;

		/** The status of the switch port. */
		enabled?: boolean | null;

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled?: boolean | null;

		/** The isolation status of the switch port. */
		isolationEnabled?: boolean | null;

		/** The link speed for the switch port. */
		linkNegotiation?: string | null;

		/** Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'. */
		macAllowList?: Array<string>;

		/** The name of the switch port. */
		name?: string | null;

		/** If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile. */
		peerSgtCapable?: boolean | null;

		/** The PoE status of the switch port. */
		poeEnabled?: boolean | null;

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId?: string | null;

		/** Profile attributes */
		profile?: UpdateDeviceSwitchPortPutBodyProfile;

		/** The rapid spanning tree protocol status. */
		rstpEnabled?: boolean | null;

		/** The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowList?: Array<string>;

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit?: number | null;

		/** The storm control status of the switch port. */
		stormControlEnabled?: boolean | null;

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard?: GetDeviceSwitchPortsReturnStpGuard | null;

		/** The list of tags of the switch port. */
		tags?: Array<string>;

		/** The type of the switch port ('trunk' or 'access'). */
		type?: GetDeviceSwitchPortsReturnType | null;

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld?: GetDeviceSwitchPortsReturnUdld | null;

		/** The VLAN of the switch port. A null value will clear the value set for trunk ports. */
		vlan?: number | null;

		/** The voice VLAN of the switch port. Only applicable to access ports. */
		voiceVlan?: number | null;
	}
	export interface UpdateDeviceSwitchPortPutBodyFormProperties {

		/** The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber: FormControl<number | null | undefined>,

		/** The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType: FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>,

		/** The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile. */
		adaptivePolicyGroupId: FormControl<string | null | undefined>,

		/** The VLANs allowed on the switch port. Only applicable to trunk ports. */
		allowedVlans: FormControl<string | null | undefined>,

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted: FormControl<boolean | null | undefined>,

		/** The status of the switch port. */
		enabled: FormControl<boolean | null | undefined>,

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled: FormControl<boolean | null | undefined>,

		/** The isolation status of the switch port. */
		isolationEnabled: FormControl<boolean | null | undefined>,

		/** The link speed for the switch port. */
		linkNegotiation: FormControl<string | null | undefined>,

		/** The name of the switch port. */
		name: FormControl<string | null | undefined>,

		/** If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile. */
		peerSgtCapable: FormControl<boolean | null | undefined>,

		/** The PoE status of the switch port. */
		poeEnabled: FormControl<boolean | null | undefined>,

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId: FormControl<string | null | undefined>,

		/** The rapid spanning tree protocol status. */
		rstpEnabled: FormControl<boolean | null | undefined>,

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit: FormControl<number | null | undefined>,

		/** The storm control status of the switch port. */
		stormControlEnabled: FormControl<boolean | null | undefined>,

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard: FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>,

		/** The type of the switch port ('trunk' or 'access'). */
		type: FormControl<GetDeviceSwitchPortsReturnType | null | undefined>,

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld: FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>,

		/** The VLAN of the switch port. A null value will clear the value set for trunk ports. */
		vlan: FormControl<number | null | undefined>,

		/** The voice VLAN of the switch port. Only applicable to access ports. */
		voiceVlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchPortPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceSwitchPortPutBodyFormProperties>({
			accessPolicyNumber: new FormControl<number | null | undefined>(undefined),
			accessPolicyType: new FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>(undefined),
			adaptivePolicyGroupId: new FormControl<string | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			daiTrusted: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			flexibleStackingEnabled: new FormControl<boolean | null | undefined>(undefined),
			isolationEnabled: new FormControl<boolean | null | undefined>(undefined),
			linkNegotiation: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			peerSgtCapable: new FormControl<boolean | null | undefined>(undefined),
			poeEnabled: new FormControl<boolean | null | undefined>(undefined),
			portScheduleId: new FormControl<string | null | undefined>(undefined),
			rstpEnabled: new FormControl<boolean | null | undefined>(undefined),
			stickyMacAllowListLimit: new FormControl<number | null | undefined>(undefined),
			stormControlEnabled: new FormControl<boolean | null | undefined>(undefined),
			stpGuard: new FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>(undefined),
			type: new FormControl<GetDeviceSwitchPortsReturnType | null | undefined>(undefined),
			udld: new FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
			voiceVlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceSwitchPortPutBodyProfile {

		/** When enabled, override this port's configuration with a port profile. */
		enabled?: boolean | null;

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id?: string | null;

		/** When enabled, the IName of the profile. */
		iname?: string | null;
	}
	export interface UpdateDeviceSwitchPortPutBodyProfileFormProperties {

		/** When enabled, override this port's configuration with a port profile. */
		enabled: FormControl<boolean | null | undefined>,

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id: FormControl<string | null | undefined>,

		/** When enabled, the IName of the profile. */
		iname: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchPortPutBodyProfileFormGroup() {
		return new FormGroup<UpdateDeviceSwitchPortPutBodyProfileFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			iname: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceSwitchPortReturn {

		/** The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber?: number | null;

		/** The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType?: GetDeviceSwitchPortsReturnAccessPolicyType | null;

		/** The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile. */
		adaptivePolicyGroupId?: string | null;

		/** The VLANs allowed on the switch port. Only applicable to trunk ports. */
		allowedVlans?: string | null;

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted?: boolean | null;

		/** The status of the switch port. */
		enabled?: boolean | null;

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled?: boolean | null;

		/** The isolation status of the switch port. */
		isolationEnabled?: boolean | null;

		/** The link speed for the switch port. */
		linkNegotiation?: string | null;

		/** Available link speeds for the switch port. */
		linkNegotiationCapabilities?: Array<string>;

		/** Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'. */
		macAllowList?: Array<string>;

		/** The name of the switch port. */
		name?: string | null;

		/** If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile. */
		peerSgtCapable?: boolean | null;

		/** The PoE status of the switch port. */
		poeEnabled?: boolean | null;

		/** The identifier of the switch port. */
		portId?: string | null;

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId?: string | null;

		/** Profile attributes */
		profile?: UpdateDeviceSwitchPortReturnProfile;

		/** The rapid spanning tree protocol status. */
		rstpEnabled?: boolean | null;

		/** The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowList?: Array<string>;

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit?: number | null;

		/** The storm control status of the switch port. */
		stormControlEnabled?: boolean | null;

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard?: GetDeviceSwitchPortsReturnStpGuard | null;

		/** The list of tags of the switch port. */
		tags?: Array<string>;

		/** The type of the switch port ('trunk' or 'access'). */
		type?: GetDeviceSwitchPortsReturnType | null;

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld?: GetDeviceSwitchPortsReturnUdld | null;

		/** The VLAN of the switch port. A null value will clear the value set for trunk ports. */
		vlan?: number | null;

		/** The voice VLAN of the switch port. Only applicable to access ports. */
		voiceVlan?: number | null;
	}
	export interface UpdateDeviceSwitchPortReturnFormProperties {

		/** The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber: FormControl<number | null | undefined>,

		/** The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType: FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>,

		/** The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile. */
		adaptivePolicyGroupId: FormControl<string | null | undefined>,

		/** The VLANs allowed on the switch port. Only applicable to trunk ports. */
		allowedVlans: FormControl<string | null | undefined>,

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted: FormControl<boolean | null | undefined>,

		/** The status of the switch port. */
		enabled: FormControl<boolean | null | undefined>,

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled: FormControl<boolean | null | undefined>,

		/** The isolation status of the switch port. */
		isolationEnabled: FormControl<boolean | null | undefined>,

		/** The link speed for the switch port. */
		linkNegotiation: FormControl<string | null | undefined>,

		/** The name of the switch port. */
		name: FormControl<string | null | undefined>,

		/** If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile. */
		peerSgtCapable: FormControl<boolean | null | undefined>,

		/** The PoE status of the switch port. */
		poeEnabled: FormControl<boolean | null | undefined>,

		/** The identifier of the switch port. */
		portId: FormControl<string | null | undefined>,

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId: FormControl<string | null | undefined>,

		/** The rapid spanning tree protocol status. */
		rstpEnabled: FormControl<boolean | null | undefined>,

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit: FormControl<number | null | undefined>,

		/** The storm control status of the switch port. */
		stormControlEnabled: FormControl<boolean | null | undefined>,

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard: FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>,

		/** The type of the switch port ('trunk' or 'access'). */
		type: FormControl<GetDeviceSwitchPortsReturnType | null | undefined>,

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld: FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>,

		/** The VLAN of the switch port. A null value will clear the value set for trunk ports. */
		vlan: FormControl<number | null | undefined>,

		/** The voice VLAN of the switch port. Only applicable to access ports. */
		voiceVlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchPortReturnFormGroup() {
		return new FormGroup<UpdateDeviceSwitchPortReturnFormProperties>({
			accessPolicyNumber: new FormControl<number | null | undefined>(undefined),
			accessPolicyType: new FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>(undefined),
			adaptivePolicyGroupId: new FormControl<string | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			daiTrusted: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			flexibleStackingEnabled: new FormControl<boolean | null | undefined>(undefined),
			isolationEnabled: new FormControl<boolean | null | undefined>(undefined),
			linkNegotiation: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			peerSgtCapable: new FormControl<boolean | null | undefined>(undefined),
			poeEnabled: new FormControl<boolean | null | undefined>(undefined),
			portId: new FormControl<string | null | undefined>(undefined),
			portScheduleId: new FormControl<string | null | undefined>(undefined),
			rstpEnabled: new FormControl<boolean | null | undefined>(undefined),
			stickyMacAllowListLimit: new FormControl<number | null | undefined>(undefined),
			stormControlEnabled: new FormControl<boolean | null | undefined>(undefined),
			stpGuard: new FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>(undefined),
			type: new FormControl<GetDeviceSwitchPortsReturnType | null | undefined>(undefined),
			udld: new FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
			voiceVlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceSwitchPortReturnProfile {

		/** When enabled, override this port's configuration with a port profile. */
		enabled?: boolean | null;

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id?: string | null;

		/** When enabled, the IName of the profile. */
		iname?: string | null;
	}
	export interface UpdateDeviceSwitchPortReturnProfileFormProperties {

		/** When enabled, override this port's configuration with a port profile. */
		enabled: FormControl<boolean | null | undefined>,

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id: FormControl<string | null | undefined>,

		/** When enabled, the IName of the profile. */
		iname: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchPortReturnProfileFormGroup() {
		return new FormGroup<UpdateDeviceSwitchPortReturnProfileFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			iname: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchRoutingInterfacesReturn {

		/** IPv4 default gateway */
		defaultGateway?: string | null;

		/** The id */
		interfaceId?: string | null;

		/** IPv4 address */
		interfaceIp?: string | null;

		/** IPv6 addressing */
		ipv6?: GetDeviceSwitchRoutingInterfacesReturnIpv6;

		/** Multicast routing status */
		multicastRouting?: string | null;

		/** The name */
		name?: string | null;

		/** IPv4 OSPF Settings */
		ospfSettings?: GetDeviceSwitchRoutingInterfacesReturnOspfSettings;

		/** IPv6 OSPF Settings */
		ospfV3?: GetDeviceSwitchRoutingInterfacesReturnOspfV3;

		/** IPv4 subnet */
		subnet?: string | null;

		/** VLAN id */
		vlanId?: number | null;
	}
	export interface GetDeviceSwitchRoutingInterfacesReturnFormProperties {

		/** IPv4 default gateway */
		defaultGateway: FormControl<string | null | undefined>,

		/** The id */
		interfaceId: FormControl<string | null | undefined>,

		/** IPv4 address */
		interfaceIp: FormControl<string | null | undefined>,

		/** Multicast routing status */
		multicastRouting: FormControl<string | null | undefined>,

		/** The name */
		name: FormControl<string | null | undefined>,

		/** IPv4 subnet */
		subnet: FormControl<string | null | undefined>,

		/** VLAN id */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceSwitchRoutingInterfacesReturnFormGroup() {
		return new FormGroup<GetDeviceSwitchRoutingInterfacesReturnFormProperties>({
			defaultGateway: new FormControl<string | null | undefined>(undefined),
			interfaceId: new FormControl<string | null | undefined>(undefined),
			interfaceIp: new FormControl<string | null | undefined>(undefined),
			multicastRouting: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchRoutingInterfacesReturnIpv6 {

		/** IPv6 address */
		address?: string | null;

		/** Assignment mode */
		assignmentMode?: string | null;

		/** IPv6 gateway */
		gateway?: string | null;

		/** IPv6 subnet */
		prefix?: string | null;
	}
	export interface GetDeviceSwitchRoutingInterfacesReturnIpv6FormProperties {

		/** IPv6 address */
		address: FormControl<string | null | undefined>,

		/** Assignment mode */
		assignmentMode: FormControl<string | null | undefined>,

		/** IPv6 gateway */
		gateway: FormControl<string | null | undefined>,

		/** IPv6 subnet */
		prefix: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceSwitchRoutingInterfacesReturnIpv6FormGroup() {
		return new FormGroup<GetDeviceSwitchRoutingInterfacesReturnIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<string | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchRoutingInterfacesReturnOspfSettings {

		/** Area id */
		area?: string | null;

		/** OSPF Cost */
		cost?: number | null;

		/** Disable sending Hello packets on this interface's IPv4 area */
		isPassiveEnabled?: boolean | null;
	}
	export interface GetDeviceSwitchRoutingInterfacesReturnOspfSettingsFormProperties {

		/** Area id */
		area: FormControl<string | null | undefined>,

		/** OSPF Cost */
		cost: FormControl<number | null | undefined>,

		/** Disable sending Hello packets on this interface's IPv4 area */
		isPassiveEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetDeviceSwitchRoutingInterfacesReturnOspfSettingsFormGroup() {
		return new FormGroup<GetDeviceSwitchRoutingInterfacesReturnOspfSettingsFormProperties>({
			area: new FormControl<string | null | undefined>(undefined),
			cost: new FormControl<number | null | undefined>(undefined),
			isPassiveEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchRoutingInterfacesReturnOspfV3 {

		/** Area id */
		area?: string | null;

		/** OSPF Cost */
		cost?: number | null;

		/** Disable sending Hello packets on this interface's IPv6 area */
		isPassiveEnabled?: boolean | null;
	}
	export interface GetDeviceSwitchRoutingInterfacesReturnOspfV3FormProperties {

		/** Area id */
		area: FormControl<string | null | undefined>,

		/** OSPF Cost */
		cost: FormControl<number | null | undefined>,

		/** Disable sending Hello packets on this interface's IPv6 area */
		isPassiveEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetDeviceSwitchRoutingInterfacesReturnOspfV3FormGroup() {
		return new FormGroup<GetDeviceSwitchRoutingInterfacesReturnOspfV3FormProperties>({
			area: new FormControl<string | null | undefined>(undefined),
			cost: new FormControl<number | null | undefined>(undefined),
			isPassiveEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchRoutingInterfaceReturn {

		/** IPv4 default gateway */
		defaultGateway?: string | null;

		/** The id */
		interfaceId?: string | null;

		/** IPv4 address */
		interfaceIp?: string | null;

		/** IPv6 addressing */
		ipv6?: GetDeviceSwitchRoutingInterfaceReturnIpv6;

		/** Multicast routing status */
		multicastRouting?: string | null;

		/** The name */
		name?: string | null;

		/** IPv4 OSPF Settings */
		ospfSettings?: GetDeviceSwitchRoutingInterfaceReturnOspfSettings;

		/** IPv6 OSPF Settings */
		ospfV3?: GetDeviceSwitchRoutingInterfaceReturnOspfV3;

		/** IPv4 subnet */
		subnet?: string | null;

		/** VLAN id */
		vlanId?: number | null;
	}
	export interface GetDeviceSwitchRoutingInterfaceReturnFormProperties {

		/** IPv4 default gateway */
		defaultGateway: FormControl<string | null | undefined>,

		/** The id */
		interfaceId: FormControl<string | null | undefined>,

		/** IPv4 address */
		interfaceIp: FormControl<string | null | undefined>,

		/** Multicast routing status */
		multicastRouting: FormControl<string | null | undefined>,

		/** The name */
		name: FormControl<string | null | undefined>,

		/** IPv4 subnet */
		subnet: FormControl<string | null | undefined>,

		/** VLAN id */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceSwitchRoutingInterfaceReturnFormGroup() {
		return new FormGroup<GetDeviceSwitchRoutingInterfaceReturnFormProperties>({
			defaultGateway: new FormControl<string | null | undefined>(undefined),
			interfaceId: new FormControl<string | null | undefined>(undefined),
			interfaceIp: new FormControl<string | null | undefined>(undefined),
			multicastRouting: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchRoutingInterfaceReturnIpv6 {

		/** IPv6 address */
		address?: string | null;

		/** Assignment mode */
		assignmentMode?: string | null;

		/** IPv6 gateway */
		gateway?: string | null;

		/** IPv6 subnet */
		prefix?: string | null;
	}
	export interface GetDeviceSwitchRoutingInterfaceReturnIpv6FormProperties {

		/** IPv6 address */
		address: FormControl<string | null | undefined>,

		/** Assignment mode */
		assignmentMode: FormControl<string | null | undefined>,

		/** IPv6 gateway */
		gateway: FormControl<string | null | undefined>,

		/** IPv6 subnet */
		prefix: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceSwitchRoutingInterfaceReturnIpv6FormGroup() {
		return new FormGroup<GetDeviceSwitchRoutingInterfaceReturnIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<string | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchRoutingInterfaceReturnOspfSettings {

		/** Area id */
		area?: string | null;

		/** OSPF Cost */
		cost?: number | null;

		/** Disable sending Hello packets on this interface's IPv4 area */
		isPassiveEnabled?: boolean | null;
	}
	export interface GetDeviceSwitchRoutingInterfaceReturnOspfSettingsFormProperties {

		/** Area id */
		area: FormControl<string | null | undefined>,

		/** OSPF Cost */
		cost: FormControl<number | null | undefined>,

		/** Disable sending Hello packets on this interface's IPv4 area */
		isPassiveEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetDeviceSwitchRoutingInterfaceReturnOspfSettingsFormGroup() {
		return new FormGroup<GetDeviceSwitchRoutingInterfaceReturnOspfSettingsFormProperties>({
			area: new FormControl<string | null | undefined>(undefined),
			cost: new FormControl<number | null | undefined>(undefined),
			isPassiveEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetDeviceSwitchRoutingInterfaceReturnOspfV3 {

		/** Area id */
		area?: string | null;

		/** OSPF Cost */
		cost?: number | null;

		/** Disable sending Hello packets on this interface's IPv6 area */
		isPassiveEnabled?: boolean | null;
	}
	export interface GetDeviceSwitchRoutingInterfaceReturnOspfV3FormProperties {

		/** Area id */
		area: FormControl<string | null | undefined>,

		/** OSPF Cost */
		cost: FormControl<number | null | undefined>,

		/** Disable sending Hello packets on this interface's IPv6 area */
		isPassiveEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetDeviceSwitchRoutingInterfaceReturnOspfV3FormGroup() {
		return new FormGroup<GetDeviceSwitchRoutingInterfaceReturnOspfV3FormProperties>({
			area: new FormControl<string | null | undefined>(undefined),
			cost: new FormControl<number | null | undefined>(undefined),
			isPassiveEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceSwitchRoutingInterfaceReturn {

		/** IPv4 default gateway */
		defaultGateway?: string | null;

		/** The id */
		interfaceId?: string | null;

		/** IPv4 address */
		interfaceIp?: string | null;

		/** IPv6 addressing */
		ipv6?: UpdateDeviceSwitchRoutingInterfaceReturnIpv6;

		/** Multicast routing status */
		multicastRouting?: string | null;

		/** The name */
		name?: string | null;

		/** IPv4 OSPF Settings */
		ospfSettings?: UpdateDeviceSwitchRoutingInterfaceReturnOspfSettings;

		/** IPv6 OSPF Settings */
		ospfV3?: UpdateDeviceSwitchRoutingInterfaceReturnOspfV3;

		/** IPv4 subnet */
		subnet?: string | null;

		/** VLAN id */
		vlanId?: number | null;
	}
	export interface UpdateDeviceSwitchRoutingInterfaceReturnFormProperties {

		/** IPv4 default gateway */
		defaultGateway: FormControl<string | null | undefined>,

		/** The id */
		interfaceId: FormControl<string | null | undefined>,

		/** IPv4 address */
		interfaceIp: FormControl<string | null | undefined>,

		/** Multicast routing status */
		multicastRouting: FormControl<string | null | undefined>,

		/** The name */
		name: FormControl<string | null | undefined>,

		/** IPv4 subnet */
		subnet: FormControl<string | null | undefined>,

		/** VLAN id */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchRoutingInterfaceReturnFormGroup() {
		return new FormGroup<UpdateDeviceSwitchRoutingInterfaceReturnFormProperties>({
			defaultGateway: new FormControl<string | null | undefined>(undefined),
			interfaceId: new FormControl<string | null | undefined>(undefined),
			interfaceIp: new FormControl<string | null | undefined>(undefined),
			multicastRouting: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceSwitchRoutingInterfaceReturnIpv6 {

		/** IPv6 address */
		address?: string | null;

		/** Assignment mode */
		assignmentMode?: string | null;

		/** IPv6 gateway */
		gateway?: string | null;

		/** IPv6 subnet */
		prefix?: string | null;
	}
	export interface UpdateDeviceSwitchRoutingInterfaceReturnIpv6FormProperties {

		/** IPv6 address */
		address: FormControl<string | null | undefined>,

		/** Assignment mode */
		assignmentMode: FormControl<string | null | undefined>,

		/** IPv6 gateway */
		gateway: FormControl<string | null | undefined>,

		/** IPv6 subnet */
		prefix: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchRoutingInterfaceReturnIpv6FormGroup() {
		return new FormGroup<UpdateDeviceSwitchRoutingInterfaceReturnIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<string | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceSwitchRoutingInterfaceReturnOspfSettings {

		/** Area id */
		area?: string | null;

		/** OSPF Cost */
		cost?: number | null;

		/** Disable sending Hello packets on this interface's IPv4 area */
		isPassiveEnabled?: boolean | null;
	}
	export interface UpdateDeviceSwitchRoutingInterfaceReturnOspfSettingsFormProperties {

		/** Area id */
		area: FormControl<string | null | undefined>,

		/** OSPF Cost */
		cost: FormControl<number | null | undefined>,

		/** Disable sending Hello packets on this interface's IPv4 area */
		isPassiveEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchRoutingInterfaceReturnOspfSettingsFormGroup() {
		return new FormGroup<UpdateDeviceSwitchRoutingInterfaceReturnOspfSettingsFormProperties>({
			area: new FormControl<string | null | undefined>(undefined),
			cost: new FormControl<number | null | undefined>(undefined),
			isPassiveEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceSwitchRoutingInterfaceReturnOspfV3 {

		/** Area id */
		area?: string | null;

		/** OSPF Cost */
		cost?: number | null;

		/** Disable sending Hello packets on this interface's IPv6 area */
		isPassiveEnabled?: boolean | null;
	}
	export interface UpdateDeviceSwitchRoutingInterfaceReturnOspfV3FormProperties {

		/** Area id */
		area: FormControl<string | null | undefined>,

		/** OSPF Cost */
		cost: FormControl<number | null | undefined>,

		/** Disable sending Hello packets on this interface's IPv6 area */
		isPassiveEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchRoutingInterfaceReturnOspfV3FormGroup() {
		return new FormGroup<UpdateDeviceSwitchRoutingInterfaceReturnOspfV3FormProperties>({
			area: new FormControl<string | null | undefined>(undefined),
			cost: new FormControl<number | null | undefined>(undefined),
			isPassiveEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceSwitchRoutingInterfaceDhcpPutBody {

		/** The PXE boot server filename for the DHCP server running on the switch interface */
		bootFileName?: string | null;

		/** The PXE boot server IP for the DHCP server running on the switch interface */
		bootNextServer?: string | null;

		/** Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch interface */
		bootOptionsEnabled?: boolean | null;

		/** The DHCP lease time config for the dhcp server running on switch interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week') */
		dhcpLeaseTime?: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null;

		/** The DHCP mode options for the switch interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer') */
		dhcpMode?: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpMode | null;

		/** Array of DHCP options consisting of code, type and value for the DHCP server running on the switch interface */
		UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptions?: Array<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptions>;

		/** The DHCP relay server IPs to which DHCP packets would get relayed for the switch interface */
		dhcpRelayServerIps?: Array<string>;

		/** The DHCP name server IPs when DHCP name server option is 'custom' */
		dnsCustomNameservers?: Array<string>;

		/** The DHCP name server option for the dhcp server running on the switch interface ('googlePublicDns', 'openDns' or 'custom') */
		dnsNameserversOption?: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDnsNameserversOption | null;

		/** Array of DHCP fixed IP assignments for the DHCP server running on the switch interface */
		UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyFixedIpAssignments?: Array<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyFixedIpAssignments>;

		/** Array of DHCP reserved IP assignments for the DHCP server running on the switch interface */
		UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyReservedIpRanges?: Array<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyReservedIpRanges>;
	}
	export interface UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyFormProperties {

		/** The PXE boot server filename for the DHCP server running on the switch interface */
		bootFileName: FormControl<string | null | undefined>,

		/** The PXE boot server IP for the DHCP server running on the switch interface */
		bootNextServer: FormControl<string | null | undefined>,

		/** Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch interface */
		bootOptionsEnabled: FormControl<boolean | null | undefined>,

		/** The DHCP lease time config for the dhcp server running on switch interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week') */
		dhcpLeaseTime: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>,

		/** The DHCP mode options for the switch interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer') */
		dhcpMode: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpMode | null | undefined>,

		/** The DHCP name server option for the dhcp server running on the switch interface ('googlePublicDns', 'openDns' or 'custom') */
		dnsNameserversOption: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDnsNameserversOption | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchRoutingInterfaceDhcpPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyFormProperties>({
			bootFileName: new FormControl<string | null | undefined>(undefined),
			bootNextServer: new FormControl<string | null | undefined>(undefined),
			bootOptionsEnabled: new FormControl<boolean | null | undefined>(undefined),
			dhcpLeaseTime: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>(undefined),
			dhcpMode: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpMode | null | undefined>(undefined),
			dnsNameserversOption: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDnsNameserversOption | null | undefined>(undefined),
		});

	}

	export enum UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime { '1 day' = '1 day', '1 hour' = '1 hour', '1 week' = '1 week', '12 hours' = '12 hours', '30 minutes' = '30 minutes', '4 hours' = '4 hours' }

	export enum UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpMode { dhcpDisabled = 'dhcpDisabled', dhcpRelay = 'dhcpRelay', dhcpServer = 'dhcpServer' }

	export interface UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptions {

		/**
		 * The code for DHCP option which should be from 2 to 254
		 * Required
		 */
		code: string;

		/**
		 * The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
		 * Required
		 */
		type: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType;

		/**
		 * The value of the DHCP option
		 * Required
		 */
		value: string;
	}
	export interface UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsFormProperties {

		/**
		 * The code for DHCP option which should be from 2 to 254
		 * Required
		 */
		code: FormControl<string | null | undefined>,

		/**
		 * The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
		 * Required
		 */
		type: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType | null | undefined>,

		/**
		 * The value of the DHCP option
		 * Required
		 */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsFormGroup() {
		return new FormGroup<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsFormProperties>({
			code: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			type: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType | null | undefined>(undefined, [Validators.required]),
			value: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType { hex = 'hex', integer = 'integer', ip = 'ip', text = 'text' }

	export enum UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDnsNameserversOption { custom = 'custom', googlePublicDns = 'googlePublicDns', openDns = 'openDns' }

	export interface UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyFixedIpAssignments {

		/**
		 * The IP address of the client which has fixed IP address assigned to it
		 * Required
		 */
		ip: string;

		/**
		 * The MAC address of the client which has fixed IP address
		 * Required
		 */
		mac: string;

		/**
		 * The name of the client which has fixed IP address
		 * Required
		 */
		name: string;
	}
	export interface UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyFixedIpAssignmentsFormProperties {

		/**
		 * The IP address of the client which has fixed IP address assigned to it
		 * Required
		 */
		ip: FormControl<string | null | undefined>,

		/**
		 * The MAC address of the client which has fixed IP address
		 * Required
		 */
		mac: FormControl<string | null | undefined>,

		/**
		 * The name of the client which has fixed IP address
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchRoutingInterfaceDhcpPutBodyFixedIpAssignmentsFormGroup() {
		return new FormGroup<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyFixedIpAssignmentsFormProperties>({
			ip: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			mac: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyReservedIpRanges {

		/** The comment for the reserved IP range */
		comment?: string | null;

		/**
		 * The ending IP address of the reserved IP range
		 * Required
		 */
		end: string;

		/**
		 * The starting IP address of the reserved IP range
		 * Required
		 */
		start: string;
	}
	export interface UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyReservedIpRangesFormProperties {

		/** The comment for the reserved IP range */
		comment: FormControl<string | null | undefined>,

		/**
		 * The ending IP address of the reserved IP range
		 * Required
		 */
		end: FormControl<string | null | undefined>,

		/**
		 * The starting IP address of the reserved IP range
		 * Required
		 */
		start: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchRoutingInterfaceDhcpPutBodyReservedIpRangesFormGroup() {
		return new FormGroup<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyReservedIpRangesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			end: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			start: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetDeviceSwitchRoutingStaticRouteReturn {

		/** Option to advertise static routes via OSPF */
		advertiseViaOspfEnabled?: boolean | null;

		/** The name or description of the layer 3 static route */
		name?: string | null;

		/**
		 * The IP address of the router to which traffic for this destination network should be sent
		 * Required
		 */
		nextHopIp: string;

		/** Option to prefer static routes over OSPF routes */
		preferOverOspfRoutesEnabled?: boolean | null;

		/** The identifier of a layer 3 static route */
		staticRouteId?: string | null;

		/**
		 * The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)
		 * Required
		 */
		subnet: string;
	}
	export interface GetDeviceSwitchRoutingStaticRouteReturnFormProperties {

		/** Option to advertise static routes via OSPF */
		advertiseViaOspfEnabled: FormControl<boolean | null | undefined>,

		/** The name or description of the layer 3 static route */
		name: FormControl<string | null | undefined>,

		/**
		 * The IP address of the router to which traffic for this destination network should be sent
		 * Required
		 */
		nextHopIp: FormControl<string | null | undefined>,

		/** Option to prefer static routes over OSPF routes */
		preferOverOspfRoutesEnabled: FormControl<boolean | null | undefined>,

		/** The identifier of a layer 3 static route */
		staticRouteId: FormControl<string | null | undefined>,

		/**
		 * The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)
		 * Required
		 */
		subnet: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceSwitchRoutingStaticRouteReturnFormGroup() {
		return new FormGroup<GetDeviceSwitchRoutingStaticRouteReturnFormProperties>({
			advertiseViaOspfEnabled: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			nextHopIp: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			preferOverOspfRoutesEnabled: new FormControl<boolean | null | undefined>(undefined),
			staticRouteId: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateDeviceSwitchWarmSparePutBody {

		/**
		 * Enable or disable warm spare for a switch
		 * Required
		 */
		enabled: boolean;

		/** Serial number of the warm spare switch */
		spareSerial?: string | null;
	}
	export interface UpdateDeviceSwitchWarmSparePutBodyFormProperties {

		/**
		 * Enable or disable warm spare for a switch
		 * Required
		 */
		enabled: FormControl<boolean | null | undefined>,

		/** Serial number of the warm spare switch */
		spareSerial: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceSwitchWarmSparePutBodyFormGroup() {
		return new FormGroup<UpdateDeviceSwitchWarmSparePutBodyFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
			spareSerial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceWirelessBluetoothSettingsReturn {

		/** Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		major?: number | null;

		/** Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		minor?: number | null;

		/** Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		uuid?: string | null;
	}
	export interface GetDeviceWirelessBluetoothSettingsReturnFormProperties {

		/** Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		major: FormControl<number | null | undefined>,

		/** Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		minor: FormControl<number | null | undefined>,

		/** Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		uuid: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceWirelessBluetoothSettingsReturnFormGroup() {
		return new FormGroup<GetDeviceWirelessBluetoothSettingsReturnFormProperties>({
			major: new FormControl<number | null | undefined>(undefined),
			minor: new FormControl<number | null | undefined>(undefined),
			uuid: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceWirelessBluetoothSettingsPutBody {

		/** Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		major?: number | null;

		/** Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		minor?: number | null;

		/** Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		uuid?: string | null;
	}
	export interface UpdateDeviceWirelessBluetoothSettingsPutBodyFormProperties {

		/** Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		major: FormControl<number | null | undefined>,

		/** Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		minor: FormControl<number | null | undefined>,

		/** Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		uuid: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceWirelessBluetoothSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceWirelessBluetoothSettingsPutBodyFormProperties>({
			major: new FormControl<number | null | undefined>(undefined),
			minor: new FormControl<number | null | undefined>(undefined),
			uuid: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceWirelessBluetoothSettingsReturn {

		/** Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		major?: number | null;

		/** Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		minor?: number | null;

		/** Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		uuid?: string | null;
	}
	export interface UpdateDeviceWirelessBluetoothSettingsReturnFormProperties {

		/** Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		major: FormControl<number | null | undefined>,

		/** Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		minor: FormControl<number | null | undefined>,

		/** Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value. */
		uuid: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceWirelessBluetoothSettingsReturnFormGroup() {
		return new FormGroup<UpdateDeviceWirelessBluetoothSettingsReturnFormProperties>({
			major: new FormControl<number | null | undefined>(undefined),
			minor: new FormControl<number | null | undefined>(undefined),
			uuid: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetDeviceWirelessConnectionStatsBand { _2_4 = '2.4', _5 = '5', _6 = '6' }

	export interface GetDeviceWirelessConnectionStatsReturn {

		/** The connection stats of the device */
		connectionStats?: GetDeviceWirelessConnectionStatsReturnConnectionStats;

		/** The serial number for the device */
		serial?: string | null;
	}
	export interface GetDeviceWirelessConnectionStatsReturnFormProperties {

		/** The serial number for the device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetDeviceWirelessConnectionStatsReturnFormGroup() {
		return new FormGroup<GetDeviceWirelessConnectionStatsReturnFormProperties>({
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetDeviceWirelessConnectionStatsReturnConnectionStats {

		/** The number of failed association attempts */
		assoc?: number | null;

		/** The number of failed authentication attempts */
		auth?: number | null;

		/** The number of failed DHCP attempts */
		dhcp?: number | null;

		/** The number of failed DNS attempts */
		dns?: number | null;

		/** The number of successful connection attempts */
		success?: number | null;
	}
	export interface GetDeviceWirelessConnectionStatsReturnConnectionStatsFormProperties {

		/** The number of failed association attempts */
		assoc: FormControl<number | null | undefined>,

		/** The number of failed authentication attempts */
		auth: FormControl<number | null | undefined>,

		/** The number of failed DHCP attempts */
		dhcp: FormControl<number | null | undefined>,

		/** The number of failed DNS attempts */
		dns: FormControl<number | null | undefined>,

		/** The number of successful connection attempts */
		success: FormControl<number | null | undefined>,
	}
	export function CreateGetDeviceWirelessConnectionStatsReturnConnectionStatsFormGroup() {
		return new FormGroup<GetDeviceWirelessConnectionStatsReturnConnectionStatsFormProperties>({
			assoc: new FormControl<number | null | undefined>(undefined),
			auth: new FormControl<number | null | undefined>(undefined),
			dhcp: new FormControl<number | null | undefined>(undefined),
			dns: new FormControl<number | null | undefined>(undefined),
			success: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceWirelessRadioSettingsPutBody {

		/** Manual radio settings for 5 GHz. */
		fiveGhzSettings?: UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettings;

		/** The ID of an RF profile to assign to the device. If the value of this parameter is null, the appropriate basic RF profile (indoor or outdoor) will be assigned to the device. Assigning an RF profile will clear ALL manually configured overrides on the device (channel width, channel, power). */
		rfProfileId?: string | null;

		/** Manual radio settings for 2.4 GHz. */
		twoFourGhzSettings?: UpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettings;
	}
	export interface UpdateDeviceWirelessRadioSettingsPutBodyFormProperties {

		/** The ID of an RF profile to assign to the device. If the value of this parameter is null, the appropriate basic RF profile (indoor or outdoor) will be assigned to the device. Assigning an RF profile will clear ALL manually configured overrides on the device (channel width, channel, power). */
		rfProfileId: FormControl<string | null | undefined>,
	}
	export function CreateUpdateDeviceWirelessRadioSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateDeviceWirelessRadioSettingsPutBodyFormProperties>({
			rfProfileId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettings {

		/** Sets a manual channel for 5 GHz. Can be '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161', '165', '169', '173' or '177' or null for using auto channel. */
		channel?: UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsChannel;

		/** Sets a manual channel for 5 GHz. Can be '0', '20', '40', '80' or '160' or null for using auto channel width. */
		channelWidth?: UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsChannelWidth;

		/** Set a manual target power for 5 GHz. Can be between '8' or '30' or null for using auto power range. */
		targetPower?: number | null;
	}
	export interface UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsFormProperties {

		/** Sets a manual channel for 5 GHz. Can be '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161', '165', '169', '173' or '177' or null for using auto channel. */
		channel: FormControl<UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsChannel | null | undefined>,

		/** Sets a manual channel for 5 GHz. Can be '0', '20', '40', '80' or '160' or null for using auto channel width. */
		channelWidth: FormControl<UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsChannelWidth | null | undefined>,

		/** Set a manual target power for 5 GHz. Can be between '8' or '30' or null for using auto power range. */
		targetPower: FormControl<number | null | undefined>,
	}
	export function CreateUpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsFormGroup() {
		return new FormGroup<UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsFormProperties>({
			channel: new FormControl<UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsChannel | null | undefined>(undefined),
			channelWidth: new FormControl<UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsChannelWidth | null | undefined>(undefined),
			targetPower: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsChannel { _36 = 0, _40 = 1, _44 = 2, _48 = 3, _52 = 4, _56 = 5, _60 = 6, _64 = 7, _100 = 8, _104 = 9, _108 = 10, _112 = 11, _116 = 12, _120 = 13, _124 = 14, _128 = 15, _132 = 16, _136 = 17, _140 = 18, _144 = 19, _149 = 20, _153 = 21, _157 = 22, _161 = 23, _165 = 24, _169 = 25, _173 = 26, _177 = 27 }

	export enum UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsChannelWidth { _0 = 0, _20 = 1, _40 = 2, _80 = 3, _160 = 4 }

	export interface UpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettings {

		/** Sets a manual channel for 2.4 GHz. Can be '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13' or '14' or null for using auto channel. */
		channel?: UpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettingsChannel;

		/** Set a manual target power for 2.4 GHz. Can be between '5' or '30' or null for using auto power range. */
		targetPower?: number | null;
	}
	export interface UpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettingsFormProperties {

		/** Sets a manual channel for 2.4 GHz. Can be '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13' or '14' or null for using auto channel. */
		channel: FormControl<UpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettingsChannel | null | undefined>,

		/** Set a manual target power for 2.4 GHz. Can be between '5' or '30' or null for using auto power range. */
		targetPower: FormControl<number | null | undefined>,
	}
	export function CreateUpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettingsFormGroup() {
		return new FormGroup<UpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettingsFormProperties>({
			channel: new FormControl<UpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettingsChannel | null | undefined>(undefined),
			targetPower: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum UpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettingsChannel { _1 = 0, _2 = 1, _3 = 2, _4 = 3, _5 = 4, _6 = 5, _7 = 6, _8 = 7, _9 = 8, _10 = 9, _11 = 10, _12 = 11, _13 = 12, _14 = 13 }

	export interface GetNetworkReturn {

		/** Enrollment string for the network */
		enrollmentString?: string | null;

		/** Network ID */
		id?: string | null;

		/** If the network is bound to a config template */
		isBoundToConfigTemplate?: boolean | null;

		/** Network name */
		name?: string | null;

		/** Notes for the network */
		notes?: string | null;

		/** Organization ID */
		organizationId?: string | null;

		/** List of the product types that the network supports */
		productTypes?: Array<string>;

		/** Network tags */
		tags?: Array<string>;

		/** Timezone of the network */
		timeZone?: string | null;

		/** URL to the network Dashboard UI */
		url?: string | null;
	}
	export interface GetNetworkReturnFormProperties {

		/** Enrollment string for the network */
		enrollmentString: FormControl<string | null | undefined>,

		/** Network ID */
		id: FormControl<string | null | undefined>,

		/** If the network is bound to a config template */
		isBoundToConfigTemplate: FormControl<boolean | null | undefined>,

		/** Network name */
		name: FormControl<string | null | undefined>,

		/** Notes for the network */
		notes: FormControl<string | null | undefined>,

		/** Organization ID */
		organizationId: FormControl<string | null | undefined>,

		/** Timezone of the network */
		timeZone: FormControl<string | null | undefined>,

		/** URL to the network Dashboard UI */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkReturnFormGroup() {
		return new FormGroup<GetNetworkReturnFormProperties>({
			enrollmentString: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isBoundToConfigTemplate: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
			organizationId: new FormControl<string | null | undefined>(undefined),
			timeZone: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkPutBody {

		/** A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. */
		enrollmentString?: string | null;

		/** The name of the network */
		name?: string | null;

		/** Add any notes or additional information about this network here. */
		notes?: string | null;

		/** A list of tags to be applied to the network */
		tags?: Array<string>;

		/** The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a> */
		timeZone?: string | null;
	}
	export interface UpdateNetworkPutBodyFormProperties {

		/** A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. */
		enrollmentString: FormControl<string | null | undefined>,

		/** The name of the network */
		name: FormControl<string | null | undefined>,

		/** Add any notes or additional information about this network here. */
		notes: FormControl<string | null | undefined>,

		/** The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a> */
		timeZone: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkPutBodyFormProperties>({
			enrollmentString: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
			timeZone: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkReturn {

		/** Enrollment string for the network */
		enrollmentString?: string | null;

		/** Network ID */
		id?: string | null;

		/** If the network is bound to a config template */
		isBoundToConfigTemplate?: boolean | null;

		/** Network name */
		name?: string | null;

		/** Notes for the network */
		notes?: string | null;

		/** Organization ID */
		organizationId?: string | null;

		/** List of the product types that the network supports */
		productTypes?: Array<string>;

		/** Network tags */
		tags?: Array<string>;

		/** Timezone of the network */
		timeZone?: string | null;

		/** URL to the network Dashboard UI */
		url?: string | null;
	}
	export interface UpdateNetworkReturnFormProperties {

		/** Enrollment string for the network */
		enrollmentString: FormControl<string | null | undefined>,

		/** Network ID */
		id: FormControl<string | null | undefined>,

		/** If the network is bound to a config template */
		isBoundToConfigTemplate: FormControl<boolean | null | undefined>,

		/** Network name */
		name: FormControl<string | null | undefined>,

		/** Notes for the network */
		notes: FormControl<string | null | undefined>,

		/** Organization ID */
		organizationId: FormControl<string | null | undefined>,

		/** Timezone of the network */
		timeZone: FormControl<string | null | undefined>,

		/** URL to the network Dashboard UI */
		url: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkReturnFormGroup() {
		return new FormGroup<UpdateNetworkReturnFormProperties>({
			enrollmentString: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isBoundToConfigTemplate: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
			organizationId: new FormControl<string | null | undefined>(undefined),
			timeZone: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkAlertsHistoryReturn {

		/** relevant data about the event that caused the alert */
		alertData?: string | null;

		/** user friendly alert type */
		alertType?: string | null;

		/** type of alert */
		alertTypeId?: string | null;

		/** the destinations this alert is configured to be delivered to */
		destinations?: GetNetworkAlertsHistoryReturnDestinations;

		/** info related to the device that caused the alert */
		device?: GetNetworkAlertsHistoryReturnDevice;

		/** time when the event occurred */
		occurredAt?: string | null;
	}
	export interface GetNetworkAlertsHistoryReturnFormProperties {

		/** relevant data about the event that caused the alert */
		alertData: FormControl<string | null | undefined>,

		/** user friendly alert type */
		alertType: FormControl<string | null | undefined>,

		/** type of alert */
		alertTypeId: FormControl<string | null | undefined>,

		/** time when the event occurred */
		occurredAt: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkAlertsHistoryReturnFormGroup() {
		return new FormGroup<GetNetworkAlertsHistoryReturnFormProperties>({
			alertData: new FormControl<string | null | undefined>(undefined),
			alertType: new FormControl<string | null | undefined>(undefined),
			alertTypeId: new FormControl<string | null | undefined>(undefined),
			occurredAt: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkAlertsHistoryReturnDestinations {

		/** email destinations for this alert */
		email?: GetNetworkAlertsHistoryReturnDestinationsEmail;

		/** push destinations for this alert */
		push?: GetNetworkAlertsHistoryReturnDestinationsPush;

		/** sms destinations for this alert */
		sms?: GetNetworkAlertsHistoryReturnDestinationsSms;

		/** webhook destinations for this alert */
		webhook?: GetNetworkAlertsHistoryReturnDestinationsWebhook;
	}
	export interface GetNetworkAlertsHistoryReturnDestinationsFormProperties {
	}
	export function CreateGetNetworkAlertsHistoryReturnDestinationsFormGroup() {
		return new FormGroup<GetNetworkAlertsHistoryReturnDestinationsFormProperties>({
		});

	}

	export interface GetNetworkAlertsHistoryReturnDestinationsEmail {

		/** time when the alert was sent to the user(s) for this channel */
		sentAt?: string | null;
	}
	export interface GetNetworkAlertsHistoryReturnDestinationsEmailFormProperties {

		/** time when the alert was sent to the user(s) for this channel */
		sentAt: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkAlertsHistoryReturnDestinationsEmailFormGroup() {
		return new FormGroup<GetNetworkAlertsHistoryReturnDestinationsEmailFormProperties>({
			sentAt: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkAlertsHistoryReturnDestinationsPush {

		/** time when the alert was sent to the user(s) for this channel */
		sentAt?: string | null;
	}
	export interface GetNetworkAlertsHistoryReturnDestinationsPushFormProperties {

		/** time when the alert was sent to the user(s) for this channel */
		sentAt: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkAlertsHistoryReturnDestinationsPushFormGroup() {
		return new FormGroup<GetNetworkAlertsHistoryReturnDestinationsPushFormProperties>({
			sentAt: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkAlertsHistoryReturnDestinationsSms {

		/** time when the alert was sent to the user(s) for this channel */
		sentAt?: string | null;
	}
	export interface GetNetworkAlertsHistoryReturnDestinationsSmsFormProperties {

		/** time when the alert was sent to the user(s) for this channel */
		sentAt: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkAlertsHistoryReturnDestinationsSmsFormGroup() {
		return new FormGroup<GetNetworkAlertsHistoryReturnDestinationsSmsFormProperties>({
			sentAt: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkAlertsHistoryReturnDestinationsWebhook {

		/** time when the alert was sent to the user(s) for this channel */
		sentAt?: string | null;
	}
	export interface GetNetworkAlertsHistoryReturnDestinationsWebhookFormProperties {

		/** time when the alert was sent to the user(s) for this channel */
		sentAt: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkAlertsHistoryReturnDestinationsWebhookFormGroup() {
		return new FormGroup<GetNetworkAlertsHistoryReturnDestinationsWebhookFormProperties>({
			sentAt: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkAlertsHistoryReturnDevice {

		/** device serial */
		serial?: string | null;
	}
	export interface GetNetworkAlertsHistoryReturnDeviceFormProperties {

		/** device serial */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkAlertsHistoryReturnDeviceFormGroup() {
		return new FormGroup<GetNetworkAlertsHistoryReturnDeviceFormProperties>({
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkAlertsSettingsPutBody {

		/** Alert-specific configuration for each type. Only alerts that pertain to the network can be updated. */
		UpdateNetworkAlertsSettingsPutBodyAlerts?: Array<UpdateNetworkAlertsSettingsPutBodyAlerts>;

		/** The network-wide destinations for all alerts on the network. */
		defaultDestinations?: UpdateNetworkAlertsSettingsPutBodyDefaultDestinations;
	}
	export interface UpdateNetworkAlertsSettingsPutBodyFormProperties {
	}
	export function CreateUpdateNetworkAlertsSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkAlertsSettingsPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkAlertsSettingsPutBodyAlerts {

		/** A hash of destinations for this specific alert */
		alertDestinations?: UpdateNetworkAlertsSettingsPutBodyAlertsAlertDestinations;

		/** A boolean depicting if the alert is turned on or off */
		enabled?: boolean | null;

		/** A hash of specific configuration data for the alert. Only filters specific to the alert will be updated. */
		filters?: string | null;

		/**
		 * The type of alert
		 * Required
		 */
		type: string;
	}
	export interface UpdateNetworkAlertsSettingsPutBodyAlertsFormProperties {

		/** A boolean depicting if the alert is turned on or off */
		enabled: FormControl<boolean | null | undefined>,

		/** A hash of specific configuration data for the alert. Only filters specific to the alert will be updated. */
		filters: FormControl<string | null | undefined>,

		/**
		 * The type of alert
		 * Required
		 */
		type: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkAlertsSettingsPutBodyAlertsFormGroup() {
		return new FormGroup<UpdateNetworkAlertsSettingsPutBodyAlertsFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			filters: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkAlertsSettingsPutBodyAlertsAlertDestinations {

		/** If true, then all network admins will receive emails for this alert */
		allAdmins?: boolean | null;

		/** A list of emails that will receive information about the alert */
		emails?: Array<string>;

		/** A list of HTTP server IDs to send a Webhook to for this alert */
		httpServerIds?: Array<string>;

		/** If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network */
		snmp?: boolean | null;
	}
	export interface UpdateNetworkAlertsSettingsPutBodyAlertsAlertDestinationsFormProperties {

		/** If true, then all network admins will receive emails for this alert */
		allAdmins: FormControl<boolean | null | undefined>,

		/** If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network */
		snmp: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkAlertsSettingsPutBodyAlertsAlertDestinationsFormGroup() {
		return new FormGroup<UpdateNetworkAlertsSettingsPutBodyAlertsAlertDestinationsFormProperties>({
			allAdmins: new FormControl<boolean | null | undefined>(undefined),
			snmp: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkAlertsSettingsPutBodyDefaultDestinations {

		/** If true, then all network admins will receive emails. */
		allAdmins?: boolean | null;

		/** A list of emails that will recieve the alert(s). */
		emails?: Array<string>;

		/** A list of HTTP server IDs to send a Webhook to */
		httpServerIds?: Array<string>;

		/** If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network. */
		snmp?: boolean | null;
	}
	export interface UpdateNetworkAlertsSettingsPutBodyDefaultDestinationsFormProperties {

		/** If true, then all network admins will receive emails. */
		allAdmins: FormControl<boolean | null | undefined>,

		/** If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network. */
		snmp: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkAlertsSettingsPutBodyDefaultDestinationsFormGroup() {
		return new FormGroup<UpdateNetworkAlertsSettingsPutBodyDefaultDestinationsFormProperties>({
			allAdmins: new FormControl<boolean | null | undefined>(undefined),
			snmp: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum GetNetworkApplianceClientSecurityEventsSortOrder { ascending = 'ascending', descending = 'descending' }

	export interface UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBody {

		/** The list of connectivity monitoring destinations */
		UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBodyDestinations?: Array<UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBodyDestinations>;
	}
	export interface UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBodyFormProperties {
	}
	export function CreateUpdateNetworkApplianceConnectivityMonitoringDestinationsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBodyDestinations {

		/** Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed */
		default?: boolean | null;

		/** Description of the testing destination. Optional, defaults to null */
		description?: string | null;

		/**
		 * The IP address to test connectivity with
		 * Required
		 */
		ip: string;
	}
	export interface UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBodyDestinationsFormProperties {

		/** Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed */
		default: FormControl<boolean | null | undefined>,

		/** Description of the testing destination. Optional, defaults to null */
		description: FormControl<string | null | undefined>,

		/**
		 * The IP address to test connectivity with
		 * Required
		 */
		ip: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceConnectivityMonitoringDestinationsPutBodyDestinationsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBodyDestinationsFormProperties>({
			default: new FormControl<boolean | null | undefined>(undefined),
			description: new FormControl<string | null | undefined>(undefined),
			ip: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceContentFilteringPutBody {

		/** A list of URL patterns that are allowed */
		allowedUrlPatterns?: Array<string>;

		/** A list of URL categories to block */
		blockedUrlCategories?: Array<string>;

		/** A list of URL patterns that are blocked */
		blockedUrlPatterns?: Array<string>;

		/** URL category list size which is either 'topSites' or 'fullList' */
		urlCategoryListSize?: UpdateNetworkApplianceContentFilteringPutBodyUrlCategoryListSize | null;
	}
	export interface UpdateNetworkApplianceContentFilteringPutBodyFormProperties {

		/** URL category list size which is either 'topSites' or 'fullList' */
		urlCategoryListSize: FormControl<UpdateNetworkApplianceContentFilteringPutBodyUrlCategoryListSize | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceContentFilteringPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceContentFilteringPutBodyFormProperties>({
			urlCategoryListSize: new FormControl<UpdateNetworkApplianceContentFilteringPutBodyUrlCategoryListSize | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkApplianceContentFilteringPutBodyUrlCategoryListSize { fullList = 'fullList', topSites = 'topSites' }

	export interface UpdateNetworkApplianceFirewallFirewalledServicePutBody {

		/**
		 * A string indicating the rule for which IPs are allowed to use the specified service. Acceptable values are "blocked" (no remote IPs can access the service), "restricted" (only allowed IPs can access the service), and "unrestriced" (any remote IP can access the service). This field is required
		 * Required
		 */
		access: UpdateNetworkApplianceFirewallFirewalledServicePutBodyAccess;

		/** An array of allowed IPs that can access the service. This field is required if "access" is set to "restricted". Otherwise this field is ignored */
		allowedIps?: Array<string>;
	}
	export interface UpdateNetworkApplianceFirewallFirewalledServicePutBodyFormProperties {

		/**
		 * A string indicating the rule for which IPs are allowed to use the specified service. Acceptable values are "blocked" (no remote IPs can access the service), "restricted" (only allowed IPs can access the service), and "unrestriced" (any remote IP can access the service). This field is required
		 * Required
		 */
		access: FormControl<UpdateNetworkApplianceFirewallFirewalledServicePutBodyAccess | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceFirewallFirewalledServicePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallFirewalledServicePutBodyFormProperties>({
			access: new FormControl<UpdateNetworkApplianceFirewallFirewalledServicePutBodyAccess | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum UpdateNetworkApplianceFirewallFirewalledServicePutBodyAccess { blocked = 'blocked', restricted = 'restricted', unrestricted = 'unrestricted' }

	export interface UpdateNetworkApplianceFirewallL7FirewallRulesPutBody {

		/** An ordered array of the MX L7 firewall rules */
		UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRules?: Array<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRules>;
	}
	export interface UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyFormProperties {
	}
	export function CreateUpdateNetworkApplianceFirewallL7FirewallRulesPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRules {

		/** 'Deny' traffic specified by this rule */
		policy?: UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy | null;

		/** Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange' */
		type?: UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType | null;

		/** The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format. */
		value?: string | null;
	}
	export interface UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesFormProperties {

		/** 'Deny' traffic specified by this rule */
		policy: FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy | null | undefined>,

		/** Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange' */
		type: FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType | null | undefined>,

		/** The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format. */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesFormProperties>({
			policy: new FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy | null | undefined>(undefined),
			type: new FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType | null | undefined>(undefined),
			value: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy { deny = 'deny' }

	export enum UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType { application = 'application', applicationCategory = 'applicationCategory', host = 'host', ipRange = 'ipRange', port = 'port' }

	export interface UpdateNetworkApplianceFirewallOneToManyNatRulesPutBody {

		/**
		 * An array of 1:Many nat rules
		 * Required
		 */
		UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRules: Array<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRules>;
	}
	export interface UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyFormProperties {
	}
	export function CreateUpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRules {

		/**
		 * An array of associated forwarding rules
		 * Required
		 */
		UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRules: Array<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRules>;

		/**
		 * The IP address that will be used to access the internal resource from the WAN
		 * Required
		 */
		publicIp: string;

		/**
		 * The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
		 * Required
		 */
		uplink: UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesUplink;
	}
	export interface UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesFormProperties {

		/**
		 * The IP address that will be used to access the internal resource from the WAN
		 * Required
		 */
		publicIp: FormControl<string | null | undefined>,

		/**
		 * The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
		 * Required
		 */
		uplink: FormControl<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesUplink | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesFormProperties>({
			publicIp: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			uplink: new FormControl<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesUplink | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRules {

		/** Remote IP addresses or ranges that are permitted to access the internal resource via this port forwarding rule, or 'any' */
		allowedIps?: Array<string>;

		/** Local IP address to which traffic will be forwarded */
		localIp?: string | null;

		/** Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port */
		localPort?: string | null;

		/** A description of the rule */
		name?: string | null;

		/** 'tcp' or 'udp' */
		protocol?: UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesProtocol | null;

		/** Destination port of the traffic that is arriving on the WAN */
		publicPort?: string | null;
	}
	export interface UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesFormProperties {

		/** Local IP address to which traffic will be forwarded */
		localIp: FormControl<string | null | undefined>,

		/** Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port */
		localPort: FormControl<string | null | undefined>,

		/** A description of the rule */
		name: FormControl<string | null | undefined>,

		/** 'tcp' or 'udp' */
		protocol: FormControl<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesProtocol | null | undefined>,

		/** Destination port of the traffic that is arriving on the WAN */
		publicPort: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesFormProperties>({
			localIp: new FormControl<string | null | undefined>(undefined),
			localPort: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			protocol: new FormControl<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesProtocol | null | undefined>(undefined),
			publicPort: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesProtocol { tcp = 'tcp', udp = 'udp' }

	export enum UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesUplink { internet1 = 'internet1', internet2 = 'internet2' }

	export interface UpdateNetworkApplianceFirewallOneToOneNatRulesPutBody {

		/**
		 * An array of 1:1 nat rules
		 * Required
		 */
		UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRules: Array<UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRules>;
	}
	export interface UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyFormProperties {
	}
	export function CreateUpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRules {

		/** The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource */
		UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInbound?: Array<UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInbound>;

		/**
		 * The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
		 * Required
		 */
		lanIp: string;

		/** A descriptive name for the rule */
		name?: string | null;

		/** The IP address that will be used to access the internal resource from the WAN */
		publicIp?: string | null;

		/** The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2') */
		uplink?: UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesUplink | null;
	}
	export interface UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesFormProperties {

		/**
		 * The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
		 * Required
		 */
		lanIp: FormControl<string | null | undefined>,

		/** A descriptive name for the rule */
		name: FormControl<string | null | undefined>,

		/** The IP address that will be used to access the internal resource from the WAN */
		publicIp: FormControl<string | null | undefined>,

		/** The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2') */
		uplink: FormControl<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesUplink | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesFormProperties>({
			lanIp: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined),
			publicIp: new FormControl<string | null | undefined>(undefined),
			uplink: new FormControl<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesUplink | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInbound {

		/** An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any' */
		allowedIps?: Array<string>;

		/** An array of ports or port ranges that will be forwarded to the host on the LAN */
		destinationPorts?: Array<string>;

		/** Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any' */
		protocol?: UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInboundProtocol | null;
	}
	export interface UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInboundFormProperties {

		/** Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any' */
		protocol: FormControl<UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInboundProtocol | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInboundFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInboundFormProperties>({
			protocol: new FormControl<UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInboundProtocol | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInboundProtocol { any = 'any', 'icmp-ping' = 'icmp-ping', tcp = 'tcp', udp = 'udp' }

	export interface UpdateNetworkApplianceFirewallPortForwardingRulesPutBody {

		/**
		 * An array of port forwarding params
		 * Required
		 */
		UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRules: Array<UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRules>;
	}
	export interface UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyFormProperties {
	}
	export function CreateUpdateNetworkApplianceFirewallPortForwardingRulesPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRules {

		/**
		 * An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges (or any)
		 * Required
		 */
		allowedIps: Array<string>;

		/**
		 * The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
		 * Required
		 */
		lanIp: string;

		/**
		 * A port or port ranges that will receive the forwarded traffic from the WAN
		 * Required
		 */
		localPort: string;

		/** A descriptive name for the rule */
		name?: string | null;

		/**
		 * TCP or UDP
		 * Required
		 */
		protocol: UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesProtocol;

		/**
		 * A port or port ranges that will be forwarded to the host on the LAN
		 * Required
		 */
		publicPort: string;

		/** The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both') */
		uplink?: UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRulesUplink | null;
	}
	export interface UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRulesFormProperties {

		/**
		 * The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
		 * Required
		 */
		lanIp: FormControl<string | null | undefined>,

		/**
		 * A port or port ranges that will receive the forwarded traffic from the WAN
		 * Required
		 */
		localPort: FormControl<string | null | undefined>,

		/** A descriptive name for the rule */
		name: FormControl<string | null | undefined>,

		/**
		 * TCP or UDP
		 * Required
		 */
		protocol: FormControl<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesProtocol | null | undefined>,

		/**
		 * A port or port ranges that will be forwarded to the host on the LAN
		 * Required
		 */
		publicPort: FormControl<string | null | undefined>,

		/** The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both') */
		uplink: FormControl<UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRulesUplink | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRulesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRulesFormProperties>({
			lanIp: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			localPort: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined),
			protocol: new FormControl<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesProtocol | null | undefined>(undefined, [Validators.required]),
			publicPort: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			uplink: new FormControl<UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRulesUplink | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRulesUplink { both = 'both', internet1 = 'internet1', internet2 = 'internet2' }

	export interface UpdateNetworkApplianceFirewallSettingsPutBody {

		/** Spoofing protection settings */
		spoofingProtection?: UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtection;
	}
	export interface UpdateNetworkApplianceFirewallSettingsPutBodyFormProperties {
	}
	export function CreateUpdateNetworkApplianceFirewallSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallSettingsPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtection {

		/** IP source address spoofing settings */
		ipSourceGuard?: UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuard;
	}
	export interface UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionFormProperties {
	}
	export function CreateUpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuard {

		/** Mode of protection */
		mode?: UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuardMode | null;
	}
	export interface UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuardFormProperties {

		/** Mode of protection */
		mode: FormControl<UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuardMode | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuardFormGroup() {
		return new FormGroup<UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuardFormProperties>({
			mode: new FormControl<UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuardMode | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuardMode { block = 'block', log = 'log' }

	export interface GetNetworkAppliancePortsReturn {

		/** The name of the policy. Only applicable to Access ports. */
		accessPolicy?: string | null;

		/** Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port. */
		allowedVlans?: string | null;

		/** Whether the trunk port can drop all untagged traffic. */
		dropUntaggedTraffic?: boolean | null;

		/** The status of the port */
		enabled?: boolean | null;

		/** Number of the port */
		number?: number | null;

		/** The type of the port: 'access' or 'trunk'. */
		type?: string | null;

		/** Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode. */
		vlan?: number | null;
	}
	export interface GetNetworkAppliancePortsReturnFormProperties {

		/** The name of the policy. Only applicable to Access ports. */
		accessPolicy: FormControl<string | null | undefined>,

		/** Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port. */
		allowedVlans: FormControl<string | null | undefined>,

		/** Whether the trunk port can drop all untagged traffic. */
		dropUntaggedTraffic: FormControl<boolean | null | undefined>,

		/** The status of the port */
		enabled: FormControl<boolean | null | undefined>,

		/** Number of the port */
		number: FormControl<number | null | undefined>,

		/** The type of the port: 'access' or 'trunk'. */
		type: FormControl<string | null | undefined>,

		/** Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkAppliancePortsReturnFormGroup() {
		return new FormGroup<GetNetworkAppliancePortsReturnFormProperties>({
			accessPolicy: new FormControl<string | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			dropUntaggedTraffic: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			number: new FormControl<number | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkAppliancePortReturn {

		/** The name of the policy. Only applicable to Access ports. */
		accessPolicy?: string | null;

		/** Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port. */
		allowedVlans?: string | null;

		/** Whether the trunk port can drop all untagged traffic. */
		dropUntaggedTraffic?: boolean | null;

		/** The status of the port */
		enabled?: boolean | null;

		/** Number of the port */
		number?: number | null;

		/** The type of the port: 'access' or 'trunk'. */
		type?: string | null;

		/** Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode. */
		vlan?: number | null;
	}
	export interface GetNetworkAppliancePortReturnFormProperties {

		/** The name of the policy. Only applicable to Access ports. */
		accessPolicy: FormControl<string | null | undefined>,

		/** Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port. */
		allowedVlans: FormControl<string | null | undefined>,

		/** Whether the trunk port can drop all untagged traffic. */
		dropUntaggedTraffic: FormControl<boolean | null | undefined>,

		/** The status of the port */
		enabled: FormControl<boolean | null | undefined>,

		/** Number of the port */
		number: FormControl<number | null | undefined>,

		/** The type of the port: 'access' or 'trunk'. */
		type: FormControl<string | null | undefined>,

		/** Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkAppliancePortReturnFormGroup() {
		return new FormGroup<GetNetworkAppliancePortReturnFormProperties>({
			accessPolicy: new FormControl<string | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			dropUntaggedTraffic: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			number: new FormControl<number | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkAppliancePortPutBody {

		/** The name of the policy. Only applicable to Access ports. Valid values are: 'open', '8021x-radius', 'mac-radius', 'hybris-radius' for MX64 or Z3 or any MX supporting the per port authentication feature. Otherwise, 'open' is the only valid value and 'open' is the default value if the field is missing. */
		accessPolicy?: string | null;

		/** Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port. */
		allowedVlans?: string | null;

		/** Trunk port can Drop all Untagged traffic. When true, no VLAN is required. Access ports cannot have dropUntaggedTraffic set to true. */
		dropUntaggedTraffic?: boolean | null;

		/** The status of the port */
		enabled?: boolean | null;

		/** The type of the port: 'access' or 'trunk'. */
		type?: string | null;

		/** Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode. */
		vlan?: number | null;
	}
	export interface UpdateNetworkAppliancePortPutBodyFormProperties {

		/** The name of the policy. Only applicable to Access ports. Valid values are: 'open', '8021x-radius', 'mac-radius', 'hybris-radius' for MX64 or Z3 or any MX supporting the per port authentication feature. Otherwise, 'open' is the only valid value and 'open' is the default value if the field is missing. */
		accessPolicy: FormControl<string | null | undefined>,

		/** Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port. */
		allowedVlans: FormControl<string | null | undefined>,

		/** Trunk port can Drop all Untagged traffic. When true, no VLAN is required. Access ports cannot have dropUntaggedTraffic set to true. */
		dropUntaggedTraffic: FormControl<boolean | null | undefined>,

		/** The status of the port */
		enabled: FormControl<boolean | null | undefined>,

		/** The type of the port: 'access' or 'trunk'. */
		type: FormControl<string | null | undefined>,

		/** Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkAppliancePortPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkAppliancePortPutBodyFormProperties>({
			accessPolicy: new FormControl<string | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			dropUntaggedTraffic: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkAppliancePortReturn {

		/** The name of the policy. Only applicable to Access ports. */
		accessPolicy?: string | null;

		/** Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port. */
		allowedVlans?: string | null;

		/** Whether the trunk port can drop all untagged traffic. */
		dropUntaggedTraffic?: boolean | null;

		/** The status of the port */
		enabled?: boolean | null;

		/** Number of the port */
		number?: number | null;

		/** The type of the port: 'access' or 'trunk'. */
		type?: string | null;

		/** Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode. */
		vlan?: number | null;
	}
	export interface UpdateNetworkAppliancePortReturnFormProperties {

		/** The name of the policy. Only applicable to Access ports. */
		accessPolicy: FormControl<string | null | undefined>,

		/** Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port. */
		allowedVlans: FormControl<string | null | undefined>,

		/** Whether the trunk port can drop all untagged traffic. */
		dropUntaggedTraffic: FormControl<boolean | null | undefined>,

		/** The status of the port */
		enabled: FormControl<boolean | null | undefined>,

		/** Number of the port */
		number: FormControl<number | null | undefined>,

		/** The type of the port: 'access' or 'trunk'. */
		type: FormControl<string | null | undefined>,

		/** Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkAppliancePortReturnFormGroup() {
		return new FormGroup<UpdateNetworkAppliancePortReturnFormProperties>({
			accessPolicy: new FormControl<string | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			dropUntaggedTraffic: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			number: new FormControl<number | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkAppliancePrefixesDelegatedStaticsReturn {

		/** Prefix creation time. */
		createdAt?: Date | null;

		/** Identifying description for the prefix. */
		description?: string | null;

		/** WAN1/WAN2/Independent prefix. */
		origin?: GetNetworkAppliancePrefixesDelegatedStaticsReturnOrigin;

		/** IPv6 prefix/prefix length. */
		prefix?: string | null;

		/** Static delegated prefix id. */
		staticDelegatedPrefixId?: string | null;

		/** Prefix Updated time. */
		updatedAt?: Date | null;
	}
	export interface GetNetworkAppliancePrefixesDelegatedStaticsReturnFormProperties {

		/** Prefix creation time. */
		createdAt: FormControl<Date | null | undefined>,

		/** Identifying description for the prefix. */
		description: FormControl<string | null | undefined>,

		/** IPv6 prefix/prefix length. */
		prefix: FormControl<string | null | undefined>,

		/** Static delegated prefix id. */
		staticDelegatedPrefixId: FormControl<string | null | undefined>,

		/** Prefix Updated time. */
		updatedAt: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkAppliancePrefixesDelegatedStaticsReturnFormGroup() {
		return new FormGroup<GetNetworkAppliancePrefixesDelegatedStaticsReturnFormProperties>({
			createdAt: new FormControl<Date | null | undefined>(undefined),
			description: new FormControl<string | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined),
			staticDelegatedPrefixId: new FormControl<string | null | undefined>(undefined),
			updatedAt: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkAppliancePrefixesDelegatedStaticsReturnOrigin {

		/** Uplink provided or independent */
		interfaces?: Array<string>;

		/** Origin type */
		type?: string | null;
	}
	export interface GetNetworkAppliancePrefixesDelegatedStaticsReturnOriginFormProperties {

		/** Origin type */
		type: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkAppliancePrefixesDelegatedStaticsReturnOriginFormGroup() {
		return new FormGroup<GetNetworkAppliancePrefixesDelegatedStaticsReturnOriginFormProperties>({
			type: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkAppliancePrefixesDelegatedStaticPostBody {

		/** A name or description for the prefix */
		description?: string | null;

		/**
		 * The origin of the prefix
		 * Required
		 */
		origin: CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOrigin;

		/**
		 * A static IPv6 prefix
		 * Required
		 */
		prefix: string;
	}
	export interface CreateNetworkAppliancePrefixesDelegatedStaticPostBodyFormProperties {

		/** A name or description for the prefix */
		description: FormControl<string | null | undefined>,

		/**
		 * A static IPv6 prefix
		 * Required
		 */
		prefix: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkAppliancePrefixesDelegatedStaticPostBodyFormGroup() {
		return new FormGroup<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOrigin {

		/** Interfaces associated with the prefix */
		interfaces?: Array<string>;

		/** Type of the origin */
		type?: CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null;
	}
	export interface CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginFormProperties {

		/** Type of the origin */
		type: FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>,
	}
	export function CreateCreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginFormGroup() {
		return new FormGroup<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginFormProperties>({
			type: new FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>(undefined),
		});

	}

	export enum CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType { independent = 'independent', internet = 'internet' }

	export interface GetNetworkAppliancePrefixesDelegatedStaticReturn {

		/** Prefix creation time. */
		createdAt?: Date | null;

		/** Identifying description for the prefix. */
		description?: string | null;

		/** WAN1/WAN2/Independent prefix. */
		origin?: GetNetworkAppliancePrefixesDelegatedStaticReturnOrigin;

		/** IPv6 prefix/prefix length. */
		prefix?: string | null;

		/** Static delegated prefix id. */
		staticDelegatedPrefixId?: string | null;

		/** Prefix Updated time. */
		updatedAt?: Date | null;
	}
	export interface GetNetworkAppliancePrefixesDelegatedStaticReturnFormProperties {

		/** Prefix creation time. */
		createdAt: FormControl<Date | null | undefined>,

		/** Identifying description for the prefix. */
		description: FormControl<string | null | undefined>,

		/** IPv6 prefix/prefix length. */
		prefix: FormControl<string | null | undefined>,

		/** Static delegated prefix id. */
		staticDelegatedPrefixId: FormControl<string | null | undefined>,

		/** Prefix Updated time. */
		updatedAt: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkAppliancePrefixesDelegatedStaticReturnFormGroup() {
		return new FormGroup<GetNetworkAppliancePrefixesDelegatedStaticReturnFormProperties>({
			createdAt: new FormControl<Date | null | undefined>(undefined),
			description: new FormControl<string | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined),
			staticDelegatedPrefixId: new FormControl<string | null | undefined>(undefined),
			updatedAt: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkAppliancePrefixesDelegatedStaticReturnOrigin {

		/** Uplink provided or independent */
		interfaces?: Array<string>;

		/** Origin type */
		type?: string | null;
	}
	export interface GetNetworkAppliancePrefixesDelegatedStaticReturnOriginFormProperties {

		/** Origin type */
		type: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkAppliancePrefixesDelegatedStaticReturnOriginFormGroup() {
		return new FormGroup<GetNetworkAppliancePrefixesDelegatedStaticReturnOriginFormProperties>({
			type: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkAppliancePrefixesDelegatedStaticPutBody {

		/** A name or description for the prefix */
		description?: string | null;

		/** The origin of the prefix */
		origin?: UpdateNetworkAppliancePrefixesDelegatedStaticPutBodyOrigin;

		/** A static IPv6 prefix */
		prefix?: string | null;
	}
	export interface UpdateNetworkAppliancePrefixesDelegatedStaticPutBodyFormProperties {

		/** A name or description for the prefix */
		description: FormControl<string | null | undefined>,

		/** A static IPv6 prefix */
		prefix: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkAppliancePrefixesDelegatedStaticPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkAppliancePrefixesDelegatedStaticPutBodyFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkAppliancePrefixesDelegatedStaticPutBodyOrigin {

		/** Interfaces associated with the prefix */
		interfaces?: Array<string>;

		/** Type of the origin */
		type?: CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null;
	}
	export interface UpdateNetworkAppliancePrefixesDelegatedStaticPutBodyOriginFormProperties {

		/** Type of the origin */
		type: FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>,
	}
	export function CreateUpdateNetworkAppliancePrefixesDelegatedStaticPutBodyOriginFormGroup() {
		return new FormGroup<UpdateNetworkAppliancePrefixesDelegatedStaticPutBodyOriginFormProperties>({
			type: new FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSecurityIntrusionPutBody {

		/** Set the detection ruleset 'connectivity'/'balanced'/'security' (optional - omitting will leave current config unchanged). Default value is 'balanced' if none currently saved */
		idsRulesets?: UpdateNetworkApplianceSecurityIntrusionPutBodyIdsRulesets | null;

		/** Set mode to 'disabled'/'detection'/'prevention' (optional - omitting will leave current config unchanged) */
		mode?: UpdateNetworkApplianceSecurityIntrusionPutBodyMode | null;

		/** Set the included/excluded networks from the intrusion engine (optional - omitting will leave current config unchanged). This is available only in 'passthrough' mode */
		protectedNetworks?: UpdateNetworkApplianceSecurityIntrusionPutBodyProtectedNetworks;
	}
	export interface UpdateNetworkApplianceSecurityIntrusionPutBodyFormProperties {

		/** Set the detection ruleset 'connectivity'/'balanced'/'security' (optional - omitting will leave current config unchanged). Default value is 'balanced' if none currently saved */
		idsRulesets: FormControl<UpdateNetworkApplianceSecurityIntrusionPutBodyIdsRulesets | null | undefined>,

		/** Set mode to 'disabled'/'detection'/'prevention' (optional - omitting will leave current config unchanged) */
		mode: FormControl<UpdateNetworkApplianceSecurityIntrusionPutBodyMode | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSecurityIntrusionPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSecurityIntrusionPutBodyFormProperties>({
			idsRulesets: new FormControl<UpdateNetworkApplianceSecurityIntrusionPutBodyIdsRulesets | null | undefined>(undefined),
			mode: new FormControl<UpdateNetworkApplianceSecurityIntrusionPutBodyMode | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkApplianceSecurityIntrusionPutBodyIdsRulesets { balanced = 'balanced', connectivity = 'connectivity', security = 'security' }

	export enum UpdateNetworkApplianceSecurityIntrusionPutBodyMode { detection = 'detection', disabled = 'disabled', prevention = 'prevention' }

	export interface UpdateNetworkApplianceSecurityIntrusionPutBodyProtectedNetworks {

		/** list of IP addresses or subnets being excluded from protection (required if 'useDefault' is false) */
		excludedCidr?: Array<string>;

		/** list of IP addresses or subnets being protected (required if 'useDefault' is false) */
		includedCidr?: Array<string>;

		/** true/false whether to use special IPv4 addresses: https://tools.ietf.org/html/rfc5735 (required). Default value is true if none currently saved */
		useDefault?: boolean | null;
	}
	export interface UpdateNetworkApplianceSecurityIntrusionPutBodyProtectedNetworksFormProperties {

		/** true/false whether to use special IPv4 addresses: https://tools.ietf.org/html/rfc5735 (required). Default value is true if none currently saved */
		useDefault: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSecurityIntrusionPutBodyProtectedNetworksFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSecurityIntrusionPutBodyProtectedNetworksFormProperties>({
			useDefault: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSecurityMalwarePutBody {

		/** The sha256 digests of files that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing */
		UpdateNetworkApplianceSecurityMalwarePutBodyAllowedFiles?: Array<UpdateNetworkApplianceSecurityMalwarePutBodyAllowedFiles>;

		/** The urls that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing */
		UpdateNetworkApplianceSecurityMalwarePutBodyAllowedUrls?: Array<UpdateNetworkApplianceSecurityMalwarePutBodyAllowedUrls>;

		/**
		 * Set mode to 'enabled' to enable malware prevention, otherwise 'disabled'
		 * Required
		 */
		mode: UpdateNetworkApplianceSecurityMalwarePutBodyMode;
	}
	export interface UpdateNetworkApplianceSecurityMalwarePutBodyFormProperties {

		/**
		 * Set mode to 'enabled' to enable malware prevention, otherwise 'disabled'
		 * Required
		 */
		mode: FormControl<UpdateNetworkApplianceSecurityMalwarePutBodyMode | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSecurityMalwarePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSecurityMalwarePutBodyFormProperties>({
			mode: new FormControl<UpdateNetworkApplianceSecurityMalwarePutBodyMode | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceSecurityMalwarePutBodyAllowedFiles {

		/**
		 * Comment about the allowed entity
		 * Required
		 */
		comment: string;

		/**
		 * The file sha256 hash to allow
		 * Required
		 */
		sha256: string;
	}
	export interface UpdateNetworkApplianceSecurityMalwarePutBodyAllowedFilesFormProperties {

		/**
		 * Comment about the allowed entity
		 * Required
		 */
		comment: FormControl<string | null | undefined>,

		/**
		 * The file sha256 hash to allow
		 * Required
		 */
		sha256: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSecurityMalwarePutBodyAllowedFilesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSecurityMalwarePutBodyAllowedFilesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			sha256: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceSecurityMalwarePutBodyAllowedUrls {

		/**
		 * Comment about the allowed entity
		 * Required
		 */
		comment: string;

		/**
		 * The url to allow
		 * Required
		 */
		url: string;
	}
	export interface UpdateNetworkApplianceSecurityMalwarePutBodyAllowedUrlsFormProperties {

		/**
		 * Comment about the allowed entity
		 * Required
		 */
		comment: FormControl<string | null | undefined>,

		/**
		 * The url to allow
		 * Required
		 */
		url: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSecurityMalwarePutBodyAllowedUrlsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSecurityMalwarePutBodyAllowedUrlsFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			url: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum UpdateNetworkApplianceSecurityMalwarePutBodyMode { disabled = 'disabled', enabled = 'enabled' }

	export interface GetNetworkApplianceSettingsReturn {

		/** Client tracking method of a network */
		clientTrackingMethod?: GetNetworkApplianceSettingsReturnClientTrackingMethod | null;

		/** Deployment mode of a network */
		deploymentMode?: GetNetworkApplianceSettingsReturnDeploymentMode | null;

		/** Dynamic DNS settings for a network */
		dynamicDns?: GetNetworkApplianceSettingsReturnDynamicDns;
	}
	export interface GetNetworkApplianceSettingsReturnFormProperties {

		/** Client tracking method of a network */
		clientTrackingMethod: FormControl<GetNetworkApplianceSettingsReturnClientTrackingMethod | null | undefined>,

		/** Deployment mode of a network */
		deploymentMode: FormControl<GetNetworkApplianceSettingsReturnDeploymentMode | null | undefined>,
	}
	export function CreateGetNetworkApplianceSettingsReturnFormGroup() {
		return new FormGroup<GetNetworkApplianceSettingsReturnFormProperties>({
			clientTrackingMethod: new FormControl<GetNetworkApplianceSettingsReturnClientTrackingMethod | null | undefined>(undefined),
			deploymentMode: new FormControl<GetNetworkApplianceSettingsReturnDeploymentMode | null | undefined>(undefined),
		});

	}

	export enum GetNetworkApplianceSettingsReturnClientTrackingMethod { 'IP address' = 'IP address', 'MAC address' = 'MAC address', 'Unique client identifier' = 'Unique client identifier' }

	export enum GetNetworkApplianceSettingsReturnDeploymentMode { passthrough = 'passthrough', routed = 'routed' }

	export interface GetNetworkApplianceSettingsReturnDynamicDns {

		/** Dynamic DNS enabled */
		enabled?: boolean | null;

		/** Dynamic DNS url prefix. DDNS must be enabled to update */
		prefix?: string | null;

		/** Dynamic DNS url. DDNS must be enabled to update */
		url?: string | null;
	}
	export interface GetNetworkApplianceSettingsReturnDynamicDnsFormProperties {

		/** Dynamic DNS enabled */
		enabled: FormControl<boolean | null | undefined>,

		/** Dynamic DNS url prefix. DDNS must be enabled to update */
		prefix: FormControl<string | null | undefined>,

		/** Dynamic DNS url. DDNS must be enabled to update */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceSettingsReturnDynamicDnsFormGroup() {
		return new FormGroup<GetNetworkApplianceSettingsReturnDynamicDnsFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSettingsPutBody {

		/** Client tracking method of a network */
		clientTrackingMethod?: GetNetworkApplianceSettingsReturnClientTrackingMethod | null;

		/** Deployment mode of a network */
		deploymentMode?: GetNetworkApplianceSettingsReturnDeploymentMode | null;

		/** Dynamic DNS settings for a network */
		dynamicDns?: UpdateNetworkApplianceSettingsPutBodyDynamicDns;
	}
	export interface UpdateNetworkApplianceSettingsPutBodyFormProperties {

		/** Client tracking method of a network */
		clientTrackingMethod: FormControl<GetNetworkApplianceSettingsReturnClientTrackingMethod | null | undefined>,

		/** Deployment mode of a network */
		deploymentMode: FormControl<GetNetworkApplianceSettingsReturnDeploymentMode | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSettingsPutBodyFormProperties>({
			clientTrackingMethod: new FormControl<GetNetworkApplianceSettingsReturnClientTrackingMethod | null | undefined>(undefined),
			deploymentMode: new FormControl<GetNetworkApplianceSettingsReturnDeploymentMode | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSettingsPutBodyDynamicDns {

		/** Dynamic DNS enabled */
		enabled?: boolean | null;

		/** Dynamic DNS url prefix. DDNS must be enabled to update */
		prefix?: string | null;
	}
	export interface UpdateNetworkApplianceSettingsPutBodyDynamicDnsFormProperties {

		/** Dynamic DNS enabled */
		enabled: FormControl<boolean | null | undefined>,

		/** Dynamic DNS url prefix. DDNS must be enabled to update */
		prefix: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSettingsPutBodyDynamicDnsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSettingsPutBodyDynamicDnsFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSettingsReturn {

		/** Client tracking method of a network */
		clientTrackingMethod?: GetNetworkApplianceSettingsReturnClientTrackingMethod | null;

		/** Deployment mode of a network */
		deploymentMode?: GetNetworkApplianceSettingsReturnDeploymentMode | null;

		/** Dynamic DNS settings for a network */
		dynamicDns?: UpdateNetworkApplianceSettingsReturnDynamicDns;
	}
	export interface UpdateNetworkApplianceSettingsReturnFormProperties {

		/** Client tracking method of a network */
		clientTrackingMethod: FormControl<GetNetworkApplianceSettingsReturnClientTrackingMethod | null | undefined>,

		/** Deployment mode of a network */
		deploymentMode: FormControl<GetNetworkApplianceSettingsReturnDeploymentMode | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSettingsReturnFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSettingsReturnFormProperties>({
			clientTrackingMethod: new FormControl<GetNetworkApplianceSettingsReturnClientTrackingMethod | null | undefined>(undefined),
			deploymentMode: new FormControl<GetNetworkApplianceSettingsReturnDeploymentMode | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSettingsReturnDynamicDns {

		/** Dynamic DNS enabled */
		enabled?: boolean | null;

		/** Dynamic DNS url prefix. DDNS must be enabled to update */
		prefix?: string | null;

		/** Dynamic DNS url. DDNS must be enabled to update */
		url?: string | null;
	}
	export interface UpdateNetworkApplianceSettingsReturnDynamicDnsFormProperties {

		/** Dynamic DNS enabled */
		enabled: FormControl<boolean | null | undefined>,

		/** Dynamic DNS url prefix. DDNS must be enabled to update */
		prefix: FormControl<string | null | undefined>,

		/** Dynamic DNS url. DDNS must be enabled to update */
		url: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSettingsReturnDynamicDnsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSettingsReturnDynamicDnsFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceSingleLanReturn {

		/** The local IP of the appliance on the single LAN */
		applianceIp?: string | null;

		/** IPv6 configuration on the single LAN */
		ipv6?: GetNetworkApplianceSingleLanReturnIpv6;

		/** Mandatory DHCP will enforce that clients connecting to this single LAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above */
		mandatoryDhcp?: GetNetworkApplianceSingleLanReturnMandatoryDhcp;

		/** The subnet of the single LAN */
		subnet?: string | null;
	}
	export interface GetNetworkApplianceSingleLanReturnFormProperties {

		/** The local IP of the appliance on the single LAN */
		applianceIp: FormControl<string | null | undefined>,

		/** The subnet of the single LAN */
		subnet: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceSingleLanReturnFormGroup() {
		return new FormGroup<GetNetworkApplianceSingleLanReturnFormProperties>({
			applianceIp: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceSingleLanReturnIpv6 {

		/** Enable IPv6 on single LAN */
		enabled?: boolean | null;

		/** Prefix assignments on the single LAN */
		GetNetworkApplianceSingleLanReturnIpv6PrefixAssignments?: Array<GetNetworkApplianceSingleLanReturnIpv6PrefixAssignments>;
	}
	export interface GetNetworkApplianceSingleLanReturnIpv6FormProperties {

		/** Enable IPv6 on single LAN */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkApplianceSingleLanReturnIpv6FormGroup() {
		return new FormGroup<GetNetworkApplianceSingleLanReturnIpv6FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceSingleLanReturnIpv6PrefixAssignments {

		/** Auto assign a /64 prefix from the origin to the single LAN */
		autonomous?: boolean | null;

		/** The origin of the prefix */
		origin?: GetNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOrigin;

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6?: string | null;

		/** Manual configuration of a /64 prefix on the single LAN */
		staticPrefix?: string | null;
	}
	export interface GetNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsFormProperties {

		/** Auto assign a /64 prefix from the origin to the single LAN */
		autonomous: FormControl<boolean | null | undefined>,

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6: FormControl<string | null | undefined>,

		/** Manual configuration of a /64 prefix on the single LAN */
		staticPrefix: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsFormGroup() {
		return new FormGroup<GetNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsFormProperties>({
			autonomous: new FormControl<boolean | null | undefined>(undefined),
			staticApplianceIp6: new FormControl<string | null | undefined>(undefined),
			staticPrefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOrigin {

		/** Interfaces associated with the prefix */
		interfaces?: Array<string>;

		/** Type of the origin */
		type?: CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null;
	}
	export interface GetNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOriginFormProperties {

		/** Type of the origin */
		type: FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>,
	}
	export function CreateGetNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOriginFormGroup() {
		return new FormGroup<GetNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOriginFormProperties>({
			type: new FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceSingleLanReturnMandatoryDhcp {

		/** Enable Mandatory DHCP on single LAN. */
		enabled?: boolean | null;
	}
	export interface GetNetworkApplianceSingleLanReturnMandatoryDhcpFormProperties {

		/** Enable Mandatory DHCP on single LAN. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkApplianceSingleLanReturnMandatoryDhcpFormGroup() {
		return new FormGroup<GetNetworkApplianceSingleLanReturnMandatoryDhcpFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSingleLanPutBody {

		/** The appliance IP address of the single LAN */
		applianceIp?: string | null;

		/** IPv6 configuration on the VLAN */
		ipv6?: UpdateNetworkApplianceSingleLanPutBodyIpv6;

		/** Mandatory DHCP will enforce that clients connecting to this LAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above */
		mandatoryDhcp?: UpdateNetworkApplianceSingleLanPutBodyMandatoryDhcp;

		/** The subnet of the single LAN configuration */
		subnet?: string | null;
	}
	export interface UpdateNetworkApplianceSingleLanPutBodyFormProperties {

		/** The appliance IP address of the single LAN */
		applianceIp: FormControl<string | null | undefined>,

		/** The subnet of the single LAN configuration */
		subnet: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSingleLanPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSingleLanPutBodyFormProperties>({
			applianceIp: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSingleLanPutBodyIpv6 {

		/** Enable IPv6 on VLAN. */
		enabled?: boolean | null;

		/** Prefix assignments on the VLAN */
		UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignments?: Array<UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignments>;
	}
	export interface UpdateNetworkApplianceSingleLanPutBodyIpv6FormProperties {

		/** Enable IPv6 on VLAN. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSingleLanPutBodyIpv6FormGroup() {
		return new FormGroup<UpdateNetworkApplianceSingleLanPutBodyIpv6FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignments {

		/** Auto assign a /64 prefix from the origin to the VLAN */
		autonomous?: boolean | null;

		/** The origin of the prefix */
		origin?: UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignmentsOrigin;

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6?: string | null;

		/** Manual configuration of a /64 prefix on the VLAN */
		staticPrefix?: string | null;
	}
	export interface UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignmentsFormProperties {

		/** Auto assign a /64 prefix from the origin to the VLAN */
		autonomous: FormControl<boolean | null | undefined>,

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6: FormControl<string | null | undefined>,

		/** Manual configuration of a /64 prefix on the VLAN */
		staticPrefix: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignmentsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignmentsFormProperties>({
			autonomous: new FormControl<boolean | null | undefined>(undefined),
			staticApplianceIp6: new FormControl<string | null | undefined>(undefined),
			staticPrefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignmentsOrigin {

		/** Interfaces associated with the prefix */
		interfaces?: Array<string>;

		/**
		 * Type of the origin
		 * Required
		 */
		type: CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType;
	}
	export interface UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignmentsOriginFormProperties {

		/**
		 * Type of the origin
		 * Required
		 */
		type: FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignmentsOriginFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignmentsOriginFormProperties>({
			type: new FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceSingleLanPutBodyMandatoryDhcp {

		/** Enable Mandatory DHCP on LAN. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkApplianceSingleLanPutBodyMandatoryDhcpFormProperties {

		/** Enable Mandatory DHCP on LAN. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSingleLanPutBodyMandatoryDhcpFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSingleLanPutBodyMandatoryDhcpFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSingleLanReturn {

		/** The local IP of the appliance on the single LAN */
		applianceIp?: string | null;

		/** IPv6 configuration on the single LAN */
		ipv6?: UpdateNetworkApplianceSingleLanReturnIpv6;

		/** Mandatory DHCP will enforce that clients connecting to this single LAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above */
		mandatoryDhcp?: UpdateNetworkApplianceSingleLanReturnMandatoryDhcp;

		/** The subnet of the single LAN */
		subnet?: string | null;
	}
	export interface UpdateNetworkApplianceSingleLanReturnFormProperties {

		/** The local IP of the appliance on the single LAN */
		applianceIp: FormControl<string | null | undefined>,

		/** The subnet of the single LAN */
		subnet: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSingleLanReturnFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSingleLanReturnFormProperties>({
			applianceIp: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSingleLanReturnIpv6 {

		/** Enable IPv6 on single LAN */
		enabled?: boolean | null;

		/** Prefix assignments on the single LAN */
		UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignments?: Array<UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignments>;
	}
	export interface UpdateNetworkApplianceSingleLanReturnIpv6FormProperties {

		/** Enable IPv6 on single LAN */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSingleLanReturnIpv6FormGroup() {
		return new FormGroup<UpdateNetworkApplianceSingleLanReturnIpv6FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignments {

		/** Auto assign a /64 prefix from the origin to the single LAN */
		autonomous?: boolean | null;

		/** The origin of the prefix */
		origin?: UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOrigin;

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6?: string | null;

		/** Manual configuration of a /64 prefix on the single LAN */
		staticPrefix?: string | null;
	}
	export interface UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsFormProperties {

		/** Auto assign a /64 prefix from the origin to the single LAN */
		autonomous: FormControl<boolean | null | undefined>,

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6: FormControl<string | null | undefined>,

		/** Manual configuration of a /64 prefix on the single LAN */
		staticPrefix: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsFormProperties>({
			autonomous: new FormControl<boolean | null | undefined>(undefined),
			staticApplianceIp6: new FormControl<string | null | undefined>(undefined),
			staticPrefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOrigin {

		/** Interfaces associated with the prefix */
		interfaces?: Array<string>;

		/** Type of the origin */
		type?: CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null;
	}
	export interface UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOriginFormProperties {

		/** Type of the origin */
		type: FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOriginFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOriginFormProperties>({
			type: new FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSingleLanReturnMandatoryDhcp {

		/** Enable Mandatory DHCP on single LAN. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkApplianceSingleLanReturnMandatoryDhcpFormProperties {

		/** Enable Mandatory DHCP on single LAN. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSingleLanReturnMandatoryDhcpFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSingleLanReturnMandatoryDhcpFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceSsidsReturn {

		/** The association control method for the SSID. */
		authMode?: string | null;

		/** The VLAN ID of the VLAN associated to this SSID. */
		defaultVlanId?: number | null;

		/** Whether or not the SSID is enabled. */
		enabled?: boolean | null;

		/** The psk encryption mode for the SSID. */
		encryptionMode?: string | null;

		/** The name of the SSID. */
		name?: string | null;

		/** The number of the SSID. */
		number?: number | null;

		/** The RADIUS 802.1x servers to be used for authentication. */
		GetNetworkApplianceSsidsReturnRadiusServers?: Array<GetNetworkApplianceSsidsReturnRadiusServers>;

		/** Boolean indicating whether the MX should advertise or hide this SSID. */
		visible?: boolean | null;

		/** WPA encryption mode for the SSID. */
		wpaEncryptionMode?: string | null;
	}
	export interface GetNetworkApplianceSsidsReturnFormProperties {

		/** The association control method for the SSID. */
		authMode: FormControl<string | null | undefined>,

		/** The VLAN ID of the VLAN associated to this SSID. */
		defaultVlanId: FormControl<number | null | undefined>,

		/** Whether or not the SSID is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** The psk encryption mode for the SSID. */
		encryptionMode: FormControl<string | null | undefined>,

		/** The name of the SSID. */
		name: FormControl<string | null | undefined>,

		/** The number of the SSID. */
		number: FormControl<number | null | undefined>,

		/** Boolean indicating whether the MX should advertise or hide this SSID. */
		visible: FormControl<boolean | null | undefined>,

		/** WPA encryption mode for the SSID. */
		wpaEncryptionMode: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceSsidsReturnFormGroup() {
		return new FormGroup<GetNetworkApplianceSsidsReturnFormProperties>({
			authMode: new FormControl<string | null | undefined>(undefined),
			defaultVlanId: new FormControl<number | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			encryptionMode: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			number: new FormControl<number | null | undefined>(undefined),
			visible: new FormControl<boolean | null | undefined>(undefined),
			wpaEncryptionMode: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceSsidsReturnRadiusServers {

		/** The IP address of your RADIUS server. */
		host?: string | null;

		/** The UDP port your RADIUS servers listens on for Access-requests. */
		port?: number | null;
	}
	export interface GetNetworkApplianceSsidsReturnRadiusServersFormProperties {

		/** The IP address of your RADIUS server. */
		host: FormControl<string | null | undefined>,

		/** The UDP port your RADIUS servers listens on for Access-requests. */
		port: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkApplianceSsidsReturnRadiusServersFormGroup() {
		return new FormGroup<GetNetworkApplianceSsidsReturnRadiusServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceSsidReturn {

		/** The association control method for the SSID. */
		authMode?: string | null;

		/** The VLAN ID of the VLAN associated to this SSID. */
		defaultVlanId?: number | null;

		/** Whether or not the SSID is enabled. */
		enabled?: boolean | null;

		/** The psk encryption mode for the SSID. */
		encryptionMode?: string | null;

		/** The name of the SSID. */
		name?: string | null;

		/** The number of the SSID. */
		number?: number | null;

		/** The RADIUS 802.1x servers to be used for authentication. */
		GetNetworkApplianceSsidReturnRadiusServers?: Array<GetNetworkApplianceSsidReturnRadiusServers>;

		/** Boolean indicating whether the MX should advertise or hide this SSID. */
		visible?: boolean | null;

		/** WPA encryption mode for the SSID. */
		wpaEncryptionMode?: string | null;
	}
	export interface GetNetworkApplianceSsidReturnFormProperties {

		/** The association control method for the SSID. */
		authMode: FormControl<string | null | undefined>,

		/** The VLAN ID of the VLAN associated to this SSID. */
		defaultVlanId: FormControl<number | null | undefined>,

		/** Whether or not the SSID is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** The psk encryption mode for the SSID. */
		encryptionMode: FormControl<string | null | undefined>,

		/** The name of the SSID. */
		name: FormControl<string | null | undefined>,

		/** The number of the SSID. */
		number: FormControl<number | null | undefined>,

		/** Boolean indicating whether the MX should advertise or hide this SSID. */
		visible: FormControl<boolean | null | undefined>,

		/** WPA encryption mode for the SSID. */
		wpaEncryptionMode: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceSsidReturnFormGroup() {
		return new FormGroup<GetNetworkApplianceSsidReturnFormProperties>({
			authMode: new FormControl<string | null | undefined>(undefined),
			defaultVlanId: new FormControl<number | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			encryptionMode: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			number: new FormControl<number | null | undefined>(undefined),
			visible: new FormControl<boolean | null | undefined>(undefined),
			wpaEncryptionMode: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceSsidReturnRadiusServers {

		/** The IP address of your RADIUS server. */
		host?: string | null;

		/** The UDP port your RADIUS servers listens on for Access-requests. */
		port?: number | null;
	}
	export interface GetNetworkApplianceSsidReturnRadiusServersFormProperties {

		/** The IP address of your RADIUS server. */
		host: FormControl<string | null | undefined>,

		/** The UDP port your RADIUS servers listens on for Access-requests. */
		port: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkApplianceSsidReturnRadiusServersFormGroup() {
		return new FormGroup<GetNetworkApplianceSsidReturnRadiusServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSsidPutBody {

		/** The association control method for the SSID ('open', 'psk', '8021x-meraki' or '8021x-radius'). */
		authMode?: UpdateNetworkApplianceSsidPutBodyAuthMode | null;

		/** The VLAN ID of the VLAN associated to this SSID. This parameter is only valid if the network is in routed mode. */
		defaultVlanId?: number | null;

		/** DHCP Enforced Deauthentication enables the disassociation of wireless clients in addition to Mandatory DHCP. This param is only valid on firmware versions >= MX 17.0 where the associated LAN has Mandatory DHCP Enabled */
		dhcpEnforcedDeauthentication?: UpdateNetworkApplianceSsidPutBodyDhcpEnforcedDeauthentication;

		/** Whether or not the SSID is enabled. */
		enabled?: boolean | null;

		/** The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'. */
		encryptionMode?: UpdateNetworkApplianceSsidPutBodyEncryptionMode | null;

		/** The name of the SSID. */
		name?: string | null;

		/** The passkey for the SSID. This param is only valid if the authMode is 'psk'. */
		psk?: string | null;

		/** The RADIUS 802.1x servers to be used for authentication. This param is only valid if the authMode is '8021x-radius'. */
		UpdateNetworkApplianceSsidPutBodyRadiusServers?: Array<UpdateNetworkApplianceSsidPutBodyRadiusServers>;

		/** Boolean indicating whether the MX should advertise or hide this SSID. */
		visible?: boolean | null;

		/** The types of WPA encryption. ('WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only'). This param is only valid if (1) the authMode is 'psk' & the encryptionMode is 'wpa' OR (2) the authMode is '8021x-meraki' OR (3) the authMode is '8021x-radius' */
		wpaEncryptionMode?: UpdateNetworkApplianceSsidPutBodyWpaEncryptionMode | null;
	}
	export interface UpdateNetworkApplianceSsidPutBodyFormProperties {

		/** The association control method for the SSID ('open', 'psk', '8021x-meraki' or '8021x-radius'). */
		authMode: FormControl<UpdateNetworkApplianceSsidPutBodyAuthMode | null | undefined>,

		/** The VLAN ID of the VLAN associated to this SSID. This parameter is only valid if the network is in routed mode. */
		defaultVlanId: FormControl<number | null | undefined>,

		/** Whether or not the SSID is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'. */
		encryptionMode: FormControl<UpdateNetworkApplianceSsidPutBodyEncryptionMode | null | undefined>,

		/** The name of the SSID. */
		name: FormControl<string | null | undefined>,

		/** The passkey for the SSID. This param is only valid if the authMode is 'psk'. */
		psk: FormControl<string | null | undefined>,

		/** Boolean indicating whether the MX should advertise or hide this SSID. */
		visible: FormControl<boolean | null | undefined>,

		/** The types of WPA encryption. ('WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only'). This param is only valid if (1) the authMode is 'psk' & the encryptionMode is 'wpa' OR (2) the authMode is '8021x-meraki' OR (3) the authMode is '8021x-radius' */
		wpaEncryptionMode: FormControl<UpdateNetworkApplianceSsidPutBodyWpaEncryptionMode | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSsidPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSsidPutBodyFormProperties>({
			authMode: new FormControl<UpdateNetworkApplianceSsidPutBodyAuthMode | null | undefined>(undefined),
			defaultVlanId: new FormControl<number | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			encryptionMode: new FormControl<UpdateNetworkApplianceSsidPutBodyEncryptionMode | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			psk: new FormControl<string | null | undefined>(undefined),
			visible: new FormControl<boolean | null | undefined>(undefined),
			wpaEncryptionMode: new FormControl<UpdateNetworkApplianceSsidPutBodyWpaEncryptionMode | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkApplianceSsidPutBodyAuthMode { '8021x-meraki' = '8021x-meraki', '8021x-radius' = '8021x-radius', open = 'open', psk = 'psk' }

	export interface UpdateNetworkApplianceSsidPutBodyDhcpEnforcedDeauthentication {

		/** Enable DCHP Enforced Deauthentication on the SSID. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkApplianceSsidPutBodyDhcpEnforcedDeauthenticationFormProperties {

		/** Enable DCHP Enforced Deauthentication on the SSID. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSsidPutBodyDhcpEnforcedDeauthenticationFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSsidPutBodyDhcpEnforcedDeauthenticationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkApplianceSsidPutBodyEncryptionMode { wep = 'wep', wpa = 'wpa' }

	export interface UpdateNetworkApplianceSsidPutBodyRadiusServers {

		/** The IP address of your RADIUS server. */
		host?: string | null;

		/** The UDP port your RADIUS servers listens on for Access-requests. */
		port?: number | null;

		/** The RADIUS client shared secret. */
		secret?: string | null;
	}
	export interface UpdateNetworkApplianceSsidPutBodyRadiusServersFormProperties {

		/** The IP address of your RADIUS server. */
		host: FormControl<string | null | undefined>,

		/** The UDP port your RADIUS servers listens on for Access-requests. */
		port: FormControl<number | null | undefined>,

		/** The RADIUS client shared secret. */
		secret: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSsidPutBodyRadiusServersFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSsidPutBodyRadiusServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
			secret: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkApplianceSsidPutBodyWpaEncryptionMode { 'WPA1 and WPA2' = 'WPA1 and WPA2', 'WPA2 only' = 'WPA2 only', 'WPA3 Transition Mode' = 'WPA3 Transition Mode', 'WPA3 only' = 'WPA3 only' }

	export interface UpdateNetworkApplianceSsidReturn {

		/** The association control method for the SSID. */
		authMode?: string | null;

		/** The VLAN ID of the VLAN associated to this SSID. */
		defaultVlanId?: number | null;

		/** Whether or not the SSID is enabled. */
		enabled?: boolean | null;

		/** The psk encryption mode for the SSID. */
		encryptionMode?: string | null;

		/** The name of the SSID. */
		name?: string | null;

		/** The number of the SSID. */
		number?: number | null;

		/** The RADIUS 802.1x servers to be used for authentication. */
		UpdateNetworkApplianceSsidReturnRadiusServers?: Array<UpdateNetworkApplianceSsidReturnRadiusServers>;

		/** Boolean indicating whether the MX should advertise or hide this SSID. */
		visible?: boolean | null;

		/** WPA encryption mode for the SSID. */
		wpaEncryptionMode?: string | null;
	}
	export interface UpdateNetworkApplianceSsidReturnFormProperties {

		/** The association control method for the SSID. */
		authMode: FormControl<string | null | undefined>,

		/** The VLAN ID of the VLAN associated to this SSID. */
		defaultVlanId: FormControl<number | null | undefined>,

		/** Whether or not the SSID is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** The psk encryption mode for the SSID. */
		encryptionMode: FormControl<string | null | undefined>,

		/** The name of the SSID. */
		name: FormControl<string | null | undefined>,

		/** The number of the SSID. */
		number: FormControl<number | null | undefined>,

		/** Boolean indicating whether the MX should advertise or hide this SSID. */
		visible: FormControl<boolean | null | undefined>,

		/** WPA encryption mode for the SSID. */
		wpaEncryptionMode: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSsidReturnFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSsidReturnFormProperties>({
			authMode: new FormControl<string | null | undefined>(undefined),
			defaultVlanId: new FormControl<number | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			encryptionMode: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			number: new FormControl<number | null | undefined>(undefined),
			visible: new FormControl<boolean | null | undefined>(undefined),
			wpaEncryptionMode: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceSsidReturnRadiusServers {

		/** The IP address of your RADIUS server. */
		host?: string | null;

		/** The UDP port your RADIUS servers listens on for Access-requests. */
		port?: number | null;
	}
	export interface UpdateNetworkApplianceSsidReturnRadiusServersFormProperties {

		/** The IP address of your RADIUS server. */
		host: FormControl<string | null | undefined>,

		/** The UDP port your RADIUS servers listens on for Access-requests. */
		port: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceSsidReturnRadiusServersFormGroup() {
		return new FormGroup<UpdateNetworkApplianceSsidReturnRadiusServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkApplianceStaticRoutePostBody {

		/**
		 * The gateway IP (next hop) of the static route
		 * Required
		 */
		gatewayIp: string;

		/** The gateway IP (next hop) VLAN ID of the static route */
		gatewayVlanId?: string | null;

		/**
		 * The name of the new static route
		 * Required
		 */
		name: string;

		/**
		 * The subnet of the static route
		 * Required
		 */
		subnet: string;
	}
	export interface CreateNetworkApplianceStaticRoutePostBodyFormProperties {

		/**
		 * The gateway IP (next hop) of the static route
		 * Required
		 */
		gatewayIp: FormControl<string | null | undefined>,

		/** The gateway IP (next hop) VLAN ID of the static route */
		gatewayVlanId: FormControl<string | null | undefined>,

		/**
		 * The name of the new static route
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/**
		 * The subnet of the static route
		 * Required
		 */
		subnet: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkApplianceStaticRoutePostBodyFormGroup() {
		return new FormGroup<CreateNetworkApplianceStaticRoutePostBodyFormProperties>({
			gatewayIp: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			gatewayVlanId: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			subnet: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceStaticRoutePutBody {

		/** The enabled state of the static route */
		enabled?: boolean | null;

		/** The DHCP fixed IP assignments on the static route. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details. */
		fixedIpAssignments?: string | null;

		/** The gateway IP (next hop) of the static route */
		gatewayIp?: string | null;

		/** The gateway IP (next hop) VLAN ID of the static route */
		gatewayVlanId?: string | null;

		/** The name of the static route */
		name?: string | null;

		/** The DHCP reserved IP ranges on the static route */
		UpdateNetworkApplianceStaticRoutePutBodyReservedIpRanges?: Array<UpdateNetworkApplianceStaticRoutePutBodyReservedIpRanges>;

		/** The subnet of the static route */
		subnet?: string | null;
	}
	export interface UpdateNetworkApplianceStaticRoutePutBodyFormProperties {

		/** The enabled state of the static route */
		enabled: FormControl<boolean | null | undefined>,

		/** The DHCP fixed IP assignments on the static route. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details. */
		fixedIpAssignments: FormControl<string | null | undefined>,

		/** The gateway IP (next hop) of the static route */
		gatewayIp: FormControl<string | null | undefined>,

		/** The gateway IP (next hop) VLAN ID of the static route */
		gatewayVlanId: FormControl<string | null | undefined>,

		/** The name of the static route */
		name: FormControl<string | null | undefined>,

		/** The subnet of the static route */
		subnet: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceStaticRoutePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceStaticRoutePutBodyFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			fixedIpAssignments: new FormControl<string | null | undefined>(undefined),
			gatewayIp: new FormControl<string | null | undefined>(undefined),
			gatewayVlanId: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceStaticRoutePutBodyReservedIpRanges {

		/**
		 * A text comment for the reserved range
		 * Required
		 */
		comment: string;

		/**
		 * The last IP in the reserved range
		 * Required
		 */
		end: string;

		/**
		 * The first IP in the reserved range
		 * Required
		 */
		start: string;
	}
	export interface UpdateNetworkApplianceStaticRoutePutBodyReservedIpRangesFormProperties {

		/**
		 * A text comment for the reserved range
		 * Required
		 */
		comment: FormControl<string | null | undefined>,

		/**
		 * The last IP in the reserved range
		 * Required
		 */
		end: FormControl<string | null | undefined>,

		/**
		 * The first IP in the reserved range
		 * Required
		 */
		start: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceStaticRoutePutBodyReservedIpRangesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceStaticRoutePutBodyReservedIpRangesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			end: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			start: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingPutBody {

		/** Global per-client bandwidth limit */
		globalBandwidthLimits?: UpdateNetworkApplianceTrafficShapingPutBodyGlobalBandwidthLimits;
	}
	export interface UpdateNetworkApplianceTrafficShapingPutBodyFormProperties {
	}
	export function CreateUpdateNetworkApplianceTrafficShapingPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingPutBodyGlobalBandwidthLimits {

		/** The download bandwidth limit in Kbps. (0 represents no limit.) */
		limitDown?: number | null;

		/** The upload bandwidth limit in Kbps. (0 represents no limit.) */
		limitUp?: number | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingPutBodyGlobalBandwidthLimitsFormProperties {

		/** The download bandwidth limit in Kbps. (0 represents no limit.) */
		limitDown: FormControl<number | null | undefined>,

		/** The upload bandwidth limit in Kbps. (0 represents no limit.) */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingPutBodyGlobalBandwidthLimitsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingPutBodyGlobalBandwidthLimitsFormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkApplianceTrafficShapingCustomPerformanceClassPostBody {

		/** Maximum jitter in milliseconds */
		maxJitter?: number | null;

		/** Maximum latency in milliseconds */
		maxLatency?: number | null;

		/** Maximum percentage of packet loss */
		maxLossPercentage?: number | null;

		/**
		 * Name of the custom performance class
		 * Required
		 */
		name: string;
	}
	export interface CreateNetworkApplianceTrafficShapingCustomPerformanceClassPostBodyFormProperties {

		/** Maximum jitter in milliseconds */
		maxJitter: FormControl<number | null | undefined>,

		/** Maximum latency in milliseconds */
		maxLatency: FormControl<number | null | undefined>,

		/** Maximum percentage of packet loss */
		maxLossPercentage: FormControl<number | null | undefined>,

		/**
		 * Name of the custom performance class
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkApplianceTrafficShapingCustomPerformanceClassPostBodyFormGroup() {
		return new FormGroup<CreateNetworkApplianceTrafficShapingCustomPerformanceClassPostBodyFormProperties>({
			maxJitter: new FormControl<number | null | undefined>(undefined),
			maxLatency: new FormControl<number | null | undefined>(undefined),
			maxLossPercentage: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingCustomPerformanceClassPutBody {

		/** Maximum jitter in milliseconds */
		maxJitter?: number | null;

		/** Maximum latency in milliseconds */
		maxLatency?: number | null;

		/** Maximum percentage of packet loss */
		maxLossPercentage?: number | null;

		/** Name of the custom performance class */
		name?: string | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingCustomPerformanceClassPutBodyFormProperties {

		/** Maximum jitter in milliseconds */
		maxJitter: FormControl<number | null | undefined>,

		/** Maximum latency in milliseconds */
		maxLatency: FormControl<number | null | undefined>,

		/** Maximum percentage of packet loss */
		maxLossPercentage: FormControl<number | null | undefined>,

		/** Name of the custom performance class */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingCustomPerformanceClassPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingCustomPerformanceClassPutBodyFormProperties>({
			maxJitter: new FormControl<number | null | undefined>(undefined),
			maxLatency: new FormControl<number | null | undefined>(undefined),
			maxLossPercentage: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingRulesPutBody {

		/** Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8. */
		defaultRulesEnabled?: boolean | null;

		/**
		 * An array of traffic shaping rules. Rules are applied in the order that
		 * they are specified in. An empty list (or null) means no rules. Note that
		 * you are allowed a maximum of 8 rules.
		 */
		UpdateNetworkApplianceTrafficShapingRulesPutBodyRules?: Array<UpdateNetworkApplianceTrafficShapingRulesPutBodyRules>;
	}
	export interface UpdateNetworkApplianceTrafficShapingRulesPutBodyFormProperties {

		/** Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8. */
		defaultRulesEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingRulesPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingRulesPutBodyFormProperties>({
			defaultRulesEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingRulesPutBodyRules {

		/**
		 * A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
		 * Required
		 */
		UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitions: Array<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitions>;

		/**
		 * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
		 * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
		 */
		dscpTagValue?: number | null;

		/**
		 * An object describing the bandwidth settings for your rule.
		 */
		perClientBandwidthLimits?: UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimits;

		/**
		 * A string, indicating the priority level for packets bound to your rule.
		 * Can be 'low', 'normal' or 'high'.
		 */
		priority?: string | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesFormProperties {

		/**
		 * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
		 * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
		 */
		dscpTagValue: FormControl<number | null | undefined>,

		/**
		 * A string, indicating the priority level for packets bound to your rule.
		 * Can be 'low', 'normal' or 'high'.
		 */
		priority: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingRulesPutBodyRulesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesFormProperties>({
			dscpTagValue: new FormControl<number | null | undefined>(undefined),
			priority: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitions {

		/**
		 * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
		 * Required
		 */
		type: UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType;

		/**
		 * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
		 * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
		 * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
		 * custom ports.
		 * If "type" is 'application' or 'applicationCategory', then "value" must be an object
		 * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
		 * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
		 * endpoint).
		 * Required
		 */
		value: string;
	}
	export interface UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsFormProperties {

		/**
		 * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
		 * Required
		 */
		type: FormControl<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType | null | undefined>,

		/**
		 * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
		 * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
		 * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
		 * custom ports.
		 * If "type" is 'application' or 'applicationCategory', then "value" must be an object
		 * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
		 * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
		 * endpoint).
		 * Required
		 */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsFormProperties>({
			type: new FormControl<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType | null | undefined>(undefined, [Validators.required]),
			value: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType { application = 'application', applicationCategory = 'applicationCategory', host = 'host', ipRange = 'ipRange', localNet = 'localNet', port = 'port' }

	export interface UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimits {

		/** The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'. */
		bandwidthLimits?: UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimits;

		/** How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'. */
		settings?: string | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsFormProperties {

		/** How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'. */
		settings: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsFormProperties>({
			settings: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimits {

		/** The maximum download limit (integer, in Kbps). */
		limitDown?: number | null;

		/** The maximum upload limit (integer, in Kbps). */
		limitUp?: number | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimitsFormProperties {

		/** The maximum download limit (integer, in Kbps). */
		limitDown: FormControl<number | null | undefined>,

		/** The maximum upload limit (integer, in Kbps). */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimitsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimitsFormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkBandwidthReturn {

		/** A hash uplink keys and their configured settings for the Appliance */
		bandwidthLimits?: GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimits;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkBandwidthReturnFormProperties {
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkBandwidthReturnFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkBandwidthReturnFormProperties>({
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimits {

		/** uplink cellular configured limits [optional] */
		cellular?: GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsCellular;

		/** uplink wan1 configured limits [optional] */
		wan1?: GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan1;

		/** uplink wan2 configured limits [optional] */
		wan2?: GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan2;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsFormProperties {
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsFormProperties>({
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsCellular {

		/** configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited */
		limitDown?: number | null;

		/** configured UP limit for the uplink (in Kbps).  Null indicated unlimited */
		limitUp?: number | null;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsCellularFormProperties {

		/** configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited */
		limitDown: FormControl<number | null | undefined>,

		/** configured UP limit for the uplink (in Kbps).  Null indicated unlimited */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsCellularFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsCellularFormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan1 {

		/** configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited */
		limitDown?: number | null;

		/** configured UP limit for the uplink (in Kbps).  Null indicated unlimited */
		limitUp?: number | null;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan1FormProperties {

		/** configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited */
		limitDown: FormControl<number | null | undefined>,

		/** configured UP limit for the uplink (in Kbps).  Null indicated unlimited */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan1FormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan1FormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan2 {

		/** configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited */
		limitDown?: number | null;

		/** configured UP limit for the uplink (in Kbps).  Null indicated unlimited */
		limitUp?: number | null;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan2FormProperties {

		/** configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited */
		limitDown: FormControl<number | null | undefined>,

		/** configured UP limit for the uplink (in Kbps).  Null indicated unlimited */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan2FormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan2FormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBody {

		/** A mapping of uplinks to their bandwidth settings (be sure to check which uplinks are supported for your network) */
		bandwidthLimits?: UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimits;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyFormProperties {
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimits {

		/** The bandwidth settings for the 'cellular' uplink */
		cellular?: UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsCellular;

		/** The bandwidth settings for the 'wan1' uplink */
		wan1?: UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan1;

		/** The bandwidth settings for the 'wan2' uplink */
		wan2?: UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan2;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsFormProperties {
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsCellular {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown?: number | null;

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp?: number | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsCellularFormProperties {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown: FormControl<number | null | undefined>,

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsCellularFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsCellularFormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan1 {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown?: number | null;

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp?: number | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan1FormProperties {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown: FormControl<number | null | undefined>,

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan1FormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan1FormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan2 {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown?: number | null;

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp?: number | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan2FormProperties {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown: FormControl<number | null | undefined>,

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan2FormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan2FormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturn {

		/** Whether active-active AutoVPN is enabled */
		activeActiveAutoVpnEnabled?: boolean | null;

		/** The default uplink. Must be one of: 'wan1' or 'wan2' */
		defaultUplink?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null;

		/** WAN failover and failback */
		failoverAndFailback?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailback;

		/** Whether load balancing is enabled */
		loadBalancingEnabled?: boolean | null;

		/** Uplink preference rules for VPN traffic */
		GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferences?: Array<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferences>;

		/** Uplink preference rules for WAN traffic */
		GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferences?: Array<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferences>;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnFormProperties {

		/** Whether active-active AutoVPN is enabled */
		activeActiveAutoVpnEnabled: FormControl<boolean | null | undefined>,

		/** The default uplink. Must be one of: 'wan1' or 'wan2' */
		defaultUplink: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null | undefined>,

		/** Whether load balancing is enabled */
		loadBalancingEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnFormProperties>({
			activeActiveAutoVpnEnabled: new FormControl<boolean | null | undefined>(undefined),
			defaultUplink: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null | undefined>(undefined),
			loadBalancingEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink { wan1 = 'wan1', wan2 = 'wan2' }

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailback {

		/** Immediate WAN failover and failback */
		immediate?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediate;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackFormProperties {
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackFormProperties>({
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediate {

		/**
		 * Whether immediate WAN failover and failback is enabled
		 * Required
		 */
		enabled: boolean;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediateFormProperties {

		/**
		 * Whether immediate WAN failover and failback is enabled
		 * Required
		 */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediateFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediateFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferences {

		/** Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown' */
		failOverCriterion?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion | null;

		/** Performance class setting for uplink preference rule */
		performanceClass?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClass;

		/**
		 * Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
		 * Required
		 */
		preferredUplink: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink;

		/**
		 * Traffic filters
		 * Required
		 */
		GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFilters: Array<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFilters>;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFormProperties {

		/** Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown' */
		failOverCriterion: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion | null | undefined>,

		/**
		 * Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
		 * Required
		 */
		preferredUplink: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFormProperties>({
			failOverCriterion: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion | null | undefined>(undefined),
			preferredUplink: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion { poorPerformance = 'poorPerformance', uplinkDown = 'uplinkDown' }

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClass {

		/** Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP' */
		builtinPerformanceClassName?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName | null;

		/** ID of created custom performance class, must be present when performanceClass type is "custom" */
		customPerformanceClassId?: string | null;

		/**
		 * Type of this performance class. Must be one of: 'builtin' or 'custom'
		 * Required
		 */
		type: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassFormProperties {

		/** Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP' */
		builtinPerformanceClassName: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName | null | undefined>,

		/** ID of created custom performance class, must be present when performanceClass type is "custom" */
		customPerformanceClassId: FormControl<string | null | undefined>,

		/**
		 * Type of this performance class. Must be one of: 'builtin' or 'custom'
		 * Required
		 */
		type: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassFormProperties>({
			builtinPerformanceClassName: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName | null | undefined>(undefined),
			customPerformanceClassId: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName { VoIP = 'VoIP' }

	export enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType { builtin = 'builtin', custom = 'custom' }

	export enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink { bestForVoIP = 'bestForVoIP', defaultUplink = 'defaultUplink', loadBalancing = 'loadBalancing', wan1 = 'wan1', wan2 = 'wan2' }

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFilters {

		/**
		 * Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
		 * Required
		 */
		type: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType;

		/**
		 * Value of traffic filter
		 * Required
		 */
		value: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValue;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersFormProperties {

		/**
		 * Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
		 * Required
		 */
		type: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersFormProperties>({
			type: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType { application = 'application', applicationCategory = 'applicationCategory', custom = 'custom' }

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValue {

		/** Destination of 'custom' type traffic filter */
		destination?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestination;

		/** ID of 'applicationCategory' or 'application' type traffic filter */
		id?: string | null;

		/** Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any' */
		protocol?: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null;

		/** Source of 'custom' type traffic filter */
		source?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSource;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueFormProperties {

		/** ID of 'applicationCategory' or 'application' type traffic filter */
		id: FormControl<string | null | undefined>,

		/** Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any' */
		protocol: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			protocol: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestination {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property */
		cidr?: string | null;

		/** FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com" */
		fqdn?: string | null;

		/** Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network. */
		host?: number | null;

		/** Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678". */
		network?: string | null;

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port?: string | null;

		/** VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network. */
		vlan?: number | null;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestinationFormProperties {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property */
		cidr: FormControl<string | null | undefined>,

		/** FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com" */
		fqdn: FormControl<string | null | undefined>,

		/** Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network. */
		host: FormControl<number | null | undefined>,

		/** Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678". */
		network: FormControl<string | null | undefined>,

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port: FormControl<string | null | undefined>,

		/** VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestinationFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestinationFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			fqdn: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<number | null | undefined>(undefined),
			network: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSource {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property */
		cidr?: string | null;

		/** Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network. */
		host?: number | null;

		/** Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678". */
		network?: string | null;

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port?: string | null;

		/** VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network. */
		vlan?: number | null;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSourceFormProperties {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property */
		cidr: FormControl<string | null | undefined>,

		/** Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network. */
		host: FormControl<number | null | undefined>,

		/** Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678". */
		network: FormControl<string | null | undefined>,

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port: FormControl<string | null | undefined>,

		/** VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSourceFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSourceFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<number | null | undefined>(undefined),
			network: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferences {

		/**
		 * Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
		 * Required
		 */
		preferredUplink: GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink;

		/**
		 * Traffic filters
		 * Required
		 */
		GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFilters: Array<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFilters>;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesFormProperties {

		/**
		 * Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
		 * Required
		 */
		preferredUplink: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesFormProperties>({
			preferredUplink: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFilters {

		/**
		 * Traffic filter type. Must be "custom"
		 * Required
		 */
		type: GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType;

		/**
		 * Value of traffic filter
		 * Required
		 */
		value: GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValue;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersFormProperties {

		/**
		 * Traffic filter type. Must be "custom"
		 * Required
		 */
		type: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersFormProperties>({
			type: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType { custom = 'custom' }

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValue {

		/**
		 * Destination of 'custom' type traffic filter
		 * Required
		 */
		destination: GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestination;

		/** Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any' */
		protocol?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol | null;

		/**
		 * Source of 'custom' type traffic filter
		 * Required
		 */
		source: GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSource;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueFormProperties {

		/** Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any' */
		protocol: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueFormProperties>({
			protocol: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestination {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any" */
		cidr?: string | null;

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port?: string | null;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestinationFormProperties {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any" */
		cidr: FormControl<string | null | undefined>,

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestinationFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestinationFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol { any = 'any', icmp6 = 'icmp6', tcp = 'tcp', udp = 'udp' }

	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSource {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property */
		cidr?: string | null;

		/** Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network. */
		host?: number | null;

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port?: string | null;

		/** VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network. */
		vlan?: number | null;
	}
	export interface GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSourceFormProperties {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property */
		cidr: FormControl<string | null | undefined>,

		/** Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network. */
		host: FormControl<number | null | undefined>,

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port: FormControl<string | null | undefined>,

		/** VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSourceFormGroup() {
		return new FormGroup<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSourceFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<number | null | undefined>(undefined),
			port: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBody {

		/** Toggle for enabling or disabling active-active AutoVPN */
		activeActiveAutoVpnEnabled?: boolean | null;

		/** The default uplink. Must be one of: 'wan1' or 'wan2' */
		defaultUplink?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null;

		/** WAN failover and failback behavior */
		failoverAndFailback?: UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailback;

		/** Toggle for enabling or disabling load balancing */
		loadBalancingEnabled?: boolean | null;

		/** Array of uplink preference rules for VPN traffic */
		UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferences?: Array<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferences>;

		/** Array of uplink preference rules for WAN traffic */
		UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferences?: Array<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferences>;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFormProperties {

		/** Toggle for enabling or disabling active-active AutoVPN */
		activeActiveAutoVpnEnabled: FormControl<boolean | null | undefined>,

		/** The default uplink. Must be one of: 'wan1' or 'wan2' */
		defaultUplink: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null | undefined>,

		/** Toggle for enabling or disabling load balancing */
		loadBalancingEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFormProperties>({
			activeActiveAutoVpnEnabled: new FormControl<boolean | null | undefined>(undefined),
			defaultUplink: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null | undefined>(undefined),
			loadBalancingEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailback {

		/** Immediate WAN transition terminates all flows (new and existing) on current WAN when it is deemed unreliable. */
		immediate?: UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailbackImmediate;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailbackFormProperties {
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailbackFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailbackFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailbackImmediate {

		/**
		 * Toggle for enabling or disabling immediate WAN failover and failback
		 * Required
		 */
		enabled: boolean;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailbackImmediateFormProperties {

		/**
		 * Toggle for enabling or disabling immediate WAN failover and failback
		 * Required
		 */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailbackImmediateFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailbackImmediateFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferences {

		/** Fail over criterion for this uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown' */
		failOverCriterion?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion | null;

		/** Performance class setting for this uplink preference rule */
		performanceClass?: UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesPerformanceClass;

		/**
		 * Preferred uplink for this uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
		 * Required
		 */
		preferredUplink: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink;

		/**
		 * Array of traffic filters for this uplink preference rule
		 * Required
		 */
		UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFilters: Array<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFilters>;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesFormProperties {

		/** Fail over criterion for this uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown' */
		failOverCriterion: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion | null | undefined>,

		/**
		 * Preferred uplink for this uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
		 * Required
		 */
		preferredUplink: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesFormProperties>({
			failOverCriterion: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion | null | undefined>(undefined),
			preferredUplink: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesPerformanceClass {

		/** Name of builtin performance class, must be present when performanceClass type is 'builtin', and value must be one of: 'VoIP' */
		builtinPerformanceClassName?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName | null;

		/** ID of created custom performance class, must be present when performanceClass type is 'custom' */
		customPerformanceClassId?: string | null;

		/**
		 * Type of this performance class. Must be one of: 'builtin' or 'custom'
		 * Required
		 */
		type: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesPerformanceClassFormProperties {

		/** Name of builtin performance class, must be present when performanceClass type is 'builtin', and value must be one of: 'VoIP' */
		builtinPerformanceClassName: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName | null | undefined>,

		/** ID of created custom performance class, must be present when performanceClass type is 'custom' */
		customPerformanceClassId: FormControl<string | null | undefined>,

		/**
		 * Type of this performance class. Must be one of: 'builtin' or 'custom'
		 * Required
		 */
		type: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesPerformanceClassFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesPerformanceClassFormProperties>({
			builtinPerformanceClassName: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName | null | undefined>(undefined),
			customPerformanceClassId: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFilters {

		/**
		 * Type of this traffic filter. Must be one of: 'applicationCategory', 'application' or 'custom'
		 * Required
		 */
		type: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType;

		/**
		 * Value object of this traffic filter
		 * Required
		 */
		value: UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValue;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersFormProperties {

		/**
		 * Type of this traffic filter. Must be one of: 'applicationCategory', 'application' or 'custom'
		 * Required
		 */
		type: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersFormProperties>({
			type: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValue {

		/** Destination of this custom type traffic filter */
		destination?: UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueDestination;

		/** ID of this applicationCategory or application type traffic filter. E.g.: "meraki:layer7/category/1", "meraki:layer7/application/4" */
		id?: string | null;

		/** Protocol of this custom type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any' */
		protocol?: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null;

		/** Source of this custom type traffic filter */
		source?: UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueSource;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueFormProperties {

		/** ID of this applicationCategory or application type traffic filter. E.g.: "meraki:layer7/category/1", "meraki:layer7/application/4" */
		id: FormControl<string | null | undefined>,

		/** Protocol of this custom type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any' */
		protocol: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			protocol: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueDestination {

		/** CIDR format address, or "any". E.g.: "192.168.10.0/24",  "192.168.10.1" (same as "192.168.10.1/32"), "0.0.0.0/0" (same as "any") */
		cidr?: string | null;

		/** FQDN format address. Currently only availabe in 'destination' of 'vpnTrafficUplinkPreference' object. E.g.: 'www.google.com' */
		fqdn?: string | null;

		/** Host ID in the VLAN, should be used along with 'vlan', and not exceed the vlan subnet capacity. Currently only available under a template network. */
		host?: number | null;

		/** Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678". */
		network?: string | null;

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port?: string | null;

		/** VLAN ID of the configured VLAN in the Meraki network. Currently only available under a template network. */
		vlan?: number | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueDestinationFormProperties {

		/** CIDR format address, or "any". E.g.: "192.168.10.0/24",  "192.168.10.1" (same as "192.168.10.1/32"), "0.0.0.0/0" (same as "any") */
		cidr: FormControl<string | null | undefined>,

		/** FQDN format address. Currently only availabe in 'destination' of 'vpnTrafficUplinkPreference' object. E.g.: 'www.google.com' */
		fqdn: FormControl<string | null | undefined>,

		/** Host ID in the VLAN, should be used along with 'vlan', and not exceed the vlan subnet capacity. Currently only available under a template network. */
		host: FormControl<number | null | undefined>,

		/** Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678". */
		network: FormControl<string | null | undefined>,

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port: FormControl<string | null | undefined>,

		/** VLAN ID of the configured VLAN in the Meraki network. Currently only available under a template network. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueDestinationFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueDestinationFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			fqdn: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<number | null | undefined>(undefined),
			network: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueSource {

		/** CIDR format address, or "any". E.g.: "192.168.10.0/24",  "192.168.10.1" (same as "192.168.10.1/32"), "0.0.0.0/0" (same as "any") */
		cidr?: string | null;

		/** Host ID in the VLAN, should be used along with 'vlan', and not exceed the vlan subnet capacity. Currently only available under a template network. */
		host?: number | null;

		/** Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678". */
		network?: string | null;

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port?: string | null;

		/** VLAN ID of the configured VLAN in the Meraki network. Currently only available under a template network. */
		vlan?: number | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueSourceFormProperties {

		/** CIDR format address, or "any". E.g.: "192.168.10.0/24",  "192.168.10.1" (same as "192.168.10.1/32"), "0.0.0.0/0" (same as "any") */
		cidr: FormControl<string | null | undefined>,

		/** Host ID in the VLAN, should be used along with 'vlan', and not exceed the vlan subnet capacity. Currently only available under a template network. */
		host: FormControl<number | null | undefined>,

		/** Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678". */
		network: FormControl<string | null | undefined>,

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port: FormControl<string | null | undefined>,

		/** VLAN ID of the configured VLAN in the Meraki network. Currently only available under a template network. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueSourceFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueSourceFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<number | null | undefined>(undefined),
			network: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferences {

		/**
		 * Preferred uplink for this uplink preference rule. Must be one of: 'wan1' or 'wan2'
		 * Required
		 */
		preferredUplink: GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink;

		/**
		 * Array of traffic filters for this uplink preference rule
		 * Required
		 */
		UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFilters: Array<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFilters>;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesFormProperties {

		/**
		 * Preferred uplink for this uplink preference rule. Must be one of: 'wan1' or 'wan2'
		 * Required
		 */
		preferredUplink: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesFormProperties>({
			preferredUplink: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFilters {

		/**
		 * Type of this traffic filter. Must be one of: 'custom'
		 * Required
		 */
		type: GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType;

		/**
		 * Value object of this traffic filter
		 * Required
		 */
		value: UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValue;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersFormProperties {

		/**
		 * Type of this traffic filter. Must be one of: 'custom'
		 * Required
		 */
		type: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersFormProperties>({
			type: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValue {

		/**
		 * Destination of this custom type traffic filter
		 * Required
		 */
		destination: UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueDestination;

		/** Protocol of this custom type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any' */
		protocol?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol | null;

		/**
		 * Source of this custom type traffic filter
		 * Required
		 */
		source: UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueSource;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueFormProperties {

		/** Protocol of this custom type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any' */
		protocol: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueFormProperties>({
			protocol: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueDestination {

		/** CIDR format address, or "any". E.g.: "192.168.10.0/24",  "192.168.10.1" (same as "192.168.10.1/32"), "0.0.0.0/0" (same as "any") */
		cidr?: string | null;

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port?: string | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueDestinationFormProperties {

		/** CIDR format address, or "any". E.g.: "192.168.10.0/24",  "192.168.10.1" (same as "192.168.10.1/32"), "0.0.0.0/0" (same as "any") */
		cidr: FormControl<string | null | undefined>,

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueDestinationFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueDestinationFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueSource {

		/** CIDR format address, or "any". E.g.: "192.168.10.0/24",  "192.168.10.1" (same as "192.168.10.1/32"), "0.0.0.0/0" (same as "any") */
		cidr?: string | null;

		/** Host ID in the VLAN, should be used along with 'vlan', and not exceed the vlan subnet capacity. Currently only available under a template network. */
		host?: number | null;

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port?: string | null;

		/** VLAN ID of the configured VLAN in the Meraki network. Currently only available under a template network. */
		vlan?: number | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueSourceFormProperties {

		/** CIDR format address, or "any". E.g.: "192.168.10.0/24",  "192.168.10.1" (same as "192.168.10.1/32"), "0.0.0.0/0" (same as "any") */
		cidr: FormControl<string | null | undefined>,

		/** Host ID in the VLAN, should be used along with 'vlan', and not exceed the vlan subnet capacity. Currently only available under a template network. */
		host: FormControl<number | null | undefined>,

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port: FormControl<string | null | undefined>,

		/** VLAN ID of the configured VLAN in the Meraki network. Currently only available under a template network. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueSourceFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueSourceFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<number | null | undefined>(undefined),
			port: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturn {

		/** Whether active-active AutoVPN is enabled */
		activeActiveAutoVpnEnabled?: boolean | null;

		/** The default uplink. Must be one of: 'wan1' or 'wan2' */
		defaultUplink?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null;

		/** WAN failover and failback */
		failoverAndFailback?: UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailback;

		/** Whether load balancing is enabled */
		loadBalancingEnabled?: boolean | null;

		/** Uplink preference rules for VPN traffic */
		UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferences?: Array<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferences>;

		/** Uplink preference rules for WAN traffic */
		UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferences?: Array<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferences>;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFormProperties {

		/** Whether active-active AutoVPN is enabled */
		activeActiveAutoVpnEnabled: FormControl<boolean | null | undefined>,

		/** The default uplink. Must be one of: 'wan1' or 'wan2' */
		defaultUplink: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null | undefined>,

		/** Whether load balancing is enabled */
		loadBalancingEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFormProperties>({
			activeActiveAutoVpnEnabled: new FormControl<boolean | null | undefined>(undefined),
			defaultUplink: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null | undefined>(undefined),
			loadBalancingEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailback {

		/** Immediate WAN failover and failback */
		immediate?: UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediate;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackFormProperties {
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackFormProperties>({
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediate {

		/**
		 * Whether immediate WAN failover and failback is enabled
		 * Required
		 */
		enabled: boolean;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediateFormProperties {

		/**
		 * Whether immediate WAN failover and failback is enabled
		 * Required
		 */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediateFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediateFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferences {

		/** Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown' */
		failOverCriterion?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion | null;

		/** Performance class setting for uplink preference rule */
		performanceClass?: UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClass;

		/**
		 * Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
		 * Required
		 */
		preferredUplink: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink;

		/**
		 * Traffic filters
		 * Required
		 */
		UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFilters: Array<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFilters>;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFormProperties {

		/** Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown' */
		failOverCriterion: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion | null | undefined>,

		/**
		 * Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
		 * Required
		 */
		preferredUplink: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFormProperties>({
			failOverCriterion: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion | null | undefined>(undefined),
			preferredUplink: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClass {

		/** Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP' */
		builtinPerformanceClassName?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName | null;

		/** ID of created custom performance class, must be present when performanceClass type is "custom" */
		customPerformanceClassId?: string | null;

		/**
		 * Type of this performance class. Must be one of: 'builtin' or 'custom'
		 * Required
		 */
		type: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassFormProperties {

		/** Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP' */
		builtinPerformanceClassName: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName | null | undefined>,

		/** ID of created custom performance class, must be present when performanceClass type is "custom" */
		customPerformanceClassId: FormControl<string | null | undefined>,

		/**
		 * Type of this performance class. Must be one of: 'builtin' or 'custom'
		 * Required
		 */
		type: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassFormProperties>({
			builtinPerformanceClassName: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName | null | undefined>(undefined),
			customPerformanceClassId: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFilters {

		/**
		 * Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
		 * Required
		 */
		type: GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType;

		/**
		 * Value of traffic filter
		 * Required
		 */
		value: UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValue;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersFormProperties {

		/**
		 * Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
		 * Required
		 */
		type: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersFormProperties>({
			type: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValue {

		/** Destination of 'custom' type traffic filter */
		destination?: UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestination;

		/** ID of 'applicationCategory' or 'application' type traffic filter */
		id?: string | null;

		/** Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any' */
		protocol?: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null;

		/** Source of 'custom' type traffic filter */
		source?: UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSource;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueFormProperties {

		/** ID of 'applicationCategory' or 'application' type traffic filter */
		id: FormControl<string | null | undefined>,

		/** Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any' */
		protocol: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			protocol: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestination {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property */
		cidr?: string | null;

		/** FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com" */
		fqdn?: string | null;

		/** Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network. */
		host?: number | null;

		/** Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678". */
		network?: string | null;

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port?: string | null;

		/** VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network. */
		vlan?: number | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestinationFormProperties {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property */
		cidr: FormControl<string | null | undefined>,

		/** FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com" */
		fqdn: FormControl<string | null | undefined>,

		/** Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network. */
		host: FormControl<number | null | undefined>,

		/** Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678". */
		network: FormControl<string | null | undefined>,

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port: FormControl<string | null | undefined>,

		/** VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestinationFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestinationFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			fqdn: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<number | null | undefined>(undefined),
			network: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSource {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property */
		cidr?: string | null;

		/** Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network. */
		host?: number | null;

		/** Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678". */
		network?: string | null;

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port?: string | null;

		/** VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network. */
		vlan?: number | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSourceFormProperties {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property */
		cidr: FormControl<string | null | undefined>,

		/** Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network. */
		host: FormControl<number | null | undefined>,

		/** Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678". */
		network: FormControl<string | null | undefined>,

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port: FormControl<string | null | undefined>,

		/** VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSourceFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSourceFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<number | null | undefined>(undefined),
			network: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferences {

		/**
		 * Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
		 * Required
		 */
		preferredUplink: GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink;

		/**
		 * Traffic filters
		 * Required
		 */
		UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFilters: Array<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFilters>;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesFormProperties {

		/**
		 * Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
		 * Required
		 */
		preferredUplink: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesFormProperties>({
			preferredUplink: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFilters {

		/**
		 * Traffic filter type. Must be "custom"
		 * Required
		 */
		type: GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType;

		/**
		 * Value of traffic filter
		 * Required
		 */
		value: UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValue;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersFormProperties {

		/**
		 * Traffic filter type. Must be "custom"
		 * Required
		 */
		type: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersFormProperties>({
			type: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValue {

		/**
		 * Destination of 'custom' type traffic filter
		 * Required
		 */
		destination: UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestination;

		/** Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any' */
		protocol?: GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol | null;

		/**
		 * Source of 'custom' type traffic filter
		 * Required
		 */
		source: UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSource;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueFormProperties {

		/** Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any' */
		protocol: FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueFormProperties>({
			protocol: new FormControl<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestination {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any" */
		cidr?: string | null;

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port?: string | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestinationFormProperties {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any" */
		cidr: FormControl<string | null | undefined>,

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestinationFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestinationFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSource {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property */
		cidr?: string | null;

		/** Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network. */
		host?: number | null;

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port?: string | null;

		/** VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network. */
		vlan?: number | null;
	}
	export interface UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSourceFormProperties {

		/** CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property */
		cidr: FormControl<string | null | undefined>,

		/** Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network. */
		host: FormControl<number | null | undefined>,

		/** E.g.: "any", "0" (also means "any"), "8080", "1-1024" */
		port: FormControl<string | null | undefined>,

		/** VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSourceFormGroup() {
		return new FormGroup<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSourceFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<number | null | undefined>(undefined),
			port: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVlansReturn {

		/** The local IP of the appliance on the VLAN */
		applianceIp?: string | null;

		/** CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN. */
		cidr?: string | null;

		/** DHCP boot option for boot filename */
		dhcpBootFilename?: string | null;

		/** DHCP boot option to direct boot clients to the server to load the boot file from */
		dhcpBootNextServer?: string | null;

		/** Use DHCP boot options specified in other properties */
		dhcpBootOptionsEnabled?: boolean | null;

		/** The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests' */
		dhcpHandling?: GetNetworkApplianceVlansReturnDhcpHandling | null;

		/** The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week' */
		dhcpLeaseTime?: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null;

		/** The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties. */
		GetNetworkApplianceVlansReturnDhcpOptions?: Array<GetNetworkApplianceVlansReturnDhcpOptions>;

		/** The IPs of the DHCP servers that DHCP requests should be relayed to */
		dhcpRelayServerIps?: Array<string>;

		/** The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names */
		dnsNameservers?: string | null;

		/** The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details. */
		fixedIpAssignments?: string | null;

		/** The id of the desired group policy to apply to the VLAN */
		groupPolicyId?: string | null;

		/** The VLAN ID of the VLAN */
		id?: string | null;

		/** The interface ID of the VLAN */
		interfaceId?: string | null;

		/** IPv6 configuration on the VLAN */
		ipv6?: GetNetworkApplianceVlansReturnIpv6;

		/** Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above */
		mandatoryDhcp?: GetNetworkApplianceVlansReturnMandatoryDhcp;

		/** Mask used for the subnet of all bound to the template networks. Applicable only for template network. */
		mask?: number | null;

		/** The name of the VLAN */
		name?: string | null;

		/** The DHCP reserved IP ranges on the VLAN */
		GetNetworkApplianceVlansReturnReservedIpRanges?: Array<GetNetworkApplianceVlansReturnReservedIpRanges>;

		/** The subnet of the VLAN */
		subnet?: string | null;

		/** Type of subnetting of the VLAN. Applicable only for template network. */
		templateVlanType?: GetNetworkApplianceVlansReturnTemplateVlanType | null;

		/** The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN */
		vpnNatSubnet?: string | null;
	}
	export interface GetNetworkApplianceVlansReturnFormProperties {

		/** The local IP of the appliance on the VLAN */
		applianceIp: FormControl<string | null | undefined>,

		/** CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN. */
		cidr: FormControl<string | null | undefined>,

		/** DHCP boot option for boot filename */
		dhcpBootFilename: FormControl<string | null | undefined>,

		/** DHCP boot option to direct boot clients to the server to load the boot file from */
		dhcpBootNextServer: FormControl<string | null | undefined>,

		/** Use DHCP boot options specified in other properties */
		dhcpBootOptionsEnabled: FormControl<boolean | null | undefined>,

		/** The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests' */
		dhcpHandling: FormControl<GetNetworkApplianceVlansReturnDhcpHandling | null | undefined>,

		/** The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week' */
		dhcpLeaseTime: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>,

		/** The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names */
		dnsNameservers: FormControl<string | null | undefined>,

		/** The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details. */
		fixedIpAssignments: FormControl<string | null | undefined>,

		/** The id of the desired group policy to apply to the VLAN */
		groupPolicyId: FormControl<string | null | undefined>,

		/** The VLAN ID of the VLAN */
		id: FormControl<string | null | undefined>,

		/** The interface ID of the VLAN */
		interfaceId: FormControl<string | null | undefined>,

		/** Mask used for the subnet of all bound to the template networks. Applicable only for template network. */
		mask: FormControl<number | null | undefined>,

		/** The name of the VLAN */
		name: FormControl<string | null | undefined>,

		/** The subnet of the VLAN */
		subnet: FormControl<string | null | undefined>,

		/** Type of subnetting of the VLAN. Applicable only for template network. */
		templateVlanType: FormControl<GetNetworkApplianceVlansReturnTemplateVlanType | null | undefined>,

		/** The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN */
		vpnNatSubnet: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlansReturnFormGroup() {
		return new FormGroup<GetNetworkApplianceVlansReturnFormProperties>({
			applianceIp: new FormControl<string | null | undefined>(undefined),
			cidr: new FormControl<string | null | undefined>(undefined),
			dhcpBootFilename: new FormControl<string | null | undefined>(undefined),
			dhcpBootNextServer: new FormControl<string | null | undefined>(undefined),
			dhcpBootOptionsEnabled: new FormControl<boolean | null | undefined>(undefined),
			dhcpHandling: new FormControl<GetNetworkApplianceVlansReturnDhcpHandling | null | undefined>(undefined),
			dhcpLeaseTime: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>(undefined),
			dnsNameservers: new FormControl<string | null | undefined>(undefined),
			fixedIpAssignments: new FormControl<string | null | undefined>(undefined),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			interfaceId: new FormControl<string | null | undefined>(undefined),
			mask: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
			templateVlanType: new FormControl<GetNetworkApplianceVlansReturnTemplateVlanType | null | undefined>(undefined),
			vpnNatSubnet: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetNetworkApplianceVlansReturnDhcpHandling { 'Do not respond to DHCP requests' = 'Do not respond to DHCP requests', 'Relay DHCP to another server' = 'Relay DHCP to another server', 'Run a DHCP server' = 'Run a DHCP server' }

	export interface GetNetworkApplianceVlansReturnDhcpOptions {

		/**
		 * The code for the DHCP option. This should be an integer between 2 and 254.
		 * Required
		 */
		code: string;

		/**
		 * The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		 * Required
		 */
		type: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType;

		/**
		 * The value for the DHCP option
		 * Required
		 */
		value: string;
	}
	export interface GetNetworkApplianceVlansReturnDhcpOptionsFormProperties {

		/**
		 * The code for the DHCP option. This should be an integer between 2 and 254.
		 * Required
		 */
		code: FormControl<string | null | undefined>,

		/**
		 * The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		 * Required
		 */
		type: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType | null | undefined>,

		/**
		 * The value for the DHCP option
		 * Required
		 */
		value: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlansReturnDhcpOptionsFormGroup() {
		return new FormGroup<GetNetworkApplianceVlansReturnDhcpOptionsFormProperties>({
			code: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			type: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType | null | undefined>(undefined, [Validators.required]),
			value: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkApplianceVlansReturnIpv6 {

		/** Enable IPv6 on VLAN */
		enabled?: boolean | null;

		/** Prefix assignments on the VLAN */
		GetNetworkApplianceVlansReturnIpv6PrefixAssignments?: Array<GetNetworkApplianceVlansReturnIpv6PrefixAssignments>;
	}
	export interface GetNetworkApplianceVlansReturnIpv6FormProperties {

		/** Enable IPv6 on VLAN */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlansReturnIpv6FormGroup() {
		return new FormGroup<GetNetworkApplianceVlansReturnIpv6FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVlansReturnIpv6PrefixAssignments {

		/** Auto assign a /64 prefix from the origin to the VLAN */
		autonomous?: boolean | null;

		/** The origin of the prefix */
		origin?: GetNetworkApplianceVlansReturnIpv6PrefixAssignmentsOrigin;

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6?: string | null;

		/** Manual configuration of a /64 prefix on the VLAN */
		staticPrefix?: string | null;
	}
	export interface GetNetworkApplianceVlansReturnIpv6PrefixAssignmentsFormProperties {

		/** Auto assign a /64 prefix from the origin to the VLAN */
		autonomous: FormControl<boolean | null | undefined>,

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6: FormControl<string | null | undefined>,

		/** Manual configuration of a /64 prefix on the VLAN */
		staticPrefix: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlansReturnIpv6PrefixAssignmentsFormGroup() {
		return new FormGroup<GetNetworkApplianceVlansReturnIpv6PrefixAssignmentsFormProperties>({
			autonomous: new FormControl<boolean | null | undefined>(undefined),
			staticApplianceIp6: new FormControl<string | null | undefined>(undefined),
			staticPrefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVlansReturnIpv6PrefixAssignmentsOrigin {

		/** Interfaces associated with the prefix */
		interfaces?: Array<string>;

		/** Type of the origin */
		type?: CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null;
	}
	export interface GetNetworkApplianceVlansReturnIpv6PrefixAssignmentsOriginFormProperties {

		/** Type of the origin */
		type: FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlansReturnIpv6PrefixAssignmentsOriginFormGroup() {
		return new FormGroup<GetNetworkApplianceVlansReturnIpv6PrefixAssignmentsOriginFormProperties>({
			type: new FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVlansReturnMandatoryDhcp {

		/** Enable Mandatory DHCP on VLAN. */
		enabled?: boolean | null;
	}
	export interface GetNetworkApplianceVlansReturnMandatoryDhcpFormProperties {

		/** Enable Mandatory DHCP on VLAN. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlansReturnMandatoryDhcpFormGroup() {
		return new FormGroup<GetNetworkApplianceVlansReturnMandatoryDhcpFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVlansReturnReservedIpRanges {

		/** A text comment for the reserved range */
		comment?: string | null;

		/** The last IP in the reserved range */
		end?: string | null;

		/** The first IP in the reserved range */
		start?: string | null;
	}
	export interface GetNetworkApplianceVlansReturnReservedIpRangesFormProperties {

		/** A text comment for the reserved range */
		comment: FormControl<string | null | undefined>,

		/** The last IP in the reserved range */
		end: FormControl<string | null | undefined>,

		/** The first IP in the reserved range */
		start: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlansReturnReservedIpRangesFormGroup() {
		return new FormGroup<GetNetworkApplianceVlansReturnReservedIpRangesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			end: new FormControl<string | null | undefined>(undefined),
			start: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetNetworkApplianceVlansReturnTemplateVlanType { same = 'same', unique = 'unique' }

	export interface CreateNetworkApplianceVlanPostBody {

		/** The local IP of the appliance on the VLAN */
		applianceIp?: string | null;

		/** CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN. */
		cidr?: string | null;

		/** The id of the desired group policy to apply to the VLAN */
		groupPolicyId?: string | null;

		/**
		 * The VLAN ID of the new VLAN (must be between 1 and 4094)
		 * Required
		 */
		id: string;

		/** IPv6 configuration on the VLAN */
		ipv6?: CreateNetworkApplianceVlanPostBodyIpv6;

		/** Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above */
		mandatoryDhcp?: CreateNetworkApplianceVlanPostBodyMandatoryDhcp;

		/** Mask used for the subnet of all bound to the template networks. Applicable only for template network. */
		mask?: number | null;

		/**
		 * The name of the new VLAN
		 * Required
		 */
		name: string;

		/** The subnet of the VLAN */
		subnet?: string | null;

		/** Type of subnetting of the VLAN. Applicable only for template network. */
		templateVlanType?: GetNetworkApplianceVlansReturnTemplateVlanType | null;
	}
	export interface CreateNetworkApplianceVlanPostBodyFormProperties {

		/** The local IP of the appliance on the VLAN */
		applianceIp: FormControl<string | null | undefined>,

		/** CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN. */
		cidr: FormControl<string | null | undefined>,

		/** The id of the desired group policy to apply to the VLAN */
		groupPolicyId: FormControl<string | null | undefined>,

		/**
		 * The VLAN ID of the new VLAN (must be between 1 and 4094)
		 * Required
		 */
		id: FormControl<string | null | undefined>,

		/** Mask used for the subnet of all bound to the template networks. Applicable only for template network. */
		mask: FormControl<number | null | undefined>,

		/**
		 * The name of the new VLAN
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/** The subnet of the VLAN */
		subnet: FormControl<string | null | undefined>,

		/** Type of subnetting of the VLAN. Applicable only for template network. */
		templateVlanType: FormControl<GetNetworkApplianceVlansReturnTemplateVlanType | null | undefined>,
	}
	export function CreateCreateNetworkApplianceVlanPostBodyFormGroup() {
		return new FormGroup<CreateNetworkApplianceVlanPostBodyFormProperties>({
			applianceIp: new FormControl<string | null | undefined>(undefined),
			cidr: new FormControl<string | null | undefined>(undefined),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			mask: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			subnet: new FormControl<string | null | undefined>(undefined),
			templateVlanType: new FormControl<GetNetworkApplianceVlansReturnTemplateVlanType | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkApplianceVlanPostBodyIpv6 {

		/** Enable IPv6 on VLAN. */
		enabled?: boolean | null;

		/** Prefix assignments on the VLAN */
		CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignments?: Array<CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignments>;
	}
	export interface CreateNetworkApplianceVlanPostBodyIpv6FormProperties {

		/** Enable IPv6 on VLAN. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateNetworkApplianceVlanPostBodyIpv6FormGroup() {
		return new FormGroup<CreateNetworkApplianceVlanPostBodyIpv6FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignments {

		/** Auto assign a /64 prefix from the origin to the VLAN */
		autonomous?: boolean | null;

		/** The origin of the prefix */
		origin?: CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignmentsOrigin;

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6?: string | null;

		/** Manual configuration of a /64 prefix on the VLAN */
		staticPrefix?: string | null;
	}
	export interface CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignmentsFormProperties {

		/** Auto assign a /64 prefix from the origin to the VLAN */
		autonomous: FormControl<boolean | null | undefined>,

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6: FormControl<string | null | undefined>,

		/** Manual configuration of a /64 prefix on the VLAN */
		staticPrefix: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkApplianceVlanPostBodyIpv6PrefixAssignmentsFormGroup() {
		return new FormGroup<CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignmentsFormProperties>({
			autonomous: new FormControl<boolean | null | undefined>(undefined),
			staticApplianceIp6: new FormControl<string | null | undefined>(undefined),
			staticPrefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignmentsOrigin {

		/** Interfaces associated with the prefix */
		interfaces?: Array<string>;

		/**
		 * Type of the origin
		 * Required
		 */
		type: CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType;
	}
	export interface CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignmentsOriginFormProperties {

		/**
		 * Type of the origin
		 * Required
		 */
		type: FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>,
	}
	export function CreateCreateNetworkApplianceVlanPostBodyIpv6PrefixAssignmentsOriginFormGroup() {
		return new FormGroup<CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignmentsOriginFormProperties>({
			type: new FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkApplianceVlanPostBodyMandatoryDhcp {

		/** Enable Mandatory DHCP on VLAN. */
		enabled?: boolean | null;
	}
	export interface CreateNetworkApplianceVlanPostBodyMandatoryDhcpFormProperties {

		/** Enable Mandatory DHCP on VLAN. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateNetworkApplianceVlanPostBodyMandatoryDhcpFormGroup() {
		return new FormGroup<CreateNetworkApplianceVlanPostBodyMandatoryDhcpFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVlansSettingsPutBody {

		/** Boolean indicating whether to enable (true) or disable (false) VLANs for the network */
		vlansEnabled?: boolean | null;
	}
	export interface UpdateNetworkApplianceVlansSettingsPutBodyFormProperties {

		/** Boolean indicating whether to enable (true) or disable (false) VLANs for the network */
		vlansEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlansSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlansSettingsPutBodyFormProperties>({
			vlansEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVlanReturn {

		/** The local IP of the appliance on the VLAN */
		applianceIp?: string | null;

		/** CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN. */
		cidr?: string | null;

		/** DHCP boot option for boot filename */
		dhcpBootFilename?: string | null;

		/** DHCP boot option to direct boot clients to the server to load the boot file from */
		dhcpBootNextServer?: string | null;

		/** Use DHCP boot options specified in other properties */
		dhcpBootOptionsEnabled?: boolean | null;

		/** The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests' */
		dhcpHandling?: GetNetworkApplianceVlansReturnDhcpHandling | null;

		/** The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week' */
		dhcpLeaseTime?: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null;

		/** The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties. */
		GetNetworkApplianceVlanReturnDhcpOptions?: Array<GetNetworkApplianceVlanReturnDhcpOptions>;

		/** The IPs of the DHCP servers that DHCP requests should be relayed to */
		dhcpRelayServerIps?: Array<string>;

		/** The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names */
		dnsNameservers?: string | null;

		/** The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details. */
		fixedIpAssignments?: string | null;

		/** The id of the desired group policy to apply to the VLAN */
		groupPolicyId?: string | null;

		/** The VLAN ID of the VLAN */
		id?: string | null;

		/** The interface ID of the VLAN */
		interfaceId?: string | null;

		/** IPv6 configuration on the VLAN */
		ipv6?: GetNetworkApplianceVlanReturnIpv6;

		/** Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above */
		mandatoryDhcp?: GetNetworkApplianceVlanReturnMandatoryDhcp;

		/** Mask used for the subnet of all bound to the template networks. Applicable only for template network. */
		mask?: number | null;

		/** The name of the VLAN */
		name?: string | null;

		/** The DHCP reserved IP ranges on the VLAN */
		GetNetworkApplianceVlanReturnReservedIpRanges?: Array<GetNetworkApplianceVlanReturnReservedIpRanges>;

		/** The subnet of the VLAN */
		subnet?: string | null;

		/** Type of subnetting of the VLAN. Applicable only for template network. */
		templateVlanType?: GetNetworkApplianceVlansReturnTemplateVlanType | null;

		/** The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN */
		vpnNatSubnet?: string | null;
	}
	export interface GetNetworkApplianceVlanReturnFormProperties {

		/** The local IP of the appliance on the VLAN */
		applianceIp: FormControl<string | null | undefined>,

		/** CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN. */
		cidr: FormControl<string | null | undefined>,

		/** DHCP boot option for boot filename */
		dhcpBootFilename: FormControl<string | null | undefined>,

		/** DHCP boot option to direct boot clients to the server to load the boot file from */
		dhcpBootNextServer: FormControl<string | null | undefined>,

		/** Use DHCP boot options specified in other properties */
		dhcpBootOptionsEnabled: FormControl<boolean | null | undefined>,

		/** The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests' */
		dhcpHandling: FormControl<GetNetworkApplianceVlansReturnDhcpHandling | null | undefined>,

		/** The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week' */
		dhcpLeaseTime: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>,

		/** The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names */
		dnsNameservers: FormControl<string | null | undefined>,

		/** The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details. */
		fixedIpAssignments: FormControl<string | null | undefined>,

		/** The id of the desired group policy to apply to the VLAN */
		groupPolicyId: FormControl<string | null | undefined>,

		/** The VLAN ID of the VLAN */
		id: FormControl<string | null | undefined>,

		/** The interface ID of the VLAN */
		interfaceId: FormControl<string | null | undefined>,

		/** Mask used for the subnet of all bound to the template networks. Applicable only for template network. */
		mask: FormControl<number | null | undefined>,

		/** The name of the VLAN */
		name: FormControl<string | null | undefined>,

		/** The subnet of the VLAN */
		subnet: FormControl<string | null | undefined>,

		/** Type of subnetting of the VLAN. Applicable only for template network. */
		templateVlanType: FormControl<GetNetworkApplianceVlansReturnTemplateVlanType | null | undefined>,

		/** The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN */
		vpnNatSubnet: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlanReturnFormGroup() {
		return new FormGroup<GetNetworkApplianceVlanReturnFormProperties>({
			applianceIp: new FormControl<string | null | undefined>(undefined),
			cidr: new FormControl<string | null | undefined>(undefined),
			dhcpBootFilename: new FormControl<string | null | undefined>(undefined),
			dhcpBootNextServer: new FormControl<string | null | undefined>(undefined),
			dhcpBootOptionsEnabled: new FormControl<boolean | null | undefined>(undefined),
			dhcpHandling: new FormControl<GetNetworkApplianceVlansReturnDhcpHandling | null | undefined>(undefined),
			dhcpLeaseTime: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>(undefined),
			dnsNameservers: new FormControl<string | null | undefined>(undefined),
			fixedIpAssignments: new FormControl<string | null | undefined>(undefined),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			interfaceId: new FormControl<string | null | undefined>(undefined),
			mask: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
			templateVlanType: new FormControl<GetNetworkApplianceVlansReturnTemplateVlanType | null | undefined>(undefined),
			vpnNatSubnet: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVlanReturnDhcpOptions {

		/**
		 * The code for the DHCP option. This should be an integer between 2 and 254.
		 * Required
		 */
		code: string;

		/**
		 * The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		 * Required
		 */
		type: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType;

		/**
		 * The value for the DHCP option
		 * Required
		 */
		value: string;
	}
	export interface GetNetworkApplianceVlanReturnDhcpOptionsFormProperties {

		/**
		 * The code for the DHCP option. This should be an integer between 2 and 254.
		 * Required
		 */
		code: FormControl<string | null | undefined>,

		/**
		 * The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		 * Required
		 */
		type: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType | null | undefined>,

		/**
		 * The value for the DHCP option
		 * Required
		 */
		value: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlanReturnDhcpOptionsFormGroup() {
		return new FormGroup<GetNetworkApplianceVlanReturnDhcpOptionsFormProperties>({
			code: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			type: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType | null | undefined>(undefined, [Validators.required]),
			value: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkApplianceVlanReturnIpv6 {

		/** Enable IPv6 on VLAN */
		enabled?: boolean | null;

		/** Prefix assignments on the VLAN */
		GetNetworkApplianceVlanReturnIpv6PrefixAssignments?: Array<GetNetworkApplianceVlanReturnIpv6PrefixAssignments>;
	}
	export interface GetNetworkApplianceVlanReturnIpv6FormProperties {

		/** Enable IPv6 on VLAN */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlanReturnIpv6FormGroup() {
		return new FormGroup<GetNetworkApplianceVlanReturnIpv6FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVlanReturnIpv6PrefixAssignments {

		/** Auto assign a /64 prefix from the origin to the VLAN */
		autonomous?: boolean | null;

		/** The origin of the prefix */
		origin?: GetNetworkApplianceVlanReturnIpv6PrefixAssignmentsOrigin;

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6?: string | null;

		/** Manual configuration of a /64 prefix on the VLAN */
		staticPrefix?: string | null;
	}
	export interface GetNetworkApplianceVlanReturnIpv6PrefixAssignmentsFormProperties {

		/** Auto assign a /64 prefix from the origin to the VLAN */
		autonomous: FormControl<boolean | null | undefined>,

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6: FormControl<string | null | undefined>,

		/** Manual configuration of a /64 prefix on the VLAN */
		staticPrefix: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlanReturnIpv6PrefixAssignmentsFormGroup() {
		return new FormGroup<GetNetworkApplianceVlanReturnIpv6PrefixAssignmentsFormProperties>({
			autonomous: new FormControl<boolean | null | undefined>(undefined),
			staticApplianceIp6: new FormControl<string | null | undefined>(undefined),
			staticPrefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVlanReturnIpv6PrefixAssignmentsOrigin {

		/** Interfaces associated with the prefix */
		interfaces?: Array<string>;

		/** Type of the origin */
		type?: CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null;
	}
	export interface GetNetworkApplianceVlanReturnIpv6PrefixAssignmentsOriginFormProperties {

		/** Type of the origin */
		type: FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlanReturnIpv6PrefixAssignmentsOriginFormGroup() {
		return new FormGroup<GetNetworkApplianceVlanReturnIpv6PrefixAssignmentsOriginFormProperties>({
			type: new FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVlanReturnMandatoryDhcp {

		/** Enable Mandatory DHCP on VLAN. */
		enabled?: boolean | null;
	}
	export interface GetNetworkApplianceVlanReturnMandatoryDhcpFormProperties {

		/** Enable Mandatory DHCP on VLAN. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlanReturnMandatoryDhcpFormGroup() {
		return new FormGroup<GetNetworkApplianceVlanReturnMandatoryDhcpFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVlanReturnReservedIpRanges {

		/** A text comment for the reserved range */
		comment?: string | null;

		/** The last IP in the reserved range */
		end?: string | null;

		/** The first IP in the reserved range */
		start?: string | null;
	}
	export interface GetNetworkApplianceVlanReturnReservedIpRangesFormProperties {

		/** A text comment for the reserved range */
		comment: FormControl<string | null | undefined>,

		/** The last IP in the reserved range */
		end: FormControl<string | null | undefined>,

		/** The first IP in the reserved range */
		start: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceVlanReturnReservedIpRangesFormGroup() {
		return new FormGroup<GetNetworkApplianceVlanReturnReservedIpRangesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			end: new FormControl<string | null | undefined>(undefined),
			start: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVlanPutBody {

		/** The local IP of the appliance on the VLAN */
		applianceIp?: string | null;

		/** CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN. */
		cidr?: string | null;

		/** DHCP boot option for boot filename */
		dhcpBootFilename?: string | null;

		/** DHCP boot option to direct boot clients to the server to load the boot file from */
		dhcpBootNextServer?: string | null;

		/** Use DHCP boot options specified in other properties */
		dhcpBootOptionsEnabled?: boolean | null;

		/** The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests' */
		dhcpHandling?: GetNetworkApplianceVlansReturnDhcpHandling | null;

		/** The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week' */
		dhcpLeaseTime?: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null;

		/** The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties. */
		UpdateNetworkApplianceVlanPutBodyDhcpOptions?: Array<UpdateNetworkApplianceVlanPutBodyDhcpOptions>;

		/** The IPs of the DHCP servers that DHCP requests should be relayed to */
		dhcpRelayServerIps?: Array<string>;

		/** The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names */
		dnsNameservers?: string | null;

		/** The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details. */
		fixedIpAssignments?: string | null;

		/** The id of the desired group policy to apply to the VLAN */
		groupPolicyId?: string | null;

		/** IPv6 configuration on the VLAN */
		ipv6?: UpdateNetworkApplianceVlanPutBodyIpv6;

		/** Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above */
		mandatoryDhcp?: UpdateNetworkApplianceVlanPutBodyMandatoryDhcp;

		/** Mask used for the subnet of all bound to the template networks. Applicable only for template network. */
		mask?: number | null;

		/** The name of the VLAN */
		name?: string | null;

		/** The DHCP reserved IP ranges on the VLAN */
		UpdateNetworkApplianceVlanPutBodyReservedIpRanges?: Array<UpdateNetworkApplianceVlanPutBodyReservedIpRanges>;

		/** The subnet of the VLAN */
		subnet?: string | null;

		/** Type of subnetting of the VLAN. Applicable only for template network. */
		templateVlanType?: GetNetworkApplianceVlansReturnTemplateVlanType | null;

		/** The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN */
		vpnNatSubnet?: string | null;
	}
	export interface UpdateNetworkApplianceVlanPutBodyFormProperties {

		/** The local IP of the appliance on the VLAN */
		applianceIp: FormControl<string | null | undefined>,

		/** CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN. */
		cidr: FormControl<string | null | undefined>,

		/** DHCP boot option for boot filename */
		dhcpBootFilename: FormControl<string | null | undefined>,

		/** DHCP boot option to direct boot clients to the server to load the boot file from */
		dhcpBootNextServer: FormControl<string | null | undefined>,

		/** Use DHCP boot options specified in other properties */
		dhcpBootOptionsEnabled: FormControl<boolean | null | undefined>,

		/** The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests' */
		dhcpHandling: FormControl<GetNetworkApplianceVlansReturnDhcpHandling | null | undefined>,

		/** The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week' */
		dhcpLeaseTime: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>,

		/** The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names */
		dnsNameservers: FormControl<string | null | undefined>,

		/** The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details. */
		fixedIpAssignments: FormControl<string | null | undefined>,

		/** The id of the desired group policy to apply to the VLAN */
		groupPolicyId: FormControl<string | null | undefined>,

		/** Mask used for the subnet of all bound to the template networks. Applicable only for template network. */
		mask: FormControl<number | null | undefined>,

		/** The name of the VLAN */
		name: FormControl<string | null | undefined>,

		/** The subnet of the VLAN */
		subnet: FormControl<string | null | undefined>,

		/** Type of subnetting of the VLAN. Applicable only for template network. */
		templateVlanType: FormControl<GetNetworkApplianceVlansReturnTemplateVlanType | null | undefined>,

		/** The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN */
		vpnNatSubnet: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanPutBodyFormProperties>({
			applianceIp: new FormControl<string | null | undefined>(undefined),
			cidr: new FormControl<string | null | undefined>(undefined),
			dhcpBootFilename: new FormControl<string | null | undefined>(undefined),
			dhcpBootNextServer: new FormControl<string | null | undefined>(undefined),
			dhcpBootOptionsEnabled: new FormControl<boolean | null | undefined>(undefined),
			dhcpHandling: new FormControl<GetNetworkApplianceVlansReturnDhcpHandling | null | undefined>(undefined),
			dhcpLeaseTime: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>(undefined),
			dnsNameservers: new FormControl<string | null | undefined>(undefined),
			fixedIpAssignments: new FormControl<string | null | undefined>(undefined),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
			mask: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
			templateVlanType: new FormControl<GetNetworkApplianceVlansReturnTemplateVlanType | null | undefined>(undefined),
			vpnNatSubnet: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVlanPutBodyDhcpOptions {

		/**
		 * The code for the DHCP option. This should be an integer between 2 and 254.
		 * Required
		 */
		code: string;

		/**
		 * The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		 * Required
		 */
		type: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType;

		/**
		 * The value for the DHCP option
		 * Required
		 */
		value: string;
	}
	export interface UpdateNetworkApplianceVlanPutBodyDhcpOptionsFormProperties {

		/**
		 * The code for the DHCP option. This should be an integer between 2 and 254.
		 * Required
		 */
		code: FormControl<string | null | undefined>,

		/**
		 * The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		 * Required
		 */
		type: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType | null | undefined>,

		/**
		 * The value for the DHCP option
		 * Required
		 */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanPutBodyDhcpOptionsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanPutBodyDhcpOptionsFormProperties>({
			code: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			type: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType | null | undefined>(undefined, [Validators.required]),
			value: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceVlanPutBodyIpv6 {

		/** Enable IPv6 on VLAN. */
		enabled?: boolean | null;

		/** Prefix assignments on the VLAN */
		UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignments?: Array<UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignments>;
	}
	export interface UpdateNetworkApplianceVlanPutBodyIpv6FormProperties {

		/** Enable IPv6 on VLAN. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanPutBodyIpv6FormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanPutBodyIpv6FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignments {

		/** Auto assign a /64 prefix from the origin to the VLAN */
		autonomous?: boolean | null;

		/** The origin of the prefix */
		origin?: UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignmentsOrigin;

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6?: string | null;

		/** Manual configuration of a /64 prefix on the VLAN */
		staticPrefix?: string | null;
	}
	export interface UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignmentsFormProperties {

		/** Auto assign a /64 prefix from the origin to the VLAN */
		autonomous: FormControl<boolean | null | undefined>,

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6: FormControl<string | null | undefined>,

		/** Manual configuration of a /64 prefix on the VLAN */
		staticPrefix: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignmentsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignmentsFormProperties>({
			autonomous: new FormControl<boolean | null | undefined>(undefined),
			staticApplianceIp6: new FormControl<string | null | undefined>(undefined),
			staticPrefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignmentsOrigin {

		/** Interfaces associated with the prefix */
		interfaces?: Array<string>;

		/**
		 * Type of the origin
		 * Required
		 */
		type: CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType;
	}
	export interface UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignmentsOriginFormProperties {

		/**
		 * Type of the origin
		 * Required
		 */
		type: FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignmentsOriginFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignmentsOriginFormProperties>({
			type: new FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceVlanPutBodyMandatoryDhcp {

		/** Enable Mandatory DHCP on VLAN. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkApplianceVlanPutBodyMandatoryDhcpFormProperties {

		/** Enable Mandatory DHCP on VLAN. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanPutBodyMandatoryDhcpFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanPutBodyMandatoryDhcpFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVlanPutBodyReservedIpRanges {

		/**
		 * A text comment for the reserved range
		 * Required
		 */
		comment: string;

		/**
		 * The last IP in the reserved range
		 * Required
		 */
		end: string;

		/**
		 * The first IP in the reserved range
		 * Required
		 */
		start: string;
	}
	export interface UpdateNetworkApplianceVlanPutBodyReservedIpRangesFormProperties {

		/**
		 * A text comment for the reserved range
		 * Required
		 */
		comment: FormControl<string | null | undefined>,

		/**
		 * The last IP in the reserved range
		 * Required
		 */
		end: FormControl<string | null | undefined>,

		/**
		 * The first IP in the reserved range
		 * Required
		 */
		start: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanPutBodyReservedIpRangesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanPutBodyReservedIpRangesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			end: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			start: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceVlanReturn {

		/** The local IP of the appliance on the VLAN */
		applianceIp?: string | null;

		/** CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN. */
		cidr?: string | null;

		/** DHCP boot option for boot filename */
		dhcpBootFilename?: string | null;

		/** DHCP boot option to direct boot clients to the server to load the boot file from */
		dhcpBootNextServer?: string | null;

		/** Use DHCP boot options specified in other properties */
		dhcpBootOptionsEnabled?: boolean | null;

		/** The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests' */
		dhcpHandling?: GetNetworkApplianceVlansReturnDhcpHandling | null;

		/** The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week' */
		dhcpLeaseTime?: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null;

		/** The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties. */
		UpdateNetworkApplianceVlanReturnDhcpOptions?: Array<UpdateNetworkApplianceVlanReturnDhcpOptions>;

		/** The IPs of the DHCP servers that DHCP requests should be relayed to */
		dhcpRelayServerIps?: Array<string>;

		/** The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names */
		dnsNameservers?: string | null;

		/** The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details. */
		fixedIpAssignments?: string | null;

		/** The id of the desired group policy to apply to the VLAN */
		groupPolicyId?: string | null;

		/** The VLAN ID of the VLAN */
		id?: string | null;

		/** The interface ID of the VLAN */
		interfaceId?: string | null;

		/** IPv6 configuration on the VLAN */
		ipv6?: UpdateNetworkApplianceVlanReturnIpv6;

		/** Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above */
		mandatoryDhcp?: UpdateNetworkApplianceVlanReturnMandatoryDhcp;

		/** Mask used for the subnet of all bound to the template networks. Applicable only for template network. */
		mask?: number | null;

		/** The name of the VLAN */
		name?: string | null;

		/** The DHCP reserved IP ranges on the VLAN */
		UpdateNetworkApplianceVlanReturnReservedIpRanges?: Array<UpdateNetworkApplianceVlanReturnReservedIpRanges>;

		/** The subnet of the VLAN */
		subnet?: string | null;

		/** Type of subnetting of the VLAN. Applicable only for template network. */
		templateVlanType?: GetNetworkApplianceVlansReturnTemplateVlanType | null;

		/** The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN */
		vpnNatSubnet?: string | null;
	}
	export interface UpdateNetworkApplianceVlanReturnFormProperties {

		/** The local IP of the appliance on the VLAN */
		applianceIp: FormControl<string | null | undefined>,

		/** CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN. */
		cidr: FormControl<string | null | undefined>,

		/** DHCP boot option for boot filename */
		dhcpBootFilename: FormControl<string | null | undefined>,

		/** DHCP boot option to direct boot clients to the server to load the boot file from */
		dhcpBootNextServer: FormControl<string | null | undefined>,

		/** Use DHCP boot options specified in other properties */
		dhcpBootOptionsEnabled: FormControl<boolean | null | undefined>,

		/** The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests' */
		dhcpHandling: FormControl<GetNetworkApplianceVlansReturnDhcpHandling | null | undefined>,

		/** The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week' */
		dhcpLeaseTime: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>,

		/** The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names */
		dnsNameservers: FormControl<string | null | undefined>,

		/** The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details. */
		fixedIpAssignments: FormControl<string | null | undefined>,

		/** The id of the desired group policy to apply to the VLAN */
		groupPolicyId: FormControl<string | null | undefined>,

		/** The VLAN ID of the VLAN */
		id: FormControl<string | null | undefined>,

		/** The interface ID of the VLAN */
		interfaceId: FormControl<string | null | undefined>,

		/** Mask used for the subnet of all bound to the template networks. Applicable only for template network. */
		mask: FormControl<number | null | undefined>,

		/** The name of the VLAN */
		name: FormControl<string | null | undefined>,

		/** The subnet of the VLAN */
		subnet: FormControl<string | null | undefined>,

		/** Type of subnetting of the VLAN. Applicable only for template network. */
		templateVlanType: FormControl<GetNetworkApplianceVlansReturnTemplateVlanType | null | undefined>,

		/** The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN */
		vpnNatSubnet: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanReturnFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanReturnFormProperties>({
			applianceIp: new FormControl<string | null | undefined>(undefined),
			cidr: new FormControl<string | null | undefined>(undefined),
			dhcpBootFilename: new FormControl<string | null | undefined>(undefined),
			dhcpBootNextServer: new FormControl<string | null | undefined>(undefined),
			dhcpBootOptionsEnabled: new FormControl<boolean | null | undefined>(undefined),
			dhcpHandling: new FormControl<GetNetworkApplianceVlansReturnDhcpHandling | null | undefined>(undefined),
			dhcpLeaseTime: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>(undefined),
			dnsNameservers: new FormControl<string | null | undefined>(undefined),
			fixedIpAssignments: new FormControl<string | null | undefined>(undefined),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			interfaceId: new FormControl<string | null | undefined>(undefined),
			mask: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
			templateVlanType: new FormControl<GetNetworkApplianceVlansReturnTemplateVlanType | null | undefined>(undefined),
			vpnNatSubnet: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVlanReturnDhcpOptions {

		/**
		 * The code for the DHCP option. This should be an integer between 2 and 254.
		 * Required
		 */
		code: string;

		/**
		 * The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		 * Required
		 */
		type: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType;

		/**
		 * The value for the DHCP option
		 * Required
		 */
		value: string;
	}
	export interface UpdateNetworkApplianceVlanReturnDhcpOptionsFormProperties {

		/**
		 * The code for the DHCP option. This should be an integer between 2 and 254.
		 * Required
		 */
		code: FormControl<string | null | undefined>,

		/**
		 * The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		 * Required
		 */
		type: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType | null | undefined>,

		/**
		 * The value for the DHCP option
		 * Required
		 */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanReturnDhcpOptionsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanReturnDhcpOptionsFormProperties>({
			code: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			type: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType | null | undefined>(undefined, [Validators.required]),
			value: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceVlanReturnIpv6 {

		/** Enable IPv6 on VLAN */
		enabled?: boolean | null;

		/** Prefix assignments on the VLAN */
		UpdateNetworkApplianceVlanReturnIpv6PrefixAssignments?: Array<UpdateNetworkApplianceVlanReturnIpv6PrefixAssignments>;
	}
	export interface UpdateNetworkApplianceVlanReturnIpv6FormProperties {

		/** Enable IPv6 on VLAN */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanReturnIpv6FormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanReturnIpv6FormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVlanReturnIpv6PrefixAssignments {

		/** Auto assign a /64 prefix from the origin to the VLAN */
		autonomous?: boolean | null;

		/** The origin of the prefix */
		origin?: UpdateNetworkApplianceVlanReturnIpv6PrefixAssignmentsOrigin;

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6?: string | null;

		/** Manual configuration of a /64 prefix on the VLAN */
		staticPrefix?: string | null;
	}
	export interface UpdateNetworkApplianceVlanReturnIpv6PrefixAssignmentsFormProperties {

		/** Auto assign a /64 prefix from the origin to the VLAN */
		autonomous: FormControl<boolean | null | undefined>,

		/** Manual configuration of the IPv6 Appliance IP */
		staticApplianceIp6: FormControl<string | null | undefined>,

		/** Manual configuration of a /64 prefix on the VLAN */
		staticPrefix: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanReturnIpv6PrefixAssignmentsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanReturnIpv6PrefixAssignmentsFormProperties>({
			autonomous: new FormControl<boolean | null | undefined>(undefined),
			staticApplianceIp6: new FormControl<string | null | undefined>(undefined),
			staticPrefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVlanReturnIpv6PrefixAssignmentsOrigin {

		/** Interfaces associated with the prefix */
		interfaces?: Array<string>;

		/** Type of the origin */
		type?: CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null;
	}
	export interface UpdateNetworkApplianceVlanReturnIpv6PrefixAssignmentsOriginFormProperties {

		/** Type of the origin */
		type: FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanReturnIpv6PrefixAssignmentsOriginFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanReturnIpv6PrefixAssignmentsOriginFormProperties>({
			type: new FormControl<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVlanReturnMandatoryDhcp {

		/** Enable Mandatory DHCP on VLAN. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkApplianceVlanReturnMandatoryDhcpFormProperties {

		/** Enable Mandatory DHCP on VLAN. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanReturnMandatoryDhcpFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanReturnMandatoryDhcpFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVlanReturnReservedIpRanges {

		/** A text comment for the reserved range */
		comment?: string | null;

		/** The last IP in the reserved range */
		end?: string | null;

		/** The first IP in the reserved range */
		start?: string | null;
	}
	export interface UpdateNetworkApplianceVlanReturnReservedIpRangesFormProperties {

		/** A text comment for the reserved range */
		comment: FormControl<string | null | undefined>,

		/** The last IP in the reserved range */
		end: FormControl<string | null | undefined>,

		/** The first IP in the reserved range */
		start: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVlanReturnReservedIpRangesFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVlanReturnReservedIpRangesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			end: new FormControl<string | null | undefined>(undefined),
			start: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVpnBgpPutBody {

		/** An Autonomous System Number (ASN) is required if you are to run BGP and peer with another BGP Speaker outside of the Auto VPN domain. This ASN will be applied to the entire Auto VPN domain. The entire 4-byte ASN range is supported. So, the ASN must be an integer between 1 and 4294967295. When absent, this field is not updated. If no value exists then it defaults to 64512. */
		asNumber?: number | null;

		/**
		 * Boolean value to enable or disable the BGP configuration. When BGP is enabled, the asNumber (ASN) will be autopopulated with the preconfigured ASN at other Hubs or a default value if there is no ASN configured.
		 * Required
		 */
		enabled: boolean;

		/** The IBGP holdtimer in seconds. The IBGP holdtimer must be an integer between 12 and 240. When absent, this field is not updated. If no value exists then it defaults to 240. */
		ibgpHoldTimer?: number | null;

		/** List of BGP neighbors. This list replaces the existing set of neighbors. When absent, this field is not updated. */
		UpdateNetworkApplianceVpnBgpPutBodyNeighbors?: Array<UpdateNetworkApplianceVpnBgpPutBodyNeighbors>;
	}
	export interface UpdateNetworkApplianceVpnBgpPutBodyFormProperties {

		/** An Autonomous System Number (ASN) is required if you are to run BGP and peer with another BGP Speaker outside of the Auto VPN domain. This ASN will be applied to the entire Auto VPN domain. The entire 4-byte ASN range is supported. So, the ASN must be an integer between 1 and 4294967295. When absent, this field is not updated. If no value exists then it defaults to 64512. */
		asNumber: FormControl<number | null | undefined>,

		/**
		 * Boolean value to enable or disable the BGP configuration. When BGP is enabled, the asNumber (ASN) will be autopopulated with the preconfigured ASN at other Hubs or a default value if there is no ASN configured.
		 * Required
		 */
		enabled: FormControl<boolean | null | undefined>,

		/** The IBGP holdtimer in seconds. The IBGP holdtimer must be an integer between 12 and 240. When absent, this field is not updated. If no value exists then it defaults to 240. */
		ibgpHoldTimer: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVpnBgpPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVpnBgpPutBodyFormProperties>({
			asNumber: new FormControl<number | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
			ibgpHoldTimer: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVpnBgpPutBodyNeighbors {

		/** When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false. */
		allowTransit?: boolean | null;

		/**
		 * The EBGP hold timer in seconds for each neighbor. The EBGP hold timer must be an integer between 12 and 240.
		 * Required
		 */
		ebgpHoldTimer: number;

		/**
		 * Configure this if the neighbor is not adjacent. The EBGP multi-hop must be an integer between 1 and 255.
		 * Required
		 */
		ebgpMultihop: number;

		/** The IPv4 address of the neighbor */
		ip?: string | null;

		/** Information regarding IPv6 address of the neighbor, Required if `ip` is not present. */
		ipv6?: UpdateNetworkApplianceVpnBgpPutBodyNeighborsIpv6;

		/** The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0. */
		receiveLimit?: number | null;

		/**
		 * Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
		 * Required
		 */
		remoteAsNumber: number;
	}
	export interface UpdateNetworkApplianceVpnBgpPutBodyNeighborsFormProperties {

		/** When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false. */
		allowTransit: FormControl<boolean | null | undefined>,

		/**
		 * The EBGP hold timer in seconds for each neighbor. The EBGP hold timer must be an integer between 12 and 240.
		 * Required
		 */
		ebgpHoldTimer: FormControl<number | null | undefined>,

		/**
		 * Configure this if the neighbor is not adjacent. The EBGP multi-hop must be an integer between 1 and 255.
		 * Required
		 */
		ebgpMultihop: FormControl<number | null | undefined>,

		/** The IPv4 address of the neighbor */
		ip: FormControl<string | null | undefined>,

		/** The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0. */
		receiveLimit: FormControl<number | null | undefined>,

		/**
		 * Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
		 * Required
		 */
		remoteAsNumber: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVpnBgpPutBodyNeighborsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVpnBgpPutBodyNeighborsFormProperties>({
			allowTransit: new FormControl<boolean | null | undefined>(undefined),
			ebgpHoldTimer: new FormControl<number | null | undefined>(undefined, [Validators.required]),
			ebgpMultihop: new FormControl<number | null | undefined>(undefined, [Validators.required]),
			ip: new FormControl<string | null | undefined>(undefined),
			receiveLimit: new FormControl<number | null | undefined>(undefined),
			remoteAsNumber: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceVpnBgpPutBodyNeighborsIpv6 {

		/**
		 * The IPv6 address of the neighbor.
		 * Required
		 */
		address: string;
	}
	export interface UpdateNetworkApplianceVpnBgpPutBodyNeighborsIpv6FormProperties {

		/**
		 * The IPv6 address of the neighbor.
		 * Required
		 */
		address: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVpnBgpPutBodyNeighborsIpv6FormGroup() {
		return new FormGroup<UpdateNetworkApplianceVpnBgpPutBodyNeighborsIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkApplianceVpnSiteToSiteVpnReturn {

		/** The list of VPN hubs, in order of preference. */
		GetNetworkApplianceVpnSiteToSiteVpnReturnHubs?: Array<GetNetworkApplianceVpnSiteToSiteVpnReturnHubs>;

		/** The site-to-site VPN mode. */
		mode?: string | null;

		/** The list of subnets and their VPN presence. */
		GetNetworkApplianceVpnSiteToSiteVpnReturnSubnets?: Array<GetNetworkApplianceVpnSiteToSiteVpnReturnSubnets>;
	}
	export interface GetNetworkApplianceVpnSiteToSiteVpnReturnFormProperties {

		/** The site-to-site VPN mode. */
		mode: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkApplianceVpnSiteToSiteVpnReturnFormGroup() {
		return new FormGroup<GetNetworkApplianceVpnSiteToSiteVpnReturnFormProperties>({
			mode: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVpnSiteToSiteVpnReturnHubs {

		/** The network ID of the hub. */
		hubId?: string | null;

		/** Indicates whether default route traffic should be sent to this hub. */
		useDefaultRoute?: boolean | null;
	}
	export interface GetNetworkApplianceVpnSiteToSiteVpnReturnHubsFormProperties {

		/** The network ID of the hub. */
		hubId: FormControl<string | null | undefined>,

		/** Indicates whether default route traffic should be sent to this hub. */
		useDefaultRoute: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkApplianceVpnSiteToSiteVpnReturnHubsFormGroup() {
		return new FormGroup<GetNetworkApplianceVpnSiteToSiteVpnReturnHubsFormProperties>({
			hubId: new FormControl<string | null | undefined>(undefined),
			useDefaultRoute: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkApplianceVpnSiteToSiteVpnReturnSubnets {

		/** The CIDR notation subnet used within the VPN */
		localSubnet?: string | null;

		/** Indicates the presence of the subnet in the VPN */
		useVpn?: boolean | null;
	}
	export interface GetNetworkApplianceVpnSiteToSiteVpnReturnSubnetsFormProperties {

		/** The CIDR notation subnet used within the VPN */
		localSubnet: FormControl<string | null | undefined>,

		/** Indicates the presence of the subnet in the VPN */
		useVpn: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkApplianceVpnSiteToSiteVpnReturnSubnetsFormGroup() {
		return new FormGroup<GetNetworkApplianceVpnSiteToSiteVpnReturnSubnetsFormProperties>({
			localSubnet: new FormControl<string | null | undefined>(undefined),
			useVpn: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVpnSiteToSiteVpnPutBody {

		/** The list of VPN hubs, in order of preference. In spoke mode, at least 1 hub is required. */
		UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyHubs?: Array<UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyHubs>;

		/**
		 * The site-to-site VPN mode. Can be one of 'none', 'spoke' or 'hub'
		 * Required
		 */
		mode: UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyMode;

		/** The list of subnets and their VPN presence. */
		UpdateNetworkApplianceVpnSiteToSiteVpnPutBodySubnets?: Array<UpdateNetworkApplianceVpnSiteToSiteVpnPutBodySubnets>;
	}
	export interface UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyFormProperties {

		/**
		 * The site-to-site VPN mode. Can be one of 'none', 'spoke' or 'hub'
		 * Required
		 */
		mode: FormControl<UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyMode | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVpnSiteToSiteVpnPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyFormProperties>({
			mode: new FormControl<UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyMode | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyHubs {

		/**
		 * The network ID of the hub.
		 * Required
		 */
		hubId: string;

		/** Only valid in 'spoke' mode. Indicates whether default route traffic should be sent to this hub. */
		useDefaultRoute?: boolean | null;
	}
	export interface UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyHubsFormProperties {

		/**
		 * The network ID of the hub.
		 * Required
		 */
		hubId: FormControl<string | null | undefined>,

		/** Only valid in 'spoke' mode. Indicates whether default route traffic should be sent to this hub. */
		useDefaultRoute: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVpnSiteToSiteVpnPutBodyHubsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyHubsFormProperties>({
			hubId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			useDefaultRoute: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyMode { hub = 'hub', none = 'none', spoke = 'spoke' }

	export interface UpdateNetworkApplianceVpnSiteToSiteVpnPutBodySubnets {

		/**
		 * The CIDR notation subnet used within the VPN
		 * Required
		 */
		localSubnet: string;

		/** Indicates the presence of the subnet in the VPN */
		useVpn?: boolean | null;
	}
	export interface UpdateNetworkApplianceVpnSiteToSiteVpnPutBodySubnetsFormProperties {

		/**
		 * The CIDR notation subnet used within the VPN
		 * Required
		 */
		localSubnet: FormControl<string | null | undefined>,

		/** Indicates the presence of the subnet in the VPN */
		useVpn: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVpnSiteToSiteVpnPutBodySubnetsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVpnSiteToSiteVpnPutBodySubnetsFormProperties>({
			localSubnet: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			useVpn: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVpnSiteToSiteVpnReturn {

		/** The list of VPN hubs, in order of preference. */
		UpdateNetworkApplianceVpnSiteToSiteVpnReturnHubs?: Array<UpdateNetworkApplianceVpnSiteToSiteVpnReturnHubs>;

		/** The site-to-site VPN mode. */
		mode?: string | null;

		/** The list of subnets and their VPN presence. */
		UpdateNetworkApplianceVpnSiteToSiteVpnReturnSubnets?: Array<UpdateNetworkApplianceVpnSiteToSiteVpnReturnSubnets>;
	}
	export interface UpdateNetworkApplianceVpnSiteToSiteVpnReturnFormProperties {

		/** The site-to-site VPN mode. */
		mode: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVpnSiteToSiteVpnReturnFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVpnSiteToSiteVpnReturnFormProperties>({
			mode: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVpnSiteToSiteVpnReturnHubs {

		/** The network ID of the hub. */
		hubId?: string | null;

		/** Indicates whether default route traffic should be sent to this hub. */
		useDefaultRoute?: boolean | null;
	}
	export interface UpdateNetworkApplianceVpnSiteToSiteVpnReturnHubsFormProperties {

		/** The network ID of the hub. */
		hubId: FormControl<string | null | undefined>,

		/** Indicates whether default route traffic should be sent to this hub. */
		useDefaultRoute: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVpnSiteToSiteVpnReturnHubsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVpnSiteToSiteVpnReturnHubsFormProperties>({
			hubId: new FormControl<string | null | undefined>(undefined),
			useDefaultRoute: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceVpnSiteToSiteVpnReturnSubnets {

		/** The CIDR notation subnet used within the VPN */
		localSubnet?: string | null;

		/** Indicates the presence of the subnet in the VPN */
		useVpn?: boolean | null;
	}
	export interface UpdateNetworkApplianceVpnSiteToSiteVpnReturnSubnetsFormProperties {

		/** The CIDR notation subnet used within the VPN */
		localSubnet: FormControl<string | null | undefined>,

		/** Indicates the presence of the subnet in the VPN */
		useVpn: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceVpnSiteToSiteVpnReturnSubnetsFormGroup() {
		return new FormGroup<UpdateNetworkApplianceVpnSiteToSiteVpnReturnSubnetsFormProperties>({
			localSubnet: new FormControl<string | null | undefined>(undefined),
			useVpn: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkApplianceWarmSparePutBody {

		/**
		 * Enable warm spare
		 * Required
		 */
		enabled: boolean;

		/** Serial number of the warm spare appliance */
		spareSerial?: string | null;

		/** Uplink mode, either virtual or public */
		uplinkMode?: string | null;

		/** The WAN 1 shared IP */
		virtualIp1?: string | null;

		/** The WAN 2 shared IP */
		virtualIp2?: string | null;
	}
	export interface UpdateNetworkApplianceWarmSparePutBodyFormProperties {

		/**
		 * Enable warm spare
		 * Required
		 */
		enabled: FormControl<boolean | null | undefined>,

		/** Serial number of the warm spare appliance */
		spareSerial: FormControl<string | null | undefined>,

		/** Uplink mode, either virtual or public */
		uplinkMode: FormControl<string | null | undefined>,

		/** The WAN 1 shared IP */
		virtualIp1: FormControl<string | null | undefined>,

		/** The WAN 2 shared IP */
		virtualIp2: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkApplianceWarmSparePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkApplianceWarmSparePutBodyFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
			spareSerial: new FormControl<string | null | undefined>(undefined),
			uplinkMode: new FormControl<string | null | undefined>(undefined),
			virtualIp1: new FormControl<string | null | undefined>(undefined),
			virtualIp2: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface BindNetworkPostBody {

		/** Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model. */
		autoBind?: boolean | null;

		/**
		 * The ID of the template to which the network should be bound.
		 * Required
		 */
		configTemplateId: string;
	}
	export interface BindNetworkPostBodyFormProperties {

		/** Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model. */
		autoBind: FormControl<boolean | null | undefined>,

		/**
		 * The ID of the template to which the network should be bound.
		 * Required
		 */
		configTemplateId: FormControl<string | null | undefined>,
	}
	export function CreateBindNetworkPostBodyFormGroup() {
		return new FormGroup<BindNetworkPostBodyFormProperties>({
			autoBind: new FormControl<boolean | null | undefined>(undefined),
			configTemplateId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkCameraQualityRetentionProfilePostBody {

		/** Whether or not to record audio. Can be either true or false. Defaults to false. */
		audioRecordingEnabled?: boolean | null;

		/** Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false. */
		cloudArchiveEnabled?: boolean | null;

		/** The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days. */
		maxRetentionDays?: number | null;

		/** Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras. */
		motionBasedRetentionEnabled?: boolean | null;

		/** The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2. */
		motionDetectorVersion?: number | null;

		/**
		 * The name of the new profile. Must be unique. This parameter is required.
		 * Required
		 */
		name: string;

		/** Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras. */
		restrictedBandwidthModeEnabled?: boolean | null;

		/** Schedule for which this camera will record video, or 'null' to always record. */
		scheduleId?: string | null;

		/** Video quality and resolution settings for all the camera models. */
		videoSettings?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyFormProperties {

		/** Whether or not to record audio. Can be either true or false. Defaults to false. */
		audioRecordingEnabled: FormControl<boolean | null | undefined>,

		/** Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false. */
		cloudArchiveEnabled: FormControl<boolean | null | undefined>,

		/** The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days. */
		maxRetentionDays: FormControl<number | null | undefined>,

		/** Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras. */
		motionBasedRetentionEnabled: FormControl<boolean | null | undefined>,

		/** The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2. */
		motionDetectorVersion: FormControl<number | null | undefined>,

		/**
		 * The name of the new profile. Must be unique. This parameter is required.
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/** Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras. */
		restrictedBandwidthModeEnabled: FormControl<boolean | null | undefined>,

		/** Schedule for which this camera will record video, or 'null' to always record. */
		scheduleId: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyFormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyFormProperties>({
			audioRecordingEnabled: new FormControl<boolean | null | undefined>(undefined),
			cloudArchiveEnabled: new FormControl<boolean | null | undefined>(undefined),
			maxRetentionDays: new FormControl<number | null | undefined>(undefined),
			motionBasedRetentionEnabled: new FormControl<boolean | null | undefined>(undefined),
			motionDetectorVersion: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			restrictedBandwidthModeEnabled: new FormControl<boolean | null | undefined>(undefined),
			scheduleId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings {

		/** Quality and resolution for MV12/MV22/MV72 camera models. */
		'MV12/MV22/MV72'?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_;

		/** Quality and resolution for MV12WE camera models. */
		MV12WE?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WE;

		/** Quality and resolution for MV13 camera models. */
		MV13?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13;

		/** Quality and resolution for MV21/MV71 camera models. */
		'MV21/MV71'?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV21SlashMV71_;

		/** Quality and resolution for MV22X/MV72X camera models. */
		'MV22X/MV72X'?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV22XSlashMV72X_;

		/** Quality and resolution for MV32 camera models. */
		MV32?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32;

		/** Quality and resolution for MV33 camera models. */
		MV33?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33;

		/** Quality and resolution for MV52 camera models. */
		MV52?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52;

		/** Quality and resolution for MV63 camera models. */
		MV63?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63;

		/** Quality and resolution for MV63X camera models. */
		MV63X?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63X;

		/** Quality and resolution for MV93 camera models. */
		MV93?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93;

		/** Quality and resolution for MV93X camera models. */
		MV93X?: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93X;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsFormProperties {
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsFormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsFormProperties>({
		});

	}

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_ {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_FormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution { '1280x720' = '1280x720', '1920x1080' = '1920x1080' }

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WE {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WEFormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WEFormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WEFormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13 {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2688x1512'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13Resolution;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2688x1512'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13Resolution | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13FormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13Resolution { '1080x1080' = '1080x1080', '2688x1512' = '2688x1512' }

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV21SlashMV71_ {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1280x720'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV21SlashMV71_Resolution;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV21SlashMV71_FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1280x720'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV21SlashMV71_Resolution | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV21SlashMV71_FormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV21SlashMV71_FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV21SlashMV71_Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV21SlashMV71_Resolution { '1280x720' = '1280x720' }

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV22XSlashMV72X_ {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV22XSlashMV72X_Resolution;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV22XSlashMV72X_FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV22XSlashMV72X_Resolution | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV22XSlashMV72X_FormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV22XSlashMV72X_FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV22XSlashMV72X_Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV22XSlashMV72X_Resolution { '1280x720' = '1280x720', '1920x1080' = '1920x1080', '2688x1512' = '2688x1512' }

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32 {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2058x2058'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32Resolution;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2058x2058'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32Resolution | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32FormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32Resolution { '1080x1080' = '1080x1080', '2058x2058' = '2058x2058' }

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33 {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33FormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution { '1080x1080' = '1080x1080', '2112x2112' = '2112x2112' }

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52 {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52Resolution;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52Resolution | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52FormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52Resolution { '1280x720' = '1280x720', '1920x1080' = '1920x1080', '2688x1512' = '2688x1512', '3840x2160' = '3840x2160' }

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63 {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63Resolution;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63Resolution | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63FormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63Resolution { '1920x1080' = '1920x1080', '2688x1512' = '2688x1512' }

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63X {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XResolution;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XFormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XResolution | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XFormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XFormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XResolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XResolution { '1920x1080' = '1920x1080', '2688x1512' = '2688x1512', '3840x2160' = '3840x2160' }

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93 {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93FormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93X {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XResolution;
	}
	export interface CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XFormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XResolution | null | undefined>,
	}
	export function CreateCreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XFormGroup() {
		return new FormGroup<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XFormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XResolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XResolution { '1080x1080' = '1080x1080', '2112x2112' = '2112x2112', '2880x2880' = '2880x2880' }

	export interface UpdateNetworkCameraQualityRetentionProfilePutBody {

		/** Whether or not to record audio. Can be either true or false. Defaults to false. */
		audioRecordingEnabled?: boolean | null;

		/** Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false. */
		cloudArchiveEnabled?: boolean | null;

		/** The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days. */
		maxRetentionDays?: number | null;

		/** Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras. */
		motionBasedRetentionEnabled?: boolean | null;

		/** The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2. */
		motionDetectorVersion?: number | null;

		/** The name of the new profile. Must be unique. */
		name?: string | null;

		/** Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras. */
		restrictedBandwidthModeEnabled?: boolean | null;

		/** Schedule for which this camera will record video, or 'null' to always record. */
		scheduleId?: string | null;

		/** Video quality and resolution settings for all the camera models. */
		videoSettings?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyFormProperties {

		/** Whether or not to record audio. Can be either true or false. Defaults to false. */
		audioRecordingEnabled: FormControl<boolean | null | undefined>,

		/** Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false. */
		cloudArchiveEnabled: FormControl<boolean | null | undefined>,

		/** The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days. */
		maxRetentionDays: FormControl<number | null | undefined>,

		/** Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras. */
		motionBasedRetentionEnabled: FormControl<boolean | null | undefined>,

		/** The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2. */
		motionDetectorVersion: FormControl<number | null | undefined>,

		/** The name of the new profile. Must be unique. */
		name: FormControl<string | null | undefined>,

		/** Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras. */
		restrictedBandwidthModeEnabled: FormControl<boolean | null | undefined>,

		/** Schedule for which this camera will record video, or 'null' to always record. */
		scheduleId: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyFormProperties>({
			audioRecordingEnabled: new FormControl<boolean | null | undefined>(undefined),
			cloudArchiveEnabled: new FormControl<boolean | null | undefined>(undefined),
			maxRetentionDays: new FormControl<number | null | undefined>(undefined),
			motionBasedRetentionEnabled: new FormControl<boolean | null | undefined>(undefined),
			motionDetectorVersion: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			restrictedBandwidthModeEnabled: new FormControl<boolean | null | undefined>(undefined),
			scheduleId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings {

		/** Quality and resolution for MV12/MV22/MV72 camera models. */
		'MV12/MV22/MV72'?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV12SlashMV22SlashMV72_;

		/** Quality and resolution for MV12WE camera models. */
		MV12WE?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WE;

		/** Quality and resolution for MV13 camera models. */
		MV13?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13;

		/** Quality and resolution for MV21/MV71 camera models. */
		'MV21/MV71'?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV21SlashMV71_;

		/** Quality and resolution for MV22X/MV72X camera models. */
		'MV22X/MV72X'?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV22XSlashMV72X_;

		/** Quality and resolution for MV32 camera models. */
		MV32?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32;

		/** Quality and resolution for MV33 camera models. */
		MV33?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33;

		/** Quality and resolution for MV52 camera models. */
		MV52?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52;

		/** Quality and resolution for MV63 camera models. */
		MV63?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63;

		/** Quality and resolution for MV63X camera models. */
		MV63X?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63X;

		/** Quality and resolution for MV93 camera models. */
		MV93?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93;

		/** Quality and resolution for MV93X camera models. */
		MV93X?: UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93X;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsFormProperties {
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsFormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsFormProperties>({
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV12SlashMV22SlashMV72_ {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV12SlashMV22SlashMV72_FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV12SlashMV22SlashMV72_FormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV12SlashMV22SlashMV72_FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WE {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WEFormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WEFormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WEFormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV12SlashMV22SlashMV72_Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13 {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2688x1512'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13Resolution;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2688x1512'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13Resolution | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13FormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV21SlashMV71_ {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1280x720'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV21SlashMV71_Resolution;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV21SlashMV71_FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1280x720'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV21SlashMV71_Resolution | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV21SlashMV71_FormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV21SlashMV71_FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV21SlashMV71_Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV22XSlashMV72X_ {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV22XSlashMV72X_Resolution;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV22XSlashMV72X_FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV22XSlashMV72X_Resolution | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV22XSlashMV72X_FormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings_MV22XSlashMV72X_FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings_MV22XSlashMV72X_Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32 {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2058x2058'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32Resolution;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2058x2058'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32Resolution | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32FormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33 {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33FormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52 {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52Resolution;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52Resolution | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52FormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63 {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63Resolution;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63Resolution | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63FormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63X {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XResolution;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63XFormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XResolution | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63XFormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63XFormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XResolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93 {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93FormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93FormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93FormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93X {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: UpdateDeviceCameraQualityAndRetentionPutBodyQuality;

		/**
		 * Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
		 * Required
		 */
		resolution: CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XResolution;
	}
	export interface UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93XFormProperties {

		/**
		 * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		 * Required
		 */
		quality: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>,

		/**
		 * Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
		 * Required
		 */
		resolution: FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XResolution | null | undefined>,
	}
	export function CreateUpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93XFormGroup() {
		return new FormGroup<UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93XFormProperties>({
			quality: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyQuality | null | undefined>(undefined, [Validators.required]),
			resolution: new FormControl<CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XResolution | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkCameraWirelessProfilePostBody {

		/** The identity of the wireless profile. Required for creating wireless profiles in 8021x-radius auth mode. */
		identity?: CreateNetworkCameraWirelessProfilePostBodyIdentity;

		/**
		 * The name of the camera wireless profile. This parameter is required.
		 * Required
		 */
		name: string;

		/**
		 * The details of the SSID config.
		 * Required
		 */
		ssid: CreateNetworkCameraWirelessProfilePostBodySsid;
	}
	export interface CreateNetworkCameraWirelessProfilePostBodyFormProperties {

		/**
		 * The name of the camera wireless profile. This parameter is required.
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkCameraWirelessProfilePostBodyFormGroup() {
		return new FormGroup<CreateNetworkCameraWirelessProfilePostBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkCameraWirelessProfilePostBodyIdentity {

		/** The password of the identity. */
		password?: string | null;

		/** The username of the identity. */
		username?: string | null;
	}
	export interface CreateNetworkCameraWirelessProfilePostBodyIdentityFormProperties {

		/** The password of the identity. */
		password: FormControl<string | null | undefined>,

		/** The username of the identity. */
		username: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkCameraWirelessProfilePostBodyIdentityFormGroup() {
		return new FormGroup<CreateNetworkCameraWirelessProfilePostBodyIdentityFormProperties>({
			password: new FormControl<string | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkCameraWirelessProfilePostBodySsid {

		/** The auth mode of the SSID. It can be set to ('psk', '8021x-radius'). */
		authMode?: CreateNetworkCameraWirelessProfilePostBodySsidAuthMode | null;

		/** The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius' */
		encryptionMode?: string | null;

		/** The name of the SSID. */
		name?: string | null;

		/** The pre-shared key of the SSID. */
		psk?: string | null;
	}
	export interface CreateNetworkCameraWirelessProfilePostBodySsidFormProperties {

		/** The auth mode of the SSID. It can be set to ('psk', '8021x-radius'). */
		authMode: FormControl<CreateNetworkCameraWirelessProfilePostBodySsidAuthMode | null | undefined>,

		/** The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius' */
		encryptionMode: FormControl<string | null | undefined>,

		/** The name of the SSID. */
		name: FormControl<string | null | undefined>,

		/** The pre-shared key of the SSID. */
		psk: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkCameraWirelessProfilePostBodySsidFormGroup() {
		return new FormGroup<CreateNetworkCameraWirelessProfilePostBodySsidFormProperties>({
			authMode: new FormControl<CreateNetworkCameraWirelessProfilePostBodySsidAuthMode | null | undefined>(undefined),
			encryptionMode: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			psk: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum CreateNetworkCameraWirelessProfilePostBodySsidAuthMode { '8021x-radius' = '8021x-radius', psk = 'psk' }

	export interface UpdateNetworkCameraWirelessProfilePutBody {

		/** The identity of the wireless profile. Required for creating wireless profiles in 8021x-radius auth mode. */
		identity?: UpdateNetworkCameraWirelessProfilePutBodyIdentity;

		/** The name of the camera wireless profile. */
		name?: string | null;

		/** The details of the SSID config. */
		ssid?: UpdateNetworkCameraWirelessProfilePutBodySsid;
	}
	export interface UpdateNetworkCameraWirelessProfilePutBodyFormProperties {

		/** The name of the camera wireless profile. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkCameraWirelessProfilePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkCameraWirelessProfilePutBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkCameraWirelessProfilePutBodyIdentity {

		/** The password of the identity. */
		password?: string | null;

		/** The username of the identity. */
		username?: string | null;
	}
	export interface UpdateNetworkCameraWirelessProfilePutBodyIdentityFormProperties {

		/** The password of the identity. */
		password: FormControl<string | null | undefined>,

		/** The username of the identity. */
		username: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkCameraWirelessProfilePutBodyIdentityFormGroup() {
		return new FormGroup<UpdateNetworkCameraWirelessProfilePutBodyIdentityFormProperties>({
			password: new FormControl<string | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkCameraWirelessProfilePutBodySsid {

		/** The auth mode of the SSID. It can be set to ('psk', '8021x-radius'). */
		authMode?: CreateNetworkCameraWirelessProfilePostBodySsidAuthMode | null;

		/** The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius' */
		encryptionMode?: string | null;

		/** The name of the SSID. */
		name?: string | null;

		/** The pre-shared key of the SSID. */
		psk?: string | null;
	}
	export interface UpdateNetworkCameraWirelessProfilePutBodySsidFormProperties {

		/** The auth mode of the SSID. It can be set to ('psk', '8021x-radius'). */
		authMode: FormControl<CreateNetworkCameraWirelessProfilePostBodySsidAuthMode | null | undefined>,

		/** The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius' */
		encryptionMode: FormControl<string | null | undefined>,

		/** The name of the SSID. */
		name: FormControl<string | null | undefined>,

		/** The pre-shared key of the SSID. */
		psk: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkCameraWirelessProfilePutBodySsidFormGroup() {
		return new FormGroup<UpdateNetworkCameraWirelessProfilePutBodySsidFormProperties>({
			authMode: new FormControl<CreateNetworkCameraWirelessProfilePostBodySsidAuthMode | null | undefined>(undefined),
			encryptionMode: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			psk: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBody {

		/** The list of connectivity monitoring destinations */
		UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBodyDestinations?: Array<UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBodyDestinations>;
	}
	export interface UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBodyFormProperties {
	}
	export function CreateUpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBodyDestinations {

		/** Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed */
		default?: boolean | null;

		/** Description of the testing destination. Optional, defaults to an empty string */
		description?: string | null;

		/**
		 * The IP address to test connectivity with
		 * Required
		 */
		ip: string;
	}
	export interface UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBodyDestinationsFormProperties {

		/** Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed */
		default: FormControl<boolean | null | undefined>,

		/** Description of the testing destination. Optional, defaults to an empty string */
		description: FormControl<string | null | undefined>,

		/**
		 * The IP address to test connectivity with
		 * Required
		 */
		ip: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBodyDestinationsFormGroup() {
		return new FormGroup<UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBodyDestinationsFormProperties>({
			default: new FormControl<boolean | null | undefined>(undefined),
			description: new FormControl<string | null | undefined>(undefined),
			ip: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkCellularGatewayDhcpReturn {

		/** DHCP Lease time for all MG in the network. */
		dhcpLeaseTime?: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null;

		/** List of fixed IPs representing the the DNS Name servers when the mode is 'custom'. */
		dnsCustomNameservers?: Array<string>;

		/** DNS name servers mode for all MG in the network. */
		dnsNameservers?: GetNetworkCellularGatewayDhcpReturnDnsNameservers | null;
	}
	export interface GetNetworkCellularGatewayDhcpReturnFormProperties {

		/** DHCP Lease time for all MG in the network. */
		dhcpLeaseTime: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>,

		/** DNS name servers mode for all MG in the network. */
		dnsNameservers: FormControl<GetNetworkCellularGatewayDhcpReturnDnsNameservers | null | undefined>,
	}
	export function CreateGetNetworkCellularGatewayDhcpReturnFormGroup() {
		return new FormGroup<GetNetworkCellularGatewayDhcpReturnFormProperties>({
			dhcpLeaseTime: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>(undefined),
			dnsNameservers: new FormControl<GetNetworkCellularGatewayDhcpReturnDnsNameservers | null | undefined>(undefined),
		});

	}

	export enum GetNetworkCellularGatewayDhcpReturnDnsNameservers { custom = 'custom', google_dns = 'google_dns', opendns = 'opendns', upstream_dns = 'upstream_dns' }

	export interface UpdateNetworkCellularGatewayDhcpPutBody {

		/** DHCP Lease time for all MG of the network. Possible values are '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'. */
		dhcpLeaseTime?: string | null;

		/** list of fixed IPs representing the the DNS Name servers when the mode is 'custom' */
		dnsCustomNameservers?: Array<string>;

		/** DNS name servers mode for all MG of the network. Possible values are: 'upstream_dns', 'google_dns', 'opendns', 'custom'. */
		dnsNameservers?: string | null;
	}
	export interface UpdateNetworkCellularGatewayDhcpPutBodyFormProperties {

		/** DHCP Lease time for all MG of the network. Possible values are '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'. */
		dhcpLeaseTime: FormControl<string | null | undefined>,

		/** DNS name servers mode for all MG of the network. Possible values are: 'upstream_dns', 'google_dns', 'opendns', 'custom'. */
		dnsNameservers: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkCellularGatewayDhcpPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkCellularGatewayDhcpPutBodyFormProperties>({
			dhcpLeaseTime: new FormControl<string | null | undefined>(undefined),
			dnsNameservers: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkCellularGatewayDhcpReturn {

		/** DHCP Lease time for all MG in the network. */
		dhcpLeaseTime?: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null;

		/** List of fixed IPs representing the the DNS Name servers when the mode is 'custom'. */
		dnsCustomNameservers?: Array<string>;

		/** DNS name servers mode for all MG in the network. */
		dnsNameservers?: GetNetworkCellularGatewayDhcpReturnDnsNameservers | null;
	}
	export interface UpdateNetworkCellularGatewayDhcpReturnFormProperties {

		/** DHCP Lease time for all MG in the network. */
		dhcpLeaseTime: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>,

		/** DNS name servers mode for all MG in the network. */
		dnsNameservers: FormControl<GetNetworkCellularGatewayDhcpReturnDnsNameservers | null | undefined>,
	}
	export function CreateUpdateNetworkCellularGatewayDhcpReturnFormGroup() {
		return new FormGroup<UpdateNetworkCellularGatewayDhcpReturnFormProperties>({
			dhcpLeaseTime: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>(undefined),
			dnsNameservers: new FormControl<GetNetworkCellularGatewayDhcpReturnDnsNameservers | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkCellularGatewaySubnetPoolPutBody {

		/** CIDR of the pool of subnets. Each MG in this network will automatically pick a subnet from this pool. */
		cidr?: string | null;

		/** Mask used for the subnet of all MGs in  this network. */
		mask?: number | null;
	}
	export interface UpdateNetworkCellularGatewaySubnetPoolPutBodyFormProperties {

		/** CIDR of the pool of subnets. Each MG in this network will automatically pick a subnet from this pool. */
		cidr: FormControl<string | null | undefined>,

		/** Mask used for the subnet of all MGs in  this network. */
		mask: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkCellularGatewaySubnetPoolPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkCellularGatewaySubnetPoolPutBodyFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			mask: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkCellularGatewayUplinkPutBody {

		/** The bandwidth settings for the 'cellular' uplink */
		bandwidthLimits?: UpdateNetworkCellularGatewayUplinkPutBodyBandwidthLimits;
	}
	export interface UpdateNetworkCellularGatewayUplinkPutBodyFormProperties {
	}
	export function CreateUpdateNetworkCellularGatewayUplinkPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkCellularGatewayUplinkPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkCellularGatewayUplinkPutBodyBandwidthLimits {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown?: number | null;

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp?: number | null;
	}
	export interface UpdateNetworkCellularGatewayUplinkPutBodyBandwidthLimitsFormProperties {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown: FormControl<number | null | undefined>,

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkCellularGatewayUplinkPutBodyBandwidthLimitsFormGroup() {
		return new FormGroup<UpdateNetworkCellularGatewayUplinkPutBodyBandwidthLimitsFormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkClientsReturn {

		/** The adaptive policy group of the client */
		adaptivePolicyGroup?: string | null;

		/** Short description of the client */
		description?: string | null;

		/** Prediction of the client's device type */
		deviceTypePrediction?: string | null;

		/** Timestamp client was first seen in the network */
		firstSeen?: number | null;

		/** 802.1x group policy of the client */
		groupPolicy8021x?: string | null;

		/** The ID of the client */
		id?: string | null;

		/** The IP address of the client */
		ip?: string | null;

		/** The IPv6 address of the client */
		ip6?: string | null;

		/** Local IPv6 address of the client */
		ip6Local?: string | null;

		/** Timestamp client was last seen in the network */
		lastSeen?: number | null;

		/** The MAC address of the client */
		mac?: string | null;

		/** Manufacturer of the client */
		manufacturer?: string | null;

		/** Named VLAN of the client */
		namedVlan?: string | null;

		/** Notes on the client */
		notes?: string | null;

		/** The operating system of the client */
		os?: string | null;

		/** Client's most recent connection type */
		recentDeviceConnection?: GetNetworkClientsReturnRecentDeviceConnection | null;

		/** The MAC address of the node that the device was last connected to */
		recentDeviceMac?: string | null;

		/** The name of the node the device was last connected to */
		recentDeviceName?: string | null;

		/** The serial of the node the device was last connected to */
		recentDeviceSerial?: string | null;

		/** Status of SM for the client */
		smInstalled?: boolean | null;

		/** The name of the SSID that the client is connected to */
		ssid?: string | null;

		/** The connection status of the client */
		status?: GetNetworkClientsReturnStatus | null;

		/** The switch port that the client is connected to */
		switchport?: string | null;

		/** Usage, sent and received */
		usage?: GetNetworkClientsReturnUsage;

		/** The username of the user of the client */
		user?: string | null;

		/** The name of the VLAN that the client is connected to */
		vlan?: string | null;

		/** Wireless capabilities of the client */
		wirelessCapabilities?: string | null;
	}
	export interface GetNetworkClientsReturnFormProperties {

		/** The adaptive policy group of the client */
		adaptivePolicyGroup: FormControl<string | null | undefined>,

		/** Short description of the client */
		description: FormControl<string | null | undefined>,

		/** Prediction of the client's device type */
		deviceTypePrediction: FormControl<string | null | undefined>,

		/** Timestamp client was first seen in the network */
		firstSeen: FormControl<number | null | undefined>,

		/** 802.1x group policy of the client */
		groupPolicy8021x: FormControl<string | null | undefined>,

		/** The ID of the client */
		id: FormControl<string | null | undefined>,

		/** The IP address of the client */
		ip: FormControl<string | null | undefined>,

		/** The IPv6 address of the client */
		ip6: FormControl<string | null | undefined>,

		/** Local IPv6 address of the client */
		ip6Local: FormControl<string | null | undefined>,

		/** Timestamp client was last seen in the network */
		lastSeen: FormControl<number | null | undefined>,

		/** The MAC address of the client */
		mac: FormControl<string | null | undefined>,

		/** Manufacturer of the client */
		manufacturer: FormControl<string | null | undefined>,

		/** Named VLAN of the client */
		namedVlan: FormControl<string | null | undefined>,

		/** Notes on the client */
		notes: FormControl<string | null | undefined>,

		/** The operating system of the client */
		os: FormControl<string | null | undefined>,

		/** Client's most recent connection type */
		recentDeviceConnection: FormControl<GetNetworkClientsReturnRecentDeviceConnection | null | undefined>,

		/** The MAC address of the node that the device was last connected to */
		recentDeviceMac: FormControl<string | null | undefined>,

		/** The name of the node the device was last connected to */
		recentDeviceName: FormControl<string | null | undefined>,

		/** The serial of the node the device was last connected to */
		recentDeviceSerial: FormControl<string | null | undefined>,

		/** Status of SM for the client */
		smInstalled: FormControl<boolean | null | undefined>,

		/** The name of the SSID that the client is connected to */
		ssid: FormControl<string | null | undefined>,

		/** The connection status of the client */
		status: FormControl<GetNetworkClientsReturnStatus | null | undefined>,

		/** The switch port that the client is connected to */
		switchport: FormControl<string | null | undefined>,

		/** The username of the user of the client */
		user: FormControl<string | null | undefined>,

		/** The name of the VLAN that the client is connected to */
		vlan: FormControl<string | null | undefined>,

		/** Wireless capabilities of the client */
		wirelessCapabilities: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkClientsReturnFormGroup() {
		return new FormGroup<GetNetworkClientsReturnFormProperties>({
			adaptivePolicyGroup: new FormControl<string | null | undefined>(undefined),
			description: new FormControl<string | null | undefined>(undefined),
			deviceTypePrediction: new FormControl<string | null | undefined>(undefined),
			firstSeen: new FormControl<number | null | undefined>(undefined),
			groupPolicy8021x: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			ip: new FormControl<string | null | undefined>(undefined),
			ip6: new FormControl<string | null | undefined>(undefined),
			ip6Local: new FormControl<string | null | undefined>(undefined),
			lastSeen: new FormControl<number | null | undefined>(undefined),
			mac: new FormControl<string | null | undefined>(undefined),
			manufacturer: new FormControl<string | null | undefined>(undefined),
			namedVlan: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
			os: new FormControl<string | null | undefined>(undefined),
			recentDeviceConnection: new FormControl<GetNetworkClientsReturnRecentDeviceConnection | null | undefined>(undefined),
			recentDeviceMac: new FormControl<string | null | undefined>(undefined),
			recentDeviceName: new FormControl<string | null | undefined>(undefined),
			recentDeviceSerial: new FormControl<string | null | undefined>(undefined),
			smInstalled: new FormControl<boolean | null | undefined>(undefined),
			ssid: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<GetNetworkClientsReturnStatus | null | undefined>(undefined),
			switchport: new FormControl<string | null | undefined>(undefined),
			user: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<string | null | undefined>(undefined),
			wirelessCapabilities: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetNetworkClientsReturnRecentDeviceConnection { Wired = 'Wired', Wireless = 'Wireless' }

	export enum GetNetworkClientsReturnStatus { Offline = 'Offline', Online = 'Online' }

	export interface GetNetworkClientsReturnUsage {

		/** Usage received by the client */
		recv?: number | null;

		/** Usage sent by the client */
		sent?: number | null;
	}
	export interface GetNetworkClientsReturnUsageFormProperties {

		/** Usage received by the client */
		recv: FormControl<number | null | undefined>,

		/** Usage sent by the client */
		sent: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkClientsReturnUsageFormGroup() {
		return new FormGroup<GetNetworkClientsReturnUsageFormProperties>({
			recv: new FormControl<number | null | undefined>(undefined),
			sent: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum GetNetworkClientsApplicationUsageSsidNumber { _0 = 0, _1 = 1, _2 = 2, _3 = 3, _4 = 4, _5 = 5, _6 = 6, _7 = 7, _8 = 8, _9 = 9, _10 = 10, _11 = 11, _12 = 12, _13 = 13, _14 = 14 }

	export interface ProvisionNetworkClientsPostBody {

		/**
		 * The array of clients to provision
		 * Required
		 */
		ProvisionNetworkClientsPostBodyClients: Array<ProvisionNetworkClientsPostBodyClients>;

		/**
		 * The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyDevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;

		/** An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network) */
		policiesBySecurityAppliance?: ProvisionNetworkClientsPostBodyPoliciesBySecurityAppliance;

		/** An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy */
		policiesBySsid?: ProvisionNetworkClientsPostBodyPoliciesBySsid;
	}
	export interface ProvisionNetworkClientsPostBodyFormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyDevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyFormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyFormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyDevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyClients {

		/**
		 * The MAC address of the client. Required.
		 * Required
		 */
		mac: string;

		/** The display name for the client. Optional. Limited to 255 bytes. */
		name?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyClientsFormProperties {

		/**
		 * The MAC address of the client. Required.
		 * Required
		 */
		mac: FormControl<string | null | undefined>,

		/** The display name for the client. Optional. Limited to 255 bytes. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyClientsFormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyClientsFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum ProvisionNetworkClientsPostBodyDevicePolicy { Allowed = 'Allowed', Blocked = 'Blocked', 'Group policy' = 'Group policy', Normal = 'Normal', 'Per connection' = 'Per connection' }

	export interface ProvisionNetworkClientsPostBodyPoliciesBySecurityAppliance {

		/** The policy to apply to the specified client. Can be 'Allowed', 'Blocked' or 'Normal'. Required. */
		devicePolicy?: ProvisionNetworkClientsPostBodyPoliciesBySecurityApplianceDevicePolicy | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySecurityApplianceFormProperties {

		/** The policy to apply to the specified client. Can be 'Allowed', 'Blocked' or 'Normal'. Required. */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySecurityApplianceDevicePolicy | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySecurityApplianceFormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySecurityApplianceFormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySecurityApplianceDevicePolicy | null | undefined>(undefined),
		});

	}

	export enum ProvisionNetworkClientsPostBodyPoliciesBySecurityApplianceDevicePolicy { Allowed = 'Allowed', Blocked = 'Blocked', Normal = 'Normal' }

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid {

		/** The number for the SSID */
		'0'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_;

		/** The number for the SSID */
		'1'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_1_;

		/** The number for the SSID */
		'2'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_2_;

		/** The number for the SSID */
		'3'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_3_;

		/** The number for the SSID */
		'4'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_4_;

		/** The number for the SSID */
		'5'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_5_;

		/** The number for the SSID */
		'6'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_6_;

		/** The number for the SSID */
		'7'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_7_;

		/** The number for the SSID */
		'8'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_8_;

		/** The number for the SSID */
		'9'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_9_;

		/** The number for the SSID */
		'10'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_10_;

		/** The number for the SSID */
		'11'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_11_;

		/** The number for the SSID */
		'12'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_12_;

		/** The number for the SSID */
		'13'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_13_;

		/** The number for the SSID */
		'14'?: ProvisionNetworkClientsPostBodyPoliciesBySsid_14_;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsidFormProperties {
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsidFormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsidFormProperties>({
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_0_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_0_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_0_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy { Allowed = 'Allowed', Blocked = 'Blocked', 'Group policy' = 'Group policy', Normal = 'Normal' }

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_1_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_1_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_1_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_1_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_2_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_2_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_2_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_2_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_3_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_3_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_3_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_3_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_4_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_4_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_4_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_4_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_5_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_5_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_5_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_5_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_6_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_6_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_6_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_6_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_7_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_7_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_7_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_7_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_8_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_8_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_8_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_8_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_9_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_9_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_9_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_9_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_10_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_10_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_10_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_10_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_11_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_11_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_11_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_11_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_12_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_12_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_12_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_12_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_13_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_13_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_13_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_13_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_14_ {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy;

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId?: string | null;
	}
	export interface ProvisionNetworkClientsPostBodyPoliciesBySsid_14_FormProperties {

		/**
		 * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>,

		/** The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateProvisionNetworkClientsPostBodyPoliciesBySsid_14_FormGroup() {
		return new FormGroup<ProvisionNetworkClientsPostBodyPoliciesBySsid_14_FormProperties>({
			devicePolicy: new FormControl<ProvisionNetworkClientsPostBodyPoliciesBySsid_0_DevicePolicy | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetNetworkClientsUsageHistoriesSsidNumber { _0 = 0, _1 = 1, _2 = 2, _3 = 3, _4 = 4, _5 = 5, _6 = 6, _7 = 7, _8 = 8, _9 = 9, _10 = 10, _11 = 11, _12 = 12, _13 = 13, _14 = 14 }

	export interface GetNetworkClientReturn {

		/** The Cisco discover protocol settings for the client */
		cdp?: Array<string>;

		/** VPN connections associated with the client */
		GetNetworkClientReturnClientVpnConnections?: Array<GetNetworkClientReturnClientVpnConnections>;

		/** Short description of the client */
		description?: string | null;

		/** Timestamp client was first seen in the network */
		firstSeen?: number | null;

		/** The ID of the client */
		id?: string | null;

		/** The IP address of the client */
		ip?: string | null;

		/** The IPv6 address of the client */
		ip6?: string | null;

		/** Timestamp client was last seen in the network */
		lastSeen?: number | null;

		/** The link layer discover protocol settings for the client */
		lldp?: Array<string>;

		/** The MAC address of the client */
		mac?: string | null;

		/** Manufacturer of the client */
		manufacturer?: string | null;

		/** The operating system of the client */
		os?: string | null;

		/** The MAC address of the node that the device was last connected to */
		recentDeviceMac?: string | null;

		/** Status of SM for the client */
		smInstalled?: boolean | null;

		/** The name of the SSID that the client is connected to */
		ssid?: string | null;

		/** The connection status of the client */
		status?: GetNetworkClientsReturnStatus | null;

		/** The switch port that the client is connected to */
		switchport?: string | null;

		/** The username of the user of the client */
		user?: string | null;

		/** The name of the VLAN that the client is connected to */
		vlan?: string | null;

		/** Wireless capabilities of the client */
		wirelessCapabilities?: string | null;
	}
	export interface GetNetworkClientReturnFormProperties {

		/** Short description of the client */
		description: FormControl<string | null | undefined>,

		/** Timestamp client was first seen in the network */
		firstSeen: FormControl<number | null | undefined>,

		/** The ID of the client */
		id: FormControl<string | null | undefined>,

		/** The IP address of the client */
		ip: FormControl<string | null | undefined>,

		/** The IPv6 address of the client */
		ip6: FormControl<string | null | undefined>,

		/** Timestamp client was last seen in the network */
		lastSeen: FormControl<number | null | undefined>,

		/** The MAC address of the client */
		mac: FormControl<string | null | undefined>,

		/** Manufacturer of the client */
		manufacturer: FormControl<string | null | undefined>,

		/** The operating system of the client */
		os: FormControl<string | null | undefined>,

		/** The MAC address of the node that the device was last connected to */
		recentDeviceMac: FormControl<string | null | undefined>,

		/** Status of SM for the client */
		smInstalled: FormControl<boolean | null | undefined>,

		/** The name of the SSID that the client is connected to */
		ssid: FormControl<string | null | undefined>,

		/** The connection status of the client */
		status: FormControl<GetNetworkClientsReturnStatus | null | undefined>,

		/** The switch port that the client is connected to */
		switchport: FormControl<string | null | undefined>,

		/** The username of the user of the client */
		user: FormControl<string | null | undefined>,

		/** The name of the VLAN that the client is connected to */
		vlan: FormControl<string | null | undefined>,

		/** Wireless capabilities of the client */
		wirelessCapabilities: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkClientReturnFormGroup() {
		return new FormGroup<GetNetworkClientReturnFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			firstSeen: new FormControl<number | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			ip: new FormControl<string | null | undefined>(undefined),
			ip6: new FormControl<string | null | undefined>(undefined),
			lastSeen: new FormControl<number | null | undefined>(undefined),
			mac: new FormControl<string | null | undefined>(undefined),
			manufacturer: new FormControl<string | null | undefined>(undefined),
			os: new FormControl<string | null | undefined>(undefined),
			recentDeviceMac: new FormControl<string | null | undefined>(undefined),
			smInstalled: new FormControl<boolean | null | undefined>(undefined),
			ssid: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<GetNetworkClientsReturnStatus | null | undefined>(undefined),
			switchport: new FormControl<string | null | undefined>(undefined),
			user: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<string | null | undefined>(undefined),
			wirelessCapabilities: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkClientReturnClientVpnConnections {

		/** The time the client last connected to the VPN */
		connectedAt?: number | null;

		/** The time the client last disconnectd from the VPN */
		disconnectedAt?: number | null;

		/** The IP address of the VPN the client last connected to */
		remoteIp?: string | null;
	}
	export interface GetNetworkClientReturnClientVpnConnectionsFormProperties {

		/** The time the client last connected to the VPN */
		connectedAt: FormControl<number | null | undefined>,

		/** The time the client last disconnectd from the VPN */
		disconnectedAt: FormControl<number | null | undefined>,

		/** The IP address of the VPN the client last connected to */
		remoteIp: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkClientReturnClientVpnConnectionsFormGroup() {
		return new FormGroup<GetNetworkClientReturnClientVpnConnectionsFormProperties>({
			connectedAt: new FormControl<number | null | undefined>(undefined),
			disconnectedAt: new FormControl<number | null | undefined>(undefined),
			remoteIp: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientPolicyPutBody {

		/**
		 * The policy to assign. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: string;

		/** [optional] If 'devicePolicy' is set to 'Group policy' this param is used to specify the group policy ID. */
		groupPolicyId?: string | null;
	}
	export interface UpdateNetworkClientPolicyPutBodyFormProperties {

		/**
		 * The policy to assign. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		 * Required
		 */
		devicePolicy: FormControl<string | null | undefined>,

		/** [optional] If 'devicePolicy' is set to 'Group policy' this param is used to specify the group policy ID. */
		groupPolicyId: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkClientPolicyPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkClientPolicyPutBodyFormProperties>({
			devicePolicy: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBody {

		/**
		 * The target SSIDs. Each SSID must be enabled and must have Click-through splash enabled. For each SSID where isAuthorized is true, the expiration time will automatically be set according to the SSID's splash frequency. Not all networks support configuring all SSIDs
		 * Required
		 */
		ssids: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodyFormProperties {
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids {

		/** Splash authorization for SSID 0 */
		'0'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_0_;

		/** Splash authorization for SSID 1 */
		'1'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_1_;

		/** Splash authorization for SSID 2 */
		'2'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_2_;

		/** Splash authorization for SSID 3 */
		'3'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_3_;

		/** Splash authorization for SSID 4 */
		'4'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_4_;

		/** Splash authorization for SSID 5 */
		'5'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_5_;

		/** Splash authorization for SSID 6 */
		'6'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_6_;

		/** Splash authorization for SSID 7 */
		'7'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_7_;

		/** Splash authorization for SSID 8 */
		'8'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_8_;

		/** Splash authorization for SSID 9 */
		'9'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_9_;

		/** Splash authorization for SSID 10 */
		'10'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_10_;

		/** Splash authorization for SSID 11 */
		'11'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_11_;

		/** Splash authorization for SSID 12 */
		'12'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_12_;

		/** Splash authorization for SSID 13 */
		'13'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_13_;

		/** Splash authorization for SSID 14 */
		'14'?: UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_14_;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsidsFormProperties {
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsidsFormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsidsFormProperties>({
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_0_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_0_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_0_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_0_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_1_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_1_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_1_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_1_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_2_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_2_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_2_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_2_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_3_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_3_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_3_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_3_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_4_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_4_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_4_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_4_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_5_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_5_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_5_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_5_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_6_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_6_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_6_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_6_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_7_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_7_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_7_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_7_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_8_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_8_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_8_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_8_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_9_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_9_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_9_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_9_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_10_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_10_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_10_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_10_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_11_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_11_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_11_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_11_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_12_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_12_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_12_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_12_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_13_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_13_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_13_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_13_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_14_ {

		/** New authorization status for the SSID (true, false). */
		isAuthorized?: boolean | null;
	}
	export interface UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_14_FormProperties {

		/** New authorization status for the SSID (true, false). */
		isAuthorized: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkClientSplashAuthorizationStatusPutBodySsids_14_FormGroup() {
		return new FormGroup<UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_14_FormProperties>({
			isAuthorized: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface ClaimNetworkDevicesPostBody {

		/**
		 * A list of serials of devices to claim
		 * Required
		 */
		serials: Array<string>;
	}
	export interface ClaimNetworkDevicesPostBodyFormProperties {
	}
	export function CreateClaimNetworkDevicesPostBodyFormGroup() {
		return new FormGroup<ClaimNetworkDevicesPostBodyFormProperties>({
		});

	}

	export interface VmxNetworkDevicesClaimPostBody {

		/**
		 * The size of the vMX you claim. It can be one of: small, medium, large, 100
		 * Required
		 */
		size: VmxNetworkDevicesClaimPostBodySize;
	}
	export interface VmxNetworkDevicesClaimPostBodyFormProperties {

		/**
		 * The size of the vMX you claim. It can be one of: small, medium, large, 100
		 * Required
		 */
		size: FormControl<VmxNetworkDevicesClaimPostBodySize | null | undefined>,
	}
	export function CreateVmxNetworkDevicesClaimPostBodyFormGroup() {
		return new FormGroup<VmxNetworkDevicesClaimPostBodyFormProperties>({
			size: new FormControl<VmxNetworkDevicesClaimPostBodySize | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum VmxNetworkDevicesClaimPostBodySize { _100 = '100', large = 'large', medium = 'medium', small = 'small' }

	export interface RemoveNetworkDevicesPostBody {

		/**
		 * The serial of a device
		 * Required
		 */
		serial: string;
	}
	export interface RemoveNetworkDevicesPostBodyFormProperties {

		/**
		 * The serial of a device
		 * Required
		 */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateRemoveNetworkDevicesPostBodyFormGroup() {
		return new FormGroup<RemoveNetworkDevicesPostBodyFormProperties>({
			serial: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum GetNetworkEventsProductType { appliance = 'appliance', camera = 'camera', cellularGateway = 'cellularGateway', switch = 'switch', systemsManager = 'systemsManager', wireless = 'wireless' }

	export interface GetNetworkEventsReturn {

		/** An array of events that took place in the network. */
		GetNetworkEventsReturnEvents?: Array<GetNetworkEventsReturnEvents>;

		/** A message regarding the events sent. Usually 'null' unless there are no events */
		message?: string | null;

		/** An UTC ISO8601 string of the latest occured at time of the listed events of the page. */
		pageEndAt?: string | null;

		/** An UTC ISO8601 string of the earliest occured at time of the listed events of the page. */
		pageStartAt?: string | null;
	}
	export interface GetNetworkEventsReturnFormProperties {

		/** A message regarding the events sent. Usually 'null' unless there are no events */
		message: FormControl<string | null | undefined>,

		/** An UTC ISO8601 string of the latest occured at time of the listed events of the page. */
		pageEndAt: FormControl<string | null | undefined>,

		/** An UTC ISO8601 string of the earliest occured at time of the listed events of the page. */
		pageStartAt: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkEventsReturnFormGroup() {
		return new FormGroup<GetNetworkEventsReturnFormProperties>({
			message: new FormControl<string | null | undefined>(undefined),
			pageEndAt: new FormControl<string | null | undefined>(undefined),
			pageStartAt: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkEventsReturnEvents {

		/** The category that the event type belongs to */
		category?: string | null;

		/** A description of the client. This is usually the client's device name. */
		clientDescription?: string | null;

		/** A string identifying the client. This could be a client's MAC or IP address */
		clientId?: string | null;

		/** The client's MAC address. */
		clientMac?: string | null;

		/** A description of the event the happened. */
		description?: string | null;

		/** The name of the device. Only shown if the device is an access point. */
		deviceName?: string | null;

		/** The serial number of the device. Only shown if the device is an access point. */
		deviceSerial?: string | null;

		/** An object containing more data related to the event. */
		eventData?: GetNetworkEventsReturnEventsEventData;

		/** The ID of the network. */
		networkId?: string | null;

		/** An UTC ISO8601 string of the time the event occurred at. */
		occurredAt?: string | null;

		/** The SSID number of the device. */
		ssidNumber?: number | null;

		/** The type of event being listed. */
		type?: string | null;
	}
	export interface GetNetworkEventsReturnEventsFormProperties {

		/** The category that the event type belongs to */
		category: FormControl<string | null | undefined>,

		/** A description of the client. This is usually the client's device name. */
		clientDescription: FormControl<string | null | undefined>,

		/** A string identifying the client. This could be a client's MAC or IP address */
		clientId: FormControl<string | null | undefined>,

		/** The client's MAC address. */
		clientMac: FormControl<string | null | undefined>,

		/** A description of the event the happened. */
		description: FormControl<string | null | undefined>,

		/** The name of the device. Only shown if the device is an access point. */
		deviceName: FormControl<string | null | undefined>,

		/** The serial number of the device. Only shown if the device is an access point. */
		deviceSerial: FormControl<string | null | undefined>,

		/** The ID of the network. */
		networkId: FormControl<string | null | undefined>,

		/** An UTC ISO8601 string of the time the event occurred at. */
		occurredAt: FormControl<string | null | undefined>,

		/** The SSID number of the device. */
		ssidNumber: FormControl<number | null | undefined>,

		/** The type of event being listed. */
		type: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkEventsReturnEventsFormGroup() {
		return new FormGroup<GetNetworkEventsReturnEventsFormProperties>({
			category: new FormControl<string | null | undefined>(undefined),
			clientDescription: new FormControl<string | null | undefined>(undefined),
			clientId: new FormControl<string | null | undefined>(undefined),
			clientMac: new FormControl<string | null | undefined>(undefined),
			description: new FormControl<string | null | undefined>(undefined),
			deviceName: new FormControl<string | null | undefined>(undefined),
			deviceSerial: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			occurredAt: new FormControl<string | null | undefined>(undefined),
			ssidNumber: new FormControl<number | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkEventsReturnEventsEventData {

		/** The association ID of the client. */
		aid?: string | null;

		/** The radio channel the client is connecting to. */
		channel?: string | null;

		/** The client's IP address */
		client_ip?: string | null;

		/** The client's MAC address */
		client_mac?: string | null;

		/** The radio band number the client is trying to connect to. */
		radio?: string | null;

		/** The current received signal strength indication (RSSI) of the client connected to an AP. */
		rssi?: string | null;

		/** The virtual access point (VAP) number the client is connecting to. */
		vap?: string | null;
	}
	export interface GetNetworkEventsReturnEventsEventDataFormProperties {

		/** The association ID of the client. */
		aid: FormControl<string | null | undefined>,

		/** The radio channel the client is connecting to. */
		channel: FormControl<string | null | undefined>,

		/** The client's IP address */
		client_ip: FormControl<string | null | undefined>,

		/** The client's MAC address */
		client_mac: FormControl<string | null | undefined>,

		/** The radio band number the client is trying to connect to. */
		radio: FormControl<string | null | undefined>,

		/** The current received signal strength indication (RSSI) of the client connected to an AP. */
		rssi: FormControl<string | null | undefined>,

		/** The virtual access point (VAP) number the client is connecting to. */
		vap: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkEventsReturnEventsEventDataFormGroup() {
		return new FormGroup<GetNetworkEventsReturnEventsEventDataFormProperties>({
			aid: new FormControl<string | null | undefined>(undefined),
			channel: new FormControl<string | null | undefined>(undefined),
			client_ip: new FormControl<string | null | undefined>(undefined),
			client_mac: new FormControl<string | null | undefined>(undefined),
			radio: new FormControl<string | null | undefined>(undefined),
			rssi: new FormControl<string | null | undefined>(undefined),
			vap: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkEventsEventTypesReturn {

		/** Event category */
		category?: string | null;

		/** Description of the event */
		description?: string | null;

		/** Event type */
		type?: string | null;
	}
	export interface GetNetworkEventsEventTypesReturnFormProperties {

		/** Event category */
		category: FormControl<string | null | undefined>,

		/** Description of the event */
		description: FormControl<string | null | undefined>,

		/** Event type */
		type: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkEventsEventTypesReturnFormGroup() {
		return new FormGroup<GetNetworkEventsEventTypesReturnFormProperties>({
			category: new FormControl<string | null | undefined>(undefined),
			description: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturn {

		/** The network devices to be updated */
		products?: GetNetworkFirmwareUpgradesReturnProducts;

		/** The timezone for the network */
		timezone?: string | null;

		/** Upgrade window for devices in network */
		upgradeWindow?: GetNetworkFirmwareUpgradesReturnUpgradeWindow;
	}
	export interface GetNetworkFirmwareUpgradesReturnFormProperties {

		/** The timezone for the network */
		timezone: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnFormProperties>({
			timezone: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProducts {

		/** The network device to be updated */
		appliance?: GetNetworkFirmwareUpgradesReturnProductsAppliance;

		/** The network device to be updated */
		camera?: GetNetworkFirmwareUpgradesReturnProductsCamera;

		/** The network device to be updated */
		cellularGateway?: GetNetworkFirmwareUpgradesReturnProductsCellularGateway;

		/** The network device to be updated */
		sensor?: GetNetworkFirmwareUpgradesReturnProductsSensor;

		/** The network device to be updated */
		switch?: GetNetworkFirmwareUpgradesReturnProductsSwitch;

		/** The network device to be updated */
		wireless?: GetNetworkFirmwareUpgradesReturnProductsWireless;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsFormProperties {
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsFormProperties>({
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsAppliance {

		/** Firmware versions available for upgrade */
		GetNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersions?: Array<GetNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersions>;

		/** Details of the current version on the device */
		currentVersion?: GetNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersion;

		/** Details of the last firmware upgrade on the device */
		lastUpgrade?: GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgrade;

		/** Details of the next firmware upgrade on the device */
		nextUpgrade?: GetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsApplianceFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsApplianceFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersions {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersionsFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersionsFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersionsFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgrade {

		/** Details of the version the device upgraded from */
		fromVersion?: GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersion;

		/** Timestamp of the last successful firmware upgrade */
		time?: Date | null;

		/** Details of the version the device upgraded to */
		toVersion?: GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFormProperties {

		/** Timestamp of the last successful firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgrade {

		/** Timestamp of the next scheduled firmware upgrade */
		time?: Date | null;

		/** Details of the version the device will upgrade to if it exists */
		toVersion?: GetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeFormProperties {

		/** Timestamp of the next scheduled firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCamera {

		/** Firmware versions available for upgrade */
		GetNetworkFirmwareUpgradesReturnProductsCameraAvailableVersions?: Array<GetNetworkFirmwareUpgradesReturnProductsCameraAvailableVersions>;

		/** Details of the current version on the device */
		currentVersion?: GetNetworkFirmwareUpgradesReturnProductsCameraCurrentVersion;

		/** Details of the last firmware upgrade on the device */
		lastUpgrade?: GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgrade;

		/** Details of the next firmware upgrade on the device */
		nextUpgrade?: GetNetworkFirmwareUpgradesReturnProductsCameraNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCameraFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCameraFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCameraFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCameraAvailableVersions {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCameraAvailableVersionsFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCameraAvailableVersionsFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCameraAvailableVersionsFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCameraCurrentVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCameraCurrentVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCameraCurrentVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCameraCurrentVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgrade {

		/** Details of the version the device upgraded from */
		fromVersion?: GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersion;

		/** Timestamp of the last successful firmware upgrade */
		time?: Date | null;

		/** Details of the version the device upgraded to */
		toVersion?: GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFormProperties {

		/** Timestamp of the last successful firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCameraNextUpgrade {

		/** Timestamp of the next scheduled firmware upgrade */
		time?: Date | null;

		/** Details of the version the device will upgrade to if it exists */
		toVersion?: GetNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeFormProperties {

		/** Timestamp of the next scheduled firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGateway {

		/** Firmware versions available for upgrade */
		GetNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersions?: Array<GetNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersions>;

		/** Details of the current version on the device */
		currentVersion?: GetNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersion;

		/** Details of the last firmware upgrade on the device */
		lastUpgrade?: GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgrade;

		/** Details of the next firmware upgrade on the device */
		nextUpgrade?: GetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCellularGatewayFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCellularGatewayFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersions {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersionsFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersionsFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersionsFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgrade {

		/** Details of the version the device upgraded from */
		fromVersion?: GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersion;

		/** Timestamp of the last successful firmware upgrade */
		time?: Date | null;

		/** Details of the version the device upgraded to */
		toVersion?: GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFormProperties {

		/** Timestamp of the last successful firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgrade {

		/** Timestamp of the next scheduled firmware upgrade */
		time?: Date | null;

		/** Details of the version the device will upgrade to if it exists */
		toVersion?: GetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeFormProperties {

		/** Timestamp of the next scheduled firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSensor {

		/** Firmware versions available for upgrade */
		GetNetworkFirmwareUpgradesReturnProductsSensorAvailableVersions?: Array<GetNetworkFirmwareUpgradesReturnProductsSensorAvailableVersions>;

		/** Details of the current version on the device */
		currentVersion?: GetNetworkFirmwareUpgradesReturnProductsSensorCurrentVersion;

		/** Details of the last firmware upgrade on the device */
		lastUpgrade?: GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgrade;

		/** Details of the next firmware upgrade on the device */
		nextUpgrade?: GetNetworkFirmwareUpgradesReturnProductsSensorNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSensorFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSensorFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSensorFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSensorAvailableVersions {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSensorAvailableVersionsFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSensorAvailableVersionsFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSensorAvailableVersionsFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSensorCurrentVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSensorCurrentVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSensorCurrentVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSensorCurrentVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgrade {

		/** Details of the version the device upgraded from */
		fromVersion?: GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersion;

		/** Timestamp of the last successful firmware upgrade */
		time?: Date | null;

		/** Details of the version the device upgraded to */
		toVersion?: GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFormProperties {

		/** Timestamp of the last successful firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSensorNextUpgrade {

		/** Timestamp of the next scheduled firmware upgrade */
		time?: Date | null;

		/** Details of the version the device will upgrade to if it exists */
		toVersion?: GetNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeFormProperties {

		/** Timestamp of the next scheduled firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSwitch {

		/** Firmware versions available for upgrade */
		GetNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersions?: Array<GetNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersions>;

		/** Details of the current version on the device */
		currentVersion?: GetNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersion;

		/** Details of the last firmware upgrade on the device */
		lastUpgrade?: GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgrade;

		/** Details of the next firmware upgrade on the device */
		nextUpgrade?: GetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSwitchFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSwitchFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersions {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersionsFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersionsFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersionsFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgrade {

		/** Details of the version the device upgraded from */
		fromVersion?: GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersion;

		/** Timestamp of the last successful firmware upgrade */
		time?: Date | null;

		/** Details of the version the device upgraded to */
		toVersion?: GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFormProperties {

		/** Timestamp of the last successful firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgrade {

		/** Timestamp of the next scheduled firmware upgrade */
		time?: Date | null;

		/** Details of the version the device will upgrade to if it exists */
		toVersion?: GetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeFormProperties {

		/** Timestamp of the next scheduled firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsWireless {

		/** Firmware versions available for upgrade */
		GetNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersions?: Array<GetNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersions>;

		/** Details of the current version on the device */
		currentVersion?: GetNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersion;

		/** Details of the last firmware upgrade on the device */
		lastUpgrade?: GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgrade;

		/** Details of the next firmware upgrade on the device */
		nextUpgrade?: GetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsWirelessFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsWirelessFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersions {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersionsFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersionsFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersionsFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgrade {

		/** Details of the version the device upgraded from */
		fromVersion?: GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersion;

		/** Timestamp of the last successful firmware upgrade */
		time?: Date | null;

		/** Details of the version the device upgraded to */
		toVersion?: GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFormProperties {

		/** Timestamp of the last successful firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgrade {

		/** Timestamp of the next scheduled firmware upgrade */
		time?: Date | null;

		/** Details of the version the device will upgrade to if it exists */
		toVersion?: GetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeFormProperties {

		/** Timestamp of the next scheduled firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesReturnUpgradeWindow {

		/** Day of the week */
		dayOfWeek?: GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek | null;

		/** Hour of the day */
		hourOfDay?: GetNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay | null;
	}
	export interface GetNetworkFirmwareUpgradesReturnUpgradeWindowFormProperties {

		/** Day of the week */
		dayOfWeek: FormControl<GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek | null | undefined>,

		/** Hour of the day */
		hourOfDay: FormControl<GetNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesReturnUpgradeWindowFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesReturnUpgradeWindowFormProperties>({
			dayOfWeek: new FormControl<GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek | null | undefined>(undefined),
			hourOfDay: new FormControl<GetNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay | null | undefined>(undefined),
		});

	}

	export enum GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek { fri = 'fri', friday = 'friday', mon = 'mon', monday = 'monday', sat = 'sat', saturday = 'saturday', sun = 'sun', sunday = 'sunday', thu = 'thu', thursday = 'thursday', tue = 'tue', tuesday = 'tuesday', wed = 'wed', wednesday = 'wednesday' }

	export enum GetNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay { '0:00' = '0:00', '10:00' = '10:00', '11:00' = '11:00', '12:00' = '12:00', '13:00' = '13:00', '14:00' = '14:00', '15:00' = '15:00', '16:00' = '16:00', '17:00' = '17:00', '18:00' = '18:00', '19:00' = '19:00', '1:00' = '1:00', '20:00' = '20:00', '21:00' = '21:00', '22:00' = '22:00', '23:00' = '23:00', '2:00' = '2:00', '3:00' = '3:00', '4:00' = '4:00', '5:00' = '5:00', '6:00' = '6:00', '7:00' = '7:00', '8:00' = '8:00', '9:00' = '9:00' }

	export interface UpdateNetworkFirmwareUpgradesPutBody {

		/** Contains information about the network to update */
		products?: UpdateNetworkFirmwareUpgradesPutBodyProducts;

		/** The timezone for the network */
		timezone?: string | null;

		/** Upgrade window for devices in network */
		upgradeWindow?: UpdateNetworkFirmwareUpgradesPutBodyUpgradeWindow;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyFormProperties {

		/** The timezone for the network */
		timezone: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyFormProperties>({
			timezone: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProducts {

		/** The network device to be updated */
		appliance?: UpdateNetworkFirmwareUpgradesPutBodyProductsAppliance;

		/** The network device to be updated */
		camera?: UpdateNetworkFirmwareUpgradesPutBodyProductsCamera;

		/** The network device to be updated */
		cellularGateway?: UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGateway;

		/** The network device to be updated */
		sensor?: UpdateNetworkFirmwareUpgradesPutBodyProductsSensor;

		/** The network device to be updated */
		switch?: UpdateNetworkFirmwareUpgradesPutBodyProductsSwitch;

		/** The network device to be updated */
		wireless?: UpdateNetworkFirmwareUpgradesPutBodyProductsWireless;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsFormProperties {
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsFormProperties>({
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsAppliance {

		/** The pending firmware upgrade if it exists */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsApplianceFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgrade {

		/** The time of the last successful upgrade */
		time?: string | null;

		/** The version to be updated to */
		toVersion?: UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgradeFormProperties {

		/** The time of the last successful upgrade */
		time: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgradeFormProperties>({
			time: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgradeToVersion {

		/** The version ID */
		id?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgradeToVersionFormProperties {

		/** The version ID */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsCamera {

		/** The pending firmware upgrade if it exists */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsCameraFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsCameraFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsCameraFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgrade {

		/** The time of the last successful upgrade */
		time?: string | null;

		/** The version to be updated to */
		toVersion?: UpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgradeFormProperties {

		/** The time of the last successful upgrade */
		time: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgradeFormProperties>({
			time: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgradeToVersion {

		/** The version ID */
		id?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgradeToVersionFormProperties {

		/** The version ID */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGateway {

		/** The pending firmware upgrade if it exists */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgrade {

		/** The time of the last successful upgrade */
		time?: string | null;

		/** The version to be updated to */
		toVersion?: UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgradeFormProperties {

		/** The time of the last successful upgrade */
		time: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgradeFormProperties>({
			time: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgradeToVersion {

		/** The version ID */
		id?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgradeToVersionFormProperties {

		/** The version ID */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsSensor {

		/** The pending firmware upgrade if it exists */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsSensorFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsSensorFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsSensorFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgrade {

		/** The time of the last successful upgrade */
		time?: string | null;

		/** The version to be updated to */
		toVersion?: UpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgradeFormProperties {

		/** The time of the last successful upgrade */
		time: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgradeFormProperties>({
			time: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgradeToVersion {

		/** The version ID */
		id?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgradeToVersionFormProperties {

		/** The version ID */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsSwitch {

		/** The pending firmware upgrade if it exists */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsSwitchFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgrade {

		/** The time of the last successful upgrade */
		time?: string | null;

		/** The version to be updated to */
		toVersion?: UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgradeFormProperties {

		/** The time of the last successful upgrade */
		time: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgradeFormProperties>({
			time: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgradeToVersion {

		/** The version ID */
		id?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgradeToVersionFormProperties {

		/** The version ID */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsWireless {

		/** The pending firmware upgrade if it exists */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsWirelessFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgrade {

		/** The time of the last successful upgrade */
		time?: string | null;

		/** The version to be updated to */
		toVersion?: UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgradeFormProperties {

		/** The time of the last successful upgrade */
		time: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgradeFormProperties>({
			time: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgradeToVersion {

		/** The version ID */
		id?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgradeToVersionFormProperties {

		/** The version ID */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesPutBodyUpgradeWindow {

		/** Day of the week */
		dayOfWeek?: GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek | null;

		/** Hour of the day */
		hourOfDay?: GetNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay | null;
	}
	export interface UpdateNetworkFirmwareUpgradesPutBodyUpgradeWindowFormProperties {

		/** Day of the week */
		dayOfWeek: FormControl<GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek | null | undefined>,

		/** Hour of the day */
		hourOfDay: FormControl<GetNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesPutBodyUpgradeWindowFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesPutBodyUpgradeWindowFormProperties>({
			dayOfWeek: new FormControl<GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek | null | undefined>(undefined),
			hourOfDay: new FormControl<GetNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturn {

		/** The network devices to be updated */
		products?: UpdateNetworkFirmwareUpgradesReturnProducts;

		/** The timezone for the network */
		timezone?: string | null;

		/** Upgrade window for devices in network */
		upgradeWindow?: UpdateNetworkFirmwareUpgradesReturnUpgradeWindow;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnFormProperties {

		/** The timezone for the network */
		timezone: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnFormProperties>({
			timezone: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProducts {

		/** The network device to be updated */
		appliance?: UpdateNetworkFirmwareUpgradesReturnProductsAppliance;

		/** The network device to be updated */
		camera?: UpdateNetworkFirmwareUpgradesReturnProductsCamera;

		/** The network device to be updated */
		cellularGateway?: UpdateNetworkFirmwareUpgradesReturnProductsCellularGateway;

		/** The network device to be updated */
		sensor?: UpdateNetworkFirmwareUpgradesReturnProductsSensor;

		/** The network device to be updated */
		switch?: UpdateNetworkFirmwareUpgradesReturnProductsSwitch;

		/** The network device to be updated */
		wireless?: UpdateNetworkFirmwareUpgradesReturnProductsWireless;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsFormProperties {
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsFormProperties>({
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsAppliance {

		/** Firmware versions available for upgrade */
		UpdateNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersions?: Array<UpdateNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersions>;

		/** Details of the current version on the device */
		currentVersion?: UpdateNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersion;

		/** Details of the last firmware upgrade on the device */
		lastUpgrade?: UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgrade;

		/** Details of the next firmware upgrade on the device */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsApplianceFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsApplianceFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersions {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersionsFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersionsFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersionsFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgrade {

		/** Details of the version the device upgraded from */
		fromVersion?: UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersion;

		/** Timestamp of the last successful firmware upgrade */
		time?: Date | null;

		/** Details of the version the device upgraded to */
		toVersion?: UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFormProperties {

		/** Timestamp of the last successful firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgrade {

		/** Timestamp of the next scheduled firmware upgrade */
		time?: Date | null;

		/** Details of the version the device will upgrade to if it exists */
		toVersion?: UpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeFormProperties {

		/** Timestamp of the next scheduled firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCamera {

		/** Firmware versions available for upgrade */
		UpdateNetworkFirmwareUpgradesReturnProductsCameraAvailableVersions?: Array<UpdateNetworkFirmwareUpgradesReturnProductsCameraAvailableVersions>;

		/** Details of the current version on the device */
		currentVersion?: UpdateNetworkFirmwareUpgradesReturnProductsCameraCurrentVersion;

		/** Details of the last firmware upgrade on the device */
		lastUpgrade?: UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgrade;

		/** Details of the next firmware upgrade on the device */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCameraFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCameraFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraAvailableVersions {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraAvailableVersionsFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCameraAvailableVersionsFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCameraAvailableVersionsFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraCurrentVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraCurrentVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCameraCurrentVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCameraCurrentVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgrade {

		/** Details of the version the device upgraded from */
		fromVersion?: UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersion;

		/** Timestamp of the last successful firmware upgrade */
		time?: Date | null;

		/** Details of the version the device upgraded to */
		toVersion?: UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFormProperties {

		/** Timestamp of the last successful firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgrade {

		/** Timestamp of the next scheduled firmware upgrade */
		time?: Date | null;

		/** Details of the version the device will upgrade to if it exists */
		toVersion?: UpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeFormProperties {

		/** Timestamp of the next scheduled firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGateway {

		/** Firmware versions available for upgrade */
		UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersions?: Array<UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersions>;

		/** Details of the current version on the device */
		currentVersion?: UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersion;

		/** Details of the last firmware upgrade on the device */
		lastUpgrade?: UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgrade;

		/** Details of the next firmware upgrade on the device */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersions {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersionsFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersionsFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersionsFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgrade {

		/** Details of the version the device upgraded from */
		fromVersion?: UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersion;

		/** Timestamp of the last successful firmware upgrade */
		time?: Date | null;

		/** Details of the version the device upgraded to */
		toVersion?: UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFormProperties {

		/** Timestamp of the last successful firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgrade {

		/** Timestamp of the next scheduled firmware upgrade */
		time?: Date | null;

		/** Details of the version the device will upgrade to if it exists */
		toVersion?: UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeFormProperties {

		/** Timestamp of the next scheduled firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensor {

		/** Firmware versions available for upgrade */
		UpdateNetworkFirmwareUpgradesReturnProductsSensorAvailableVersions?: Array<UpdateNetworkFirmwareUpgradesReturnProductsSensorAvailableVersions>;

		/** Details of the current version on the device */
		currentVersion?: UpdateNetworkFirmwareUpgradesReturnProductsSensorCurrentVersion;

		/** Details of the last firmware upgrade on the device */
		lastUpgrade?: UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgrade;

		/** Details of the next firmware upgrade on the device */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSensorFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSensorFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorAvailableVersions {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorAvailableVersionsFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSensorAvailableVersionsFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSensorAvailableVersionsFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorCurrentVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorCurrentVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSensorCurrentVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSensorCurrentVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgrade {

		/** Details of the version the device upgraded from */
		fromVersion?: UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersion;

		/** Timestamp of the last successful firmware upgrade */
		time?: Date | null;

		/** Details of the version the device upgraded to */
		toVersion?: UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFormProperties {

		/** Timestamp of the last successful firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgrade {

		/** Timestamp of the next scheduled firmware upgrade */
		time?: Date | null;

		/** Details of the version the device will upgrade to if it exists */
		toVersion?: UpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeFormProperties {

		/** Timestamp of the next scheduled firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitch {

		/** Firmware versions available for upgrade */
		UpdateNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersions?: Array<UpdateNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersions>;

		/** Details of the current version on the device */
		currentVersion?: UpdateNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersion;

		/** Details of the last firmware upgrade on the device */
		lastUpgrade?: UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgrade;

		/** Details of the next firmware upgrade on the device */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSwitchFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSwitchFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersions {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersionsFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersionsFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersionsFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgrade {

		/** Details of the version the device upgraded from */
		fromVersion?: UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersion;

		/** Timestamp of the last successful firmware upgrade */
		time?: Date | null;

		/** Details of the version the device upgraded to */
		toVersion?: UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFormProperties {

		/** Timestamp of the last successful firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgrade {

		/** Timestamp of the next scheduled firmware upgrade */
		time?: Date | null;

		/** Details of the version the device will upgrade to if it exists */
		toVersion?: UpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeFormProperties {

		/** Timestamp of the next scheduled firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsWireless {

		/** Firmware versions available for upgrade */
		UpdateNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersions?: Array<UpdateNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersions>;

		/** Details of the current version on the device */
		currentVersion?: UpdateNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersion;

		/** Details of the last firmware upgrade on the device */
		lastUpgrade?: UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgrade;

		/** Details of the next firmware upgrade on the device */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgrade;

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease?: boolean | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessFormProperties {

		/** Whether or not the network wants beta firmware */
		participateInNextBetaRelease: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsWirelessFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsWirelessFormProperties>({
			participateInNextBetaRelease: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersions {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersionsFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersionsFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersionsFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgrade {

		/** Details of the version the device upgraded from */
		fromVersion?: UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersion;

		/** Timestamp of the last successful firmware upgrade */
		time?: Date | null;

		/** Details of the version the device upgraded to */
		toVersion?: UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFormProperties {

		/** Timestamp of the last successful firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgrade {

		/** Timestamp of the next scheduled firmware upgrade */
		time?: Date | null;

		/** Details of the version the device will upgrade to if it exists */
		toVersion?: UpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeFormProperties {

		/** Timestamp of the next scheduled firmware upgrade */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeFormProperties>({
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesReturnUpgradeWindow {

		/** Day of the week */
		dayOfWeek?: GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek | null;

		/** Hour of the day */
		hourOfDay?: GetNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay | null;
	}
	export interface UpdateNetworkFirmwareUpgradesReturnUpgradeWindowFormProperties {

		/** Day of the week */
		dayOfWeek: FormControl<GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek | null | undefined>,

		/** Hour of the day */
		hourOfDay: FormControl<GetNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesReturnUpgradeWindowFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesReturnUpgradeWindowFormProperties>({
			dayOfWeek: new FormControl<GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek | null | undefined>(undefined),
			hourOfDay: new FormControl<GetNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFirmwareUpgradesRollbackPostBody {

		/** Product type to rollback (if the network is a combined network) */
		product?: CreateNetworkFirmwareUpgradesRollbackPostBodyProduct | null;

		/**
		 * Reasons for the rollback
		 * Required
		 */
		CreateNetworkFirmwareUpgradesRollbackPostBodyReasons: Array<CreateNetworkFirmwareUpgradesRollbackPostBodyReasons>;

		/** Scheduled time for the rollback */
		time?: Date | null;

		/** Version to downgrade to (if the network has firmware flexibility) */
		toVersion?: CreateNetworkFirmwareUpgradesRollbackPostBodyToVersion;
	}
	export interface CreateNetworkFirmwareUpgradesRollbackPostBodyFormProperties {

		/** Product type to rollback (if the network is a combined network) */
		product: FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyProduct | null | undefined>,

		/** Scheduled time for the rollback */
		time: FormControl<Date | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesRollbackPostBodyFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesRollbackPostBodyFormProperties>({
			product: new FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyProduct | null | undefined>(undefined),
			time: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export enum CreateNetworkFirmwareUpgradesRollbackPostBodyProduct { appliance = 'appliance', camera = 'camera', cellularGateway = 'cellularGateway', switch = 'switch', wireless = 'wireless' }

	export interface CreateNetworkFirmwareUpgradesRollbackPostBodyReasons {

		/**
		 * Reason for the rollback
		 * Required
		 */
		category: CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory;

		/**
		 * Additional comment about the rollback
		 * Required
		 */
		comment: string;
	}
	export interface CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsFormProperties {

		/**
		 * Reason for the rollback
		 * Required
		 */
		category: FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>,

		/**
		 * Additional comment about the rollback
		 * Required
		 */
		comment: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesRollbackPostBodyReasonsFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsFormProperties>({
			category: new FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>(undefined, [Validators.required]),
			comment: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory { 'broke old features' = 'broke old features', other = 'other', performance = 'performance', stability = 'stability', testing = 'testing', 'unifying networks versions' = 'unifying networks versions' }

	export interface CreateNetworkFirmwareUpgradesRollbackPostBodyToVersion {

		/** The version ID */
		id?: string | null;
	}
	export interface CreateNetworkFirmwareUpgradesRollbackPostBodyToVersionFormProperties {

		/** The version ID */
		id: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesRollbackPostBodyToVersionFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesRollbackPostBodyToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFirmwareUpgradesRollbackReturn {

		/** Product type to rollback (if the network is a combined network) */
		product?: CreateNetworkFirmwareUpgradesRollbackPostBodyProduct | null;

		/** Reasons for the rollback */
		CreateNetworkFirmwareUpgradesRollbackReturnReasons?: Array<CreateNetworkFirmwareUpgradesRollbackReturnReasons>;

		/** Status of the rollback */
		status?: CreateNetworkFirmwareUpgradesRollbackReturnStatus | null;

		/** Scheduled time for the rollback */
		time?: Date | null;

		/** Version to downgrade to (if the network has firmware flexibility) */
		toVersion?: CreateNetworkFirmwareUpgradesRollbackReturnToVersion;

		/** Batch ID of the firmware rollback */
		upgradeBatchId?: string | null;
	}
	export interface CreateNetworkFirmwareUpgradesRollbackReturnFormProperties {

		/** Product type to rollback (if the network is a combined network) */
		product: FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyProduct | null | undefined>,

		/** Status of the rollback */
		status: FormControl<CreateNetworkFirmwareUpgradesRollbackReturnStatus | null | undefined>,

		/** Scheduled time for the rollback */
		time: FormControl<Date | null | undefined>,

		/** Batch ID of the firmware rollback */
		upgradeBatchId: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesRollbackReturnFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesRollbackReturnFormProperties>({
			product: new FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyProduct | null | undefined>(undefined),
			status: new FormControl<CreateNetworkFirmwareUpgradesRollbackReturnStatus | null | undefined>(undefined),
			time: new FormControl<Date | null | undefined>(undefined),
			upgradeBatchId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFirmwareUpgradesRollbackReturnReasons {

		/** Reason for the rollback */
		category?: CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null;

		/** Additional comment about the rollback */
		comment?: string | null;
	}
	export interface CreateNetworkFirmwareUpgradesRollbackReturnReasonsFormProperties {

		/** Reason for the rollback */
		category: FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>,

		/** Additional comment about the rollback */
		comment: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesRollbackReturnReasonsFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesRollbackReturnReasonsFormProperties>({
			category: new FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>(undefined),
			comment: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum CreateNetworkFirmwareUpgradesRollbackReturnStatus { canceled = 'canceled', completed = 'completed', in_progress = 'in_progress', pending = 'pending' }

	export interface CreateNetworkFirmwareUpgradesRollbackReturnToVersion {

		/** Name of the firmware version */
		firmware?: string | null;

		/** Firmware version identifier */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface CreateNetworkFirmwareUpgradesRollbackReturnToVersionFormProperties {

		/** Name of the firmware version */
		firmware: FormControl<string | null | undefined>,

		/** Firmware version identifier */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesRollbackReturnToVersionFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesRollbackReturnToVersionFormProperties>({
			firmware: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedEventsReturn {

		/** The network devices to be updated */
		products?: GetNetworkFirmwareUpgradesStagedEventsReturnProducts;

		/** Reasons for the rollback */
		GetNetworkFirmwareUpgradesStagedEventsReturnReasons?: Array<GetNetworkFirmwareUpgradesStagedEventsReturnReasons>;

		/** The ordered stages in the network */
		GetNetworkFirmwareUpgradesStagedEventsReturnStages?: Array<GetNetworkFirmwareUpgradesStagedEventsReturnStages>;
	}
	export interface GetNetworkFirmwareUpgradesStagedEventsReturnFormProperties {
	}
	export function CreateGetNetworkFirmwareUpgradesStagedEventsReturnFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedEventsReturnFormProperties>({
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedEventsReturnProducts {

		/** The Switch network to be updated */
		switch?: GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch;
	}
	export interface GetNetworkFirmwareUpgradesStagedEventsReturnProductsFormProperties {
	}
	export function CreateGetNetworkFirmwareUpgradesStagedEventsReturnProductsFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedEventsReturnProductsFormProperties>({
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch {

		/** Details of the next firmware upgrade */
		nextUpgrade?: GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade;
	}
	export interface GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchFormProperties {
	}
	export function CreateGetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchFormProperties>({
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade {

		/** Details of the version the device will upgrade to */
		toVersion?: GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion;
	}
	export interface GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeFormProperties {
	}
	export function CreateGetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeFormProperties>({
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion {

		/** Id of the Version being upgraded to */
		id?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersionFormProperties {

		/** Id of the Version being upgraded to */
		id: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersionFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedEventsReturnReasons {

		/** Reason for the rollback */
		category?: CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null;

		/** Additional comment about the rollback */
		comment?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesStagedEventsReturnReasonsFormProperties {

		/** Reason for the rollback */
		category: FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>,

		/** Additional comment about the rollback */
		comment: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesStagedEventsReturnReasonsFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedEventsReturnReasonsFormProperties>({
			category: new FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>(undefined),
			comment: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedEventsReturnStages {

		/** The staged upgrade group */
		group?: GetNetworkFirmwareUpgradesStagedEventsReturnStagesGroup;

		/** The Staged Upgrade Milestones for the stage */
		milestones?: GetNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones;

		/** Current upgrade status of the group */
		status?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesStagedEventsReturnStagesFormProperties {

		/** Current upgrade status of the group */
		status: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesStagedEventsReturnStagesFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedEventsReturnStagesFormProperties>({
			status: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedEventsReturnStagesGroup {

		/** Description of the Staged Upgrade Group */
		description?: string | null;

		/** Id of the Staged Upgrade Group */
		id?: string | null;

		/** Name of the Staged Upgrade Group */
		name?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesStagedEventsReturnStagesGroupFormProperties {

		/** Description of the Staged Upgrade Group */
		description: FormControl<string | null | undefined>,

		/** Id of the Staged Upgrade Group */
		id: FormControl<string | null | undefined>,

		/** Name of the Staged Upgrade Group */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesStagedEventsReturnStagesGroupFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedEventsReturnStagesGroupFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones {

		/** Time that the group was canceled */
		canceledAt?: Date | null;

		/** Finish time for the group */
		completedAt?: Date | null;

		/** Scheduled start time for the group */
		scheduledFor?: Date | null;

		/** Start time for the group */
		startedAt?: Date | null;
	}
	export interface GetNetworkFirmwareUpgradesStagedEventsReturnStagesMilestonesFormProperties {

		/** Time that the group was canceled */
		canceledAt: FormControl<Date | null | undefined>,

		/** Finish time for the group */
		completedAt: FormControl<Date | null | undefined>,

		/** Scheduled start time for the group */
		scheduledFor: FormControl<Date | null | undefined>,

		/** Start time for the group */
		startedAt: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesStagedEventsReturnStagesMilestonesFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedEventsReturnStagesMilestonesFormProperties>({
			canceledAt: new FormControl<Date | null | undefined>(undefined),
			completedAt: new FormControl<Date | null | undefined>(undefined),
			scheduledFor: new FormControl<Date | null | undefined>(undefined),
			startedAt: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventPostBody {

		/** Contains firmware upgrade version information */
		products?: CreateNetworkFirmwareUpgradesStagedEventPostBodyProducts;

		/**
		 * All firmware upgrade stages in the network with their start time.
		 * Required
		 */
		CreateNetworkFirmwareUpgradesStagedEventPostBodyStages: Array<CreateNetworkFirmwareUpgradesStagedEventPostBodyStages>;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyFormProperties {
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventPostBodyFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventPostBodyFormProperties>({
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyProducts {

		/** Version information for the switch network being upgraded */
		switch?: CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitch;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsFormProperties {
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventPostBodyProductsFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsFormProperties>({
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitch {

		/** The next upgrade version for the switch network */
		nextUpgrade?: CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgrade;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchFormProperties {
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchFormProperties>({
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgrade {

		/** The version to be updated to for switch devices */
		toVersion?: CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgradeToVersion;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgradeFormProperties {
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgradeFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgradeFormProperties>({
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgradeToVersion {

		/**
		 * The version ID
		 * Required
		 */
		id: string;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgradeToVersionFormProperties {

		/**
		 * The version ID
		 * Required
		 */
		id: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgradeToVersionFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyStages {

		/** The Staged Upgrade Group containing the name and ID */
		group?: CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesGroup;

		/** The Staged Upgrade Milestones for the specific stage */
		milestones?: CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesMilestones;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesFormProperties {
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventPostBodyStagesFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesFormProperties>({
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesGroup {

		/**
		 * ID of the Staged Upgrade Group
		 * Required
		 */
		id: string;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesGroupFormProperties {

		/**
		 * ID of the Staged Upgrade Group
		 * Required
		 */
		id: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventPostBodyStagesGroupFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesGroupFormProperties>({
			id: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesMilestones {

		/**
		 * The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
		 * Required
		 */
		scheduledFor: string;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesMilestonesFormProperties {

		/**
		 * The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
		 * Required
		 */
		scheduledFor: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventPostBodyStagesMilestonesFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesMilestonesFormProperties>({
			scheduledFor: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventReturn {

		/** The network devices to be updated */
		products?: CreateNetworkFirmwareUpgradesStagedEventReturnProducts;

		/** Reasons for the rollback */
		CreateNetworkFirmwareUpgradesStagedEventReturnReasons?: Array<CreateNetworkFirmwareUpgradesStagedEventReturnReasons>;

		/** The ordered stages in the network */
		CreateNetworkFirmwareUpgradesStagedEventReturnStages?: Array<CreateNetworkFirmwareUpgradesStagedEventReturnStages>;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventReturnFormProperties {
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventReturnFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventReturnFormProperties>({
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventReturnProducts {

		/** The Switch network to be updated */
		switch?: CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitch;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventReturnProductsFormProperties {
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventReturnProductsFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventReturnProductsFormProperties>({
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitch {

		/** Details of the next firmware upgrade */
		nextUpgrade?: CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgrade;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchFormProperties {
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchFormProperties>({
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgrade {

		/** Details of the version the device will upgrade to */
		toVersion?: CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgradeToVersion;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgradeFormProperties {
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgradeFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgradeFormProperties>({
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgradeToVersion {

		/** Id of the Version being upgraded to */
		id?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgradeToVersionFormProperties {

		/** Id of the Version being upgraded to */
		id: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgradeToVersionFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventReturnReasons {

		/** Reason for the rollback */
		category?: CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null;

		/** Additional comment about the rollback */
		comment?: string | null;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventReturnReasonsFormProperties {

		/** Reason for the rollback */
		category: FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>,

		/** Additional comment about the rollback */
		comment: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventReturnReasonsFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventReturnReasonsFormProperties>({
			category: new FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>(undefined),
			comment: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventReturnStages {

		/** The staged upgrade group */
		group?: CreateNetworkFirmwareUpgradesStagedEventReturnStagesGroup;

		/** The Staged Upgrade Milestones for the stage */
		milestones?: CreateNetworkFirmwareUpgradesStagedEventReturnStagesMilestones;

		/** Current upgrade status of the group */
		status?: string | null;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventReturnStagesFormProperties {

		/** Current upgrade status of the group */
		status: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventReturnStagesFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventReturnStagesFormProperties>({
			status: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventReturnStagesGroup {

		/** Description of the Staged Upgrade Group */
		description?: string | null;

		/** Id of the Staged Upgrade Group */
		id?: string | null;

		/** Name of the Staged Upgrade Group */
		name?: string | null;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventReturnStagesGroupFormProperties {

		/** Description of the Staged Upgrade Group */
		description: FormControl<string | null | undefined>,

		/** Id of the Staged Upgrade Group */
		id: FormControl<string | null | undefined>,

		/** Name of the Staged Upgrade Group */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventReturnStagesGroupFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventReturnStagesGroupFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFirmwareUpgradesStagedEventReturnStagesMilestones {

		/** Time that the group was canceled */
		canceledAt?: Date | null;

		/** Finish time for the group */
		completedAt?: Date | null;

		/** Scheduled start time for the group */
		scheduledFor?: Date | null;

		/** Start time for the group */
		startedAt?: Date | null;
	}
	export interface CreateNetworkFirmwareUpgradesStagedEventReturnStagesMilestonesFormProperties {

		/** Time that the group was canceled */
		canceledAt: FormControl<Date | null | undefined>,

		/** Finish time for the group */
		completedAt: FormControl<Date | null | undefined>,

		/** Scheduled start time for the group */
		scheduledFor: FormControl<Date | null | undefined>,

		/** Start time for the group */
		startedAt: FormControl<Date | null | undefined>,
	}
	export function CreateCreateNetworkFirmwareUpgradesStagedEventReturnStagesMilestonesFormGroup() {
		return new FormGroup<CreateNetworkFirmwareUpgradesStagedEventReturnStagesMilestonesFormProperties>({
			canceledAt: new FormControl<Date | null | undefined>(undefined),
			completedAt: new FormControl<Date | null | undefined>(undefined),
			scheduledFor: new FormControl<Date | null | undefined>(undefined),
			startedAt: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsPutBody {

		/**
		 * All firmware upgrade stages in the network with their start time.
		 * Required
		 */
		UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStages: Array<UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStages>;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsPutBodyFormProperties {
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStages {

		/** The Staged Upgrade Group containing the name and ID */
		group?: UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesGroup;

		/** The Staged Upgrade Milestones for the specific stage */
		milestones?: UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesMilestones;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesFormProperties {
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesFormProperties>({
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesGroup {

		/**
		 * ID of the Staged Upgrade Group
		 * Required
		 */
		id: string;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesGroupFormProperties {

		/**
		 * ID of the Staged Upgrade Group
		 * Required
		 */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesGroupFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesGroupFormProperties>({
			id: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesMilestones {

		/**
		 * The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
		 * Required
		 */
		scheduledFor: string;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesMilestonesFormProperties {

		/**
		 * The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
		 * Required
		 */
		scheduledFor: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesMilestonesFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesMilestonesFormProperties>({
			scheduledFor: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturn {

		/** The network devices to be updated */
		products?: UpdateNetworkFirmwareUpgradesStagedEventsReturnProducts;

		/** Reasons for the rollback */
		UpdateNetworkFirmwareUpgradesStagedEventsReturnReasons?: Array<UpdateNetworkFirmwareUpgradesStagedEventsReturnReasons>;

		/** The ordered stages in the network */
		UpdateNetworkFirmwareUpgradesStagedEventsReturnStages?: Array<UpdateNetworkFirmwareUpgradesStagedEventsReturnStages>;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnFormProperties {
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsReturnFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsReturnFormProperties>({
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnProducts {

		/** The Switch network to be updated */
		switch?: UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsFormProperties {
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsReturnProductsFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsFormProperties>({
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch {

		/** Details of the next firmware upgrade */
		nextUpgrade?: UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchFormProperties {
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchFormProperties>({
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade {

		/** Details of the version the device will upgrade to */
		toVersion?: UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeFormProperties {
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeFormProperties>({
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion {

		/** Id of the Version being upgraded to */
		id?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersionFormProperties {

		/** Id of the Version being upgraded to */
		id: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersionFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnReasons {

		/** Reason for the rollback */
		category?: CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null;

		/** Additional comment about the rollback */
		comment?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnReasonsFormProperties {

		/** Reason for the rollback */
		category: FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>,

		/** Additional comment about the rollback */
		comment: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsReturnReasonsFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsReturnReasonsFormProperties>({
			category: new FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>(undefined),
			comment: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnStages {

		/** The staged upgrade group */
		group?: UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesGroup;

		/** The Staged Upgrade Milestones for the stage */
		milestones?: UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones;

		/** Current upgrade status of the group */
		status?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesFormProperties {

		/** Current upgrade status of the group */
		status: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsReturnStagesFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesFormProperties>({
			status: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesGroup {

		/** Description of the Staged Upgrade Group */
		description?: string | null;

		/** Id of the Staged Upgrade Group */
		id?: string | null;

		/** Name of the Staged Upgrade Group */
		name?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesGroupFormProperties {

		/** Description of the Staged Upgrade Group */
		description: FormControl<string | null | undefined>,

		/** Id of the Staged Upgrade Group */
		id: FormControl<string | null | undefined>,

		/** Name of the Staged Upgrade Group */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsReturnStagesGroupFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesGroupFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones {

		/** Time that the group was canceled */
		canceledAt?: Date | null;

		/** Finish time for the group */
		completedAt?: Date | null;

		/** Scheduled start time for the group */
		scheduledFor?: Date | null;

		/** Start time for the group */
		startedAt?: Date | null;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesMilestonesFormProperties {

		/** Time that the group was canceled */
		canceledAt: FormControl<Date | null | undefined>,

		/** Finish time for the group */
		completedAt: FormControl<Date | null | undefined>,

		/** Scheduled start time for the group */
		scheduledFor: FormControl<Date | null | undefined>,

		/** Start time for the group */
		startedAt: FormControl<Date | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedEventsReturnStagesMilestonesFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesMilestonesFormProperties>({
			canceledAt: new FormControl<Date | null | undefined>(undefined),
			completedAt: new FormControl<Date | null | undefined>(undefined),
			scheduledFor: new FormControl<Date | null | undefined>(undefined),
			startedAt: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface DeferNetworkFirmwareUpgradesStagedEventsReturn {

		/** The network devices to be updated */
		products?: DeferNetworkFirmwareUpgradesStagedEventsReturnProducts;

		/** Reasons for the rollback */
		DeferNetworkFirmwareUpgradesStagedEventsReturnReasons?: Array<DeferNetworkFirmwareUpgradesStagedEventsReturnReasons>;

		/** The ordered stages in the network */
		DeferNetworkFirmwareUpgradesStagedEventsReturnStages?: Array<DeferNetworkFirmwareUpgradesStagedEventsReturnStages>;
	}
	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnFormProperties {
	}
	export function CreateDeferNetworkFirmwareUpgradesStagedEventsReturnFormGroup() {
		return new FormGroup<DeferNetworkFirmwareUpgradesStagedEventsReturnFormProperties>({
		});

	}

	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnProducts {

		/** The Switch network to be updated */
		switch?: DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch;
	}
	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnProductsFormProperties {
	}
	export function CreateDeferNetworkFirmwareUpgradesStagedEventsReturnProductsFormGroup() {
		return new FormGroup<DeferNetworkFirmwareUpgradesStagedEventsReturnProductsFormProperties>({
		});

	}

	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch {

		/** Details of the next firmware upgrade */
		nextUpgrade?: DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade;
	}
	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchFormProperties {
	}
	export function CreateDeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchFormGroup() {
		return new FormGroup<DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchFormProperties>({
		});

	}

	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade {

		/** Details of the version the device will upgrade to */
		toVersion?: DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion;
	}
	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeFormProperties {
	}
	export function CreateDeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeFormGroup() {
		return new FormGroup<DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeFormProperties>({
		});

	}

	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion {

		/** Id of the Version being upgraded to */
		id?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersionFormProperties {

		/** Id of the Version being upgraded to */
		id: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateDeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersionFormGroup() {
		return new FormGroup<DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnReasons {

		/** Reason for the rollback */
		category?: CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null;

		/** Additional comment about the rollback */
		comment?: string | null;
	}
	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnReasonsFormProperties {

		/** Reason for the rollback */
		category: FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>,

		/** Additional comment about the rollback */
		comment: FormControl<string | null | undefined>,
	}
	export function CreateDeferNetworkFirmwareUpgradesStagedEventsReturnReasonsFormGroup() {
		return new FormGroup<DeferNetworkFirmwareUpgradesStagedEventsReturnReasonsFormProperties>({
			category: new FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>(undefined),
			comment: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnStages {

		/** The staged upgrade group */
		group?: DeferNetworkFirmwareUpgradesStagedEventsReturnStagesGroup;

		/** The Staged Upgrade Milestones for the stage */
		milestones?: DeferNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones;

		/** Current upgrade status of the group */
		status?: string | null;
	}
	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnStagesFormProperties {

		/** Current upgrade status of the group */
		status: FormControl<string | null | undefined>,
	}
	export function CreateDeferNetworkFirmwareUpgradesStagedEventsReturnStagesFormGroup() {
		return new FormGroup<DeferNetworkFirmwareUpgradesStagedEventsReturnStagesFormProperties>({
			status: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnStagesGroup {

		/** Description of the Staged Upgrade Group */
		description?: string | null;

		/** Id of the Staged Upgrade Group */
		id?: string | null;

		/** Name of the Staged Upgrade Group */
		name?: string | null;
	}
	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnStagesGroupFormProperties {

		/** Description of the Staged Upgrade Group */
		description: FormControl<string | null | undefined>,

		/** Id of the Staged Upgrade Group */
		id: FormControl<string | null | undefined>,

		/** Name of the Staged Upgrade Group */
		name: FormControl<string | null | undefined>,
	}
	export function CreateDeferNetworkFirmwareUpgradesStagedEventsReturnStagesGroupFormGroup() {
		return new FormGroup<DeferNetworkFirmwareUpgradesStagedEventsReturnStagesGroupFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones {

		/** Time that the group was canceled */
		canceledAt?: Date | null;

		/** Finish time for the group */
		completedAt?: Date | null;

		/** Scheduled start time for the group */
		scheduledFor?: Date | null;

		/** Start time for the group */
		startedAt?: Date | null;
	}
	export interface DeferNetworkFirmwareUpgradesStagedEventsReturnStagesMilestonesFormProperties {

		/** Time that the group was canceled */
		canceledAt: FormControl<Date | null | undefined>,

		/** Finish time for the group */
		completedAt: FormControl<Date | null | undefined>,

		/** Scheduled start time for the group */
		scheduledFor: FormControl<Date | null | undefined>,

		/** Start time for the group */
		startedAt: FormControl<Date | null | undefined>,
	}
	export function CreateDeferNetworkFirmwareUpgradesStagedEventsReturnStagesMilestonesFormGroup() {
		return new FormGroup<DeferNetworkFirmwareUpgradesStagedEventsReturnStagesMilestonesFormProperties>({
			canceledAt: new FormControl<Date | null | undefined>(undefined),
			completedAt: new FormControl<Date | null | undefined>(undefined),
			scheduledFor: new FormControl<Date | null | undefined>(undefined),
			startedAt: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsPostBody {

		/** The reason for rolling back the staged upgrade */
		RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyReasons?: Array<RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyReasons>;

		/**
		 * All completed or in-progress stages in the network with their new start times. All pending stages will be canceled
		 * Required
		 */
		RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStages: Array<RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStages>;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyFormProperties {
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsPostBodyFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyFormProperties>({
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyReasons {

		/**
		 * Reason for the rollback
		 * Required
		 */
		category: CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory;

		/**
		 * Additional comment about the rollback
		 * Required
		 */
		comment: string;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyReasonsFormProperties {

		/**
		 * Reason for the rollback
		 * Required
		 */
		category: FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>,

		/**
		 * Additional comment about the rollback
		 * Required
		 */
		comment: FormControl<string | null | undefined>,
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsPostBodyReasonsFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyReasonsFormProperties>({
			category: new FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>(undefined, [Validators.required]),
			comment: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStages {

		/** The Staged Upgrade Group containing the name and ID */
		group?: RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesGroup;

		/** The Staged Upgrade Milestones for the specific stage */
		milestones?: RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesMilestones;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesFormProperties {
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesFormProperties>({
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesGroup {

		/**
		 * ID of the Staged Upgrade Group
		 * Required
		 */
		id: string;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesGroupFormProperties {

		/**
		 * ID of the Staged Upgrade Group
		 * Required
		 */
		id: FormControl<string | null | undefined>,
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesGroupFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesGroupFormProperties>({
			id: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesMilestones {

		/**
		 * The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
		 * Required
		 */
		scheduledFor: string;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesMilestonesFormProperties {

		/**
		 * The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
		 * Required
		 */
		scheduledFor: FormControl<string | null | undefined>,
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesMilestonesFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesMilestonesFormProperties>({
			scheduledFor: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturn {

		/** The network devices to be updated */
		products?: RollbacksNetworkFirmwareUpgradesStagedEventsReturnProducts;

		/** Reasons for the rollback */
		RollbacksNetworkFirmwareUpgradesStagedEventsReturnReasons?: Array<RollbacksNetworkFirmwareUpgradesStagedEventsReturnReasons>;

		/** The ordered stages in the network */
		RollbacksNetworkFirmwareUpgradesStagedEventsReturnStages?: Array<RollbacksNetworkFirmwareUpgradesStagedEventsReturnStages>;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnFormProperties {
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsReturnFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsReturnFormProperties>({
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnProducts {

		/** The Switch network to be updated */
		switch?: RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsFormProperties {
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsFormProperties>({
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch {

		/** Details of the next firmware upgrade */
		nextUpgrade?: RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchFormProperties {
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchFormProperties>({
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade {

		/** Details of the version the device will upgrade to */
		toVersion?: RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeFormProperties {
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeFormProperties>({
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion {

		/** Id of the Version being upgraded to */
		id?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersionFormProperties {

		/** Id of the Version being upgraded to */
		id: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersionFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnReasons {

		/** Reason for the rollback */
		category?: CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null;

		/** Additional comment about the rollback */
		comment?: string | null;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnReasonsFormProperties {

		/** Reason for the rollback */
		category: FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>,

		/** Additional comment about the rollback */
		comment: FormControl<string | null | undefined>,
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsReturnReasonsFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsReturnReasonsFormProperties>({
			category: new FormControl<CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory | null | undefined>(undefined),
			comment: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnStages {

		/** The staged upgrade group */
		group?: RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesGroup;

		/** The Staged Upgrade Milestones for the stage */
		milestones?: RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones;

		/** Current upgrade status of the group */
		status?: string | null;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesFormProperties {

		/** Current upgrade status of the group */
		status: FormControl<string | null | undefined>,
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesFormProperties>({
			status: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesGroup {

		/** Description of the Staged Upgrade Group */
		description?: string | null;

		/** Id of the Staged Upgrade Group */
		id?: string | null;

		/** Name of the Staged Upgrade Group */
		name?: string | null;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesGroupFormProperties {

		/** Description of the Staged Upgrade Group */
		description: FormControl<string | null | undefined>,

		/** Id of the Staged Upgrade Group */
		id: FormControl<string | null | undefined>,

		/** Name of the Staged Upgrade Group */
		name: FormControl<string | null | undefined>,
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesGroupFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesGroupFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones {

		/** Time that the group was canceled */
		canceledAt?: Date | null;

		/** Finish time for the group */
		completedAt?: Date | null;

		/** Scheduled start time for the group */
		scheduledFor?: Date | null;

		/** Start time for the group */
		startedAt?: Date | null;
	}
	export interface RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesMilestonesFormProperties {

		/** Time that the group was canceled */
		canceledAt: FormControl<Date | null | undefined>,

		/** Finish time for the group */
		completedAt: FormControl<Date | null | undefined>,

		/** Scheduled start time for the group */
		scheduledFor: FormControl<Date | null | undefined>,

		/** Start time for the group */
		startedAt: FormControl<Date | null | undefined>,
	}
	export function CreateRollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesMilestonesFormGroup() {
		return new FormGroup<RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesMilestonesFormProperties>({
			canceledAt: new FormControl<Date | null | undefined>(undefined),
			completedAt: new FormControl<Date | null | undefined>(undefined),
			scheduledFor: new FormControl<Date | null | undefined>(undefined),
			startedAt: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedGroupsReturn {

		/** The devices and Switch Stacks assigned to the Group */
		assignedDevices?: GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevices;

		/** Description of the Staged Upgrade Group */
		description?: string | null;

		/** Id of staged upgrade group */
		groupId?: string | null;

		/** Boolean indicating the default Group. Any device that does not have a group explicitly assigned will upgrade with this group */
		isDefault?: boolean | null;

		/** Name of the Staged Upgrade Group */
		name?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesStagedGroupsReturnFormProperties {

		/** Description of the Staged Upgrade Group */
		description: FormControl<string | null | undefined>,

		/** Id of staged upgrade group */
		groupId: FormControl<string | null | undefined>,

		/** Boolean indicating the default Group. Any device that does not have a group explicitly assigned will upgrade with this group */
		isDefault: FormControl<boolean | null | undefined>,

		/** Name of the Staged Upgrade Group */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesStagedGroupsReturnFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedGroupsReturnFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			groupId: new FormControl<string | null | undefined>(undefined),
			isDefault: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevices {

		/** Data Array of Devices containing the name and serial */
		GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesDevices?: Array<GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesDevices>;

		/** Data Array of Switch Stacks containing the name and id */
		GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesSwitchStacks?: Array<GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesSwitchStacks>;
	}
	export interface GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesFormProperties {
	}
	export function CreateGetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesFormProperties>({
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesDevices {

		/** Name of the device */
		name?: string | null;

		/** Serial of the device */
		serial?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesDevicesFormProperties {

		/** Name of the device */
		name: FormControl<string | null | undefined>,

		/** Serial of the device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesDevicesFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesDevicesFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesSwitchStacks {

		/** ID of the Switch Stack */
		id?: string | null;

		/** Name of the Switch Stack */
		name?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesSwitchStacksFormProperties {

		/** ID of the Switch Stack */
		id: FormControl<string | null | undefined>,

		/** Name of the Switch Stack */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesSwitchStacksFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesSwitchStacksFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedGroupReturn {

		/** The devices and Switch Stacks assigned to the Group */
		assignedDevices?: GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevices;

		/** Description of the Staged Upgrade Group */
		description?: string | null;

		/** Id of staged upgrade group */
		groupId?: string | null;

		/** Boolean indicating the default Group. Any device that does not have a group explicitly assigned will upgrade with this group */
		isDefault?: boolean | null;

		/** Name of the Staged Upgrade Group */
		name?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesStagedGroupReturnFormProperties {

		/** Description of the Staged Upgrade Group */
		description: FormControl<string | null | undefined>,

		/** Id of staged upgrade group */
		groupId: FormControl<string | null | undefined>,

		/** Boolean indicating the default Group. Any device that does not have a group explicitly assigned will upgrade with this group */
		isDefault: FormControl<boolean | null | undefined>,

		/** Name of the Staged Upgrade Group */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesStagedGroupReturnFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedGroupReturnFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			groupId: new FormControl<string | null | undefined>(undefined),
			isDefault: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevices {

		/** Data Array of Devices containing the name and serial */
		GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesDevices?: Array<GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesDevices>;

		/** Data Array of Switch Stacks containing the name and id */
		GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesSwitchStacks?: Array<GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesSwitchStacks>;
	}
	export interface GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesFormProperties {
	}
	export function CreateGetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesFormProperties>({
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesDevices {

		/** Name of the device */
		name?: string | null;

		/** Serial of the device */
		serial?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesDevicesFormProperties {

		/** Name of the device */
		name: FormControl<string | null | undefined>,

		/** Serial of the device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesDevicesFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesDevicesFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesSwitchStacks {

		/** ID of the Switch Stack */
		id?: string | null;

		/** Name of the Switch Stack */
		name?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesSwitchStacksFormProperties {

		/** ID of the Switch Stack */
		id: FormControl<string | null | undefined>,

		/** Name of the Switch Stack */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesSwitchStacksFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesSwitchStacksFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedStagesReturn {

		/** The Staged Upgrade Group */
		group?: GetNetworkFirmwareUpgradesStagedStagesReturnGroup;
	}
	export interface GetNetworkFirmwareUpgradesStagedStagesReturnFormProperties {
	}
	export function CreateGetNetworkFirmwareUpgradesStagedStagesReturnFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedStagesReturnFormProperties>({
		});

	}

	export interface GetNetworkFirmwareUpgradesStagedStagesReturnGroup {

		/** Description of the Staged Upgrade Group */
		description?: string | null;

		/** Id of the Staged Upgrade Group */
		id?: string | null;

		/** Name of the Staged Upgrade Group */
		name?: string | null;
	}
	export interface GetNetworkFirmwareUpgradesStagedStagesReturnGroupFormProperties {

		/** Description of the Staged Upgrade Group */
		description: FormControl<string | null | undefined>,

		/** Id of the Staged Upgrade Group */
		id: FormControl<string | null | undefined>,

		/** Name of the Staged Upgrade Group */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkFirmwareUpgradesStagedStagesReturnGroupFormGroup() {
		return new FormGroup<GetNetworkFirmwareUpgradesStagedStagesReturnGroupFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedStagesPutBody {

		/** Array of Staged Upgrade Groups */
		UpdateNetworkFirmwareUpgradesStagedStagesPutBody_json?: Array<UpdateNetworkFirmwareUpgradesStagedStagesPutBody_json>;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedStagesPutBodyFormProperties {
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedStagesPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedStagesPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedStagesPutBody_json {

		/** The Staged Upgrade Group */
		group?: UpdateNetworkFirmwareUpgradesStagedStagesPutBody_jsonGroup;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedStagesPutBody_jsonFormProperties {
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedStagesPutBody_jsonFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedStagesPutBody_jsonFormProperties>({
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedStagesPutBody_jsonGroup {

		/**
		 * ID of the Staged Upgrade Group
		 * Required
		 */
		id: string;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedStagesPutBody_jsonGroupFormProperties {

		/**
		 * ID of the Staged Upgrade Group
		 * Required
		 */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedStagesPutBody_jsonGroupFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedStagesPutBody_jsonGroupFormProperties>({
			id: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedStagesReturn {

		/** The Staged Upgrade Group */
		group?: UpdateNetworkFirmwareUpgradesStagedStagesReturnGroup;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedStagesReturnFormProperties {
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedStagesReturnFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedStagesReturnFormProperties>({
		});

	}

	export interface UpdateNetworkFirmwareUpgradesStagedStagesReturnGroup {

		/** Description of the Staged Upgrade Group */
		description?: string | null;

		/** Id of the Staged Upgrade Group */
		id?: string | null;

		/** Name of the Staged Upgrade Group */
		name?: string | null;
	}
	export interface UpdateNetworkFirmwareUpgradesStagedStagesReturnGroupFormProperties {

		/** Description of the Staged Upgrade Group */
		description: FormControl<string | null | undefined>,

		/** Id of the Staged Upgrade Group */
		id: FormControl<string | null | undefined>,

		/** Name of the Staged Upgrade Group */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFirmwareUpgradesStagedStagesReturnGroupFormGroup() {
		return new FormGroup<UpdateNetworkFirmwareUpgradesStagedStagesReturnGroupFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFloorPlanPostBody {

		/** The longitude and latitude of the bottom left corner of your floor plan. */
		bottomLeftCorner?: CreateNetworkFloorPlanPostBodyBottomLeftCorner;

		/** The longitude and latitude of the bottom right corner of your floor plan. */
		bottomRightCorner?: CreateNetworkFloorPlanPostBodyBottomRightCorner;

		/** The longitude and latitude of the center of your floor plan. The 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair. */
		center?: CreateNetworkFloorPlanPostBodyCenter;

		/**
		 * The file contents (a base 64 encoded string) of your image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in.
		 * Required
		 */
		imageContents: string;

		/**
		 * The name of your floor plan.
		 * Required
		 */
		name: string;

		/** The longitude and latitude of the top left corner of your floor plan. */
		topLeftCorner?: CreateNetworkFloorPlanPostBodyTopLeftCorner;

		/** The longitude and latitude of the top right corner of your floor plan. */
		topRightCorner?: CreateNetworkFloorPlanPostBodyTopRightCorner;
	}
	export interface CreateNetworkFloorPlanPostBodyFormProperties {

		/**
		 * The file contents (a base 64 encoded string) of your image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in.
		 * Required
		 */
		imageContents: FormControl<string | null | undefined>,

		/**
		 * The name of your floor plan.
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkFloorPlanPostBodyFormGroup() {
		return new FormGroup<CreateNetworkFloorPlanPostBodyFormProperties>({
			imageContents: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkFloorPlanPostBodyBottomLeftCorner {

		/** Latitude */
		lat?: number | null;

		/** Longitude */
		lng?: number | null;
	}
	export interface CreateNetworkFloorPlanPostBodyBottomLeftCornerFormProperties {

		/** Latitude */
		lat: FormControl<number | null | undefined>,

		/** Longitude */
		lng: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkFloorPlanPostBodyBottomLeftCornerFormGroup() {
		return new FormGroup<CreateNetworkFloorPlanPostBodyBottomLeftCornerFormProperties>({
			lat: new FormControl<number | null | undefined>(undefined),
			lng: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFloorPlanPostBodyBottomRightCorner {

		/** Latitude */
		lat?: number | null;

		/** Longitude */
		lng?: number | null;
	}
	export interface CreateNetworkFloorPlanPostBodyBottomRightCornerFormProperties {

		/** Latitude */
		lat: FormControl<number | null | undefined>,

		/** Longitude */
		lng: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkFloorPlanPostBodyBottomRightCornerFormGroup() {
		return new FormGroup<CreateNetworkFloorPlanPostBodyBottomRightCornerFormProperties>({
			lat: new FormControl<number | null | undefined>(undefined),
			lng: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFloorPlanPostBodyCenter {

		/** Latitude */
		lat?: number | null;

		/** Longitude */
		lng?: number | null;
	}
	export interface CreateNetworkFloorPlanPostBodyCenterFormProperties {

		/** Latitude */
		lat: FormControl<number | null | undefined>,

		/** Longitude */
		lng: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkFloorPlanPostBodyCenterFormGroup() {
		return new FormGroup<CreateNetworkFloorPlanPostBodyCenterFormProperties>({
			lat: new FormControl<number | null | undefined>(undefined),
			lng: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFloorPlanPostBodyTopLeftCorner {

		/** Latitude */
		lat?: number | null;

		/** Longitude */
		lng?: number | null;
	}
	export interface CreateNetworkFloorPlanPostBodyTopLeftCornerFormProperties {

		/** Latitude */
		lat: FormControl<number | null | undefined>,

		/** Longitude */
		lng: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkFloorPlanPostBodyTopLeftCornerFormGroup() {
		return new FormGroup<CreateNetworkFloorPlanPostBodyTopLeftCornerFormProperties>({
			lat: new FormControl<number | null | undefined>(undefined),
			lng: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkFloorPlanPostBodyTopRightCorner {

		/** Latitude */
		lat?: number | null;

		/** Longitude */
		lng?: number | null;
	}
	export interface CreateNetworkFloorPlanPostBodyTopRightCornerFormProperties {

		/** Latitude */
		lat: FormControl<number | null | undefined>,

		/** Longitude */
		lng: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkFloorPlanPostBodyTopRightCornerFormGroup() {
		return new FormGroup<CreateNetworkFloorPlanPostBodyTopRightCornerFormProperties>({
			lat: new FormControl<number | null | undefined>(undefined),
			lng: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFloorPlanPutBody {

		/** The longitude and latitude of the bottom left corner of your floor plan. */
		bottomLeftCorner?: UpdateNetworkFloorPlanPutBodyBottomLeftCorner;

		/** The longitude and latitude of the bottom right corner of your floor plan. */
		bottomRightCorner?: UpdateNetworkFloorPlanPutBodyBottomRightCorner;

		/** The longitude and latitude of the center of your floor plan. If you want to change the geolocation data of your floor plan, either the 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair. */
		center?: UpdateNetworkFloorPlanPutBodyCenter;

		/** The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image. */
		imageContents?: string | null;

		/** The name of your floor plan. */
		name?: string | null;

		/** The longitude and latitude of the top left corner of your floor plan. */
		topLeftCorner?: UpdateNetworkFloorPlanPutBodyTopLeftCorner;

		/** The longitude and latitude of the top right corner of your floor plan. */
		topRightCorner?: UpdateNetworkFloorPlanPutBodyTopRightCorner;
	}
	export interface UpdateNetworkFloorPlanPutBodyFormProperties {

		/** The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image. */
		imageContents: FormControl<string | null | undefined>,

		/** The name of your floor plan. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkFloorPlanPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkFloorPlanPutBodyFormProperties>({
			imageContents: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFloorPlanPutBodyBottomLeftCorner {

		/** Latitude */
		lat?: number | null;

		/** Longitude */
		lng?: number | null;
	}
	export interface UpdateNetworkFloorPlanPutBodyBottomLeftCornerFormProperties {

		/** Latitude */
		lat: FormControl<number | null | undefined>,

		/** Longitude */
		lng: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkFloorPlanPutBodyBottomLeftCornerFormGroup() {
		return new FormGroup<UpdateNetworkFloorPlanPutBodyBottomLeftCornerFormProperties>({
			lat: new FormControl<number | null | undefined>(undefined),
			lng: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFloorPlanPutBodyBottomRightCorner {

		/** Latitude */
		lat?: number | null;

		/** Longitude */
		lng?: number | null;
	}
	export interface UpdateNetworkFloorPlanPutBodyBottomRightCornerFormProperties {

		/** Latitude */
		lat: FormControl<number | null | undefined>,

		/** Longitude */
		lng: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkFloorPlanPutBodyBottomRightCornerFormGroup() {
		return new FormGroup<UpdateNetworkFloorPlanPutBodyBottomRightCornerFormProperties>({
			lat: new FormControl<number | null | undefined>(undefined),
			lng: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFloorPlanPutBodyCenter {

		/** Latitude */
		lat?: number | null;

		/** Longitude */
		lng?: number | null;
	}
	export interface UpdateNetworkFloorPlanPutBodyCenterFormProperties {

		/** Latitude */
		lat: FormControl<number | null | undefined>,

		/** Longitude */
		lng: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkFloorPlanPutBodyCenterFormGroup() {
		return new FormGroup<UpdateNetworkFloorPlanPutBodyCenterFormProperties>({
			lat: new FormControl<number | null | undefined>(undefined),
			lng: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFloorPlanPutBodyTopLeftCorner {

		/** Latitude */
		lat?: number | null;

		/** Longitude */
		lng?: number | null;
	}
	export interface UpdateNetworkFloorPlanPutBodyTopLeftCornerFormProperties {

		/** Latitude */
		lat: FormControl<number | null | undefined>,

		/** Longitude */
		lng: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkFloorPlanPutBodyTopLeftCornerFormGroup() {
		return new FormGroup<UpdateNetworkFloorPlanPutBodyTopLeftCornerFormProperties>({
			lat: new FormControl<number | null | undefined>(undefined),
			lng: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkFloorPlanPutBodyTopRightCorner {

		/** Latitude */
		lat?: number | null;

		/** Longitude */
		lng?: number | null;
	}
	export interface UpdateNetworkFloorPlanPutBodyTopRightCornerFormProperties {

		/** Latitude */
		lat: FormControl<number | null | undefined>,

		/** Longitude */
		lng: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkFloorPlanPutBodyTopRightCornerFormGroup() {
		return new FormGroup<UpdateNetworkFloorPlanPutBodyTopRightCornerFormProperties>({
			lat: new FormControl<number | null | undefined>(undefined),
			lng: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBody {

		/**
		 * The bandwidth settings for clients bound to your group policy.
		 */
		bandwidth?: CreateNetworkGroupPolicyPostBodyBandwidth;

		/** The Bonjour settings for your group policy. Only valid if your network has a wireless configuration. */
		bonjourForwarding?: CreateNetworkGroupPolicyPostBodyBonjourForwarding;

		/** The content filtering settings for your group policy */
		contentFiltering?: CreateNetworkGroupPolicyPostBodyContentFiltering;

		/**
		 * The firewall and traffic shaping rules and settings for your policy.
		 */
		firewallAndTrafficShaping?: CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShaping;

		/**
		 * The name for your group policy. Required.
		 * Required
		 */
		name: string;

		/**
		 * The schedule for the group policy. Schedules are applied to days of the week.
		 */
		scheduling?: CreateNetworkGroupPolicyPostBodyScheduling;

		/** Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration. */
		splashAuthSettings?: CreateNetworkGroupPolicyPostBodySplashAuthSettings | null;

		/** The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration. */
		vlanTagging?: CreateNetworkGroupPolicyPostBodyVlanTagging;
	}
	export interface CreateNetworkGroupPolicyPostBodyFormProperties {

		/**
		 * The name for your group policy. Required.
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/** Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration. */
		splashAuthSettings: FormControl<CreateNetworkGroupPolicyPostBodySplashAuthSettings | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			splashAuthSettings: new FormControl<CreateNetworkGroupPolicyPostBodySplashAuthSettings | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyBandwidth {

		/** The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'. */
		bandwidthLimits?: CreateNetworkGroupPolicyPostBodyBandwidthBandwidthLimits;

		/** How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'. */
		settings?: CreateNetworkGroupPolicyPostBodyBandwidthSettings | null;
	}
	export interface CreateNetworkGroupPolicyPostBodyBandwidthFormProperties {

		/** How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyBandwidthFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyBandwidthFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyBandwidthBandwidthLimits {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown?: number | null;

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp?: number | null;
	}
	export interface CreateNetworkGroupPolicyPostBodyBandwidthBandwidthLimitsFormProperties {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown: FormControl<number | null | undefined>,

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyBandwidthBandwidthLimitsFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyBandwidthBandwidthLimitsFormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum CreateNetworkGroupPolicyPostBodyBandwidthSettings { custom = 'custom', ignore = 'ignore', 'network default' = 'network default' }

	export interface CreateNetworkGroupPolicyPostBodyBonjourForwarding {

		/** A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified. */
		CreateNetworkGroupPolicyPostBodyBonjourForwardingRules?: Array<CreateNetworkGroupPolicyPostBodyBonjourForwardingRules>;

		/** How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'. */
		settings?: CreateNetworkGroupPolicyPostBodyBandwidthSettings | null;
	}
	export interface CreateNetworkGroupPolicyPostBodyBonjourForwardingFormProperties {

		/** How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyBonjourForwardingFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyBonjourForwardingFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyBonjourForwardingRules {

		/** A description for your Bonjour forwarding rule. Optional. */
		description?: string | null;

		/**
		 * A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
		 * Required
		 */
		services: Array<string>;

		/**
		 * The ID of the service VLAN. Required.
		 * Required
		 */
		vlanId: string;
	}
	export interface CreateNetworkGroupPolicyPostBodyBonjourForwardingRulesFormProperties {

		/** A description for your Bonjour forwarding rule. Optional. */
		description: FormControl<string | null | undefined>,

		/**
		 * The ID of the service VLAN. Required.
		 * Required
		 */
		vlanId: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyBonjourForwardingRulesFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyBonjourForwardingRulesFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			vlanId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyContentFiltering {

		/** Settings for allowed URL patterns */
		allowedUrlPatterns?: CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatterns;

		/** Settings for blocked URL categories */
		blockedUrlCategories?: CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlCategories;

		/** Settings for blocked URL patterns */
		blockedUrlPatterns?: CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlPatterns;
	}
	export interface CreateNetworkGroupPolicyPostBodyContentFilteringFormProperties {
	}
	export function CreateCreateNetworkGroupPolicyPostBodyContentFilteringFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyContentFilteringFormProperties>({
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatterns {

		/** A list of URL patterns that are allowed */
		patterns?: Array<string>;

		/** How URL patterns are applied. Can be 'network default', 'append' or 'override'. */
		settings?: CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null;
	}
	export interface CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsFormProperties {

		/** How URL patterns are applied. Can be 'network default', 'append' or 'override'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null | undefined>(undefined),
		});

	}

	export enum CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings { append = 'append', 'network default' = 'network default', override = 'override' }

	export interface CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlCategories {

		/** A list of URL categories to block */
		categories?: Array<string>;

		/** How URL categories are applied. Can be 'network default', 'append' or 'override'. */
		settings?: CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null;
	}
	export interface CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlCategoriesFormProperties {

		/** How URL categories are applied. Can be 'network default', 'append' or 'override'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlCategoriesFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlCategoriesFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlPatterns {

		/** A list of URL patterns that are blocked */
		patterns?: Array<string>;

		/** How URL patterns are applied. Can be 'network default', 'append' or 'override'. */
		settings?: CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null;
	}
	export interface CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlPatternsFormProperties {

		/** How URL patterns are applied. Can be 'network default', 'append' or 'override'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlPatternsFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlPatternsFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShaping {

		/** An ordered array of the L3 firewall rules */
		CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL3FirewallRules?: Array<CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL3FirewallRules>;

		/** An ordered array of L7 firewall rules */
		CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL7FirewallRules?: Array<CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL7FirewallRules>;

		/** How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'. */
		settings?: CreateNetworkGroupPolicyPostBodyBandwidthSettings | null;

		/**
		 * An array of traffic shaping rules. Rules are applied in the order that
		 * they are specified in. An empty list (or null) means no rules. Note that
		 * you are allowed a maximum of 8 rules.
		 */
		CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRules?: Array<CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRules>;
	}
	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingFormProperties {

		/** How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL3FirewallRules {

		/** Description of the rule (optional) */
		comment?: string | null;

		/**
		 * Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
		 * Required
		 */
		destCidr: string;

		/** Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any' */
		destPort?: string | null;

		/**
		 * 'allow' or 'deny' traffic specified by this rule
		 * Required
		 */
		policy: string;

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		 * Required
		 */
		protocol: string;
	}
	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL3FirewallRulesFormProperties {

		/** Description of the rule (optional) */
		comment: FormControl<string | null | undefined>,

		/**
		 * Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
		 * Required
		 */
		destCidr: FormControl<string | null | undefined>,

		/** Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any' */
		destPort: FormControl<string | null | undefined>,

		/**
		 * 'allow' or 'deny' traffic specified by this rule
		 * Required
		 */
		policy: FormControl<string | null | undefined>,

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		 * Required
		 */
		protocol: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL3FirewallRulesFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL3FirewallRulesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			destCidr: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			destPort: new FormControl<string | null | undefined>(undefined),
			policy: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			protocol: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL7FirewallRules {

		/** The policy applied to matching traffic. Must be 'deny'. */
		policy?: UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy | null;

		/** Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange' */
		type?: UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType | null;

		/** The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application. */
		value?: string | null;
	}
	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL7FirewallRulesFormProperties {

		/** The policy applied to matching traffic. Must be 'deny'. */
		policy: FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy | null | undefined>,

		/** Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange' */
		type: FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType | null | undefined>,

		/** The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application. */
		value: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL7FirewallRulesFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL7FirewallRulesFormProperties>({
			policy: new FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy | null | undefined>(undefined),
			type: new FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType | null | undefined>(undefined),
			value: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRules {

		/**
		 * A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
		 * Required
		 */
		CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions: Array<CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions>;

		/**
		 * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
		 * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
		 */
		dscpTagValue?: number | null;

		/**
		 * The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
		 * null means 'Do not set PCP tag'.
		 */
		pcpTagValue?: number | null;

		/**
		 * An object describing the bandwidth settings for your rule.
		 */
		perClientBandwidthLimits?: CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimits;

		/**
		 * A string, indicating the priority level for packets bound to your rule.
		 * Can be 'low', 'normal' or 'high'.
		 */
		priority?: string | null;
	}
	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesFormProperties {

		/**
		 * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
		 * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
		 */
		dscpTagValue: FormControl<number | null | undefined>,

		/**
		 * The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
		 * null means 'Do not set PCP tag'.
		 */
		pcpTagValue: FormControl<number | null | undefined>,

		/**
		 * A string, indicating the priority level for packets bound to your rule.
		 * Can be 'low', 'normal' or 'high'.
		 */
		priority: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesFormProperties>({
			dscpTagValue: new FormControl<number | null | undefined>(undefined),
			pcpTagValue: new FormControl<number | null | undefined>(undefined),
			priority: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions {

		/**
		 * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
		 * Required
		 */
		type: UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType;

		/**
		 * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
		 * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
		 * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
		 * custom ports.
		 * If "type" is 'application' or 'applicationCategory', then "value" must be an object
		 * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
		 * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
		 * endpoint).
		 * Required
		 */
		value: string;
	}
	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitionsFormProperties {

		/**
		 * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
		 * Required
		 */
		type: FormControl<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType | null | undefined>,

		/**
		 * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
		 * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
		 * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
		 * custom ports.
		 * If "type" is 'application' or 'applicationCategory', then "value" must be an object
		 * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
		 * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
		 * endpoint).
		 * Required
		 */
		value: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitionsFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitionsFormProperties>({
			type: new FormControl<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType | null | undefined>(undefined, [Validators.required]),
			value: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimits {

		/** The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'. */
		bandwidthLimits?: CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimits;

		/** How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'. */
		settings?: string | null;
	}
	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsFormProperties {

		/** How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'. */
		settings: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsFormProperties>({
			settings: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimits {

		/** The maximum download limit (integer, in Kbps). */
		limitDown?: number | null;

		/** The maximum upload limit (integer, in Kbps). */
		limitUp?: number | null;
	}
	export interface CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimitsFormProperties {

		/** The maximum download limit (integer, in Kbps). */
		limitDown: FormControl<number | null | undefined>,

		/** The maximum upload limit (integer, in Kbps). */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimitsFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimitsFormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodyScheduling {

		/** Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed. */
		enabled?: boolean | null;

		/** The schedule object for Friday. */
		friday?: CreateNetworkGroupPolicyPostBodySchedulingFriday;

		/** The schedule object for Monday. */
		monday?: CreateNetworkGroupPolicyPostBodySchedulingMonday;

		/** The schedule object for Saturday. */
		saturday?: CreateNetworkGroupPolicyPostBodySchedulingSaturday;

		/** The schedule object for Sunday. */
		sunday?: CreateNetworkGroupPolicyPostBodySchedulingSunday;

		/** The schedule object for Thursday. */
		thursday?: CreateNetworkGroupPolicyPostBodySchedulingThursday;

		/** The schedule object for Tuesday. */
		tuesday?: CreateNetworkGroupPolicyPostBodySchedulingTuesday;

		/** The schedule object for Wednesday. */
		wednesday?: CreateNetworkGroupPolicyPostBodySchedulingWednesday;
	}
	export interface CreateNetworkGroupPolicyPostBodySchedulingFormProperties {

		/** Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodySchedulingFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodySchedulingFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodySchedulingFriday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkGroupPolicyPostBodySchedulingFridayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodySchedulingFridayFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodySchedulingFridayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodySchedulingMonday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkGroupPolicyPostBodySchedulingMondayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodySchedulingMondayFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodySchedulingMondayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodySchedulingSaturday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkGroupPolicyPostBodySchedulingSaturdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodySchedulingSaturdayFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodySchedulingSaturdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodySchedulingSunday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkGroupPolicyPostBodySchedulingSundayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodySchedulingSundayFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodySchedulingSundayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodySchedulingThursday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkGroupPolicyPostBodySchedulingThursdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodySchedulingThursdayFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodySchedulingThursdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodySchedulingTuesday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkGroupPolicyPostBodySchedulingTuesdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodySchedulingTuesdayFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodySchedulingTuesdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkGroupPolicyPostBodySchedulingWednesday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkGroupPolicyPostBodySchedulingWednesdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodySchedulingWednesdayFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodySchedulingWednesdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum CreateNetworkGroupPolicyPostBodySplashAuthSettings { bypass = 'bypass', 'network default' = 'network default' }

	export interface CreateNetworkGroupPolicyPostBodyVlanTagging {

		/** How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'. */
		settings?: CreateNetworkGroupPolicyPostBodyBandwidthSettings | null;

		/** The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'. */
		vlanId?: string | null;
	}
	export interface CreateNetworkGroupPolicyPostBodyVlanTaggingFormProperties {

		/** How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>,

		/** The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'. */
		vlanId: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkGroupPolicyPostBodyVlanTaggingFormGroup() {
		return new FormGroup<CreateNetworkGroupPolicyPostBodyVlanTaggingFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>(undefined),
			vlanId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBody {

		/**
		 * The bandwidth settings for clients bound to your group policy.
		 */
		bandwidth?: UpdateNetworkGroupPolicyPutBodyBandwidth;

		/** The Bonjour settings for your group policy. Only valid if your network has a wireless configuration. */
		bonjourForwarding?: UpdateNetworkGroupPolicyPutBodyBonjourForwarding;

		/** The content filtering settings for your group policy */
		contentFiltering?: UpdateNetworkGroupPolicyPutBodyContentFiltering;

		/**
		 * The firewall and traffic shaping rules and settings for your policy.
		 */
		firewallAndTrafficShaping?: UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShaping;

		/** The name for your group policy. */
		name?: string | null;

		/**
		 * The schedule for the group policy. Schedules are applied to days of the week.
		 */
		scheduling?: UpdateNetworkGroupPolicyPutBodyScheduling;

		/** Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration. */
		splashAuthSettings?: CreateNetworkGroupPolicyPostBodySplashAuthSettings | null;

		/** The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration. */
		vlanTagging?: UpdateNetworkGroupPolicyPutBodyVlanTagging;
	}
	export interface UpdateNetworkGroupPolicyPutBodyFormProperties {

		/** The name for your group policy. */
		name: FormControl<string | null | undefined>,

		/** Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration. */
		splashAuthSettings: FormControl<CreateNetworkGroupPolicyPostBodySplashAuthSettings | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			splashAuthSettings: new FormControl<CreateNetworkGroupPolicyPostBodySplashAuthSettings | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyBandwidth {

		/** The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'. */
		bandwidthLimits?: UpdateNetworkGroupPolicyPutBodyBandwidthBandwidthLimits;

		/** How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'. */
		settings?: CreateNetworkGroupPolicyPostBodyBandwidthSettings | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodyBandwidthFormProperties {

		/** How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyBandwidthFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyBandwidthFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyBandwidthBandwidthLimits {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown?: number | null;

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp?: number | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodyBandwidthBandwidthLimitsFormProperties {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown: FormControl<number | null | undefined>,

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyBandwidthBandwidthLimitsFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyBandwidthBandwidthLimitsFormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyBonjourForwarding {

		/** A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified. */
		UpdateNetworkGroupPolicyPutBodyBonjourForwardingRules?: Array<UpdateNetworkGroupPolicyPutBodyBonjourForwardingRules>;

		/** How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'. */
		settings?: CreateNetworkGroupPolicyPostBodyBandwidthSettings | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodyBonjourForwardingFormProperties {

		/** How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyBonjourForwardingFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyBonjourForwardingFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyBonjourForwardingRules {

		/** A description for your Bonjour forwarding rule. Optional. */
		description?: string | null;

		/**
		 * A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
		 * Required
		 */
		services: Array<string>;

		/**
		 * The ID of the service VLAN. Required.
		 * Required
		 */
		vlanId: string;
	}
	export interface UpdateNetworkGroupPolicyPutBodyBonjourForwardingRulesFormProperties {

		/** A description for your Bonjour forwarding rule. Optional. */
		description: FormControl<string | null | undefined>,

		/**
		 * The ID of the service VLAN. Required.
		 * Required
		 */
		vlanId: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyBonjourForwardingRulesFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyBonjourForwardingRulesFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			vlanId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyContentFiltering {

		/** Settings for allowed URL patterns */
		allowedUrlPatterns?: UpdateNetworkGroupPolicyPutBodyContentFilteringAllowedUrlPatterns;

		/** Settings for blocked URL categories */
		blockedUrlCategories?: UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlCategories;

		/** Settings for blocked URL patterns */
		blockedUrlPatterns?: UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlPatterns;
	}
	export interface UpdateNetworkGroupPolicyPutBodyContentFilteringFormProperties {
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyContentFilteringFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyContentFilteringFormProperties>({
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyContentFilteringAllowedUrlPatterns {

		/** A list of URL patterns that are allowed */
		patterns?: Array<string>;

		/** How URL patterns are applied. Can be 'network default', 'append' or 'override'. */
		settings?: CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodyContentFilteringAllowedUrlPatternsFormProperties {

		/** How URL patterns are applied. Can be 'network default', 'append' or 'override'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyContentFilteringAllowedUrlPatternsFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyContentFilteringAllowedUrlPatternsFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlCategories {

		/** A list of URL categories to block */
		categories?: Array<string>;

		/** How URL categories are applied. Can be 'network default', 'append' or 'override'. */
		settings?: CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlCategoriesFormProperties {

		/** How URL categories are applied. Can be 'network default', 'append' or 'override'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlCategoriesFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlCategoriesFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlPatterns {

		/** A list of URL patterns that are blocked */
		patterns?: Array<string>;

		/** How URL patterns are applied. Can be 'network default', 'append' or 'override'. */
		settings?: CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlPatternsFormProperties {

		/** How URL patterns are applied. Can be 'network default', 'append' or 'override'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlPatternsFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlPatternsFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShaping {

		/** An ordered array of the L3 firewall rules */
		UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL3FirewallRules?: Array<UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL3FirewallRules>;

		/** An ordered array of L7 firewall rules */
		UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL7FirewallRules?: Array<UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL7FirewallRules>;

		/** How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'. */
		settings?: CreateNetworkGroupPolicyPostBodyBandwidthSettings | null;

		/**
		 * An array of traffic shaping rules. Rules are applied in the order that
		 * they are specified in. An empty list (or null) means no rules. Note that
		 * you are allowed a maximum of 8 rules.
		 */
		UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRules?: Array<UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRules>;
	}
	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingFormProperties {

		/** How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL3FirewallRules {

		/** Description of the rule (optional) */
		comment?: string | null;

		/**
		 * Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
		 * Required
		 */
		destCidr: string;

		/** Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any' */
		destPort?: string | null;

		/**
		 * 'allow' or 'deny' traffic specified by this rule
		 * Required
		 */
		policy: string;

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		 * Required
		 */
		protocol: string;
	}
	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL3FirewallRulesFormProperties {

		/** Description of the rule (optional) */
		comment: FormControl<string | null | undefined>,

		/**
		 * Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
		 * Required
		 */
		destCidr: FormControl<string | null | undefined>,

		/** Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any' */
		destPort: FormControl<string | null | undefined>,

		/**
		 * 'allow' or 'deny' traffic specified by this rule
		 * Required
		 */
		policy: FormControl<string | null | undefined>,

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		 * Required
		 */
		protocol: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL3FirewallRulesFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL3FirewallRulesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			destCidr: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			destPort: new FormControl<string | null | undefined>(undefined),
			policy: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			protocol: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL7FirewallRules {

		/** The policy applied to matching traffic. Must be 'deny'. */
		policy?: UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy | null;

		/** Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange' */
		type?: UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType | null;

		/** The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application. */
		value?: string | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL7FirewallRulesFormProperties {

		/** The policy applied to matching traffic. Must be 'deny'. */
		policy: FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy | null | undefined>,

		/** Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange' */
		type: FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType | null | undefined>,

		/** The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application. */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL7FirewallRulesFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL7FirewallRulesFormProperties>({
			policy: new FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy | null | undefined>(undefined),
			type: new FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType | null | undefined>(undefined),
			value: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRules {

		/**
		 * A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
		 * Required
		 */
		UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions: Array<UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions>;

		/**
		 * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
		 * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
		 */
		dscpTagValue?: number | null;

		/**
		 * The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
		 * null means 'Do not set PCP tag'.
		 */
		pcpTagValue?: number | null;

		/**
		 * An object describing the bandwidth settings for your rule.
		 */
		perClientBandwidthLimits?: UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimits;

		/**
		 * A string, indicating the priority level for packets bound to your rule.
		 * Can be 'low', 'normal' or 'high'.
		 */
		priority?: string | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesFormProperties {

		/**
		 * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
		 * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
		 */
		dscpTagValue: FormControl<number | null | undefined>,

		/**
		 * The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
		 * null means 'Do not set PCP tag'.
		 */
		pcpTagValue: FormControl<number | null | undefined>,

		/**
		 * A string, indicating the priority level for packets bound to your rule.
		 * Can be 'low', 'normal' or 'high'.
		 */
		priority: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesFormProperties>({
			dscpTagValue: new FormControl<number | null | undefined>(undefined),
			pcpTagValue: new FormControl<number | null | undefined>(undefined),
			priority: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions {

		/**
		 * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
		 * Required
		 */
		type: UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType;

		/**
		 * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
		 * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
		 * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
		 * custom ports.
		 * If "type" is 'application' or 'applicationCategory', then "value" must be an object
		 * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
		 * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
		 * endpoint).
		 * Required
		 */
		value: string;
	}
	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitionsFormProperties {

		/**
		 * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
		 * Required
		 */
		type: FormControl<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType | null | undefined>,

		/**
		 * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
		 * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
		 * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
		 * custom ports.
		 * If "type" is 'application' or 'applicationCategory', then "value" must be an object
		 * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
		 * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
		 * endpoint).
		 * Required
		 */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitionsFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitionsFormProperties>({
			type: new FormControl<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType | null | undefined>(undefined, [Validators.required]),
			value: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimits {

		/** The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'. */
		bandwidthLimits?: UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimits;

		/** How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'. */
		settings?: string | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsFormProperties {

		/** How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'. */
		settings: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsFormProperties>({
			settings: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimits {

		/** The maximum download limit (integer, in Kbps). */
		limitDown?: number | null;

		/** The maximum upload limit (integer, in Kbps). */
		limitUp?: number | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimitsFormProperties {

		/** The maximum download limit (integer, in Kbps). */
		limitDown: FormControl<number | null | undefined>,

		/** The maximum upload limit (integer, in Kbps). */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimitsFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimitsFormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyScheduling {

		/** Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed. */
		enabled?: boolean | null;

		/** The schedule object for Friday. */
		friday?: UpdateNetworkGroupPolicyPutBodySchedulingFriday;

		/** The schedule object for Monday. */
		monday?: UpdateNetworkGroupPolicyPutBodySchedulingMonday;

		/** The schedule object for Saturday. */
		saturday?: UpdateNetworkGroupPolicyPutBodySchedulingSaturday;

		/** The schedule object for Sunday. */
		sunday?: UpdateNetworkGroupPolicyPutBodySchedulingSunday;

		/** The schedule object for Thursday. */
		thursday?: UpdateNetworkGroupPolicyPutBodySchedulingThursday;

		/** The schedule object for Tuesday. */
		tuesday?: UpdateNetworkGroupPolicyPutBodySchedulingTuesday;

		/** The schedule object for Wednesday. */
		wednesday?: UpdateNetworkGroupPolicyPutBodySchedulingWednesday;
	}
	export interface UpdateNetworkGroupPolicyPutBodySchedulingFormProperties {

		/** Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodySchedulingFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodySchedulingFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodySchedulingFriday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodySchedulingFridayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodySchedulingFridayFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodySchedulingFridayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodySchedulingMonday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodySchedulingMondayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodySchedulingMondayFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodySchedulingMondayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodySchedulingSaturday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodySchedulingSaturdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodySchedulingSaturdayFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodySchedulingSaturdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodySchedulingSunday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodySchedulingSundayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodySchedulingSundayFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodySchedulingSundayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodySchedulingThursday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodySchedulingThursdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodySchedulingThursdayFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodySchedulingThursdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodySchedulingTuesday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodySchedulingTuesdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodySchedulingTuesdayFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodySchedulingTuesdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodySchedulingWednesday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodySchedulingWednesdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodySchedulingWednesdayFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodySchedulingWednesdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkGroupPolicyPutBodyVlanTagging {

		/** How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'. */
		settings?: CreateNetworkGroupPolicyPostBodyBandwidthSettings | null;

		/** The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'. */
		vlanId?: string | null;
	}
	export interface UpdateNetworkGroupPolicyPutBodyVlanTaggingFormProperties {

		/** How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'. */
		settings: FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>,

		/** The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'. */
		vlanId: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkGroupPolicyPutBodyVlanTaggingFormGroup() {
		return new FormGroup<UpdateNetworkGroupPolicyPutBodyVlanTaggingFormProperties>({
			settings: new FormControl<CreateNetworkGroupPolicyPostBodyBandwidthSettings | null | undefined>(undefined),
			vlanId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkHealthAlertsReturn {

		/** Category of the alert */
		category?: string | null;

		/** Alert identifier. Value can be empty */
		id?: string | null;

		/** The scope of the alert */
		scope?: GetNetworkHealthAlertsReturnScope;

		/** Severity of the alert */
		severity?: GetNetworkHealthAlertsReturnSeverity | null;

		/** Alert type */
		type?: string | null;
	}
	export interface GetNetworkHealthAlertsReturnFormProperties {

		/** Category of the alert */
		category: FormControl<string | null | undefined>,

		/** Alert identifier. Value can be empty */
		id: FormControl<string | null | undefined>,

		/** Severity of the alert */
		severity: FormControl<GetNetworkHealthAlertsReturnSeverity | null | undefined>,

		/** Alert type */
		type: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkHealthAlertsReturnFormGroup() {
		return new FormGroup<GetNetworkHealthAlertsReturnFormProperties>({
			category: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			severity: new FormControl<GetNetworkHealthAlertsReturnSeverity | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkHealthAlertsReturnScope {

		/** Applications related to the alert */
		GetNetworkHealthAlertsReturnScopeApplications?: Array<GetNetworkHealthAlertsReturnScopeApplications>;

		/** Devices related to the alert */
		GetNetworkHealthAlertsReturnScopeDevices?: Array<GetNetworkHealthAlertsReturnScopeDevices>;

		/** Peers related to the alert */
		GetNetworkHealthAlertsReturnScopePeers?: Array<GetNetworkHealthAlertsReturnScopePeers>;
	}
	export interface GetNetworkHealthAlertsReturnScopeFormProperties {
	}
	export function CreateGetNetworkHealthAlertsReturnScopeFormGroup() {
		return new FormGroup<GetNetworkHealthAlertsReturnScopeFormProperties>({
		});

	}

	export interface GetNetworkHealthAlertsReturnScopeApplications {

		/** Name of the application */
		name?: string | null;

		/** URL to the application */
		url?: string | null;
	}
	export interface GetNetworkHealthAlertsReturnScopeApplicationsFormProperties {

		/** Name of the application */
		name: FormControl<string | null | undefined>,

		/** URL to the application */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkHealthAlertsReturnScopeApplicationsFormGroup() {
		return new FormGroup<GetNetworkHealthAlertsReturnScopeApplicationsFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkHealthAlertsReturnScopeDevices {

		/** Clients related to the device */
		GetNetworkHealthAlertsReturnScopeDevicesClients?: Array<GetNetworkHealthAlertsReturnScopeDevicesClients>;

		/** Lldp information */
		lldp?: GetNetworkHealthAlertsReturnScopeDevicesLldp;

		/** The mac address of the device */
		mac?: string | null;

		/** Name of the device */
		name?: string | null;

		/** Product type of the device */
		productType?: string | null;

		/** Serial number of the device */
		serial?: string | null;

		/** URL to the device */
		url?: string | null;
	}
	export interface GetNetworkHealthAlertsReturnScopeDevicesFormProperties {

		/** The mac address of the device */
		mac: FormControl<string | null | undefined>,

		/** Name of the device */
		name: FormControl<string | null | undefined>,

		/** Product type of the device */
		productType: FormControl<string | null | undefined>,

		/** Serial number of the device */
		serial: FormControl<string | null | undefined>,

		/** URL to the device */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkHealthAlertsReturnScopeDevicesFormGroup() {
		return new FormGroup<GetNetworkHealthAlertsReturnScopeDevicesFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkHealthAlertsReturnScopeDevicesClients {

		/** Mac address of the client */
		mac?: string | null;
	}
	export interface GetNetworkHealthAlertsReturnScopeDevicesClientsFormProperties {

		/** Mac address of the client */
		mac: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkHealthAlertsReturnScopeDevicesClientsFormGroup() {
		return new FormGroup<GetNetworkHealthAlertsReturnScopeDevicesClientsFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkHealthAlertsReturnScopeDevicesLldp {

		/** Port Id */
		portId?: string | null;
	}
	export interface GetNetworkHealthAlertsReturnScopeDevicesLldpFormProperties {

		/** Port Id */
		portId: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkHealthAlertsReturnScopeDevicesLldpFormGroup() {
		return new FormGroup<GetNetworkHealthAlertsReturnScopeDevicesLldpFormProperties>({
			portId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkHealthAlertsReturnScopePeers {

		/** Network of the peer */
		network?: GetNetworkHealthAlertsReturnScopePeersNetwork;

		/** URL to the peer */
		url?: string | null;
	}
	export interface GetNetworkHealthAlertsReturnScopePeersFormProperties {

		/** URL to the peer */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkHealthAlertsReturnScopePeersFormGroup() {
		return new FormGroup<GetNetworkHealthAlertsReturnScopePeersFormProperties>({
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkHealthAlertsReturnScopePeersNetwork {

		/** Id of the network */
		id?: string | null;

		/** Name of the network */
		name?: string | null;
	}
	export interface GetNetworkHealthAlertsReturnScopePeersNetworkFormProperties {

		/** Id of the network */
		id: FormControl<string | null | undefined>,

		/** Name of the network */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkHealthAlertsReturnScopePeersNetworkFormGroup() {
		return new FormGroup<GetNetworkHealthAlertsReturnScopePeersNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetNetworkHealthAlertsReturnSeverity { error = 'error', info = 'info', warning = 'warning' }

	export interface GetNetworkInsightApplicationHealthByTimeReturn {

		/** The end time of the query range */
		endTs?: Date | null;

		/** LAN goodput (Number of useful information bits delivered over a LAN per unit of time) */
		lanGoodput?: number | null;

		/** LAN latency in milliseconds */
		lanLatencyMs?: number | null;

		/** LAN loss percentage */
		lanLossPercent?: number | null;

		/** Number of clients */
		numClients?: number | null;

		/** Received kilobytes-per-second */
		recv?: number | null;

		/** Duration of the response, in milliseconds */
		responseDuration?: number | null;

		/** Sent kilobytes-per-second */
		sent?: number | null;

		/** The start time of the query range */
		startTs?: Date | null;

		/** WAN goodput (Number of useful information bits delivered over a WAN per unit of time) */
		wanGoodput?: number | null;

		/** WAN latency in milliseconds */
		wanLatencyMs?: number | null;

		/** WAN loss percentage */
		wanLossPercent?: number | null;
	}
	export interface GetNetworkInsightApplicationHealthByTimeReturnFormProperties {

		/** The end time of the query range */
		endTs: FormControl<Date | null | undefined>,

		/** LAN goodput (Number of useful information bits delivered over a LAN per unit of time) */
		lanGoodput: FormControl<number | null | undefined>,

		/** LAN latency in milliseconds */
		lanLatencyMs: FormControl<number | null | undefined>,

		/** LAN loss percentage */
		lanLossPercent: FormControl<number | null | undefined>,

		/** Number of clients */
		numClients: FormControl<number | null | undefined>,

		/** Received kilobytes-per-second */
		recv: FormControl<number | null | undefined>,

		/** Duration of the response, in milliseconds */
		responseDuration: FormControl<number | null | undefined>,

		/** Sent kilobytes-per-second */
		sent: FormControl<number | null | undefined>,

		/** The start time of the query range */
		startTs: FormControl<Date | null | undefined>,

		/** WAN goodput (Number of useful information bits delivered over a WAN per unit of time) */
		wanGoodput: FormControl<number | null | undefined>,

		/** WAN latency in milliseconds */
		wanLatencyMs: FormControl<number | null | undefined>,

		/** WAN loss percentage */
		wanLossPercent: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkInsightApplicationHealthByTimeReturnFormGroup() {
		return new FormGroup<GetNetworkInsightApplicationHealthByTimeReturnFormProperties>({
			endTs: new FormControl<Date | null | undefined>(undefined),
			lanGoodput: new FormControl<number | null | undefined>(undefined),
			lanLatencyMs: new FormControl<number | null | undefined>(undefined),
			lanLossPercent: new FormControl<number | null | undefined>(undefined),
			numClients: new FormControl<number | null | undefined>(undefined),
			recv: new FormControl<number | null | undefined>(undefined),
			responseDuration: new FormControl<number | null | undefined>(undefined),
			sent: new FormControl<number | null | undefined>(undefined),
			startTs: new FormControl<Date | null | undefined>(undefined),
			wanGoodput: new FormControl<number | null | undefined>(undefined),
			wanLatencyMs: new FormControl<number | null | undefined>(undefined),
			wanLossPercent: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkMerakiAuthUsersReturn {

		/** Authorization type for user. */
		accountType?: string | null;

		/** User authorization info */
		GetNetworkMerakiAuthUsersReturnAuthorizations?: Array<GetNetworkMerakiAuthUsersReturnAuthorizations>;

		/** Creation time of the user */
		createdAt?: Date | null;

		/** Email address of the user */
		email?: string | null;

		/** Meraki auth user id */
		id?: string | null;

		/** Whether or not the user is a Dashboard administrator */
		isAdmin?: boolean | null;

		/** Name of the user */
		name?: string | null;
	}
	export interface GetNetworkMerakiAuthUsersReturnFormProperties {

		/** Authorization type for user. */
		accountType: FormControl<string | null | undefined>,

		/** Creation time of the user */
		createdAt: FormControl<Date | null | undefined>,

		/** Email address of the user */
		email: FormControl<string | null | undefined>,

		/** Meraki auth user id */
		id: FormControl<string | null | undefined>,

		/** Whether or not the user is a Dashboard administrator */
		isAdmin: FormControl<boolean | null | undefined>,

		/** Name of the user */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkMerakiAuthUsersReturnFormGroup() {
		return new FormGroup<GetNetworkMerakiAuthUsersReturnFormProperties>({
			accountType: new FormControl<string | null | undefined>(undefined),
			createdAt: new FormControl<Date | null | undefined>(undefined),
			email: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isAdmin: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkMerakiAuthUsersReturnAuthorizations {

		/** User is authorized by the account email address */
		authorizedByEmail?: string | null;

		/** User is authorized by the account name */
		authorizedByName?: string | null;

		/** Authorized zone of the user */
		authorizedZone?: string | null;

		/** Authorization expiration time */
		expiresAt?: Date | null;

		/** SSID number */
		ssidNumber?: number | null;
	}
	export interface GetNetworkMerakiAuthUsersReturnAuthorizationsFormProperties {

		/** User is authorized by the account email address */
		authorizedByEmail: FormControl<string | null | undefined>,

		/** User is authorized by the account name */
		authorizedByName: FormControl<string | null | undefined>,

		/** Authorized zone of the user */
		authorizedZone: FormControl<string | null | undefined>,

		/** Authorization expiration time */
		expiresAt: FormControl<Date | null | undefined>,

		/** SSID number */
		ssidNumber: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkMerakiAuthUsersReturnAuthorizationsFormGroup() {
		return new FormGroup<GetNetworkMerakiAuthUsersReturnAuthorizationsFormProperties>({
			authorizedByEmail: new FormControl<string | null | undefined>(undefined),
			authorizedByName: new FormControl<string | null | undefined>(undefined),
			authorizedZone: new FormControl<string | null | undefined>(undefined),
			expiresAt: new FormControl<Date | null | undefined>(undefined),
			ssidNumber: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkMerakiAuthUserPostBody {

		/** Authorization type for user. Can be 'Guest' or '802.1X' for wireless networks, or 'Client VPN' for wired networks. Defaults to '802.1X'. */
		accountType?: CreateNetworkMerakiAuthUserPostBodyAccountType | null;

		/**
		 * Authorization zones and expiration dates for the user.
		 * Required
		 */
		CreateNetworkMerakiAuthUserPostBodyAuthorizations: Array<CreateNetworkMerakiAuthUserPostBodyAuthorizations>;

		/**
		 * Email address of the user
		 * Required
		 */
		email: string;

		/** Whether or not Meraki should email the password to user. Default is false. */
		emailPasswordToUser?: boolean | null;

		/** Whether or not the user is a Dashboard administrator. */
		isAdmin?: boolean | null;

		/** Name of the user. Only required If the user is not a Dashboard administrator. */
		name?: string | null;

		/** The password for this user account. Only required If the user is not a Dashboard administrator. */
		password?: string | null;
	}
	export interface CreateNetworkMerakiAuthUserPostBodyFormProperties {

		/** Authorization type for user. Can be 'Guest' or '802.1X' for wireless networks, or 'Client VPN' for wired networks. Defaults to '802.1X'. */
		accountType: FormControl<CreateNetworkMerakiAuthUserPostBodyAccountType | null | undefined>,

		/**
		 * Email address of the user
		 * Required
		 */
		email: FormControl<string | null | undefined>,

		/** Whether or not Meraki should email the password to user. Default is false. */
		emailPasswordToUser: FormControl<boolean | null | undefined>,

		/** Whether or not the user is a Dashboard administrator. */
		isAdmin: FormControl<boolean | null | undefined>,

		/** Name of the user. Only required If the user is not a Dashboard administrator. */
		name: FormControl<string | null | undefined>,

		/** The password for this user account. Only required If the user is not a Dashboard administrator. */
		password: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkMerakiAuthUserPostBodyFormGroup() {
		return new FormGroup<CreateNetworkMerakiAuthUserPostBodyFormProperties>({
			accountType: new FormControl<CreateNetworkMerakiAuthUserPostBodyAccountType | null | undefined>(undefined),
			email: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			emailPasswordToUser: new FormControl<boolean | null | undefined>(undefined),
			isAdmin: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			password: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum CreateNetworkMerakiAuthUserPostBodyAccountType { '802.1X' = '802.1X', 'Client VPN' = 'Client VPN', Guest = 'Guest' }

	export interface CreateNetworkMerakiAuthUserPostBodyAuthorizations {

		/** Date for authorization to expire. Set to 'Never' for the authorization to not expire, which is the default. */
		expiresAt?: string | null;

		/** Required for wireless networks. The SSID for which the user is being authorized, which must be configured for the user's given accountType. */
		ssidNumber?: number | null;
	}
	export interface CreateNetworkMerakiAuthUserPostBodyAuthorizationsFormProperties {

		/** Date for authorization to expire. Set to 'Never' for the authorization to not expire, which is the default. */
		expiresAt: FormControl<string | null | undefined>,

		/** Required for wireless networks. The SSID for which the user is being authorized, which must be configured for the user's given accountType. */
		ssidNumber: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkMerakiAuthUserPostBodyAuthorizationsFormGroup() {
		return new FormGroup<CreateNetworkMerakiAuthUserPostBodyAuthorizationsFormProperties>({
			expiresAt: new FormControl<string | null | undefined>(undefined),
			ssidNumber: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkMerakiAuthUserReturn {

		/** Authorization type for user. */
		accountType?: string | null;

		/** User authorization info */
		GetNetworkMerakiAuthUserReturnAuthorizations?: Array<GetNetworkMerakiAuthUserReturnAuthorizations>;

		/** Creation time of the user */
		createdAt?: Date | null;

		/** Email address of the user */
		email?: string | null;

		/** Meraki auth user id */
		id?: string | null;

		/** Whether or not the user is a Dashboard administrator */
		isAdmin?: boolean | null;

		/** Name of the user */
		name?: string | null;
	}
	export interface GetNetworkMerakiAuthUserReturnFormProperties {

		/** Authorization type for user. */
		accountType: FormControl<string | null | undefined>,

		/** Creation time of the user */
		createdAt: FormControl<Date | null | undefined>,

		/** Email address of the user */
		email: FormControl<string | null | undefined>,

		/** Meraki auth user id */
		id: FormControl<string | null | undefined>,

		/** Whether or not the user is a Dashboard administrator */
		isAdmin: FormControl<boolean | null | undefined>,

		/** Name of the user */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkMerakiAuthUserReturnFormGroup() {
		return new FormGroup<GetNetworkMerakiAuthUserReturnFormProperties>({
			accountType: new FormControl<string | null | undefined>(undefined),
			createdAt: new FormControl<Date | null | undefined>(undefined),
			email: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isAdmin: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkMerakiAuthUserReturnAuthorizations {

		/** User is authorized by the account email address */
		authorizedByEmail?: string | null;

		/** User is authorized by the account name */
		authorizedByName?: string | null;

		/** Authorized zone of the user */
		authorizedZone?: string | null;

		/** Authorization expiration time */
		expiresAt?: Date | null;

		/** SSID number */
		ssidNumber?: number | null;
	}
	export interface GetNetworkMerakiAuthUserReturnAuthorizationsFormProperties {

		/** User is authorized by the account email address */
		authorizedByEmail: FormControl<string | null | undefined>,

		/** User is authorized by the account name */
		authorizedByName: FormControl<string | null | undefined>,

		/** Authorized zone of the user */
		authorizedZone: FormControl<string | null | undefined>,

		/** Authorization expiration time */
		expiresAt: FormControl<Date | null | undefined>,

		/** SSID number */
		ssidNumber: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkMerakiAuthUserReturnAuthorizationsFormGroup() {
		return new FormGroup<GetNetworkMerakiAuthUserReturnAuthorizationsFormProperties>({
			authorizedByEmail: new FormControl<string | null | undefined>(undefined),
			authorizedByName: new FormControl<string | null | undefined>(undefined),
			authorizedZone: new FormControl<string | null | undefined>(undefined),
			expiresAt: new FormControl<Date | null | undefined>(undefined),
			ssidNumber: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkMerakiAuthUserPutBody {

		/** Authorization zones and expiration dates for the user. */
		UpdateNetworkMerakiAuthUserPutBodyAuthorizations?: Array<UpdateNetworkMerakiAuthUserPutBodyAuthorizations>;

		/** Whether or not Meraki should email the password to user. Default is false. */
		emailPasswordToUser?: boolean | null;

		/** Name of the user. Only allowed If the user is not Dashboard administrator. */
		name?: string | null;

		/** The password for this user account. Only allowed If the user is not Dashboard administrator. */
		password?: string | null;
	}
	export interface UpdateNetworkMerakiAuthUserPutBodyFormProperties {

		/** Whether or not Meraki should email the password to user. Default is false. */
		emailPasswordToUser: FormControl<boolean | null | undefined>,

		/** Name of the user. Only allowed If the user is not Dashboard administrator. */
		name: FormControl<string | null | undefined>,

		/** The password for this user account. Only allowed If the user is not Dashboard administrator. */
		password: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkMerakiAuthUserPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkMerakiAuthUserPutBodyFormProperties>({
			emailPasswordToUser: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			password: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkMerakiAuthUserPutBodyAuthorizations {

		/** Date for authorization to expire. Default is for authorization to not expire. */
		expiresAt?: string | null;

		/**
		 * SSID for which the user is being authorized
		 * Required
		 */
		ssidNumber: number;
	}
	export interface UpdateNetworkMerakiAuthUserPutBodyAuthorizationsFormProperties {

		/** Date for authorization to expire. Default is for authorization to not expire. */
		expiresAt: FormControl<string | null | undefined>,

		/**
		 * SSID for which the user is being authorized
		 * Required
		 */
		ssidNumber: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkMerakiAuthUserPutBodyAuthorizationsFormGroup() {
		return new FormGroup<UpdateNetworkMerakiAuthUserPutBodyAuthorizationsFormProperties>({
			expiresAt: new FormControl<string | null | undefined>(undefined),
			ssidNumber: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkMerakiAuthUserReturn {

		/** Authorization type for user. */
		accountType?: string | null;

		/** User authorization info */
		UpdateNetworkMerakiAuthUserReturnAuthorizations?: Array<UpdateNetworkMerakiAuthUserReturnAuthorizations>;

		/** Creation time of the user */
		createdAt?: Date | null;

		/** Email address of the user */
		email?: string | null;

		/** Meraki auth user id */
		id?: string | null;

		/** Whether or not the user is a Dashboard administrator */
		isAdmin?: boolean | null;

		/** Name of the user */
		name?: string | null;
	}
	export interface UpdateNetworkMerakiAuthUserReturnFormProperties {

		/** Authorization type for user. */
		accountType: FormControl<string | null | undefined>,

		/** Creation time of the user */
		createdAt: FormControl<Date | null | undefined>,

		/** Email address of the user */
		email: FormControl<string | null | undefined>,

		/** Meraki auth user id */
		id: FormControl<string | null | undefined>,

		/** Whether or not the user is a Dashboard administrator */
		isAdmin: FormControl<boolean | null | undefined>,

		/** Name of the user */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkMerakiAuthUserReturnFormGroup() {
		return new FormGroup<UpdateNetworkMerakiAuthUserReturnFormProperties>({
			accountType: new FormControl<string | null | undefined>(undefined),
			createdAt: new FormControl<Date | null | undefined>(undefined),
			email: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isAdmin: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkMerakiAuthUserReturnAuthorizations {

		/** User is authorized by the account email address */
		authorizedByEmail?: string | null;

		/** User is authorized by the account name */
		authorizedByName?: string | null;

		/** Authorized zone of the user */
		authorizedZone?: string | null;

		/** Authorization expiration time */
		expiresAt?: Date | null;

		/** SSID number */
		ssidNumber?: number | null;
	}
	export interface UpdateNetworkMerakiAuthUserReturnAuthorizationsFormProperties {

		/** User is authorized by the account email address */
		authorizedByEmail: FormControl<string | null | undefined>,

		/** User is authorized by the account name */
		authorizedByName: FormControl<string | null | undefined>,

		/** Authorized zone of the user */
		authorizedZone: FormControl<string | null | undefined>,

		/** Authorization expiration time */
		expiresAt: FormControl<Date | null | undefined>,

		/** SSID number */
		ssidNumber: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkMerakiAuthUserReturnAuthorizationsFormGroup() {
		return new FormGroup<UpdateNetworkMerakiAuthUserReturnAuthorizationsFormProperties>({
			authorizedByEmail: new FormControl<string | null | undefined>(undefined),
			authorizedByName: new FormControl<string | null | undefined>(undefined),
			authorizedZone: new FormControl<string | null | undefined>(undefined),
			expiresAt: new FormControl<Date | null | undefined>(undefined),
			ssidNumber: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkMqttBrokerPostBody {

		/** Authentication settings of the MQTT broker */
		authentication?: string | null;

		/**
		 * Host name/IP address where the MQTT broker runs.
		 * Required
		 */
		host: string;

		/**
		 * Name of the MQTT broker.
		 * Required
		 */
		name: string;

		/**
		 * Host port though which the MQTT broker can be reached.
		 * Required
		 */
		port: number;

		/** Security settings of the MQTT broker. */
		security?: CreateNetworkMqttBrokerPostBodySecurity;
	}
	export interface CreateNetworkMqttBrokerPostBodyFormProperties {

		/** Authentication settings of the MQTT broker */
		authentication: FormControl<string | null | undefined>,

		/**
		 * Host name/IP address where the MQTT broker runs.
		 * Required
		 */
		host: FormControl<string | null | undefined>,

		/**
		 * Name of the MQTT broker.
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/**
		 * Host port though which the MQTT broker can be reached.
		 * Required
		 */
		port: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkMqttBrokerPostBodyFormGroup() {
		return new FormGroup<CreateNetworkMqttBrokerPostBodyFormProperties>({
			authentication: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			port: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkMqttBrokerPostBodySecurity {

		/** Security protocol of the MQTT broker. */
		mode?: string | null;

		/** TLS settings of the MQTT broker. */
		security?: CreateNetworkMqttBrokerPostBodySecuritySecurity;
	}
	export interface CreateNetworkMqttBrokerPostBodySecurityFormProperties {

		/** Security protocol of the MQTT broker. */
		mode: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkMqttBrokerPostBodySecurityFormGroup() {
		return new FormGroup<CreateNetworkMqttBrokerPostBodySecurityFormProperties>({
			mode: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkMqttBrokerPostBodySecuritySecurity {

		/** CA Certificate of the MQTT broker. */
		caCertificate?: string | null;

		/** Whether the TLS hostname verification is enabled for the MQTT broker. */
		verifyHostnames?: boolean | null;
	}
	export interface CreateNetworkMqttBrokerPostBodySecuritySecurityFormProperties {

		/** CA Certificate of the MQTT broker. */
		caCertificate: FormControl<string | null | undefined>,

		/** Whether the TLS hostname verification is enabled for the MQTT broker. */
		verifyHostnames: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateNetworkMqttBrokerPostBodySecuritySecurityFormGroup() {
		return new FormGroup<CreateNetworkMqttBrokerPostBodySecuritySecurityFormProperties>({
			caCertificate: new FormControl<string | null | undefined>(undefined),
			verifyHostnames: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkMqttBrokerPutBody {

		/** Authentication settings of the MQTT broker */
		authentication?: string | null;

		/** Host name/IP address where the MQTT broker runs. */
		host?: string | null;

		/** Name of the MQTT broker. */
		name?: string | null;

		/** Host port though which the MQTT broker can be reached. */
		port?: number | null;

		/** Security settings of the MQTT broker. */
		security?: UpdateNetworkMqttBrokerPutBodySecurity;
	}
	export interface UpdateNetworkMqttBrokerPutBodyFormProperties {

		/** Authentication settings of the MQTT broker */
		authentication: FormControl<string | null | undefined>,

		/** Host name/IP address where the MQTT broker runs. */
		host: FormControl<string | null | undefined>,

		/** Name of the MQTT broker. */
		name: FormControl<string | null | undefined>,

		/** Host port though which the MQTT broker can be reached. */
		port: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkMqttBrokerPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkMqttBrokerPutBodyFormProperties>({
			authentication: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkMqttBrokerPutBodySecurity {

		/** Security protocol of the MQTT broker. */
		mode?: string | null;

		/** TLS settings of the MQTT broker. */
		security?: UpdateNetworkMqttBrokerPutBodySecuritySecurity;
	}
	export interface UpdateNetworkMqttBrokerPutBodySecurityFormProperties {

		/** Security protocol of the MQTT broker. */
		mode: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkMqttBrokerPutBodySecurityFormGroup() {
		return new FormGroup<UpdateNetworkMqttBrokerPutBodySecurityFormProperties>({
			mode: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkMqttBrokerPutBodySecuritySecurity {

		/** CA Certificate of the MQTT broker. */
		caCertificate?: string | null;

		/** Whether the TLS hostname verification is enabled for the MQTT broker. */
		verifyHostnames?: boolean | null;
	}
	export interface UpdateNetworkMqttBrokerPutBodySecuritySecurityFormProperties {

		/** CA Certificate of the MQTT broker. */
		caCertificate: FormControl<string | null | undefined>,

		/** Whether the TLS hostname verification is enabled for the MQTT broker. */
		verifyHostnames: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkMqttBrokerPutBodySecuritySecurityFormGroup() {
		return new FormGroup<UpdateNetworkMqttBrokerPutBodySecuritySecurityFormProperties>({
			caCertificate: new FormControl<string | null | undefined>(undefined),
			verifyHostnames: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkNetflowPutBody {

		/** The IPv4 address of the NetFlow collector. */
		collectorIp?: string | null;

		/** The port that the NetFlow collector will be listening on. */
		collectorPort?: number | null;

		/** The port that the Encrypted Traffic Analytics collector will be listening on. */
		etaDstPort?: number | null;

		/** Boolean indicating whether Encrypted Traffic Analytics is enabled (true) or disabled (false). */
		etaEnabled?: boolean | null;

		/** Boolean indicating whether NetFlow traffic reporting is enabled (true) or disabled (false). */
		reportingEnabled?: boolean | null;
	}
	export interface UpdateNetworkNetflowPutBodyFormProperties {

		/** The IPv4 address of the NetFlow collector. */
		collectorIp: FormControl<string | null | undefined>,

		/** The port that the NetFlow collector will be listening on. */
		collectorPort: FormControl<number | null | undefined>,

		/** The port that the Encrypted Traffic Analytics collector will be listening on. */
		etaDstPort: FormControl<number | null | undefined>,

		/** Boolean indicating whether Encrypted Traffic Analytics is enabled (true) or disabled (false). */
		etaEnabled: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether NetFlow traffic reporting is enabled (true) or disabled (false). */
		reportingEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkNetflowPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkNetflowPutBodyFormProperties>({
			collectorIp: new FormControl<string | null | undefined>(undefined),
			collectorPort: new FormControl<number | null | undefined>(undefined),
			etaDstPort: new FormControl<number | null | undefined>(undefined),
			etaEnabled: new FormControl<boolean | null | undefined>(undefined),
			reportingEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkPiiRequestPostBody {

		/** The datasets related to the provided key that should be deleted. Only applies to "delete" requests. The value "all" will be expanded to all datasets applicable to this type. The datasets by applicable to each type are: mac (usage, events, traffic), email (users, loginAttempts), username (users, loginAttempts), bluetoothMac (client, connectivity), smDeviceId (device), smUserId (user) */
		datasets?: Array<string>;

		/** The email of a network user account. Only applies to "delete" requests. */
		email?: string | null;

		/** The MAC of a network client device. Applies to both "restrict processing" and "delete" requests. */
		mac?: string | null;

		/** The sm_device_id of a Systems Manager device. The only way to "restrict processing" or "delete" a Systems Manager device. Must include "device" in the dataset for a "delete" request to destroy the device. */
		smDeviceId?: string | null;

		/** The sm_user_id of a Systems Manager user. The only way to "restrict processing" or "delete" a Systems Manager user. Must include "user" in the dataset for a "delete" request to destroy the user. */
		smUserId?: string | null;

		/** One of "delete" or "restrict processing" */
		type?: CreateNetworkPiiRequestPostBodyType | null;

		/** The username of a network log in. Only applies to "delete" requests. */
		username?: string | null;
	}
	export interface CreateNetworkPiiRequestPostBodyFormProperties {

		/** The email of a network user account. Only applies to "delete" requests. */
		email: FormControl<string | null | undefined>,

		/** The MAC of a network client device. Applies to both "restrict processing" and "delete" requests. */
		mac: FormControl<string | null | undefined>,

		/** The sm_device_id of a Systems Manager device. The only way to "restrict processing" or "delete" a Systems Manager device. Must include "device" in the dataset for a "delete" request to destroy the device. */
		smDeviceId: FormControl<string | null | undefined>,

		/** The sm_user_id of a Systems Manager user. The only way to "restrict processing" or "delete" a Systems Manager user. Must include "user" in the dataset for a "delete" request to destroy the user. */
		smUserId: FormControl<string | null | undefined>,

		/** One of "delete" or "restrict processing" */
		type: FormControl<CreateNetworkPiiRequestPostBodyType | null | undefined>,

		/** The username of a network log in. Only applies to "delete" requests. */
		username: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkPiiRequestPostBodyFormGroup() {
		return new FormGroup<CreateNetworkPiiRequestPostBodyFormProperties>({
			email: new FormControl<string | null | undefined>(undefined),
			mac: new FormControl<string | null | undefined>(undefined),
			smDeviceId: new FormControl<string | null | undefined>(undefined),
			smUserId: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<CreateNetworkPiiRequestPostBodyType | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum CreateNetworkPiiRequestPostBodyType { delete = 'delete', 'restrict processing' = 'restrict processing' }

	export interface GetNetworkPoliciesByClientReturn {

		/** Assigned policies */
		GetNetworkPoliciesByClientReturnAssigned?: Array<GetNetworkPoliciesByClientReturnAssigned>;

		/** ID of client */
		clientId?: string | null;

		/** Name of client */
		name?: string | null;
	}
	export interface GetNetworkPoliciesByClientReturnFormProperties {

		/** ID of client */
		clientId: FormControl<string | null | undefined>,

		/** Name of client */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkPoliciesByClientReturnFormGroup() {
		return new FormGroup<GetNetworkPoliciesByClientReturnFormProperties>({
			clientId: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkPoliciesByClientReturnAssigned {

		/** id of policy */
		groupPolicyId?: string | null;

		/** name of policy */
		name?: string | null;

		/** ssid */
		GetNetworkPoliciesByClientReturnAssignedSsid?: Array<GetNetworkPoliciesByClientReturnAssignedSsid>;

		/** type of policy */
		type?: string | null;
	}
	export interface GetNetworkPoliciesByClientReturnAssignedFormProperties {

		/** id of policy */
		groupPolicyId: FormControl<string | null | undefined>,

		/** name of policy */
		name: FormControl<string | null | undefined>,

		/** type of policy */
		type: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkPoliciesByClientReturnAssignedFormGroup() {
		return new FormGroup<GetNetworkPoliciesByClientReturnAssignedFormProperties>({
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkPoliciesByClientReturnAssignedSsid {

		/** number of ssid */
		ssidNumber?: number | null;
	}
	export interface GetNetworkPoliciesByClientReturnAssignedSsidFormProperties {

		/** number of ssid */
		ssidNumber: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkPoliciesByClientReturnAssignedSsidFormGroup() {
		return new FormGroup<GetNetworkPoliciesByClientReturnAssignedSsidFormProperties>({
			ssidNumber: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsCurrentOverviewByMetricReturn {

		/** Counts of currently alerting sensors, aggregated by alerting metric */
		counts?: GetNetworkSensorAlertsCurrentOverviewByMetricReturnCounts;

		/** List of metrics that are supported for alerts, based on available sensor devices in the network */
		supportedMetrics?: Array<string>;
	}
	export interface GetNetworkSensorAlertsCurrentOverviewByMetricReturnFormProperties {
	}
	export function CreateGetNetworkSensorAlertsCurrentOverviewByMetricReturnFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsCurrentOverviewByMetricReturnFormProperties>({
		});

	}

	export interface GetNetworkSensorAlertsCurrentOverviewByMetricReturnCounts {

		/** Number of sensors that are currently alerting due to an open door */
		door?: number | null;

		/** Number of sensors that are currently alerting due to humidity readings */
		humidity?: number | null;

		/** Number of sensors that are currently alerting due to indoor air quality readings */
		indoorAirQuality?: number | null;

		/** Object containing the number of sensors that are currently alerting due to noise readings */
		noise?: GetNetworkSensorAlertsCurrentOverviewByMetricReturnCountsNoise;

		/** Number of sensors that are currently alerting due to PM2.5 readings */
		pm25?: number | null;

		/** Number of sensors that are currently alerting due to temperature readings */
		temperature?: number | null;

		/** Number of sensors that are currently alerting due to TVOC readings */
		tvoc?: number | null;

		/** Number of sensors that are currently alerting due to the presence of water */
		water?: number | null;
	}
	export interface GetNetworkSensorAlertsCurrentOverviewByMetricReturnCountsFormProperties {

		/** Number of sensors that are currently alerting due to an open door */
		door: FormControl<number | null | undefined>,

		/** Number of sensors that are currently alerting due to humidity readings */
		humidity: FormControl<number | null | undefined>,

		/** Number of sensors that are currently alerting due to indoor air quality readings */
		indoorAirQuality: FormControl<number | null | undefined>,

		/** Number of sensors that are currently alerting due to PM2.5 readings */
		pm25: FormControl<number | null | undefined>,

		/** Number of sensors that are currently alerting due to temperature readings */
		temperature: FormControl<number | null | undefined>,

		/** Number of sensors that are currently alerting due to TVOC readings */
		tvoc: FormControl<number | null | undefined>,

		/** Number of sensors that are currently alerting due to the presence of water */
		water: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsCurrentOverviewByMetricReturnCountsFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsCurrentOverviewByMetricReturnCountsFormProperties>({
			door: new FormControl<number | null | undefined>(undefined),
			humidity: new FormControl<number | null | undefined>(undefined),
			indoorAirQuality: new FormControl<number | null | undefined>(undefined),
			pm25: new FormControl<number | null | undefined>(undefined),
			temperature: new FormControl<number | null | undefined>(undefined),
			tvoc: new FormControl<number | null | undefined>(undefined),
			water: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsCurrentOverviewByMetricReturnCountsNoise {

		/** Number of sensors that are currently alerting due to ambient noise readings */
		ambient?: number | null;
	}
	export interface GetNetworkSensorAlertsCurrentOverviewByMetricReturnCountsNoiseFormProperties {

		/** Number of sensors that are currently alerting due to ambient noise readings */
		ambient: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsCurrentOverviewByMetricReturnCountsNoiseFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsCurrentOverviewByMetricReturnCountsNoiseFormProperties>({
			ambient: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsOverviewByMetricReturn {

		/** Counts of sensor alerts over the timespan, by reading metric */
		counts?: GetNetworkSensorAlertsOverviewByMetricReturnCounts;

		/** End of the timespan over which sensor alerts are counted */
		endTs?: Date | null;

		/** Start of the timespan over which sensor alerts are counted */
		startTs?: Date | null;
	}
	export interface GetNetworkSensorAlertsOverviewByMetricReturnFormProperties {

		/** End of the timespan over which sensor alerts are counted */
		endTs: FormControl<Date | null | undefined>,

		/** Start of the timespan over which sensor alerts are counted */
		startTs: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsOverviewByMetricReturnFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsOverviewByMetricReturnFormProperties>({
			endTs: new FormControl<Date | null | undefined>(undefined),
			startTs: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsOverviewByMetricReturnCounts {

		/** Number of sensor alerts that occurred due to an open door */
		door?: number | null;

		/** Number of sensor alerts that occurred due to humidity readings */
		humidity?: number | null;

		/** Number of sensor alerts that occurred due to indoor air quality readings */
		indoorAirQuality?: number | null;

		/** Object containing the number of sensor alerts that occurred due to noise readings */
		noise?: GetNetworkSensorAlertsOverviewByMetricReturnCountsNoise;

		/** Number of sensor alerts that occurred due to PM2.5 readings */
		pm25?: number | null;

		/** Number of sensor alerts that occurred due to temperature readings */
		temperature?: number | null;

		/** Number of sensor alerts that occurred due to TVOC readings */
		tvoc?: number | null;

		/** Number of sensor alerts that occurred due to the presence of water */
		water?: number | null;
	}
	export interface GetNetworkSensorAlertsOverviewByMetricReturnCountsFormProperties {

		/** Number of sensor alerts that occurred due to an open door */
		door: FormControl<number | null | undefined>,

		/** Number of sensor alerts that occurred due to humidity readings */
		humidity: FormControl<number | null | undefined>,

		/** Number of sensor alerts that occurred due to indoor air quality readings */
		indoorAirQuality: FormControl<number | null | undefined>,

		/** Number of sensor alerts that occurred due to PM2.5 readings */
		pm25: FormControl<number | null | undefined>,

		/** Number of sensor alerts that occurred due to temperature readings */
		temperature: FormControl<number | null | undefined>,

		/** Number of sensor alerts that occurred due to TVOC readings */
		tvoc: FormControl<number | null | undefined>,

		/** Number of sensor alerts that occurred due to the presence of water */
		water: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsOverviewByMetricReturnCountsFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsOverviewByMetricReturnCountsFormProperties>({
			door: new FormControl<number | null | undefined>(undefined),
			humidity: new FormControl<number | null | undefined>(undefined),
			indoorAirQuality: new FormControl<number | null | undefined>(undefined),
			pm25: new FormControl<number | null | undefined>(undefined),
			temperature: new FormControl<number | null | undefined>(undefined),
			tvoc: new FormControl<number | null | undefined>(undefined),
			water: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsOverviewByMetricReturnCountsNoise {

		/** Number of sensor alerts that occurred due to ambient noise readings */
		ambient?: number | null;
	}
	export interface GetNetworkSensorAlertsOverviewByMetricReturnCountsNoiseFormProperties {

		/** Number of sensor alerts that occurred due to ambient noise readings */
		ambient: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsOverviewByMetricReturnCountsNoiseFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsOverviewByMetricReturnCountsNoiseFormProperties>({
			ambient: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfilesReturn {

		/**
		 * List of conditions that will cause the profile to send an alert.
		 * Required
		 */
		GetNetworkSensorAlertsProfilesReturnConditions: Array<GetNetworkSensorAlertsProfilesReturnConditions>;

		/** Name of the sensor alert profile. */
		name?: string | null;

		/** ID of the sensor alert profile. */
		profileId?: string | null;

		/** List of recipients that will recieve the alert. */
		recipients?: GetNetworkSensorAlertsProfilesReturnRecipients;

		/** The sensor schedule to use with the alert profile. */
		schedule?: GetNetworkSensorAlertsProfilesReturnSchedule;

		/** List of device serials assigned to this sensor alert profile. */
		serials?: Array<string>;
	}
	export interface GetNetworkSensorAlertsProfilesReturnFormProperties {

		/** Name of the sensor alert profile. */
		name: FormControl<string | null | undefined>,

		/** ID of the sensor alert profile. */
		profileId: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			profileId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfilesReturnConditions {

		/** If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds. */
		direction?: GetNetworkSensorAlertsProfilesReturnConditionsDirection | null;

		/** Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0. */
		duration?: GetNetworkSensorAlertsProfilesReturnConditionsDuration;

		/**
		 * The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * Required
		 */
		metric: string;

		/**
		 * Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
		 * Required
		 */
		threshold: GetNetworkSensorAlertsProfilesReturnConditionsThreshold;
	}
	export interface GetNetworkSensorAlertsProfilesReturnConditionsFormProperties {

		/** If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds. */
		direction: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDirection | null | undefined>,

		/** Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0. */
		duration: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDuration | null | undefined>,

		/**
		 * The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * Required
		 */
		metric: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnConditionsFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnConditionsFormProperties>({
			direction: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDirection | null | undefined>(undefined),
			duration: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDuration | null | undefined>(undefined),
			metric: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum GetNetworkSensorAlertsProfilesReturnConditionsDirection { above = 'above', below = 'below' }

	export enum GetNetworkSensorAlertsProfilesReturnConditionsDuration { _0 = 0, _60 = 1, _120 = 2, _180 = 3, _240 = 4, _300 = 5, _600 = 6, _900 = 7, _1800 = 8, _3600 = 9 }

	export interface GetNetworkSensorAlertsProfilesReturnConditionsThreshold {

		/** Door open threshold. 'open' must be provided and set to true. */
		door?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdDoor;

		/** Humidity threshold. One of 'relativePercentage' or 'quality' must be provided. */
		humidity?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidity;

		/** Indoor air quality score threshold. One of 'score' or 'quality' must be provided. */
		indoorAirQuality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdIndoorAirQuality;

		/** Noise threshold. 'ambient' must be provided. */
		noise?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdNoise;

		/** PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided. */
		pm25?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdPm25;

		/** Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided. */
		temperature?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdTemperature;

		/** TVOC concentration threshold. One of 'concentration' or 'quality' must be provided. */
		tvoc?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdTvoc;

		/** Water detection threshold. 'present' must be provided and set to true. */
		water?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdWater;
	}
	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdFormProperties {
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnConditionsThresholdFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnConditionsThresholdFormProperties>({
		});

	}

	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdDoor {

		/**
		 * Alerting threshold for a door open event. Must be set to true.
		 * Required
		 */
		open: boolean;
	}
	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdDoorFormProperties {

		/**
		 * Alerting threshold for a door open event. Must be set to true.
		 * Required
		 */
		open: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnConditionsThresholdDoorFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnConditionsThresholdDoorFormProperties>({
			open: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidity {

		/** Alerting threshold as a qualitative humidity level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;

		/** Alerting threshold in %RH. */
		relativePercentage?: number | null;
	}
	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityFormProperties {

		/** Alerting threshold as a qualitative humidity level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,

		/** Alerting threshold in %RH. */
		relativePercentage: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityFormProperties>({
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
			relativePercentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality { fair = 'fair', good = 'good', inadequate = 'inadequate', poor = 'poor' }

	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdIndoorAirQuality {

		/** Alerting threshold as a qualitative indoor air quality level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;

		/** Alerting threshold as indoor air quality score. */
		score?: number | null;
	}
	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdIndoorAirQualityFormProperties {

		/** Alerting threshold as a qualitative indoor air quality level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,

		/** Alerting threshold as indoor air quality score. */
		score: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnConditionsThresholdIndoorAirQualityFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnConditionsThresholdIndoorAirQualityFormProperties>({
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
			score: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdNoise {

		/**
		 * Ambient noise threshold. One of 'level' or 'quality' must be provided.
		 * Required
		 */
		ambient: GetNetworkSensorAlertsProfilesReturnConditionsThresholdNoiseAmbient;
	}
	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdNoiseFormProperties {
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnConditionsThresholdNoiseFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnConditionsThresholdNoiseFormProperties>({
		});

	}

	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdNoiseAmbient {

		/** Alerting threshold as adjusted decibels. */
		level?: number | null;

		/** Alerting threshold as a qualitative ambient noise level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdNoiseAmbientFormProperties {

		/** Alerting threshold as adjusted decibels. */
		level: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative ambient noise level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnConditionsThresholdNoiseAmbientFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnConditionsThresholdNoiseAmbientFormProperties>({
			level: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdPm25 {

		/** Alerting threshold as PM2.5 parts per million. */
		concentration?: number | null;

		/** Alerting threshold as a qualitative PM2.5 level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdPm25FormProperties {

		/** Alerting threshold as PM2.5 parts per million. */
		concentration: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative PM2.5 level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnConditionsThresholdPm25FormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnConditionsThresholdPm25FormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdTemperature {

		/** Alerting threshold in degrees Celsius. */
		celsius?: number | null;

		/** Alerting threshold in degrees Fahrenheit. */
		fahrenheit?: number | null;

		/** Alerting threshold as a qualitative temperature level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdTemperatureFormProperties {

		/** Alerting threshold in degrees Celsius. */
		celsius: FormControl<number | null | undefined>,

		/** Alerting threshold in degrees Fahrenheit. */
		fahrenheit: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative temperature level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnConditionsThresholdTemperatureFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnConditionsThresholdTemperatureFormProperties>({
			celsius: new FormControl<number | null | undefined>(undefined),
			fahrenheit: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdTvoc {

		/** Alerting threshold as TVOC micrograms per cubic meter. */
		concentration?: number | null;

		/** Alerting threshold as a qualitative TVOC level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdTvocFormProperties {

		/** Alerting threshold as TVOC micrograms per cubic meter. */
		concentration: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative TVOC level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnConditionsThresholdTvocFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnConditionsThresholdTvocFormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdWater {

		/**
		 * Alerting threshold for a water detection event. Must be set to true.
		 * Required
		 */
		present: boolean;
	}
	export interface GetNetworkSensorAlertsProfilesReturnConditionsThresholdWaterFormProperties {

		/**
		 * Alerting threshold for a water detection event. Must be set to true.
		 * Required
		 */
		present: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnConditionsThresholdWaterFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnConditionsThresholdWaterFormProperties>({
			present: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkSensorAlertsProfilesReturnRecipients {

		/** A list of emails that will receive information about the alert. */
		emails?: Array<string>;

		/** A list of webhook endpoint IDs that will receive information about the alert. */
		httpServerIds?: Array<string>;

		/** A list of SMS numbers that will receive information about the alert. */
		smsNumbers?: Array<string>;
	}
	export interface GetNetworkSensorAlertsProfilesReturnRecipientsFormProperties {
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnRecipientsFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnRecipientsFormProperties>({
		});

	}

	export interface GetNetworkSensorAlertsProfilesReturnSchedule {

		/** ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times. */
		id?: string | null;

		/** Name of the sensor schedule to use with the alert profile. */
		name?: string | null;
	}
	export interface GetNetworkSensorAlertsProfilesReturnScheduleFormProperties {

		/** ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times. */
		id: FormControl<string | null | undefined>,

		/** Name of the sensor schedule to use with the alert profile. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfilesReturnScheduleFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfilesReturnScheduleFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBody {

		/**
		 * List of conditions that will cause the profile to send an alert.
		 * Required
		 */
		CreateNetworkSensorAlertsProfilePostBodyConditions: Array<CreateNetworkSensorAlertsProfilePostBodyConditions>;

		/**
		 * Name of the sensor alert profile.
		 * Required
		 */
		name: string;

		/** List of recipients that will recieve the alert. */
		recipients?: CreateNetworkSensorAlertsProfilePostBodyRecipients;

		/** The sensor schedule to use with the alert profile. */
		schedule?: CreateNetworkSensorAlertsProfilePostBodySchedule;

		/** List of device serials assigned to this sensor alert profile. */
		serials?: Array<string>;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyFormProperties {

		/**
		 * Name of the sensor alert profile.
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBodyConditions {

		/** If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds. */
		direction?: GetNetworkSensorAlertsProfilesReturnConditionsDirection | null;

		/** Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0. */
		duration?: CreateNetworkSensorAlertsProfilePostBodyConditionsDuration;

		/**
		 * The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * Required
		 */
		metric: string;

		/**
		 * Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
		 * Required
		 */
		threshold: CreateNetworkSensorAlertsProfilePostBodyConditionsThreshold;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsFormProperties {

		/** If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds. */
		direction: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDirection | null | undefined>,

		/** Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0. */
		duration: FormControl<CreateNetworkSensorAlertsProfilePostBodyConditionsDuration | null | undefined>,

		/**
		 * The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * Required
		 */
		metric: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyConditionsFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyConditionsFormProperties>({
			direction: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDirection | null | undefined>(undefined),
			duration: new FormControl<CreateNetworkSensorAlertsProfilePostBodyConditionsDuration | null | undefined>(undefined),
			metric: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkSensorAlertsProfilePostBodyConditionsDuration { _0 = 0, _60 = 1, _120 = 2, _180 = 3, _240 = 4, _300 = 5, _600 = 6, _900 = 7, _1800 = 8, _3600 = 9 }

	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThreshold {

		/** Door open threshold. 'open' must be provided and set to true. */
		door?: CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdDoor;

		/** Humidity threshold. One of 'relativePercentage' or 'quality' must be provided. */
		humidity?: CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdHumidity;

		/** Indoor air quality score threshold. One of 'score' or 'quality' must be provided. */
		indoorAirQuality?: CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdIndoorAirQuality;

		/** Noise threshold. 'ambient' must be provided. */
		noise?: CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoise;

		/** PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided. */
		pm25?: CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdPm25;

		/** Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided. */
		temperature?: CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTemperature;

		/** TVOC concentration threshold. One of 'concentration' or 'quality' must be provided. */
		tvoc?: CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTvoc;

		/** Water detection threshold. 'present' must be provided and set to true. */
		water?: CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdWater;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdFormProperties {
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyConditionsThresholdFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdFormProperties>({
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdDoor {

		/**
		 * Alerting threshold for a door open event. Must be set to true.
		 * Required
		 */
		open: boolean;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdDoorFormProperties {

		/**
		 * Alerting threshold for a door open event. Must be set to true.
		 * Required
		 */
		open: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyConditionsThresholdDoorFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdDoorFormProperties>({
			open: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdHumidity {

		/** Alerting threshold as a qualitative humidity level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;

		/** Alerting threshold in %RH. */
		relativePercentage?: number | null;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdHumidityFormProperties {

		/** Alerting threshold as a qualitative humidity level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,

		/** Alerting threshold in %RH. */
		relativePercentage: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyConditionsThresholdHumidityFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdHumidityFormProperties>({
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
			relativePercentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdIndoorAirQuality {

		/** Alerting threshold as a qualitative indoor air quality level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;

		/** Alerting threshold as indoor air quality score. */
		score?: number | null;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdIndoorAirQualityFormProperties {

		/** Alerting threshold as a qualitative indoor air quality level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,

		/** Alerting threshold as indoor air quality score. */
		score: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyConditionsThresholdIndoorAirQualityFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdIndoorAirQualityFormProperties>({
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
			score: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoise {

		/**
		 * Ambient noise threshold. One of 'level' or 'quality' must be provided.
		 * Required
		 */
		ambient: CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoiseAmbient;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoiseFormProperties {
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoiseFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoiseFormProperties>({
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoiseAmbient {

		/** Alerting threshold as adjusted decibels. */
		level?: number | null;

		/** Alerting threshold as a qualitative ambient noise level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoiseAmbientFormProperties {

		/** Alerting threshold as adjusted decibels. */
		level: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative ambient noise level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoiseAmbientFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoiseAmbientFormProperties>({
			level: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdPm25 {

		/** Alerting threshold as PM2.5 parts per million. */
		concentration?: number | null;

		/** Alerting threshold as a qualitative PM2.5 level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdPm25FormProperties {

		/** Alerting threshold as PM2.5 parts per million. */
		concentration: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative PM2.5 level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyConditionsThresholdPm25FormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdPm25FormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTemperature {

		/** Alerting threshold in degrees Celsius. */
		celsius?: number | null;

		/** Alerting threshold in degrees Fahrenheit. */
		fahrenheit?: number | null;

		/** Alerting threshold as a qualitative temperature level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTemperatureFormProperties {

		/** Alerting threshold in degrees Celsius. */
		celsius: FormControl<number | null | undefined>,

		/** Alerting threshold in degrees Fahrenheit. */
		fahrenheit: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative temperature level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTemperatureFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTemperatureFormProperties>({
			celsius: new FormControl<number | null | undefined>(undefined),
			fahrenheit: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTvoc {

		/** Alerting threshold as TVOC micrograms per cubic meter. */
		concentration?: number | null;

		/** Alerting threshold as a qualitative TVOC level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTvocFormProperties {

		/** Alerting threshold as TVOC micrograms per cubic meter. */
		concentration: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative TVOC level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTvocFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTvocFormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdWater {

		/**
		 * Alerting threshold for a water detection event. Must be set to true.
		 * Required
		 */
		present: boolean;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdWaterFormProperties {

		/**
		 * Alerting threshold for a water detection event. Must be set to true.
		 * Required
		 */
		present: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyConditionsThresholdWaterFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdWaterFormProperties>({
			present: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBodyRecipients {

		/** A list of emails that will receive information about the alert. */
		emails?: Array<string>;

		/** A list of webhook endpoint IDs that will receive information about the alert. */
		httpServerIds?: Array<string>;

		/** A list of SMS numbers that will receive information about the alert. */
		smsNumbers?: Array<string>;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyRecipientsFormProperties {
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyRecipientsFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyRecipientsFormProperties>({
		});

	}

	export interface CreateNetworkSensorAlertsProfilePostBodySchedule {

		/** ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times. */
		id?: string | null;
	}
	export interface CreateNetworkSensorAlertsProfilePostBodyScheduleFormProperties {

		/** ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times. */
		id: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfilePostBodyScheduleFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfilePostBodyScheduleFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturn {

		/**
		 * List of conditions that will cause the profile to send an alert.
		 * Required
		 */
		CreateNetworkSensorAlertsProfileReturnConditions: Array<CreateNetworkSensorAlertsProfileReturnConditions>;

		/** Name of the sensor alert profile. */
		name?: string | null;

		/** ID of the sensor alert profile. */
		profileId?: string | null;

		/** List of recipients that will recieve the alert. */
		recipients?: CreateNetworkSensorAlertsProfileReturnRecipients;

		/** The sensor schedule to use with the alert profile. */
		schedule?: CreateNetworkSensorAlertsProfileReturnSchedule;

		/** List of device serials assigned to this sensor alert profile. */
		serials?: Array<string>;
	}
	export interface CreateNetworkSensorAlertsProfileReturnFormProperties {

		/** Name of the sensor alert profile. */
		name: FormControl<string | null | undefined>,

		/** ID of the sensor alert profile. */
		profileId: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			profileId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturnConditions {

		/** If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds. */
		direction?: GetNetworkSensorAlertsProfilesReturnConditionsDirection | null;

		/** Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0. */
		duration?: CreateNetworkSensorAlertsProfileReturnConditionsDuration;

		/**
		 * The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * Required
		 */
		metric: string;

		/**
		 * Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
		 * Required
		 */
		threshold: CreateNetworkSensorAlertsProfileReturnConditionsThreshold;
	}
	export interface CreateNetworkSensorAlertsProfileReturnConditionsFormProperties {

		/** If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds. */
		direction: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDirection | null | undefined>,

		/** Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0. */
		duration: FormControl<CreateNetworkSensorAlertsProfileReturnConditionsDuration | null | undefined>,

		/**
		 * The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * Required
		 */
		metric: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnConditionsFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnConditionsFormProperties>({
			direction: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDirection | null | undefined>(undefined),
			duration: new FormControl<CreateNetworkSensorAlertsProfileReturnConditionsDuration | null | undefined>(undefined),
			metric: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkSensorAlertsProfileReturnConditionsDuration { _0 = 0, _60 = 1, _120 = 2, _180 = 3, _240 = 4, _300 = 5, _600 = 6, _900 = 7, _1800 = 8, _3600 = 9 }

	export interface CreateNetworkSensorAlertsProfileReturnConditionsThreshold {

		/** Door open threshold. 'open' must be provided and set to true. */
		door?: CreateNetworkSensorAlertsProfileReturnConditionsThresholdDoor;

		/** Humidity threshold. One of 'relativePercentage' or 'quality' must be provided. */
		humidity?: CreateNetworkSensorAlertsProfileReturnConditionsThresholdHumidity;

		/** Indoor air quality score threshold. One of 'score' or 'quality' must be provided. */
		indoorAirQuality?: CreateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQuality;

		/** Noise threshold. 'ambient' must be provided. */
		noise?: CreateNetworkSensorAlertsProfileReturnConditionsThresholdNoise;

		/** PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided. */
		pm25?: CreateNetworkSensorAlertsProfileReturnConditionsThresholdPm25;

		/** Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided. */
		temperature?: CreateNetworkSensorAlertsProfileReturnConditionsThresholdTemperature;

		/** TVOC concentration threshold. One of 'concentration' or 'quality' must be provided. */
		tvoc?: CreateNetworkSensorAlertsProfileReturnConditionsThresholdTvoc;

		/** Water detection threshold. 'present' must be provided and set to true. */
		water?: CreateNetworkSensorAlertsProfileReturnConditionsThresholdWater;
	}
	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdFormProperties {
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnConditionsThresholdFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnConditionsThresholdFormProperties>({
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdDoor {

		/**
		 * Alerting threshold for a door open event. Must be set to true.
		 * Required
		 */
		open: boolean;
	}
	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdDoorFormProperties {

		/**
		 * Alerting threshold for a door open event. Must be set to true.
		 * Required
		 */
		open: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnConditionsThresholdDoorFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnConditionsThresholdDoorFormProperties>({
			open: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdHumidity {

		/** Alerting threshold as a qualitative humidity level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;

		/** Alerting threshold in %RH. */
		relativePercentage?: number | null;
	}
	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdHumidityFormProperties {

		/** Alerting threshold as a qualitative humidity level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,

		/** Alerting threshold in %RH. */
		relativePercentage: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnConditionsThresholdHumidityFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnConditionsThresholdHumidityFormProperties>({
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
			relativePercentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQuality {

		/** Alerting threshold as a qualitative indoor air quality level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;

		/** Alerting threshold as indoor air quality score. */
		score?: number | null;
	}
	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQualityFormProperties {

		/** Alerting threshold as a qualitative indoor air quality level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,

		/** Alerting threshold as indoor air quality score. */
		score: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQualityFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQualityFormProperties>({
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
			score: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdNoise {

		/**
		 * Ambient noise threshold. One of 'level' or 'quality' must be provided.
		 * Required
		 */
		ambient: CreateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbient;
	}
	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseFormProperties {
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseFormProperties>({
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbient {

		/** Alerting threshold as adjusted decibels. */
		level?: number | null;

		/** Alerting threshold as a qualitative ambient noise level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbientFormProperties {

		/** Alerting threshold as adjusted decibels. */
		level: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative ambient noise level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbientFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbientFormProperties>({
			level: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdPm25 {

		/** Alerting threshold as PM2.5 parts per million. */
		concentration?: number | null;

		/** Alerting threshold as a qualitative PM2.5 level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdPm25FormProperties {

		/** Alerting threshold as PM2.5 parts per million. */
		concentration: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative PM2.5 level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnConditionsThresholdPm25FormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnConditionsThresholdPm25FormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdTemperature {

		/** Alerting threshold in degrees Celsius. */
		celsius?: number | null;

		/** Alerting threshold in degrees Fahrenheit. */
		fahrenheit?: number | null;

		/** Alerting threshold as a qualitative temperature level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdTemperatureFormProperties {

		/** Alerting threshold in degrees Celsius. */
		celsius: FormControl<number | null | undefined>,

		/** Alerting threshold in degrees Fahrenheit. */
		fahrenheit: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative temperature level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnConditionsThresholdTemperatureFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnConditionsThresholdTemperatureFormProperties>({
			celsius: new FormControl<number | null | undefined>(undefined),
			fahrenheit: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdTvoc {

		/** Alerting threshold as TVOC micrograms per cubic meter. */
		concentration?: number | null;

		/** Alerting threshold as a qualitative TVOC level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdTvocFormProperties {

		/** Alerting threshold as TVOC micrograms per cubic meter. */
		concentration: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative TVOC level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnConditionsThresholdTvocFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnConditionsThresholdTvocFormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdWater {

		/**
		 * Alerting threshold for a water detection event. Must be set to true.
		 * Required
		 */
		present: boolean;
	}
	export interface CreateNetworkSensorAlertsProfileReturnConditionsThresholdWaterFormProperties {

		/**
		 * Alerting threshold for a water detection event. Must be set to true.
		 * Required
		 */
		present: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnConditionsThresholdWaterFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnConditionsThresholdWaterFormProperties>({
			present: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturnRecipients {

		/** A list of emails that will receive information about the alert. */
		emails?: Array<string>;

		/** A list of webhook endpoint IDs that will receive information about the alert. */
		httpServerIds?: Array<string>;

		/** A list of SMS numbers that will receive information about the alert. */
		smsNumbers?: Array<string>;
	}
	export interface CreateNetworkSensorAlertsProfileReturnRecipientsFormProperties {
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnRecipientsFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnRecipientsFormProperties>({
		});

	}

	export interface CreateNetworkSensorAlertsProfileReturnSchedule {

		/** ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times. */
		id?: string | null;

		/** Name of the sensor schedule to use with the alert profile. */
		name?: string | null;
	}
	export interface CreateNetworkSensorAlertsProfileReturnScheduleFormProperties {

		/** ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times. */
		id: FormControl<string | null | undefined>,

		/** Name of the sensor schedule to use with the alert profile. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSensorAlertsProfileReturnScheduleFormGroup() {
		return new FormGroup<CreateNetworkSensorAlertsProfileReturnScheduleFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfileReturn {

		/**
		 * List of conditions that will cause the profile to send an alert.
		 * Required
		 */
		GetNetworkSensorAlertsProfileReturnConditions: Array<GetNetworkSensorAlertsProfileReturnConditions>;

		/** Name of the sensor alert profile. */
		name?: string | null;

		/** ID of the sensor alert profile. */
		profileId?: string | null;

		/** List of recipients that will recieve the alert. */
		recipients?: GetNetworkSensorAlertsProfileReturnRecipients;

		/** The sensor schedule to use with the alert profile. */
		schedule?: GetNetworkSensorAlertsProfileReturnSchedule;

		/** List of device serials assigned to this sensor alert profile. */
		serials?: Array<string>;
	}
	export interface GetNetworkSensorAlertsProfileReturnFormProperties {

		/** Name of the sensor alert profile. */
		name: FormControl<string | null | undefined>,

		/** ID of the sensor alert profile. */
		profileId: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfileReturnFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			profileId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfileReturnConditions {

		/** If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds. */
		direction?: GetNetworkSensorAlertsProfilesReturnConditionsDirection | null;

		/** Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0. */
		duration?: GetNetworkSensorAlertsProfileReturnConditionsDuration;

		/**
		 * The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * Required
		 */
		metric: string;

		/**
		 * Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
		 * Required
		 */
		threshold: GetNetworkSensorAlertsProfileReturnConditionsThreshold;
	}
	export interface GetNetworkSensorAlertsProfileReturnConditionsFormProperties {

		/** If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds. */
		direction: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDirection | null | undefined>,

		/** Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0. */
		duration: FormControl<GetNetworkSensorAlertsProfileReturnConditionsDuration | null | undefined>,

		/**
		 * The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * Required
		 */
		metric: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfileReturnConditionsFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnConditionsFormProperties>({
			direction: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDirection | null | undefined>(undefined),
			duration: new FormControl<GetNetworkSensorAlertsProfileReturnConditionsDuration | null | undefined>(undefined),
			metric: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum GetNetworkSensorAlertsProfileReturnConditionsDuration { _0 = 0, _60 = 1, _120 = 2, _180 = 3, _240 = 4, _300 = 5, _600 = 6, _900 = 7, _1800 = 8, _3600 = 9 }

	export interface GetNetworkSensorAlertsProfileReturnConditionsThreshold {

		/** Door open threshold. 'open' must be provided and set to true. */
		door?: GetNetworkSensorAlertsProfileReturnConditionsThresholdDoor;

		/** Humidity threshold. One of 'relativePercentage' or 'quality' must be provided. */
		humidity?: GetNetworkSensorAlertsProfileReturnConditionsThresholdHumidity;

		/** Indoor air quality score threshold. One of 'score' or 'quality' must be provided. */
		indoorAirQuality?: GetNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQuality;

		/** Noise threshold. 'ambient' must be provided. */
		noise?: GetNetworkSensorAlertsProfileReturnConditionsThresholdNoise;

		/** PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided. */
		pm25?: GetNetworkSensorAlertsProfileReturnConditionsThresholdPm25;

		/** Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided. */
		temperature?: GetNetworkSensorAlertsProfileReturnConditionsThresholdTemperature;

		/** TVOC concentration threshold. One of 'concentration' or 'quality' must be provided. */
		tvoc?: GetNetworkSensorAlertsProfileReturnConditionsThresholdTvoc;

		/** Water detection threshold. 'present' must be provided and set to true. */
		water?: GetNetworkSensorAlertsProfileReturnConditionsThresholdWater;
	}
	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdFormProperties {
	}
	export function CreateGetNetworkSensorAlertsProfileReturnConditionsThresholdFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnConditionsThresholdFormProperties>({
		});

	}

	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdDoor {

		/**
		 * Alerting threshold for a door open event. Must be set to true.
		 * Required
		 */
		open: boolean;
	}
	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdDoorFormProperties {

		/**
		 * Alerting threshold for a door open event. Must be set to true.
		 * Required
		 */
		open: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfileReturnConditionsThresholdDoorFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnConditionsThresholdDoorFormProperties>({
			open: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdHumidity {

		/** Alerting threshold as a qualitative humidity level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;

		/** Alerting threshold in %RH. */
		relativePercentage?: number | null;
	}
	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdHumidityFormProperties {

		/** Alerting threshold as a qualitative humidity level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,

		/** Alerting threshold in %RH. */
		relativePercentage: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfileReturnConditionsThresholdHumidityFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnConditionsThresholdHumidityFormProperties>({
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
			relativePercentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQuality {

		/** Alerting threshold as a qualitative indoor air quality level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;

		/** Alerting threshold as indoor air quality score. */
		score?: number | null;
	}
	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQualityFormProperties {

		/** Alerting threshold as a qualitative indoor air quality level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,

		/** Alerting threshold as indoor air quality score. */
		score: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQualityFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQualityFormProperties>({
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
			score: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdNoise {

		/**
		 * Ambient noise threshold. One of 'level' or 'quality' must be provided.
		 * Required
		 */
		ambient: GetNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbient;
	}
	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdNoiseFormProperties {
	}
	export function CreateGetNetworkSensorAlertsProfileReturnConditionsThresholdNoiseFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnConditionsThresholdNoiseFormProperties>({
		});

	}

	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbient {

		/** Alerting threshold as adjusted decibels. */
		level?: number | null;

		/** Alerting threshold as a qualitative ambient noise level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbientFormProperties {

		/** Alerting threshold as adjusted decibels. */
		level: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative ambient noise level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbientFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbientFormProperties>({
			level: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdPm25 {

		/** Alerting threshold as PM2.5 parts per million. */
		concentration?: number | null;

		/** Alerting threshold as a qualitative PM2.5 level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdPm25FormProperties {

		/** Alerting threshold as PM2.5 parts per million. */
		concentration: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative PM2.5 level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfileReturnConditionsThresholdPm25FormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnConditionsThresholdPm25FormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdTemperature {

		/** Alerting threshold in degrees Celsius. */
		celsius?: number | null;

		/** Alerting threshold in degrees Fahrenheit. */
		fahrenheit?: number | null;

		/** Alerting threshold as a qualitative temperature level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdTemperatureFormProperties {

		/** Alerting threshold in degrees Celsius. */
		celsius: FormControl<number | null | undefined>,

		/** Alerting threshold in degrees Fahrenheit. */
		fahrenheit: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative temperature level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfileReturnConditionsThresholdTemperatureFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnConditionsThresholdTemperatureFormProperties>({
			celsius: new FormControl<number | null | undefined>(undefined),
			fahrenheit: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdTvoc {

		/** Alerting threshold as TVOC micrograms per cubic meter. */
		concentration?: number | null;

		/** Alerting threshold as a qualitative TVOC level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdTvocFormProperties {

		/** Alerting threshold as TVOC micrograms per cubic meter. */
		concentration: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative TVOC level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfileReturnConditionsThresholdTvocFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnConditionsThresholdTvocFormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdWater {

		/**
		 * Alerting threshold for a water detection event. Must be set to true.
		 * Required
		 */
		present: boolean;
	}
	export interface GetNetworkSensorAlertsProfileReturnConditionsThresholdWaterFormProperties {

		/**
		 * Alerting threshold for a water detection event. Must be set to true.
		 * Required
		 */
		present: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfileReturnConditionsThresholdWaterFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnConditionsThresholdWaterFormProperties>({
			present: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkSensorAlertsProfileReturnRecipients {

		/** A list of emails that will receive information about the alert. */
		emails?: Array<string>;

		/** A list of webhook endpoint IDs that will receive information about the alert. */
		httpServerIds?: Array<string>;

		/** A list of SMS numbers that will receive information about the alert. */
		smsNumbers?: Array<string>;
	}
	export interface GetNetworkSensorAlertsProfileReturnRecipientsFormProperties {
	}
	export function CreateGetNetworkSensorAlertsProfileReturnRecipientsFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnRecipientsFormProperties>({
		});

	}

	export interface GetNetworkSensorAlertsProfileReturnSchedule {

		/** ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times. */
		id?: string | null;

		/** Name of the sensor schedule to use with the alert profile. */
		name?: string | null;
	}
	export interface GetNetworkSensorAlertsProfileReturnScheduleFormProperties {

		/** ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times. */
		id: FormControl<string | null | undefined>,

		/** Name of the sensor schedule to use with the alert profile. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSensorAlertsProfileReturnScheduleFormGroup() {
		return new FormGroup<GetNetworkSensorAlertsProfileReturnScheduleFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBody {

		/** List of conditions that will cause the profile to send an alert. */
		UpdateNetworkSensorAlertsProfilePutBodyConditions?: Array<UpdateNetworkSensorAlertsProfilePutBodyConditions>;

		/** Name of the sensor alert profile. */
		name?: string | null;

		/** List of recipients that will recieve the alert. */
		recipients?: UpdateNetworkSensorAlertsProfilePutBodyRecipients;

		/** The sensor schedule to use with the alert profile. */
		schedule?: UpdateNetworkSensorAlertsProfilePutBodySchedule;

		/** List of device serials assigned to this sensor alert profile. */
		serials?: Array<string>;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyFormProperties {

		/** Name of the sensor alert profile. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBodyConditions {

		/** If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds. */
		direction?: GetNetworkSensorAlertsProfilesReturnConditionsDirection | null;

		/** Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0. */
		duration?: UpdateNetworkSensorAlertsProfilePutBodyConditionsDuration;

		/**
		 * The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * Required
		 */
		metric: string;

		/**
		 * Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
		 * Required
		 */
		threshold: UpdateNetworkSensorAlertsProfilePutBodyConditionsThreshold;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsFormProperties {

		/** If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds. */
		direction: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDirection | null | undefined>,

		/** Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0. */
		duration: FormControl<UpdateNetworkSensorAlertsProfilePutBodyConditionsDuration | null | undefined>,

		/**
		 * The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * Required
		 */
		metric: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyConditionsFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyConditionsFormProperties>({
			direction: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDirection | null | undefined>(undefined),
			duration: new FormControl<UpdateNetworkSensorAlertsProfilePutBodyConditionsDuration | null | undefined>(undefined),
			metric: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum UpdateNetworkSensorAlertsProfilePutBodyConditionsDuration { _0 = 0, _60 = 1, _120 = 2, _180 = 3, _240 = 4, _300 = 5, _600 = 6, _900 = 7, _1800 = 8, _3600 = 9 }

	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThreshold {

		/** Door open threshold. 'open' must be provided and set to true. */
		door?: UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdDoor;

		/** Humidity threshold. One of 'relativePercentage' or 'quality' must be provided. */
		humidity?: UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdHumidity;

		/** Indoor air quality score threshold. One of 'score' or 'quality' must be provided. */
		indoorAirQuality?: UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdIndoorAirQuality;

		/** Noise threshold. 'ambient' must be provided. */
		noise?: UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoise;

		/** PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided. */
		pm25?: UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdPm25;

		/** Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided. */
		temperature?: UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTemperature;

		/** TVOC concentration threshold. One of 'concentration' or 'quality' must be provided. */
		tvoc?: UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTvoc;

		/** Water detection threshold. 'present' must be provided and set to true. */
		water?: UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdWater;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdFormProperties {
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdFormProperties>({
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdDoor {

		/**
		 * Alerting threshold for a door open event. Must be set to true.
		 * Required
		 */
		open: boolean;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdDoorFormProperties {

		/**
		 * Alerting threshold for a door open event. Must be set to true.
		 * Required
		 */
		open: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdDoorFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdDoorFormProperties>({
			open: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdHumidity {

		/** Alerting threshold as a qualitative humidity level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;

		/** Alerting threshold in %RH. */
		relativePercentage?: number | null;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdHumidityFormProperties {

		/** Alerting threshold as a qualitative humidity level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,

		/** Alerting threshold in %RH. */
		relativePercentage: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdHumidityFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdHumidityFormProperties>({
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
			relativePercentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdIndoorAirQuality {

		/** Alerting threshold as a qualitative indoor air quality level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;

		/** Alerting threshold as indoor air quality score. */
		score?: number | null;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdIndoorAirQualityFormProperties {

		/** Alerting threshold as a qualitative indoor air quality level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,

		/** Alerting threshold as indoor air quality score. */
		score: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdIndoorAirQualityFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdIndoorAirQualityFormProperties>({
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
			score: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoise {

		/**
		 * Ambient noise threshold. One of 'level' or 'quality' must be provided.
		 * Required
		 */
		ambient: UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoiseAmbient;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoiseFormProperties {
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoiseFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoiseFormProperties>({
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoiseAmbient {

		/** Alerting threshold as adjusted decibels. */
		level?: number | null;

		/** Alerting threshold as a qualitative ambient noise level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoiseAmbientFormProperties {

		/** Alerting threshold as adjusted decibels. */
		level: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative ambient noise level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoiseAmbientFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoiseAmbientFormProperties>({
			level: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdPm25 {

		/** Alerting threshold as PM2.5 parts per million. */
		concentration?: number | null;

		/** Alerting threshold as a qualitative PM2.5 level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdPm25FormProperties {

		/** Alerting threshold as PM2.5 parts per million. */
		concentration: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative PM2.5 level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdPm25FormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdPm25FormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTemperature {

		/** Alerting threshold in degrees Celsius. */
		celsius?: number | null;

		/** Alerting threshold in degrees Fahrenheit. */
		fahrenheit?: number | null;

		/** Alerting threshold as a qualitative temperature level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTemperatureFormProperties {

		/** Alerting threshold in degrees Celsius. */
		celsius: FormControl<number | null | undefined>,

		/** Alerting threshold in degrees Fahrenheit. */
		fahrenheit: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative temperature level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTemperatureFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTemperatureFormProperties>({
			celsius: new FormControl<number | null | undefined>(undefined),
			fahrenheit: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTvoc {

		/** Alerting threshold as TVOC micrograms per cubic meter. */
		concentration?: number | null;

		/** Alerting threshold as a qualitative TVOC level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTvocFormProperties {

		/** Alerting threshold as TVOC micrograms per cubic meter. */
		concentration: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative TVOC level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTvocFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTvocFormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdWater {

		/**
		 * Alerting threshold for a water detection event. Must be set to true.
		 * Required
		 */
		present: boolean;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdWaterFormProperties {

		/**
		 * Alerting threshold for a water detection event. Must be set to true.
		 * Required
		 */
		present: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdWaterFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdWaterFormProperties>({
			present: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBodyRecipients {

		/** A list of emails that will receive information about the alert. */
		emails?: Array<string>;

		/** A list of webhook endpoint IDs that will receive information about the alert. */
		httpServerIds?: Array<string>;

		/** A list of SMS numbers that will receive information about the alert. */
		smsNumbers?: Array<string>;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyRecipientsFormProperties {
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyRecipientsFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyRecipientsFormProperties>({
		});

	}

	export interface UpdateNetworkSensorAlertsProfilePutBodySchedule {

		/** ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times. */
		id?: string | null;
	}
	export interface UpdateNetworkSensorAlertsProfilePutBodyScheduleFormProperties {

		/** ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times. */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfilePutBodyScheduleFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfilePutBodyScheduleFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturn {

		/**
		 * List of conditions that will cause the profile to send an alert.
		 * Required
		 */
		UpdateNetworkSensorAlertsProfileReturnConditions: Array<UpdateNetworkSensorAlertsProfileReturnConditions>;

		/** Name of the sensor alert profile. */
		name?: string | null;

		/** ID of the sensor alert profile. */
		profileId?: string | null;

		/** List of recipients that will recieve the alert. */
		recipients?: UpdateNetworkSensorAlertsProfileReturnRecipients;

		/** The sensor schedule to use with the alert profile. */
		schedule?: UpdateNetworkSensorAlertsProfileReturnSchedule;

		/** List of device serials assigned to this sensor alert profile. */
		serials?: Array<string>;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnFormProperties {

		/** Name of the sensor alert profile. */
		name: FormControl<string | null | undefined>,

		/** ID of the sensor alert profile. */
		profileId: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			profileId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturnConditions {

		/** If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds. */
		direction?: GetNetworkSensorAlertsProfilesReturnConditionsDirection | null;

		/** Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0. */
		duration?: UpdateNetworkSensorAlertsProfileReturnConditionsDuration;

		/**
		 * The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * Required
		 */
		metric: string;

		/**
		 * Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
		 * Required
		 */
		threshold: UpdateNetworkSensorAlertsProfileReturnConditionsThreshold;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnConditionsFormProperties {

		/** If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds. */
		direction: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDirection | null | undefined>,

		/** Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0. */
		duration: FormControl<UpdateNetworkSensorAlertsProfileReturnConditionsDuration | null | undefined>,

		/**
		 * The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		 * Required
		 */
		metric: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnConditionsFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnConditionsFormProperties>({
			direction: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsDirection | null | undefined>(undefined),
			duration: new FormControl<UpdateNetworkSensorAlertsProfileReturnConditionsDuration | null | undefined>(undefined),
			metric: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum UpdateNetworkSensorAlertsProfileReturnConditionsDuration { _0 = 0, _60 = 1, _120 = 2, _180 = 3, _240 = 4, _300 = 5, _600 = 6, _900 = 7, _1800 = 8, _3600 = 9 }

	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThreshold {

		/** Door open threshold. 'open' must be provided and set to true. */
		door?: UpdateNetworkSensorAlertsProfileReturnConditionsThresholdDoor;

		/** Humidity threshold. One of 'relativePercentage' or 'quality' must be provided. */
		humidity?: UpdateNetworkSensorAlertsProfileReturnConditionsThresholdHumidity;

		/** Indoor air quality score threshold. One of 'score' or 'quality' must be provided. */
		indoorAirQuality?: UpdateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQuality;

		/** Noise threshold. 'ambient' must be provided. */
		noise?: UpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoise;

		/** PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided. */
		pm25?: UpdateNetworkSensorAlertsProfileReturnConditionsThresholdPm25;

		/** Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided. */
		temperature?: UpdateNetworkSensorAlertsProfileReturnConditionsThresholdTemperature;

		/** TVOC concentration threshold. One of 'concentration' or 'quality' must be provided. */
		tvoc?: UpdateNetworkSensorAlertsProfileReturnConditionsThresholdTvoc;

		/** Water detection threshold. 'present' must be provided and set to true. */
		water?: UpdateNetworkSensorAlertsProfileReturnConditionsThresholdWater;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdFormProperties {
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnConditionsThresholdFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnConditionsThresholdFormProperties>({
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdDoor {

		/**
		 * Alerting threshold for a door open event. Must be set to true.
		 * Required
		 */
		open: boolean;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdDoorFormProperties {

		/**
		 * Alerting threshold for a door open event. Must be set to true.
		 * Required
		 */
		open: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnConditionsThresholdDoorFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnConditionsThresholdDoorFormProperties>({
			open: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdHumidity {

		/** Alerting threshold as a qualitative humidity level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;

		/** Alerting threshold in %RH. */
		relativePercentage?: number | null;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdHumidityFormProperties {

		/** Alerting threshold as a qualitative humidity level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,

		/** Alerting threshold in %RH. */
		relativePercentage: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnConditionsThresholdHumidityFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnConditionsThresholdHumidityFormProperties>({
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
			relativePercentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQuality {

		/** Alerting threshold as a qualitative indoor air quality level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;

		/** Alerting threshold as indoor air quality score. */
		score?: number | null;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQualityFormProperties {

		/** Alerting threshold as a qualitative indoor air quality level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,

		/** Alerting threshold as indoor air quality score. */
		score: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQualityFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQualityFormProperties>({
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
			score: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoise {

		/**
		 * Ambient noise threshold. One of 'level' or 'quality' must be provided.
		 * Required
		 */
		ambient: UpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbient;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseFormProperties {
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseFormProperties>({
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbient {

		/** Alerting threshold as adjusted decibels. */
		level?: number | null;

		/** Alerting threshold as a qualitative ambient noise level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbientFormProperties {

		/** Alerting threshold as adjusted decibels. */
		level: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative ambient noise level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbientFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbientFormProperties>({
			level: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdPm25 {

		/** Alerting threshold as PM2.5 parts per million. */
		concentration?: number | null;

		/** Alerting threshold as a qualitative PM2.5 level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdPm25FormProperties {

		/** Alerting threshold as PM2.5 parts per million. */
		concentration: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative PM2.5 level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnConditionsThresholdPm25FormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnConditionsThresholdPm25FormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdTemperature {

		/** Alerting threshold in degrees Celsius. */
		celsius?: number | null;

		/** Alerting threshold in degrees Fahrenheit. */
		fahrenheit?: number | null;

		/** Alerting threshold as a qualitative temperature level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdTemperatureFormProperties {

		/** Alerting threshold in degrees Celsius. */
		celsius: FormControl<number | null | undefined>,

		/** Alerting threshold in degrees Fahrenheit. */
		fahrenheit: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative temperature level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnConditionsThresholdTemperatureFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnConditionsThresholdTemperatureFormProperties>({
			celsius: new FormControl<number | null | undefined>(undefined),
			fahrenheit: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdTvoc {

		/** Alerting threshold as TVOC micrograms per cubic meter. */
		concentration?: number | null;

		/** Alerting threshold as a qualitative TVOC level. */
		quality?: GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdTvocFormProperties {

		/** Alerting threshold as TVOC micrograms per cubic meter. */
		concentration: FormControl<number | null | undefined>,

		/** Alerting threshold as a qualitative TVOC level. */
		quality: FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnConditionsThresholdTvocFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnConditionsThresholdTvocFormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
			quality: new FormControl<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdWater {

		/**
		 * Alerting threshold for a water detection event. Must be set to true.
		 * Required
		 */
		present: boolean;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnConditionsThresholdWaterFormProperties {

		/**
		 * Alerting threshold for a water detection event. Must be set to true.
		 * Required
		 */
		present: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnConditionsThresholdWaterFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnConditionsThresholdWaterFormProperties>({
			present: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturnRecipients {

		/** A list of emails that will receive information about the alert. */
		emails?: Array<string>;

		/** A list of webhook endpoint IDs that will receive information about the alert. */
		httpServerIds?: Array<string>;

		/** A list of SMS numbers that will receive information about the alert. */
		smsNumbers?: Array<string>;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnRecipientsFormProperties {
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnRecipientsFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnRecipientsFormProperties>({
		});

	}

	export interface UpdateNetworkSensorAlertsProfileReturnSchedule {

		/** ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times. */
		id?: string | null;

		/** Name of the sensor schedule to use with the alert profile. */
		name?: string | null;
	}
	export interface UpdateNetworkSensorAlertsProfileReturnScheduleFormProperties {

		/** ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times. */
		id: FormControl<string | null | undefined>,

		/** Name of the sensor schedule to use with the alert profile. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSensorAlertsProfileReturnScheduleFormGroup() {
		return new FormGroup<UpdateNetworkSensorAlertsProfileReturnScheduleFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorRelationshipsReturn {

		/** A sensor or gateway device in the network */
		device?: GetNetworkSensorRelationshipsReturnDevice;

		/** An object describing the relationships defined between the device and other devices */
		relationships?: GetNetworkSensorRelationshipsReturnRelationships;
	}
	export interface GetNetworkSensorRelationshipsReturnFormProperties {
	}
	export function CreateGetNetworkSensorRelationshipsReturnFormGroup() {
		return new FormGroup<GetNetworkSensorRelationshipsReturnFormProperties>({
		});

	}

	export interface GetNetworkSensorRelationshipsReturnDevice {

		/** The name of the device */
		name?: string | null;

		/** The product type of the device */
		productType?: GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType | null;

		/** The serial of the device */
		serial?: string | null;
	}
	export interface GetNetworkSensorRelationshipsReturnDeviceFormProperties {

		/** The name of the device */
		name: FormControl<string | null | undefined>,

		/** The product type of the device */
		productType: FormControl<GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType | null | undefined>,

		/** The serial of the device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSensorRelationshipsReturnDeviceFormGroup() {
		return new FormGroup<GetNetworkSensorRelationshipsReturnDeviceFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSensorRelationshipsReturnRelationships {

		/** A role defined between an MT sensor and an MV camera that adds the camera's livestream to the sensor's details page. Snapshots from the camera will also appear in alert notifications that the sensor triggers. */
		livestream?: GetNetworkSensorRelationshipsReturnRelationshipsLivestream;
	}
	export interface GetNetworkSensorRelationshipsReturnRelationshipsFormProperties {
	}
	export function CreateGetNetworkSensorRelationshipsReturnRelationshipsFormGroup() {
		return new FormGroup<GetNetworkSensorRelationshipsReturnRelationshipsFormProperties>({
		});

	}

	export interface GetNetworkSensorRelationshipsReturnRelationshipsLivestream {

		/** An array of the related devices for the role */
		GetNetworkSensorRelationshipsReturnRelationshipsLivestreamRelatedDevices?: Array<GetNetworkSensorRelationshipsReturnRelationshipsLivestreamRelatedDevices>;
	}
	export interface GetNetworkSensorRelationshipsReturnRelationshipsLivestreamFormProperties {
	}
	export function CreateGetNetworkSensorRelationshipsReturnRelationshipsLivestreamFormGroup() {
		return new FormGroup<GetNetworkSensorRelationshipsReturnRelationshipsLivestreamFormProperties>({
		});

	}

	export interface GetNetworkSensorRelationshipsReturnRelationshipsLivestreamRelatedDevices {

		/** The product type of the related device */
		productType?: GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType | null;

		/** The serial of the related device */
		serial?: string | null;
	}
	export interface GetNetworkSensorRelationshipsReturnRelationshipsLivestreamRelatedDevicesFormProperties {

		/** The product type of the related device */
		productType: FormControl<GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType | null | undefined>,

		/** The serial of the related device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSensorRelationshipsReturnRelationshipsLivestreamRelatedDevicesFormGroup() {
		return new FormGroup<GetNetworkSensorRelationshipsReturnRelationshipsLivestreamRelatedDevicesFormProperties>({
			productType: new FormControl<GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSettingsReturn {

		/** Privacy settings */
		clientPrivacy?: GetNetworkSettingsReturnClientPrivacy;

		/** A hash of FIPS options applied to the Network */
		fips?: GetNetworkSettingsReturnFips;

		/** A hash of Local Status page(s)' authentication options applied to the Network. */
		localStatusPage?: GetNetworkSettingsReturnLocalStatusPage;

		/** Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false) */
		localStatusPageEnabled?: boolean | null;

		/** A hash of Named VLANs options applied to the Network. */
		namedVlans?: GetNetworkSettingsReturnNamedVlans;

		/** Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true */
		remoteStatusPageEnabled?: boolean | null;

		/** A hash of SecureConnect options applied to the Network. */
		securePort?: GetNetworkSettingsReturnSecurePort;
	}
	export interface GetNetworkSettingsReturnFormProperties {

		/** Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false) */
		localStatusPageEnabled: FormControl<boolean | null | undefined>,

		/** Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true */
		remoteStatusPageEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkSettingsReturnFormGroup() {
		return new FormGroup<GetNetworkSettingsReturnFormProperties>({
			localStatusPageEnabled: new FormControl<boolean | null | undefined>(undefined),
			remoteStatusPageEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSettingsReturnClientPrivacy {

		/** The date to expire the data before */
		expireDataBefore?: Date | null;

		/** The number of days, weeks, or months in Epoch time to expire the data before */
		expireDataOlderThan?: number | null;
	}
	export interface GetNetworkSettingsReturnClientPrivacyFormProperties {

		/** The date to expire the data before */
		expireDataBefore: FormControl<Date | null | undefined>,

		/** The number of days, weeks, or months in Epoch time to expire the data before */
		expireDataOlderThan: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSettingsReturnClientPrivacyFormGroup() {
		return new FormGroup<GetNetworkSettingsReturnClientPrivacyFormProperties>({
			expireDataBefore: new FormControl<Date | null | undefined>(undefined),
			expireDataOlderThan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSettingsReturnFips {

		/** Enables / disables FIPS on the network. */
		enabled?: boolean | null;
	}
	export interface GetNetworkSettingsReturnFipsFormProperties {

		/** Enables / disables FIPS on the network. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkSettingsReturnFipsFormGroup() {
		return new FormGroup<GetNetworkSettingsReturnFipsFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSettingsReturnLocalStatusPage {

		/** A hash of Local Status page(s)' authentication options applied to the Network. */
		authentication?: GetNetworkSettingsReturnLocalStatusPageAuthentication;
	}
	export interface GetNetworkSettingsReturnLocalStatusPageFormProperties {
	}
	export function CreateGetNetworkSettingsReturnLocalStatusPageFormGroup() {
		return new FormGroup<GetNetworkSettingsReturnLocalStatusPageFormProperties>({
		});

	}

	export interface GetNetworkSettingsReturnLocalStatusPageAuthentication {

		/** Enables / disables the authentication on Local Status page(s). */
		enabled?: boolean | null;

		/** The username used for Local Status Page(s). */
		username?: string | null;
	}
	export interface GetNetworkSettingsReturnLocalStatusPageAuthenticationFormProperties {

		/** Enables / disables the authentication on Local Status page(s). */
		enabled: FormControl<boolean | null | undefined>,

		/** The username used for Local Status Page(s). */
		username: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSettingsReturnLocalStatusPageAuthenticationFormGroup() {
		return new FormGroup<GetNetworkSettingsReturnLocalStatusPageAuthenticationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSettingsReturnNamedVlans {

		/**
		 * Enables / disables Named VLANs on the Network.
		 * Required
		 */
		enabled: boolean;
	}
	export interface GetNetworkSettingsReturnNamedVlansFormProperties {

		/**
		 * Enables / disables Named VLANs on the Network.
		 * Required
		 */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkSettingsReturnNamedVlansFormGroup() {
		return new FormGroup<GetNetworkSettingsReturnNamedVlansFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkSettingsReturnSecurePort {

		/** Enables / disables SecureConnect on the network. Optional. */
		enabled?: boolean | null;
	}
	export interface GetNetworkSettingsReturnSecurePortFormProperties {

		/** Enables / disables SecureConnect on the network. Optional. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkSettingsReturnSecurePortFormGroup() {
		return new FormGroup<GetNetworkSettingsReturnSecurePortFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSettingsPutBody {

		/** A hash of Local Status page(s)' authentication options applied to the Network. */
		localStatusPage?: UpdateNetworkSettingsPutBodyLocalStatusPage;

		/** Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false) */
		localStatusPageEnabled?: boolean | null;

		/** Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true */
		remoteStatusPageEnabled?: boolean | null;

		/** A hash of SecureConnect options applied to the Network. */
		securePort?: UpdateNetworkSettingsPutBodySecurePort;
	}
	export interface UpdateNetworkSettingsPutBodyFormProperties {

		/** Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false) */
		localStatusPageEnabled: FormControl<boolean | null | undefined>,

		/** Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true */
		remoteStatusPageEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSettingsPutBodyFormProperties>({
			localStatusPageEnabled: new FormControl<boolean | null | undefined>(undefined),
			remoteStatusPageEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSettingsPutBodyLocalStatusPage {

		/** A hash of Local Status page(s)' authentication options applied to the Network. */
		authentication?: UpdateNetworkSettingsPutBodyLocalStatusPageAuthentication;
	}
	export interface UpdateNetworkSettingsPutBodyLocalStatusPageFormProperties {
	}
	export function CreateUpdateNetworkSettingsPutBodyLocalStatusPageFormGroup() {
		return new FormGroup<UpdateNetworkSettingsPutBodyLocalStatusPageFormProperties>({
		});

	}

	export interface UpdateNetworkSettingsPutBodyLocalStatusPageAuthentication {

		/** Enables / disables the authentication on Local Status page(s). */
		enabled?: boolean | null;

		/** The password used for Local Status Page(s). Set this to null to clear the password. */
		password?: string | null;
	}
	export interface UpdateNetworkSettingsPutBodyLocalStatusPageAuthenticationFormProperties {

		/** Enables / disables the authentication on Local Status page(s). */
		enabled: FormControl<boolean | null | undefined>,

		/** The password used for Local Status Page(s). Set this to null to clear the password. */
		password: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSettingsPutBodyLocalStatusPageAuthenticationFormGroup() {
		return new FormGroup<UpdateNetworkSettingsPutBodyLocalStatusPageAuthenticationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			password: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSettingsPutBodySecurePort {

		/** Enables / disables SecureConnect on the network. Optional. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkSettingsPutBodySecurePortFormProperties {

		/** Enables / disables SecureConnect on the network. Optional. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSettingsPutBodySecurePortFormGroup() {
		return new FormGroup<UpdateNetworkSettingsPutBodySecurePortFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSettingsReturn {

		/** Privacy settings */
		clientPrivacy?: UpdateNetworkSettingsReturnClientPrivacy;

		/** A hash of FIPS options applied to the Network */
		fips?: UpdateNetworkSettingsReturnFips;

		/** A hash of Local Status page(s)' authentication options applied to the Network. */
		localStatusPage?: UpdateNetworkSettingsReturnLocalStatusPage;

		/** Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false) */
		localStatusPageEnabled?: boolean | null;

		/** A hash of Named VLANs options applied to the Network. */
		namedVlans?: UpdateNetworkSettingsReturnNamedVlans;

		/** Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true */
		remoteStatusPageEnabled?: boolean | null;

		/** A hash of SecureConnect options applied to the Network. */
		securePort?: UpdateNetworkSettingsReturnSecurePort;
	}
	export interface UpdateNetworkSettingsReturnFormProperties {

		/** Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false) */
		localStatusPageEnabled: FormControl<boolean | null | undefined>,

		/** Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true */
		remoteStatusPageEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSettingsReturnFormGroup() {
		return new FormGroup<UpdateNetworkSettingsReturnFormProperties>({
			localStatusPageEnabled: new FormControl<boolean | null | undefined>(undefined),
			remoteStatusPageEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSettingsReturnClientPrivacy {

		/** The date to expire the data before */
		expireDataBefore?: Date | null;

		/** The number of days, weeks, or months in Epoch time to expire the data before */
		expireDataOlderThan?: number | null;
	}
	export interface UpdateNetworkSettingsReturnClientPrivacyFormProperties {

		/** The date to expire the data before */
		expireDataBefore: FormControl<Date | null | undefined>,

		/** The number of days, weeks, or months in Epoch time to expire the data before */
		expireDataOlderThan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSettingsReturnClientPrivacyFormGroup() {
		return new FormGroup<UpdateNetworkSettingsReturnClientPrivacyFormProperties>({
			expireDataBefore: new FormControl<Date | null | undefined>(undefined),
			expireDataOlderThan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSettingsReturnFips {

		/** Enables / disables FIPS on the network. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkSettingsReturnFipsFormProperties {

		/** Enables / disables FIPS on the network. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSettingsReturnFipsFormGroup() {
		return new FormGroup<UpdateNetworkSettingsReturnFipsFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSettingsReturnLocalStatusPage {

		/** A hash of Local Status page(s)' authentication options applied to the Network. */
		authentication?: UpdateNetworkSettingsReturnLocalStatusPageAuthentication;
	}
	export interface UpdateNetworkSettingsReturnLocalStatusPageFormProperties {
	}
	export function CreateUpdateNetworkSettingsReturnLocalStatusPageFormGroup() {
		return new FormGroup<UpdateNetworkSettingsReturnLocalStatusPageFormProperties>({
		});

	}

	export interface UpdateNetworkSettingsReturnLocalStatusPageAuthentication {

		/** Enables / disables the authentication on Local Status page(s). */
		enabled?: boolean | null;

		/** The username used for Local Status Page(s). */
		username?: string | null;
	}
	export interface UpdateNetworkSettingsReturnLocalStatusPageAuthenticationFormProperties {

		/** Enables / disables the authentication on Local Status page(s). */
		enabled: FormControl<boolean | null | undefined>,

		/** The username used for Local Status Page(s). */
		username: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSettingsReturnLocalStatusPageAuthenticationFormGroup() {
		return new FormGroup<UpdateNetworkSettingsReturnLocalStatusPageAuthenticationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSettingsReturnNamedVlans {

		/**
		 * Enables / disables Named VLANs on the Network.
		 * Required
		 */
		enabled: boolean;
	}
	export interface UpdateNetworkSettingsReturnNamedVlansFormProperties {

		/**
		 * Enables / disables Named VLANs on the Network.
		 * Required
		 */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSettingsReturnNamedVlansFormGroup() {
		return new FormGroup<UpdateNetworkSettingsReturnNamedVlansFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSettingsReturnSecurePort {

		/** Enables / disables SecureConnect on the network. Optional. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkSettingsReturnSecurePortFormProperties {

		/** Enables / disables SecureConnect on the network. Optional. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSettingsReturnSecurePortFormGroup() {
		return new FormGroup<UpdateNetworkSettingsReturnSecurePortFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSmBypassActivationLockAttemptPostBody {

		/**
		 * The ids of the devices to attempt activation lock bypass.
		 * Required
		 */
		ids: Array<string>;
	}
	export interface CreateNetworkSmBypassActivationLockAttemptPostBodyFormProperties {
	}
	export function CreateCreateNetworkSmBypassActivationLockAttemptPostBodyFormGroup() {
		return new FormGroup<CreateNetworkSmBypassActivationLockAttemptPostBodyFormProperties>({
		});

	}

	export interface GetNetworkSmDevicesReturn {

		/** The Meraki Id of the device record. */
		id?: string | null;

		/** The IP address of the device. */
		ip?: string | null;

		/** The name of the device. */
		name?: string | null;

		/** Notes associated with the device. */
		notes?: string | null;

		/** The name of the device OS. */
		osName?: string | null;

		/** The device serial. */
		serial?: string | null;

		/** The device serial number. */
		serialNumber?: string | null;

		/** The name of the SSID the device was last connected to. */
		ssid?: string | null;

		/** The device model. */
		systemModel?: string | null;

		/** An array of tags associated with the device. */
		tags?: Array<string>;

		/** The UUID of the device. */
		uuid?: string | null;

		/** The MAC of the device. */
		wifiMac?: string | null;
	}
	export interface GetNetworkSmDevicesReturnFormProperties {

		/** The Meraki Id of the device record. */
		id: FormControl<string | null | undefined>,

		/** The IP address of the device. */
		ip: FormControl<string | null | undefined>,

		/** The name of the device. */
		name: FormControl<string | null | undefined>,

		/** Notes associated with the device. */
		notes: FormControl<string | null | undefined>,

		/** The name of the device OS. */
		osName: FormControl<string | null | undefined>,

		/** The device serial. */
		serial: FormControl<string | null | undefined>,

		/** The device serial number. */
		serialNumber: FormControl<string | null | undefined>,

		/** The name of the SSID the device was last connected to. */
		ssid: FormControl<string | null | undefined>,

		/** The device model. */
		systemModel: FormControl<string | null | undefined>,

		/** The UUID of the device. */
		uuid: FormControl<string | null | undefined>,

		/** The MAC of the device. */
		wifiMac: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmDevicesReturnFormGroup() {
		return new FormGroup<GetNetworkSmDevicesReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			ip: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
			osName: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			serialNumber: new FormControl<string | null | undefined>(undefined),
			ssid: new FormControl<string | null | undefined>(undefined),
			systemModel: new FormControl<string | null | undefined>(undefined),
			uuid: new FormControl<string | null | undefined>(undefined),
			wifiMac: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CheckinNetworkSmDevicesPostBody {

		/** The ids of the devices to be checked-in. */
		ids?: Array<string>;

		/** The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in. */
		scope?: Array<string>;

		/** The serials of the devices to be checked-in. */
		serials?: Array<string>;

		/** The wifiMacs of the devices to be checked-in. */
		wifiMacs?: Array<string>;
	}
	export interface CheckinNetworkSmDevicesPostBodyFormProperties {
	}
	export function CreateCheckinNetworkSmDevicesPostBodyFormGroup() {
		return new FormGroup<CheckinNetworkSmDevicesPostBodyFormProperties>({
		});

	}

	export interface CheckinNetworkSmDevicesReturn {

		/** The Meraki Ids of the set of devices. */
		ids?: Array<string>;
	}
	export interface CheckinNetworkSmDevicesReturnFormProperties {
	}
	export function CreateCheckinNetworkSmDevicesReturnFormGroup() {
		return new FormGroup<CheckinNetworkSmDevicesReturnFormProperties>({
		});

	}

	export interface UpdateNetworkSmDevicesFieldsPutBody {

		/**
		 * The new fields of the device. Each field of this object is optional.
		 * Required
		 */
		deviceFields: UpdateNetworkSmDevicesFieldsPutBodyDeviceFields;

		/** The id of the device to be modified. */
		id?: string | null;

		/** The serial of the device to be modified. */
		serial?: string | null;

		/** The wifiMac of the device to be modified. */
		wifiMac?: string | null;
	}
	export interface UpdateNetworkSmDevicesFieldsPutBodyFormProperties {

		/** The id of the device to be modified. */
		id: FormControl<string | null | undefined>,

		/** The serial of the device to be modified. */
		serial: FormControl<string | null | undefined>,

		/** The wifiMac of the device to be modified. */
		wifiMac: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSmDevicesFieldsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSmDevicesFieldsPutBodyFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			wifiMac: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSmDevicesFieldsPutBodyDeviceFields {

		/** New name for the device */
		name?: string | null;

		/** New notes for the device */
		notes?: string | null;
	}
	export interface UpdateNetworkSmDevicesFieldsPutBodyDeviceFieldsFormProperties {

		/** New name for the device */
		name: FormControl<string | null | undefined>,

		/** New notes for the device */
		notes: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSmDevicesFieldsPutBodyDeviceFieldsFormGroup() {
		return new FormGroup<UpdateNetworkSmDevicesFieldsPutBodyDeviceFieldsFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSmDevicesFieldsReturn {

		/** The Meraki Id of the device record. */
		id?: string | null;

		/** The name of the device. */
		name?: string | null;

		/** Notes associated with the device. */
		notes?: string | null;

		/** The device serial. */
		serial?: string | null;

		/** The MAC of the device. */
		wifiMac?: string | null;
	}
	export interface UpdateNetworkSmDevicesFieldsReturnFormProperties {

		/** The Meraki Id of the device record. */
		id: FormControl<string | null | undefined>,

		/** The name of the device. */
		name: FormControl<string | null | undefined>,

		/** Notes associated with the device. */
		notes: FormControl<string | null | undefined>,

		/** The device serial. */
		serial: FormControl<string | null | undefined>,

		/** The MAC of the device. */
		wifiMac: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSmDevicesFieldsReturnFormGroup() {
		return new FormGroup<UpdateNetworkSmDevicesFieldsReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			wifiMac: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface LockNetworkSmDevicesPostBody {

		/** The ids of the devices to be locked. */
		ids?: Array<string>;

		/** The pin number for locking macOS devices (a six digit number). Required only for macOS devices. */
		pin?: number | null;

		/** The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped. */
		scope?: Array<string>;

		/** The serials of the devices to be locked. */
		serials?: Array<string>;

		/** The wifiMacs of the devices to be locked. */
		wifiMacs?: Array<string>;
	}
	export interface LockNetworkSmDevicesPostBodyFormProperties {

		/** The pin number for locking macOS devices (a six digit number). Required only for macOS devices. */
		pin: FormControl<number | null | undefined>,
	}
	export function CreateLockNetworkSmDevicesPostBodyFormGroup() {
		return new FormGroup<LockNetworkSmDevicesPostBodyFormProperties>({
			pin: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface LockNetworkSmDevicesReturn {

		/** The Meraki Ids of the set of devices. */
		ids?: Array<string>;
	}
	export interface LockNetworkSmDevicesReturnFormProperties {
	}
	export function CreateLockNetworkSmDevicesReturnFormGroup() {
		return new FormGroup<LockNetworkSmDevicesReturnFormProperties>({
		});

	}

	export interface ModifyNetworkSmDevicesTagsPostBody {

		/** The ids of the devices to be modified. */
		ids?: Array<string>;

		/** The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified. */
		scope?: Array<string>;

		/** The serials of the devices to be modified. */
		serials?: Array<string>;

		/**
		 * The tags to be added, deleted, or updated.
		 * Required
		 */
		tags: Array<string>;

		/**
		 * One of add, delete, or update. Only devices that have been modified will be returned.
		 * Required
		 */
		updateAction: string;

		/** The wifiMacs of the devices to be modified. */
		wifiMacs?: Array<string>;
	}
	export interface ModifyNetworkSmDevicesTagsPostBodyFormProperties {

		/**
		 * One of add, delete, or update. Only devices that have been modified will be returned.
		 * Required
		 */
		updateAction: FormControl<string | null | undefined>,
	}
	export function CreateModifyNetworkSmDevicesTagsPostBodyFormGroup() {
		return new FormGroup<ModifyNetworkSmDevicesTagsPostBodyFormProperties>({
			updateAction: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface ModifyNetworkSmDevicesTagsReturn {

		/** The Meraki Id of the device record. */
		id?: string | null;

		/** The device serial. */
		serial?: string | null;

		/** An array of tags associated with the device. */
		tags?: Array<string>;

		/** The MAC of the device. */
		wifiMac?: string | null;
	}
	export interface ModifyNetworkSmDevicesTagsReturnFormProperties {

		/** The Meraki Id of the device record. */
		id: FormControl<string | null | undefined>,

		/** The device serial. */
		serial: FormControl<string | null | undefined>,

		/** The MAC of the device. */
		wifiMac: FormControl<string | null | undefined>,
	}
	export function CreateModifyNetworkSmDevicesTagsReturnFormGroup() {
		return new FormGroup<ModifyNetworkSmDevicesTagsReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			wifiMac: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface MoveNetworkSmDevicesPostBody {

		/** The ids of the devices to be moved. */
		ids?: Array<string>;

		/**
		 * The new network to which the devices will be moved.
		 * Required
		 */
		newNetwork: string;

		/** The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved. */
		scope?: Array<string>;

		/** The serials of the devices to be moved. */
		serials?: Array<string>;

		/** The wifiMacs of the devices to be moved. */
		wifiMacs?: Array<string>;
	}
	export interface MoveNetworkSmDevicesPostBodyFormProperties {

		/**
		 * The new network to which the devices will be moved.
		 * Required
		 */
		newNetwork: FormControl<string | null | undefined>,
	}
	export function CreateMoveNetworkSmDevicesPostBodyFormGroup() {
		return new FormGroup<MoveNetworkSmDevicesPostBodyFormProperties>({
			newNetwork: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface MoveNetworkSmDevicesReturn {

		/** The Meraki Ids of the set of devices. */
		ids?: Array<string>;

		/** The network to which the devices was moved. */
		newNetwork?: string | null;
	}
	export interface MoveNetworkSmDevicesReturnFormProperties {

		/** The network to which the devices was moved. */
		newNetwork: FormControl<string | null | undefined>,
	}
	export function CreateMoveNetworkSmDevicesReturnFormGroup() {
		return new FormGroup<MoveNetworkSmDevicesReturnFormProperties>({
			newNetwork: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface WipeNetworkSmDevicesPostBody {

		/** The id of the device to be wiped. */
		id?: string | null;

		/** The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices. */
		pin?: number | null;

		/** The serial of the device to be wiped. */
		serial?: string | null;

		/** The wifiMac of the device to be wiped. */
		wifiMac?: string | null;
	}
	export interface WipeNetworkSmDevicesPostBodyFormProperties {

		/** The id of the device to be wiped. */
		id: FormControl<string | null | undefined>,

		/** The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices. */
		pin: FormControl<number | null | undefined>,

		/** The serial of the device to be wiped. */
		serial: FormControl<string | null | undefined>,

		/** The wifiMac of the device to be wiped. */
		wifiMac: FormControl<string | null | undefined>,
	}
	export function CreateWipeNetworkSmDevicesPostBodyFormGroup() {
		return new FormGroup<WipeNetworkSmDevicesPostBodyFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			pin: new FormControl<number | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			wifiMac: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface WipeNetworkSmDevicesReturn {

		/** The Meraki Id of the devices. */
		id?: string | null;
	}
	export interface WipeNetworkSmDevicesReturnFormProperties {

		/** The Meraki Id of the devices. */
		id: FormControl<string | null | undefined>,
	}
	export function CreateWipeNetworkSmDevicesReturnFormGroup() {
		return new FormGroup<WipeNetworkSmDevicesReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmDeviceCellularUsageHistoryReturn {

		/** The amount of cellular data received by the device. */
		received?: number | null;

		/** The amount of cellular sent received by the device. */
		sent?: number | null;

		/** When the cellular usage data was collected. */
		ts?: string | null;
	}
	export interface GetNetworkSmDeviceCellularUsageHistoryReturnFormProperties {

		/** The amount of cellular data received by the device. */
		received: FormControl<number | null | undefined>,

		/** The amount of cellular sent received by the device. */
		sent: FormControl<number | null | undefined>,

		/** When the cellular usage data was collected. */
		ts: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmDeviceCellularUsageHistoryReturnFormGroup() {
		return new FormGroup<GetNetworkSmDeviceCellularUsageHistoryReturnFormProperties>({
			received: new FormControl<number | null | undefined>(undefined),
			sent: new FormControl<number | null | undefined>(undefined),
			ts: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmDeviceCertsReturn {

		/** The PEM of the certificate. */
		certPem?: string | null;

		/** The Meraki managed device Id. */
		deviceId?: string | null;

		/** The Meraki Id of the certificate record. */
		id?: string | null;

		/** The certificate issuer. */
		issuer?: string | null;

		/** The name of the certificate. */
		name?: string | null;

		/** The date after which the certificate is no longer valid. */
		notValidAfter?: string | null;

		/** The date before which the certificate is not valid. */
		notValidBefore?: string | null;

		/** The subject of the certificate. */
		subject?: string | null;
	}
	export interface GetNetworkSmDeviceCertsReturnFormProperties {

		/** The PEM of the certificate. */
		certPem: FormControl<string | null | undefined>,

		/** The Meraki managed device Id. */
		deviceId: FormControl<string | null | undefined>,

		/** The Meraki Id of the certificate record. */
		id: FormControl<string | null | undefined>,

		/** The certificate issuer. */
		issuer: FormControl<string | null | undefined>,

		/** The name of the certificate. */
		name: FormControl<string | null | undefined>,

		/** The date after which the certificate is no longer valid. */
		notValidAfter: FormControl<string | null | undefined>,

		/** The date before which the certificate is not valid. */
		notValidBefore: FormControl<string | null | undefined>,

		/** The subject of the certificate. */
		subject: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmDeviceCertsReturnFormGroup() {
		return new FormGroup<GetNetworkSmDeviceCertsReturnFormProperties>({
			certPem: new FormControl<string | null | undefined>(undefined),
			deviceId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			issuer: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			notValidAfter: new FormControl<string | null | undefined>(undefined),
			notValidBefore: new FormControl<string | null | undefined>(undefined),
			subject: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmDeviceConnectivityReturn {

		/** When the device was first seen as connected to the internet in each connection. */
		firstSeenAt?: string | null;

		/** When the device was last seen as connected to the internet in each connection. */
		lastSeenAt?: string | null;
	}
	export interface GetNetworkSmDeviceConnectivityReturnFormProperties {

		/** When the device was first seen as connected to the internet in each connection. */
		firstSeenAt: FormControl<string | null | undefined>,

		/** When the device was last seen as connected to the internet in each connection. */
		lastSeenAt: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmDeviceConnectivityReturnFormGroup() {
		return new FormGroup<GetNetworkSmDeviceConnectivityReturnFormProperties>({
			firstSeenAt: new FormControl<string | null | undefined>(undefined),
			lastSeenAt: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmDeviceDesktopLogsReturn {

		/** The IP address of the DCHP Server. */
		dhcpServer?: string | null;

		/** The DNS Server during the connection. */
		dnsServer?: string | null;

		/** The gateway IP the device was connected to. */
		gateway?: string | null;

		/** The IP of the device during connection. */
		ip?: string | null;

		/** The time the data was measured at. */
		measuredAt?: string | null;

		/** The network device for the device used for connection. */
		networkDevice?: string | null;

		/** The network driver for the device. */
		networkDriver?: string | null;

		/** The network max transmission unit. */
		networkMTU?: string | null;

		/** The public IP address of the device. */
		publicIP?: string | null;

		/** The subnet of the device connection. */
		subnet?: string | null;

		/** The time the connection was logged. */
		ts?: string | null;

		/** The user during connection. */
		user?: string | null;

		/** The type of authentication used by the SSID. */
		wifiAuth?: string | null;

		/** The MAC of the access point the device is connected to. */
		wifiBssid?: string | null;

		/** Channel through which the connection is routing. */
		wifiChannel?: string | null;

		/** The wireless signal power level received by the device. */
		wifiNoise?: string | null;

		/** The Received Signal Strength Indicator for the device. */
		wifiRssi?: string | null;

		/** The name of the network the device is connected to. */
		wifiSsid?: string | null;
	}
	export interface GetNetworkSmDeviceDesktopLogsReturnFormProperties {

		/** The IP address of the DCHP Server. */
		dhcpServer: FormControl<string | null | undefined>,

		/** The DNS Server during the connection. */
		dnsServer: FormControl<string | null | undefined>,

		/** The gateway IP the device was connected to. */
		gateway: FormControl<string | null | undefined>,

		/** The IP of the device during connection. */
		ip: FormControl<string | null | undefined>,

		/** The time the data was measured at. */
		measuredAt: FormControl<string | null | undefined>,

		/** The network device for the device used for connection. */
		networkDevice: FormControl<string | null | undefined>,

		/** The network driver for the device. */
		networkDriver: FormControl<string | null | undefined>,

		/** The network max transmission unit. */
		networkMTU: FormControl<string | null | undefined>,

		/** The public IP address of the device. */
		publicIP: FormControl<string | null | undefined>,

		/** The subnet of the device connection. */
		subnet: FormControl<string | null | undefined>,

		/** The time the connection was logged. */
		ts: FormControl<string | null | undefined>,

		/** The user during connection. */
		user: FormControl<string | null | undefined>,

		/** The type of authentication used by the SSID. */
		wifiAuth: FormControl<string | null | undefined>,

		/** The MAC of the access point the device is connected to. */
		wifiBssid: FormControl<string | null | undefined>,

		/** Channel through which the connection is routing. */
		wifiChannel: FormControl<string | null | undefined>,

		/** The wireless signal power level received by the device. */
		wifiNoise: FormControl<string | null | undefined>,

		/** The Received Signal Strength Indicator for the device. */
		wifiRssi: FormControl<string | null | undefined>,

		/** The name of the network the device is connected to. */
		wifiSsid: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmDeviceDesktopLogsReturnFormGroup() {
		return new FormGroup<GetNetworkSmDeviceDesktopLogsReturnFormProperties>({
			dhcpServer: new FormControl<string | null | undefined>(undefined),
			dnsServer: new FormControl<string | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			ip: new FormControl<string | null | undefined>(undefined),
			measuredAt: new FormControl<string | null | undefined>(undefined),
			networkDevice: new FormControl<string | null | undefined>(undefined),
			networkDriver: new FormControl<string | null | undefined>(undefined),
			networkMTU: new FormControl<string | null | undefined>(undefined),
			publicIP: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
			ts: new FormControl<string | null | undefined>(undefined),
			user: new FormControl<string | null | undefined>(undefined),
			wifiAuth: new FormControl<string | null | undefined>(undefined),
			wifiBssid: new FormControl<string | null | undefined>(undefined),
			wifiChannel: new FormControl<string | null | undefined>(undefined),
			wifiNoise: new FormControl<string | null | undefined>(undefined),
			wifiRssi: new FormControl<string | null | undefined>(undefined),
			wifiSsid: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmDeviceDeviceCommandLogsReturn {

		/** The type of command sent to the device. */
		action?: string | null;

		/** The Meraki dashboard user who initiated the command. */
		dashboardUser?: string | null;

		/** A JSON string object containing command details. */
		details?: string | null;

		/** The name of the device to which the command is sent. */
		name?: string | null;

		/** The time the command was sent to the device. */
		ts?: string | null;
	}
	export interface GetNetworkSmDeviceDeviceCommandLogsReturnFormProperties {

		/** The type of command sent to the device. */
		action: FormControl<string | null | undefined>,

		/** The Meraki dashboard user who initiated the command. */
		dashboardUser: FormControl<string | null | undefined>,

		/** A JSON string object containing command details. */
		details: FormControl<string | null | undefined>,

		/** The name of the device to which the command is sent. */
		name: FormControl<string | null | undefined>,

		/** The time the command was sent to the device. */
		ts: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmDeviceDeviceCommandLogsReturnFormGroup() {
		return new FormGroup<GetNetworkSmDeviceDeviceCommandLogsReturnFormProperties>({
			action: new FormControl<string | null | undefined>(undefined),
			dashboardUser: new FormControl<string | null | undefined>(undefined),
			details: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			ts: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmDeviceDeviceProfilesReturn {

		/** The Meraki managed device Id. */
		deviceId?: string | null;

		/** The numerical Meraki Id of the profile. */
		id?: string | null;

		/** A boolean indicating if the profile is encrypted. */
		isEncrypted?: boolean | null;

		/** Whether or not the profile is managed by Meraki. */
		isManaged?: boolean | null;

		/** The name of the profile. */
		name?: string | null;

		/** A string containing a JSON object with the profile data. */
		profileData?: string | null;

		/** The identifier of the profile. */
		profileIdentifier?: string | null;

		/** The verison of the profile. */
		version?: string | null;
	}
	export interface GetNetworkSmDeviceDeviceProfilesReturnFormProperties {

		/** The Meraki managed device Id. */
		deviceId: FormControl<string | null | undefined>,

		/** The numerical Meraki Id of the profile. */
		id: FormControl<string | null | undefined>,

		/** A boolean indicating if the profile is encrypted. */
		isEncrypted: FormControl<boolean | null | undefined>,

		/** Whether or not the profile is managed by Meraki. */
		isManaged: FormControl<boolean | null | undefined>,

		/** The name of the profile. */
		name: FormControl<string | null | undefined>,

		/** A string containing a JSON object with the profile data. */
		profileData: FormControl<string | null | undefined>,

		/** The identifier of the profile. */
		profileIdentifier: FormControl<string | null | undefined>,

		/** The verison of the profile. */
		version: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmDeviceDeviceProfilesReturnFormGroup() {
		return new FormGroup<GetNetworkSmDeviceDeviceProfilesReturnFormProperties>({
			deviceId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isEncrypted: new FormControl<boolean | null | undefined>(undefined),
			isManaged: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			profileData: new FormControl<string | null | undefined>(undefined),
			profileIdentifier: new FormControl<string | null | undefined>(undefined),
			version: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmDeviceNetworkAdaptersReturn {

		/** The IP address of the DCHP Server. */
		dhcpServer?: string | null;

		/** The IP address of the DNS Server. */
		dnsServer?: string | null;

		/** The IP address of the Gateway. */
		gateway?: string | null;

		/** The Meraki Id of the network adapter record. */
		id?: string | null;

		/** The IP address of the network adapter. */
		ip?: string | null;

		/** The MAC associated with the network adapter. */
		mac?: string | null;

		/** The name of the newtwork adapter. */
		name?: string | null;

		/** The subnet for the network adapter. */
		subnet?: string | null;
	}
	export interface GetNetworkSmDeviceNetworkAdaptersReturnFormProperties {

		/** The IP address of the DCHP Server. */
		dhcpServer: FormControl<string | null | undefined>,

		/** The IP address of the DNS Server. */
		dnsServer: FormControl<string | null | undefined>,

		/** The IP address of the Gateway. */
		gateway: FormControl<string | null | undefined>,

		/** The Meraki Id of the network adapter record. */
		id: FormControl<string | null | undefined>,

		/** The IP address of the network adapter. */
		ip: FormControl<string | null | undefined>,

		/** The MAC associated with the network adapter. */
		mac: FormControl<string | null | undefined>,

		/** The name of the newtwork adapter. */
		name: FormControl<string | null | undefined>,

		/** The subnet for the network adapter. */
		subnet: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmDeviceNetworkAdaptersReturnFormGroup() {
		return new FormGroup<GetNetworkSmDeviceNetworkAdaptersReturnFormProperties>({
			dhcpServer: new FormControl<string | null | undefined>(undefined),
			dnsServer: new FormControl<string | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			ip: new FormControl<string | null | undefined>(undefined),
			mac: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmDevicePerformanceHistoryReturn {

		/** The percentage of CPU used as a decimal format. */
		cpuPercentUsed?: number | null;

		/** An object containing disk usage details. */
		diskUsage?: GetNetworkSmDevicePerformanceHistoryReturnDiskUsage;

		/** The active RAM on the device. */
		memActive?: number | null;

		/** Memory that is not yet in use by the system. */
		memFree?: number | null;

		/** The inactive RAM on the device. */
		memInactive?: number | null;

		/** Memory used for core OS functions on the device. */
		memWired?: number | null;

		/** Network bandwith received. */
		networkReceived?: number | null;

		/** Network bandwith transmitted. */
		networkSent?: number | null;

		/** The amount of space being used on the startup disk to swap unused files to and from RAM. */
		swapUsed?: number | null;

		/** The time at which the performance was measured. */
		ts?: string | null;
	}
	export interface GetNetworkSmDevicePerformanceHistoryReturnFormProperties {

		/** The percentage of CPU used as a decimal format. */
		cpuPercentUsed: FormControl<number | null | undefined>,

		/** The active RAM on the device. */
		memActive: FormControl<number | null | undefined>,

		/** Memory that is not yet in use by the system. */
		memFree: FormControl<number | null | undefined>,

		/** The inactive RAM on the device. */
		memInactive: FormControl<number | null | undefined>,

		/** Memory used for core OS functions on the device. */
		memWired: FormControl<number | null | undefined>,

		/** Network bandwith received. */
		networkReceived: FormControl<number | null | undefined>,

		/** Network bandwith transmitted. */
		networkSent: FormControl<number | null | undefined>,

		/** The amount of space being used on the startup disk to swap unused files to and from RAM. */
		swapUsed: FormControl<number | null | undefined>,

		/** The time at which the performance was measured. */
		ts: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmDevicePerformanceHistoryReturnFormGroup() {
		return new FormGroup<GetNetworkSmDevicePerformanceHistoryReturnFormProperties>({
			cpuPercentUsed: new FormControl<number | null | undefined>(undefined),
			memActive: new FormControl<number | null | undefined>(undefined),
			memFree: new FormControl<number | null | undefined>(undefined),
			memInactive: new FormControl<number | null | undefined>(undefined),
			memWired: new FormControl<number | null | undefined>(undefined),
			networkReceived: new FormControl<number | null | undefined>(undefined),
			networkSent: new FormControl<number | null | undefined>(undefined),
			swapUsed: new FormControl<number | null | undefined>(undefined),
			ts: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmDevicePerformanceHistoryReturnDiskUsage {

		/** An object containing current disk usage details. */
		c?: GetNetworkSmDevicePerformanceHistoryReturnDiskUsageC;
	}
	export interface GetNetworkSmDevicePerformanceHistoryReturnDiskUsageFormProperties {
	}
	export function CreateGetNetworkSmDevicePerformanceHistoryReturnDiskUsageFormGroup() {
		return new FormGroup<GetNetworkSmDevicePerformanceHistoryReturnDiskUsageFormProperties>({
		});

	}

	export interface GetNetworkSmDevicePerformanceHistoryReturnDiskUsageC {

		/** The available disk space. */
		space?: number | null;

		/** The used disk space. */
		used?: number | null;
	}
	export interface GetNetworkSmDevicePerformanceHistoryReturnDiskUsageCFormProperties {

		/** The available disk space. */
		space: FormControl<number | null | undefined>,

		/** The used disk space. */
		used: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSmDevicePerformanceHistoryReturnDiskUsageCFormGroup() {
		return new FormGroup<GetNetworkSmDevicePerformanceHistoryReturnDiskUsageCFormProperties>({
			space: new FormControl<number | null | undefined>(undefined),
			used: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmDeviceSecurityCentersReturn {

		/** The name of the Antivirus. */
		antiVirusName?: string | null;

		/** The name of the Firewall. */
		fireWallName?: string | null;

		/** Boolean indicating if the device has Antivirus. */
		hasAntiVirus?: boolean | null;

		/** Boolean indicating if the device has a Firewall installed. */
		hasFireWallInstalled?: boolean | null;

		/** The Meraki identifier for the security center record. */
		id?: string | null;

		/** Boolean indicating if the device has auto login disabled. */
		isAutoLoginDisabled?: boolean | null;

		/** Boolean indicating if the device has disk encryption. */
		isDiskEncrypted?: boolean | null;

		/** Boolean indicating if the device has a Firewall enabled. */
		isFireWallEnabled?: boolean | null;

		/** Boolean indicating if the device is rooted. */
		isRooted?: boolean | null;

		/** A comma seperated list of procs running on the device. */
		runningProcs?: string | null;
	}
	export interface GetNetworkSmDeviceSecurityCentersReturnFormProperties {

		/** The name of the Antivirus. */
		antiVirusName: FormControl<string | null | undefined>,

		/** The name of the Firewall. */
		fireWallName: FormControl<string | null | undefined>,

		/** Boolean indicating if the device has Antivirus. */
		hasAntiVirus: FormControl<boolean | null | undefined>,

		/** Boolean indicating if the device has a Firewall installed. */
		hasFireWallInstalled: FormControl<boolean | null | undefined>,

		/** The Meraki identifier for the security center record. */
		id: FormControl<string | null | undefined>,

		/** Boolean indicating if the device has auto login disabled. */
		isAutoLoginDisabled: FormControl<boolean | null | undefined>,

		/** Boolean indicating if the device has disk encryption. */
		isDiskEncrypted: FormControl<boolean | null | undefined>,

		/** Boolean indicating if the device has a Firewall enabled. */
		isFireWallEnabled: FormControl<boolean | null | undefined>,

		/** Boolean indicating if the device is rooted. */
		isRooted: FormControl<boolean | null | undefined>,

		/** A comma seperated list of procs running on the device. */
		runningProcs: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmDeviceSecurityCentersReturnFormGroup() {
		return new FormGroup<GetNetworkSmDeviceSecurityCentersReturnFormProperties>({
			antiVirusName: new FormControl<string | null | undefined>(undefined),
			fireWallName: new FormControl<string | null | undefined>(undefined),
			hasAntiVirus: new FormControl<boolean | null | undefined>(undefined),
			hasFireWallInstalled: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isAutoLoginDisabled: new FormControl<boolean | null | undefined>(undefined),
			isDiskEncrypted: new FormControl<boolean | null | undefined>(undefined),
			isFireWallEnabled: new FormControl<boolean | null | undefined>(undefined),
			isRooted: new FormControl<boolean | null | undefined>(undefined),
			runningProcs: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmDeviceSoftwaresReturn {

		/** The Meraki managed application Id for this record on a particular device. */
		appId?: string | null;

		/** The size of the software bundle. */
		bundleSize?: number | null;

		/** When the Meraki record for the software was created. */
		createdAt?: string | null;

		/** The Meraki managed device Id. */
		deviceId?: string | null;

		/** The size of the data stored in the application. */
		dynamicSize?: number | null;

		/** The Meraki software Id. */
		id?: string | null;

		/** Software bundle identifier. */
		identifier?: string | null;

		/** When the Software was installed on the device. */
		installedAt?: string | null;

		/** A boolean indicating whether or not an iOS redemption code was used. */
		iosRedemptionCode?: boolean | null;

		/** A boolean indicating whether or not the software is managed by Meraki. */
		isManaged?: boolean | null;

		/** The itunes numerical identifier. */
		itunesId?: string | null;

		/** The license key associated with this software installation. */
		licenseKey?: string | null;

		/** The name of the software. */
		name?: string | null;

		/** The path on the device where the software record is located. */
		path?: string | null;

		/** The redemption code used for this software. */
		redemptionCode?: number | null;

		/** Short version notation for the software. */
		shortVersion?: string | null;

		/** The management status of the software. */
		status?: string | null;

		/** A boolean indicating this software record should be installed on the associated device. */
		toInstall?: boolean | null;

		/** A boolean indicating this software record should be uninstalled on the associated device. */
		toUninstall?: boolean | null;

		/** When the record was uninstalled from the device. */
		uninstalledAt?: string | null;

		/** When the record was last updated by Meraki. */
		updatedAt?: string | null;

		/** The vendor of the software. */
		vendor?: string | null;

		/** Full version notation for the software. */
		version?: string | null;
	}
	export interface GetNetworkSmDeviceSoftwaresReturnFormProperties {

		/** The Meraki managed application Id for this record on a particular device. */
		appId: FormControl<string | null | undefined>,

		/** The size of the software bundle. */
		bundleSize: FormControl<number | null | undefined>,

		/** When the Meraki record for the software was created. */
		createdAt: FormControl<string | null | undefined>,

		/** The Meraki managed device Id. */
		deviceId: FormControl<string | null | undefined>,

		/** The size of the data stored in the application. */
		dynamicSize: FormControl<number | null | undefined>,

		/** The Meraki software Id. */
		id: FormControl<string | null | undefined>,

		/** Software bundle identifier. */
		identifier: FormControl<string | null | undefined>,

		/** When the Software was installed on the device. */
		installedAt: FormControl<string | null | undefined>,

		/** A boolean indicating whether or not an iOS redemption code was used. */
		iosRedemptionCode: FormControl<boolean | null | undefined>,

		/** A boolean indicating whether or not the software is managed by Meraki. */
		isManaged: FormControl<boolean | null | undefined>,

		/** The itunes numerical identifier. */
		itunesId: FormControl<string | null | undefined>,

		/** The license key associated with this software installation. */
		licenseKey: FormControl<string | null | undefined>,

		/** The name of the software. */
		name: FormControl<string | null | undefined>,

		/** The path on the device where the software record is located. */
		path: FormControl<string | null | undefined>,

		/** The redemption code used for this software. */
		redemptionCode: FormControl<number | null | undefined>,

		/** Short version notation for the software. */
		shortVersion: FormControl<string | null | undefined>,

		/** The management status of the software. */
		status: FormControl<string | null | undefined>,

		/** A boolean indicating this software record should be installed on the associated device. */
		toInstall: FormControl<boolean | null | undefined>,

		/** A boolean indicating this software record should be uninstalled on the associated device. */
		toUninstall: FormControl<boolean | null | undefined>,

		/** When the record was uninstalled from the device. */
		uninstalledAt: FormControl<string | null | undefined>,

		/** When the record was last updated by Meraki. */
		updatedAt: FormControl<string | null | undefined>,

		/** The vendor of the software. */
		vendor: FormControl<string | null | undefined>,

		/** Full version notation for the software. */
		version: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmDeviceSoftwaresReturnFormGroup() {
		return new FormGroup<GetNetworkSmDeviceSoftwaresReturnFormProperties>({
			appId: new FormControl<string | null | undefined>(undefined),
			bundleSize: new FormControl<number | null | undefined>(undefined),
			createdAt: new FormControl<string | null | undefined>(undefined),
			deviceId: new FormControl<string | null | undefined>(undefined),
			dynamicSize: new FormControl<number | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			identifier: new FormControl<string | null | undefined>(undefined),
			installedAt: new FormControl<string | null | undefined>(undefined),
			iosRedemptionCode: new FormControl<boolean | null | undefined>(undefined),
			isManaged: new FormControl<boolean | null | undefined>(undefined),
			itunesId: new FormControl<string | null | undefined>(undefined),
			licenseKey: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			path: new FormControl<string | null | undefined>(undefined),
			redemptionCode: new FormControl<number | null | undefined>(undefined),
			shortVersion: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<string | null | undefined>(undefined),
			toInstall: new FormControl<boolean | null | undefined>(undefined),
			toUninstall: new FormControl<boolean | null | undefined>(undefined),
			uninstalledAt: new FormControl<string | null | undefined>(undefined),
			updatedAt: new FormControl<string | null | undefined>(undefined),
			vendor: new FormControl<string | null | undefined>(undefined),
			version: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmDeviceWlanListsReturn {

		/** When the Meraki record for the wlanList was created. */
		createdAt?: string | null;

		/** The Meraki managed Id of the wlanList record. */
		id?: string | null;

		/** An XML string containing the WLAN List for the device. */
		xml?: string | null;
	}
	export interface GetNetworkSmDeviceWlanListsReturnFormProperties {

		/** When the Meraki record for the wlanList was created. */
		createdAt: FormControl<string | null | undefined>,

		/** The Meraki managed Id of the wlanList record. */
		id: FormControl<string | null | undefined>,

		/** An XML string containing the WLAN List for the device. */
		xml: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmDeviceWlanListsReturnFormGroup() {
		return new FormGroup<GetNetworkSmDeviceWlanListsReturnFormProperties>({
			createdAt: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			xml: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmProfilesReturn {

		/** Description of a profile. */
		description?: string | null;

		/** ID of a profile. */
		id?: string | null;

		/** Name of a profile. */
		name?: string | null;

		/** Scope of a profile. */
		scope?: string | null;

		/** Tags of a profile. */
		tags?: Array<string>;
	}
	export interface GetNetworkSmProfilesReturnFormProperties {

		/** Description of a profile. */
		description: FormControl<string | null | undefined>,

		/** ID of a profile. */
		id: FormControl<string | null | undefined>,

		/** Name of a profile. */
		name: FormControl<string | null | undefined>,

		/** Scope of a profile. */
		scope: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmProfilesReturnFormGroup() {
		return new FormGroup<GetNetworkSmProfilesReturnFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			scope: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmTrustedAccessConfigsReturn {

		/** time that access ends */
		accessEndAt?: Date | null;

		/** time that access starts */
		accessStartAt?: Date | null;

		/** device ID */
		id?: string | null;

		/** device name */
		name?: string | null;

		/** scope */
		scope?: string | null;

		/** SSID name */
		ssidName?: string | null;

		/** device tags */
		tags?: Array<string>;

		/** type of access period, either a static range or a dynamic period */
		timeboundType?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;
	}
	export interface GetNetworkSmTrustedAccessConfigsReturnFormProperties {

		/** time that access ends */
		accessEndAt: FormControl<Date | null | undefined>,

		/** time that access starts */
		accessStartAt: FormControl<Date | null | undefined>,

		/** device ID */
		id: FormControl<string | null | undefined>,

		/** device name */
		name: FormControl<string | null | undefined>,

		/** scope */
		scope: FormControl<string | null | undefined>,

		/** SSID name */
		ssidName: FormControl<string | null | undefined>,

		/** type of access period, either a static range or a dynamic period */
		timeboundType: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,
	}
	export function CreateGetNetworkSmTrustedAccessConfigsReturnFormGroup() {
		return new FormGroup<GetNetworkSmTrustedAccessConfigsReturnFormProperties>({
			accessEndAt: new FormControl<Date | null | undefined>(undefined),
			accessStartAt: new FormControl<Date | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			scope: new FormControl<string | null | undefined>(undefined),
			ssidName: new FormControl<string | null | undefined>(undefined),
			timeboundType: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmUserAccessDevicesReturn {

		/** user email */
		email?: string | null;

		/** device ID */
		id?: string | null;

		/** mac address */
		mac?: string | null;

		/** device name */
		name?: string | null;

		/** system type */
		systemType?: string | null;

		/** device tags */
		tags?: Array<string>;

		/** Array of trusted access configs */
		GetNetworkSmUserAccessDevicesReturnTrustedAccessConnections?: Array<GetNetworkSmUserAccessDevicesReturnTrustedAccessConnections>;

		/** username */
		username?: string | null;
	}
	export interface GetNetworkSmUserAccessDevicesReturnFormProperties {

		/** user email */
		email: FormControl<string | null | undefined>,

		/** device ID */
		id: FormControl<string | null | undefined>,

		/** mac address */
		mac: FormControl<string | null | undefined>,

		/** device name */
		name: FormControl<string | null | undefined>,

		/** system type */
		systemType: FormControl<string | null | undefined>,

		/** username */
		username: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmUserAccessDevicesReturnFormGroup() {
		return new FormGroup<GetNetworkSmUserAccessDevicesReturnFormProperties>({
			email: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			mac: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			systemType: new FormControl<string | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmUserAccessDevicesReturnTrustedAccessConnections {

		/** time that config was downloaded */
		downloadedAt?: string | null;

		/** time of last connection */
		lastConnectedAt?: Date | null;

		/** time that SCEP completed */
		scepCompletedAt?: Date | null;

		/** config id */
		trustedAccessConfigId?: string | null;
	}
	export interface GetNetworkSmUserAccessDevicesReturnTrustedAccessConnectionsFormProperties {

		/** time that config was downloaded */
		downloadedAt: FormControl<string | null | undefined>,

		/** time of last connection */
		lastConnectedAt: FormControl<Date | null | undefined>,

		/** time that SCEP completed */
		scepCompletedAt: FormControl<Date | null | undefined>,

		/** config id */
		trustedAccessConfigId: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmUserAccessDevicesReturnTrustedAccessConnectionsFormGroup() {
		return new FormGroup<GetNetworkSmUserAccessDevicesReturnTrustedAccessConnectionsFormProperties>({
			downloadedAt: new FormControl<string | null | undefined>(undefined),
			lastConnectedAt: new FormControl<Date | null | undefined>(undefined),
			scepCompletedAt: new FormControl<Date | null | undefined>(undefined),
			trustedAccessConfigId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmUsersReturn {

		/** Active Directory Groups the user belongs to. */
		adGroups?: Array<string>;

		/** Apple School Manager Groups the user belongs to. */
		asmGroups?: Array<string>;

		/** Azure Active Directory Groups the user belongs to. */
		azureAdGroups?: Array<string>;

		/** The user display name. */
		displayName?: string | null;

		/** User email. */
		email?: string | null;

		/** User full name. */
		fullName?: string | null;

		/** A boolean indicating if the user has an associated identity certificate.. */
		hasIdentityCertificate?: boolean | null;

		/** A boolean denoting if the user has a password associated with the record. */
		hasPassword?: boolean | null;

		/** The Meraki managed Id of the user record. */
		id?: string | null;

		/** Whether the user was created using an external integration, or via the Meraki Dashboard. */
		isExternal?: boolean | null;

		/** SAML Groups the user belongs to. */
		samlGroups?: Array<string>;

		/** The set of tags the user is scoped to. */
		tags?: string | null;

		/** The url where the users thumbnail is hosted. */
		userThumbnail?: string | null;

		/** The users username. */
		username?: string | null;
	}
	export interface GetNetworkSmUsersReturnFormProperties {

		/** The user display name. */
		displayName: FormControl<string | null | undefined>,

		/** User email. */
		email: FormControl<string | null | undefined>,

		/** User full name. */
		fullName: FormControl<string | null | undefined>,

		/** A boolean indicating if the user has an associated identity certificate.. */
		hasIdentityCertificate: FormControl<boolean | null | undefined>,

		/** A boolean denoting if the user has a password associated with the record. */
		hasPassword: FormControl<boolean | null | undefined>,

		/** The Meraki managed Id of the user record. */
		id: FormControl<string | null | undefined>,

		/** Whether the user was created using an external integration, or via the Meraki Dashboard. */
		isExternal: FormControl<boolean | null | undefined>,

		/** The set of tags the user is scoped to. */
		tags: FormControl<string | null | undefined>,

		/** The url where the users thumbnail is hosted. */
		userThumbnail: FormControl<string | null | undefined>,

		/** The users username. */
		username: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmUsersReturnFormGroup() {
		return new FormGroup<GetNetworkSmUsersReturnFormProperties>({
			displayName: new FormControl<string | null | undefined>(undefined),
			email: new FormControl<string | null | undefined>(undefined),
			fullName: new FormControl<string | null | undefined>(undefined),
			hasIdentityCertificate: new FormControl<boolean | null | undefined>(undefined),
			hasPassword: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isExternal: new FormControl<boolean | null | undefined>(undefined),
			tags: new FormControl<string | null | undefined>(undefined),
			userThumbnail: new FormControl<string | null | undefined>(undefined),
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmUserDeviceProfilesReturn {

		/** The Meraki managed device Id. */
		deviceId?: string | null;

		/** The numerical Meraki Id of the profile. */
		id?: string | null;

		/** A boolean indicating if the profile is encrypted. */
		isEncrypted?: boolean | null;

		/** Whether or not the profile is managed by Meraki. */
		isManaged?: boolean | null;

		/** The name of the profile. */
		name?: string | null;

		/** A string containing a JSON object with the profile data. */
		profileData?: string | null;

		/** The identifier of the profile. */
		profileIdentifier?: string | null;

		/** The verison of the profile. */
		version?: string | null;
	}
	export interface GetNetworkSmUserDeviceProfilesReturnFormProperties {

		/** The Meraki managed device Id. */
		deviceId: FormControl<string | null | undefined>,

		/** The numerical Meraki Id of the profile. */
		id: FormControl<string | null | undefined>,

		/** A boolean indicating if the profile is encrypted. */
		isEncrypted: FormControl<boolean | null | undefined>,

		/** Whether or not the profile is managed by Meraki. */
		isManaged: FormControl<boolean | null | undefined>,

		/** The name of the profile. */
		name: FormControl<string | null | undefined>,

		/** A string containing a JSON object with the profile data. */
		profileData: FormControl<string | null | undefined>,

		/** The identifier of the profile. */
		profileIdentifier: FormControl<string | null | undefined>,

		/** The verison of the profile. */
		version: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmUserDeviceProfilesReturnFormGroup() {
		return new FormGroup<GetNetworkSmUserDeviceProfilesReturnFormProperties>({
			deviceId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isEncrypted: new FormControl<boolean | null | undefined>(undefined),
			isManaged: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			profileData: new FormControl<string | null | undefined>(undefined),
			profileIdentifier: new FormControl<string | null | undefined>(undefined),
			version: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSmUserSoftwaresReturn {

		/** The Meraki managed application Id for this record on a particular device. */
		appId?: string | null;

		/** The size of the software bundle. */
		bundleSize?: number | null;

		/** When the Meraki record for the software was created. */
		createdAt?: string | null;

		/** The Meraki managed device Id. */
		deviceId?: string | null;

		/** The size of the data stored in the application. */
		dynamicSize?: number | null;

		/** The Meraki software Id. */
		id?: string | null;

		/** Software bundle identifier. */
		identifier?: string | null;

		/** When the Software was installed on the device. */
		installedAt?: string | null;

		/** A boolean indicating whether or not an iOS redemption code was used. */
		iosRedemptionCode?: boolean | null;

		/** A boolean indicating whether or not the software is managed by Meraki. */
		isManaged?: boolean | null;

		/** The itunes numerical identifier. */
		itunesId?: string | null;

		/** The license key associated with this software installation. */
		licenseKey?: string | null;

		/** The name of the software. */
		name?: string | null;

		/** The path on the device where the software record is located. */
		path?: string | null;

		/** The redemption code used for this software. */
		redemptionCode?: number | null;

		/** Short version notation for the software. */
		shortVersion?: string | null;

		/** The management status of the software. */
		status?: string | null;

		/** A boolean indicating this software record should be installed on the associated device. */
		toInstall?: boolean | null;

		/** A boolean indicating this software record should be uninstalled on the associated device. */
		toUninstall?: boolean | null;

		/** When the record was uninstalled from the device. */
		uninstalledAt?: string | null;

		/** When the record was last updated by Meraki. */
		updatedAt?: string | null;

		/** The vendor of the software. */
		vendor?: string | null;

		/** Full version notation for the software. */
		version?: string | null;
	}
	export interface GetNetworkSmUserSoftwaresReturnFormProperties {

		/** The Meraki managed application Id for this record on a particular device. */
		appId: FormControl<string | null | undefined>,

		/** The size of the software bundle. */
		bundleSize: FormControl<number | null | undefined>,

		/** When the Meraki record for the software was created. */
		createdAt: FormControl<string | null | undefined>,

		/** The Meraki managed device Id. */
		deviceId: FormControl<string | null | undefined>,

		/** The size of the data stored in the application. */
		dynamicSize: FormControl<number | null | undefined>,

		/** The Meraki software Id. */
		id: FormControl<string | null | undefined>,

		/** Software bundle identifier. */
		identifier: FormControl<string | null | undefined>,

		/** When the Software was installed on the device. */
		installedAt: FormControl<string | null | undefined>,

		/** A boolean indicating whether or not an iOS redemption code was used. */
		iosRedemptionCode: FormControl<boolean | null | undefined>,

		/** A boolean indicating whether or not the software is managed by Meraki. */
		isManaged: FormControl<boolean | null | undefined>,

		/** The itunes numerical identifier. */
		itunesId: FormControl<string | null | undefined>,

		/** The license key associated with this software installation. */
		licenseKey: FormControl<string | null | undefined>,

		/** The name of the software. */
		name: FormControl<string | null | undefined>,

		/** The path on the device where the software record is located. */
		path: FormControl<string | null | undefined>,

		/** The redemption code used for this software. */
		redemptionCode: FormControl<number | null | undefined>,

		/** Short version notation for the software. */
		shortVersion: FormControl<string | null | undefined>,

		/** The management status of the software. */
		status: FormControl<string | null | undefined>,

		/** A boolean indicating this software record should be installed on the associated device. */
		toInstall: FormControl<boolean | null | undefined>,

		/** A boolean indicating this software record should be uninstalled on the associated device. */
		toUninstall: FormControl<boolean | null | undefined>,

		/** When the record was uninstalled from the device. */
		uninstalledAt: FormControl<string | null | undefined>,

		/** When the record was last updated by Meraki. */
		updatedAt: FormControl<string | null | undefined>,

		/** The vendor of the software. */
		vendor: FormControl<string | null | undefined>,

		/** Full version notation for the software. */
		version: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSmUserSoftwaresReturnFormGroup() {
		return new FormGroup<GetNetworkSmUserSoftwaresReturnFormProperties>({
			appId: new FormControl<string | null | undefined>(undefined),
			bundleSize: new FormControl<number | null | undefined>(undefined),
			createdAt: new FormControl<string | null | undefined>(undefined),
			deviceId: new FormControl<string | null | undefined>(undefined),
			dynamicSize: new FormControl<number | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			identifier: new FormControl<string | null | undefined>(undefined),
			installedAt: new FormControl<string | null | undefined>(undefined),
			iosRedemptionCode: new FormControl<boolean | null | undefined>(undefined),
			isManaged: new FormControl<boolean | null | undefined>(undefined),
			itunesId: new FormControl<string | null | undefined>(undefined),
			licenseKey: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			path: new FormControl<string | null | undefined>(undefined),
			redemptionCode: new FormControl<number | null | undefined>(undefined),
			shortVersion: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<string | null | undefined>(undefined),
			toInstall: new FormControl<boolean | null | undefined>(undefined),
			toUninstall: new FormControl<boolean | null | undefined>(undefined),
			uninstalledAt: new FormControl<string | null | undefined>(undefined),
			updatedAt: new FormControl<string | null | undefined>(undefined),
			vendor: new FormControl<string | null | undefined>(undefined),
			version: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSnmpPutBody {

		/** The type of SNMP access. Can be one of 'none' (disabled), 'community' (V1/V2c), or 'users' (V3). */
		access?: UpdateNetworkSnmpPutBodyAccess | null;

		/** The SNMP community string. Only relevant if 'access' is set to 'community'. */
		communityString?: string | null;

		/** The list of SNMP users. Only relevant if 'access' is set to 'users'. */
		UpdateNetworkSnmpPutBodyUsers?: Array<UpdateNetworkSnmpPutBodyUsers>;
	}
	export interface UpdateNetworkSnmpPutBodyFormProperties {

		/** The type of SNMP access. Can be one of 'none' (disabled), 'community' (V1/V2c), or 'users' (V3). */
		access: FormControl<UpdateNetworkSnmpPutBodyAccess | null | undefined>,

		/** The SNMP community string. Only relevant if 'access' is set to 'community'. */
		communityString: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSnmpPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSnmpPutBodyFormProperties>({
			access: new FormControl<UpdateNetworkSnmpPutBodyAccess | null | undefined>(undefined),
			communityString: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkSnmpPutBodyAccess { community = 'community', none = 'none', users = 'users' }

	export interface UpdateNetworkSnmpPutBodyUsers {

		/**
		 * The passphrase for the SNMP user. Required.
		 * Required
		 */
		passphrase: string;

		/**
		 * The username for the SNMP user. Required.
		 * Required
		 */
		username: string;
	}
	export interface UpdateNetworkSnmpPutBodyUsersFormProperties {

		/**
		 * The passphrase for the SNMP user. Required.
		 * Required
		 */
		passphrase: FormControl<string | null | undefined>,

		/**
		 * The username for the SNMP user. Required.
		 * Required
		 */
		username: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSnmpPutBodyUsersFormGroup() {
		return new FormGroup<UpdateNetworkSnmpPutBodyUsersFormProperties>({
			passphrase: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			username: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum GetNetworkSplashLoginAttemptsSsidNumber { _0 = 0, _1 = 1, _2 = 2, _3 = 3, _4 = 4, _5 = 5, _6 = 6, _7 = 7, _8 = 8, _9 = 9, _10 = 10, _11 = 11, _12 = 12, _13 = 13, _14 = 14 }

	export interface SplitNetworkReturn {

		/** Networks after the split */
		SplitNetworkReturnResultingNetworks?: Array<SplitNetworkReturnResultingNetworks>;
	}
	export interface SplitNetworkReturnFormProperties {
	}
	export function CreateSplitNetworkReturnFormGroup() {
		return new FormGroup<SplitNetworkReturnFormProperties>({
		});

	}

	export interface SplitNetworkReturnResultingNetworks {

		/** Enrollment string for the network */
		enrollmentString?: string | null;

		/** Network ID */
		id?: string | null;

		/** If the network is bound to a config template */
		isBoundToConfigTemplate?: boolean | null;

		/** Network name */
		name?: string | null;

		/** Notes for the network */
		notes?: string | null;

		/** Organization ID */
		organizationId?: string | null;

		/** List of the product types that the network supports */
		productTypes?: Array<string>;

		/** Network tags */
		tags?: Array<string>;

		/** Timezone of the network */
		timeZone?: string | null;

		/** URL to the network Dashboard UI */
		url?: string | null;
	}
	export interface SplitNetworkReturnResultingNetworksFormProperties {

		/** Enrollment string for the network */
		enrollmentString: FormControl<string | null | undefined>,

		/** Network ID */
		id: FormControl<string | null | undefined>,

		/** If the network is bound to a config template */
		isBoundToConfigTemplate: FormControl<boolean | null | undefined>,

		/** Network name */
		name: FormControl<string | null | undefined>,

		/** Notes for the network */
		notes: FormControl<string | null | undefined>,

		/** Organization ID */
		organizationId: FormControl<string | null | undefined>,

		/** Timezone of the network */
		timeZone: FormControl<string | null | undefined>,

		/** URL to the network Dashboard UI */
		url: FormControl<string | null | undefined>,
	}
	export function CreateSplitNetworkReturnResultingNetworksFormGroup() {
		return new FormGroup<SplitNetworkReturnResultingNetworksFormProperties>({
			enrollmentString: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isBoundToConfigTemplate: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
			organizationId: new FormControl<string | null | undefined>(undefined),
			timeZone: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchAccessControlListsReturn {

		/** An ordered array of the access control list rules */
		GetNetworkSwitchAccessControlListsReturnRules?: Array<GetNetworkSwitchAccessControlListsReturnRules>;
	}
	export interface GetNetworkSwitchAccessControlListsReturnFormProperties {
	}
	export function CreateGetNetworkSwitchAccessControlListsReturnFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessControlListsReturnFormProperties>({
		});

	}

	export interface GetNetworkSwitchAccessControlListsReturnRules {

		/** Description of the rule (optional) */
		comment?: string | null;

		/** Destination IP address (in IP or CIDR notation) */
		dstCidr?: string | null;

		/** Destination port */
		dstPort?: string | null;

		/** IP address version */
		ipVersion?: GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null;

		/** 'allow' or 'deny' traffic specified by this rule */
		policy?: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null;

		/** The type of protocol */
		protocol?: GetNetworkSwitchAccessControlListsReturnRulesProtocol | null;

		/** Source IP address (in IP or CIDR notation) */
		srcCidr?: string | null;

		/** Source port */
		srcPort?: string | null;

		/** ncoming traffic VLAN */
		vlan?: string | null;
	}
	export interface GetNetworkSwitchAccessControlListsReturnRulesFormProperties {

		/** Description of the rule (optional) */
		comment: FormControl<string | null | undefined>,

		/** Destination IP address (in IP or CIDR notation) */
		dstCidr: FormControl<string | null | undefined>,

		/** Destination port */
		dstPort: FormControl<string | null | undefined>,

		/** IP address version */
		ipVersion: FormControl<GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null | undefined>,

		/** 'allow' or 'deny' traffic specified by this rule */
		policy: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>,

		/** The type of protocol */
		protocol: FormControl<GetNetworkSwitchAccessControlListsReturnRulesProtocol | null | undefined>,

		/** Source IP address (in IP or CIDR notation) */
		srcCidr: FormControl<string | null | undefined>,

		/** Source port */
		srcPort: FormControl<string | null | undefined>,

		/** ncoming traffic VLAN */
		vlan: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessControlListsReturnRulesFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessControlListsReturnRulesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			dstCidr: new FormControl<string | null | undefined>(undefined),
			dstPort: new FormControl<string | null | undefined>(undefined),
			ipVersion: new FormControl<GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null | undefined>(undefined),
			policy: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>(undefined),
			protocol: new FormControl<GetNetworkSwitchAccessControlListsReturnRulesProtocol | null | undefined>(undefined),
			srcCidr: new FormControl<string | null | undefined>(undefined),
			srcPort: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetNetworkSwitchAccessControlListsReturnRulesIpVersion { any = 'any', ipv4 = 'ipv4', ipv6 = 'ipv6' }

	export enum GetNetworkSwitchAccessControlListsReturnRulesProtocol { any = 'any', tcp = 'tcp', udp = 'udp' }

	export interface UpdateNetworkSwitchAccessControlListsPutBody {

		/**
		 * An ordered array of the access control list rules (not including the default rule). An empty array will clear the rules.
		 * Required
		 */
		UpdateNetworkSwitchAccessControlListsPutBodyRules: Array<UpdateNetworkSwitchAccessControlListsPutBodyRules>;
	}
	export interface UpdateNetworkSwitchAccessControlListsPutBodyFormProperties {
	}
	export function CreateUpdateNetworkSwitchAccessControlListsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessControlListsPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkSwitchAccessControlListsPutBodyRules {

		/** Description of the rule (optional). */
		comment?: string | null;

		/**
		 * Destination IP address (in IP or CIDR notation) or 'any'.
		 * Required
		 */
		dstCidr: string;

		/** Destination port. Must be in the range of 1-65535 or 'any'. Default is 'any'. */
		dstPort?: string | null;

		/** IP address version (must be 'any', 'ipv4' or 'ipv6'). Applicable only if network supports IPv6. Default value is 'ipv4'. */
		ipVersion?: GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null;

		/**
		 * 'allow' or 'deny' traffic specified by this rule.
		 * Required
		 */
		policy: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy;

		/**
		 * The type of protocol (must be 'tcp', 'udp', or 'any').
		 * Required
		 */
		protocol: GetNetworkSwitchAccessControlListsReturnRulesProtocol;

		/**
		 * Source IP address (in IP or CIDR notation) or 'any'.
		 * Required
		 */
		srcCidr: string;

		/** Source port. Must be in the range  of 1-65535 or 'any'. Default is 'any'. */
		srcPort?: string | null;

		/** Incoming traffic VLAN. Must be in the range of 1-4095 or 'any'. Default is 'any'. */
		vlan?: string | null;
	}
	export interface UpdateNetworkSwitchAccessControlListsPutBodyRulesFormProperties {

		/** Description of the rule (optional). */
		comment: FormControl<string | null | undefined>,

		/**
		 * Destination IP address (in IP or CIDR notation) or 'any'.
		 * Required
		 */
		dstCidr: FormControl<string | null | undefined>,

		/** Destination port. Must be in the range of 1-65535 or 'any'. Default is 'any'. */
		dstPort: FormControl<string | null | undefined>,

		/** IP address version (must be 'any', 'ipv4' or 'ipv6'). Applicable only if network supports IPv6. Default value is 'ipv4'. */
		ipVersion: FormControl<GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null | undefined>,

		/**
		 * 'allow' or 'deny' traffic specified by this rule.
		 * Required
		 */
		policy: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>,

		/**
		 * The type of protocol (must be 'tcp', 'udp', or 'any').
		 * Required
		 */
		protocol: FormControl<GetNetworkSwitchAccessControlListsReturnRulesProtocol | null | undefined>,

		/**
		 * Source IP address (in IP or CIDR notation) or 'any'.
		 * Required
		 */
		srcCidr: FormControl<string | null | undefined>,

		/** Source port. Must be in the range  of 1-65535 or 'any'. Default is 'any'. */
		srcPort: FormControl<string | null | undefined>,

		/** Incoming traffic VLAN. Must be in the range of 1-4095 or 'any'. Default is 'any'. */
		vlan: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessControlListsPutBodyRulesFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessControlListsPutBodyRulesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			dstCidr: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			dstPort: new FormControl<string | null | undefined>(undefined),
			ipVersion: new FormControl<GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null | undefined>(undefined),
			policy: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>(undefined, [Validators.required]),
			protocol: new FormControl<GetNetworkSwitchAccessControlListsReturnRulesProtocol | null | undefined>(undefined, [Validators.required]),
			srcCidr: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			srcPort: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAccessControlListsReturn {

		/** An ordered array of the access control list rules */
		UpdateNetworkSwitchAccessControlListsReturnRules?: Array<UpdateNetworkSwitchAccessControlListsReturnRules>;
	}
	export interface UpdateNetworkSwitchAccessControlListsReturnFormProperties {
	}
	export function CreateUpdateNetworkSwitchAccessControlListsReturnFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessControlListsReturnFormProperties>({
		});

	}

	export interface UpdateNetworkSwitchAccessControlListsReturnRules {

		/** Description of the rule (optional) */
		comment?: string | null;

		/** Destination IP address (in IP or CIDR notation) */
		dstCidr?: string | null;

		/** Destination port */
		dstPort?: string | null;

		/** IP address version */
		ipVersion?: GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null;

		/** 'allow' or 'deny' traffic specified by this rule */
		policy?: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null;

		/** The type of protocol */
		protocol?: GetNetworkSwitchAccessControlListsReturnRulesProtocol | null;

		/** Source IP address (in IP or CIDR notation) */
		srcCidr?: string | null;

		/** Source port */
		srcPort?: string | null;

		/** ncoming traffic VLAN */
		vlan?: string | null;
	}
	export interface UpdateNetworkSwitchAccessControlListsReturnRulesFormProperties {

		/** Description of the rule (optional) */
		comment: FormControl<string | null | undefined>,

		/** Destination IP address (in IP or CIDR notation) */
		dstCidr: FormControl<string | null | undefined>,

		/** Destination port */
		dstPort: FormControl<string | null | undefined>,

		/** IP address version */
		ipVersion: FormControl<GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null | undefined>,

		/** 'allow' or 'deny' traffic specified by this rule */
		policy: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>,

		/** The type of protocol */
		protocol: FormControl<GetNetworkSwitchAccessControlListsReturnRulesProtocol | null | undefined>,

		/** Source IP address (in IP or CIDR notation) */
		srcCidr: FormControl<string | null | undefined>,

		/** Source port */
		srcPort: FormControl<string | null | undefined>,

		/** ncoming traffic VLAN */
		vlan: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessControlListsReturnRulesFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessControlListsReturnRulesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			dstCidr: new FormControl<string | null | undefined>(undefined),
			dstPort: new FormControl<string | null | undefined>(undefined),
			ipVersion: new FormControl<GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null | undefined>(undefined),
			policy: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>(undefined),
			protocol: new FormControl<GetNetworkSwitchAccessControlListsReturnRulesProtocol | null | undefined>(undefined),
			srcCidr: new FormControl<string | null | undefined>(undefined),
			srcPort: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchAccessPoliciesReturn {

		/** Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'. */
		accessPolicyType?: GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null;

		/** 802.1x Settings */
		dot1x?: GetNetworkSwitchAccessPoliciesReturnDot1x;

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		guestPortBouncing?: boolean | null;

		/** ID for the guest VLAN allow unauthorized devices access to limited network resources */
		guestVlanId?: number | null;

		/** Choose the Host Mode for the access policy. */
		hostMode?: GetNetworkSwitchAccessPoliciesReturnHostMode | null;

		/** Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication. */
		increaseAccessSpeed?: boolean | null;

		/** Name of the access policy */
		name?: string | null;

		/** Object for RADIUS Settings */
		radius?: GetNetworkSwitchAccessPoliciesReturnRadius;

		/** Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients */
		radiusAccountingEnabled?: boolean | null;

		/** List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access */
		GetNetworkSwitchAccessPoliciesReturnRadiusAccountingServers?: Array<GetNetworkSwitchAccessPoliciesReturnRadiusAccountingServers>;

		/** Change of authentication for RADIUS re-authentication and disconnection */
		radiusCoaSupportEnabled?: boolean | null;

		/** Acceptable values are `""` for None, or `"11"` for Group Policies ACL */
		radiusGroupAttribute?: string | null;

		/** List of RADIUS servers to require connecting devices to authenticate against before granting network access */
		GetNetworkSwitchAccessPoliciesReturnRadiusServers?: Array<GetNetworkSwitchAccessPoliciesReturnRadiusServers>;

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		radiusTestingEnabled?: boolean | null;

		/** Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenEnabled?: boolean | null;

		/** IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenRanges?: Array<string>;

		/** CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'. */
		voiceVlanClients?: boolean | null;
	}
	export interface GetNetworkSwitchAccessPoliciesReturnFormProperties {

		/** Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'. */
		accessPolicyType: FormControl<GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null | undefined>,

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		guestPortBouncing: FormControl<boolean | null | undefined>,

		/** ID for the guest VLAN allow unauthorized devices access to limited network resources */
		guestVlanId: FormControl<number | null | undefined>,

		/** Choose the Host Mode for the access policy. */
		hostMode: FormControl<GetNetworkSwitchAccessPoliciesReturnHostMode | null | undefined>,

		/** Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication. */
		increaseAccessSpeed: FormControl<boolean | null | undefined>,

		/** Name of the access policy */
		name: FormControl<string | null | undefined>,

		/** Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients */
		radiusAccountingEnabled: FormControl<boolean | null | undefined>,

		/** Change of authentication for RADIUS re-authentication and disconnection */
		radiusCoaSupportEnabled: FormControl<boolean | null | undefined>,

		/** Acceptable values are `""` for None, or `"11"` for Group Policies ACL */
		radiusGroupAttribute: FormControl<string | null | undefined>,

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		radiusTestingEnabled: FormControl<boolean | null | undefined>,

		/** Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenEnabled: FormControl<boolean | null | undefined>,

		/** CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'. */
		voiceVlanClients: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessPoliciesReturnFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessPoliciesReturnFormProperties>({
			accessPolicyType: new FormControl<GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null | undefined>(undefined),
			guestPortBouncing: new FormControl<boolean | null | undefined>(undefined),
			guestVlanId: new FormControl<number | null | undefined>(undefined),
			hostMode: new FormControl<GetNetworkSwitchAccessPoliciesReturnHostMode | null | undefined>(undefined),
			increaseAccessSpeed: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			radiusAccountingEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusCoaSupportEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusGroupAttribute: new FormControl<string | null | undefined>(undefined),
			radiusTestingEnabled: new FormControl<boolean | null | undefined>(undefined),
			urlRedirectWalledGardenEnabled: new FormControl<boolean | null | undefined>(undefined),
			voiceVlanClients: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum GetNetworkSwitchAccessPoliciesReturnAccessPolicyType { '802.1x' = '802.1x', 'Hybrid authentication' = 'Hybrid authentication', 'MAC authentication bypass' = 'MAC authentication bypass' }

	export interface GetNetworkSwitchAccessPoliciesReturnDot1x {

		/** Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both' */
		controlDirection?: GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null;
	}
	export interface GetNetworkSwitchAccessPoliciesReturnDot1xFormProperties {

		/** Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both' */
		controlDirection: FormControl<GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessPoliciesReturnDot1xFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessPoliciesReturnDot1xFormProperties>({
			controlDirection: new FormControl<GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null | undefined>(undefined),
		});

	}

	export enum GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection { both = 'both', inbound = 'inbound' }

	export enum GetNetworkSwitchAccessPoliciesReturnHostMode { 'Multi-Auth' = 'Multi-Auth', 'Multi-Domain' = 'Multi-Domain', 'Multi-Host' = 'Multi-Host', 'Single-Host' = 'Single-Host' }

	export interface GetNetworkSwitchAccessPoliciesReturnRadius {

		/** Critical auth settings for when authentication is rejected by the RADIUS server */
		criticalAuth?: GetNetworkSwitchAccessPoliciesReturnRadiusCriticalAuth;

		/** VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		failedAuthVlanId?: number | null;

		/** Re-authentication period in seconds. Will be null if hostMode is Multi-Auth */
		reAuthenticationInterval?: number | null;
	}
	export interface GetNetworkSwitchAccessPoliciesReturnRadiusFormProperties {

		/** VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		failedAuthVlanId: FormControl<number | null | undefined>,

		/** Re-authentication period in seconds. Will be null if hostMode is Multi-Auth */
		reAuthenticationInterval: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessPoliciesReturnRadiusFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessPoliciesReturnRadiusFormProperties>({
			failedAuthVlanId: new FormControl<number | null | undefined>(undefined),
			reAuthenticationInterval: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchAccessPoliciesReturnRadiusCriticalAuth {

		/** VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		dataVlanId?: number | null;

		/** Enable to suspend port bounce when RADIUS servers are unreachable */
		suspendPortBounce?: boolean | null;

		/** VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		voiceVlanId?: number | null;
	}
	export interface GetNetworkSwitchAccessPoliciesReturnRadiusCriticalAuthFormProperties {

		/** VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		dataVlanId: FormControl<number | null | undefined>,

		/** Enable to suspend port bounce when RADIUS servers are unreachable */
		suspendPortBounce: FormControl<boolean | null | undefined>,

		/** VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		voiceVlanId: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessPoliciesReturnRadiusCriticalAuthFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessPoliciesReturnRadiusCriticalAuthFormProperties>({
			dataVlanId: new FormControl<number | null | undefined>(undefined),
			suspendPortBounce: new FormControl<boolean | null | undefined>(undefined),
			voiceVlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchAccessPoliciesReturnRadiusAccountingServers {

		/** Public IP address of the RADIUS accounting server */
		host?: string | null;

		/** UDP port that the RADIUS Accounting server listens on for access requests */
		port?: number | null;
	}
	export interface GetNetworkSwitchAccessPoliciesReturnRadiusAccountingServersFormProperties {

		/** Public IP address of the RADIUS accounting server */
		host: FormControl<string | null | undefined>,

		/** UDP port that the RADIUS Accounting server listens on for access requests */
		port: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessPoliciesReturnRadiusAccountingServersFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessPoliciesReturnRadiusAccountingServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchAccessPoliciesReturnRadiusServers {

		/** Public IP address of the RADIUS server */
		host?: string | null;

		/** UDP port that the RADIUS server listens on for access requests */
		port?: number | null;
	}
	export interface GetNetworkSwitchAccessPoliciesReturnRadiusServersFormProperties {

		/** Public IP address of the RADIUS server */
		host: FormControl<string | null | undefined>,

		/** UDP port that the RADIUS server listens on for access requests */
		port: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessPoliciesReturnRadiusServersFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessPoliciesReturnRadiusServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchAccessPolicyPostBody {

		/** Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'. */
		accessPolicyType?: GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null;

		/** 802.1x Settings */
		dot1x?: CreateNetworkSwitchAccessPolicyPostBodyDot1x;

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		guestPortBouncing?: boolean | null;

		/** ID for the guest VLAN allow unauthorized devices access to limited network resources */
		guestVlanId?: number | null;

		/**
		 * Choose the Host Mode for the access policy.
		 * Required
		 */
		hostMode: GetNetworkSwitchAccessPoliciesReturnHostMode;

		/** Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication. */
		increaseAccessSpeed?: boolean | null;

		/**
		 * Name of the access policy
		 * Required
		 */
		name: string;

		/** Object for RADIUS Settings */
		radius?: CreateNetworkSwitchAccessPolicyPostBodyRadius;

		/**
		 * Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
		 * Required
		 */
		radiusAccountingEnabled: boolean;

		/** List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access */
		CreateNetworkSwitchAccessPolicyPostBodyRadiusAccountingServers?: Array<CreateNetworkSwitchAccessPolicyPostBodyRadiusAccountingServers>;

		/**
		 * Change of authentication for RADIUS re-authentication and disconnection
		 * Required
		 */
		radiusCoaSupportEnabled: boolean;

		/** Acceptable values are `""` for None, or `"11"` for Group Policies ACL */
		radiusGroupAttribute?: string | null;

		/**
		 * List of RADIUS servers to require connecting devices to authenticate against before granting network access
		 * Required
		 */
		CreateNetworkSwitchAccessPolicyPostBodyRadiusServers: Array<CreateNetworkSwitchAccessPolicyPostBodyRadiusServers>;

		/**
		 * If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
		 * Required
		 */
		radiusTestingEnabled: boolean;

		/**
		 * Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
		 * Required
		 */
		urlRedirectWalledGardenEnabled: boolean;

		/** IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenRanges?: Array<string>;

		/** CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'. */
		voiceVlanClients?: boolean | null;
	}
	export interface CreateNetworkSwitchAccessPolicyPostBodyFormProperties {

		/** Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'. */
		accessPolicyType: FormControl<GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null | undefined>,

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		guestPortBouncing: FormControl<boolean | null | undefined>,

		/** ID for the guest VLAN allow unauthorized devices access to limited network resources */
		guestVlanId: FormControl<number | null | undefined>,

		/**
		 * Choose the Host Mode for the access policy.
		 * Required
		 */
		hostMode: FormControl<GetNetworkSwitchAccessPoliciesReturnHostMode | null | undefined>,

		/** Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication. */
		increaseAccessSpeed: FormControl<boolean | null | undefined>,

		/**
		 * Name of the access policy
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/**
		 * Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
		 * Required
		 */
		radiusAccountingEnabled: FormControl<boolean | null | undefined>,

		/**
		 * Change of authentication for RADIUS re-authentication and disconnection
		 * Required
		 */
		radiusCoaSupportEnabled: FormControl<boolean | null | undefined>,

		/** Acceptable values are `""` for None, or `"11"` for Group Policies ACL */
		radiusGroupAttribute: FormControl<string | null | undefined>,

		/**
		 * If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
		 * Required
		 */
		radiusTestingEnabled: FormControl<boolean | null | undefined>,

		/**
		 * Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
		 * Required
		 */
		urlRedirectWalledGardenEnabled: FormControl<boolean | null | undefined>,

		/** CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'. */
		voiceVlanClients: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateNetworkSwitchAccessPolicyPostBodyFormGroup() {
		return new FormGroup<CreateNetworkSwitchAccessPolicyPostBodyFormProperties>({
			accessPolicyType: new FormControl<GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null | undefined>(undefined),
			guestPortBouncing: new FormControl<boolean | null | undefined>(undefined),
			guestVlanId: new FormControl<number | null | undefined>(undefined),
			hostMode: new FormControl<GetNetworkSwitchAccessPoliciesReturnHostMode | null | undefined>(undefined, [Validators.required]),
			increaseAccessSpeed: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			radiusAccountingEnabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
			radiusCoaSupportEnabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
			radiusGroupAttribute: new FormControl<string | null | undefined>(undefined),
			radiusTestingEnabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
			urlRedirectWalledGardenEnabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
			voiceVlanClients: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchAccessPolicyPostBodyDot1x {

		/** Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both' */
		controlDirection?: GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null;
	}
	export interface CreateNetworkSwitchAccessPolicyPostBodyDot1xFormProperties {

		/** Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both' */
		controlDirection: FormControl<GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null | undefined>,
	}
	export function CreateCreateNetworkSwitchAccessPolicyPostBodyDot1xFormGroup() {
		return new FormGroup<CreateNetworkSwitchAccessPolicyPostBodyDot1xFormProperties>({
			controlDirection: new FormControl<GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchAccessPolicyPostBodyRadius {

		/** Critical auth settings for when authentication is rejected by the RADIUS server */
		criticalAuth?: CreateNetworkSwitchAccessPolicyPostBodyRadiusCriticalAuth;

		/** VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		failedAuthVlanId?: number | null;

		/** Re-authentication period in seconds. Will be null if hostMode is Multi-Auth */
		reAuthenticationInterval?: number | null;
	}
	export interface CreateNetworkSwitchAccessPolicyPostBodyRadiusFormProperties {

		/** VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		failedAuthVlanId: FormControl<number | null | undefined>,

		/** Re-authentication period in seconds. Will be null if hostMode is Multi-Auth */
		reAuthenticationInterval: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkSwitchAccessPolicyPostBodyRadiusFormGroup() {
		return new FormGroup<CreateNetworkSwitchAccessPolicyPostBodyRadiusFormProperties>({
			failedAuthVlanId: new FormControl<number | null | undefined>(undefined),
			reAuthenticationInterval: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchAccessPolicyPostBodyRadiusCriticalAuth {

		/** VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		dataVlanId?: number | null;

		/** Enable to suspend port bounce when RADIUS servers are unreachable */
		suspendPortBounce?: boolean | null;

		/** VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		voiceVlanId?: number | null;
	}
	export interface CreateNetworkSwitchAccessPolicyPostBodyRadiusCriticalAuthFormProperties {

		/** VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		dataVlanId: FormControl<number | null | undefined>,

		/** Enable to suspend port bounce when RADIUS servers are unreachable */
		suspendPortBounce: FormControl<boolean | null | undefined>,

		/** VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		voiceVlanId: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkSwitchAccessPolicyPostBodyRadiusCriticalAuthFormGroup() {
		return new FormGroup<CreateNetworkSwitchAccessPolicyPostBodyRadiusCriticalAuthFormProperties>({
			dataVlanId: new FormControl<number | null | undefined>(undefined),
			suspendPortBounce: new FormControl<boolean | null | undefined>(undefined),
			voiceVlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchAccessPolicyPostBodyRadiusAccountingServers {

		/**
		 * Public IP address of the RADIUS accounting server
		 * Required
		 */
		host: string;

		/**
		 * UDP port that the RADIUS Accounting server listens on for access requests
		 * Required
		 */
		port: number;

		/**
		 * RADIUS client shared secret
		 * Required
		 */
		secret: string;
	}
	export interface CreateNetworkSwitchAccessPolicyPostBodyRadiusAccountingServersFormProperties {

		/**
		 * Public IP address of the RADIUS accounting server
		 * Required
		 */
		host: FormControl<string | null | undefined>,

		/**
		 * UDP port that the RADIUS Accounting server listens on for access requests
		 * Required
		 */
		port: FormControl<number | null | undefined>,

		/**
		 * RADIUS client shared secret
		 * Required
		 */
		secret: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchAccessPolicyPostBodyRadiusAccountingServersFormGroup() {
		return new FormGroup<CreateNetworkSwitchAccessPolicyPostBodyRadiusAccountingServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			port: new FormControl<number | null | undefined>(undefined, [Validators.required]),
			secret: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSwitchAccessPolicyPostBodyRadiusServers {

		/**
		 * Public IP address of the RADIUS server
		 * Required
		 */
		host: string;

		/**
		 * UDP port that the RADIUS server listens on for access requests
		 * Required
		 */
		port: number;

		/**
		 * RADIUS client shared secret
		 * Required
		 */
		secret: string;
	}
	export interface CreateNetworkSwitchAccessPolicyPostBodyRadiusServersFormProperties {

		/**
		 * Public IP address of the RADIUS server
		 * Required
		 */
		host: FormControl<string | null | undefined>,

		/**
		 * UDP port that the RADIUS server listens on for access requests
		 * Required
		 */
		port: FormControl<number | null | undefined>,

		/**
		 * RADIUS client shared secret
		 * Required
		 */
		secret: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchAccessPolicyPostBodyRadiusServersFormGroup() {
		return new FormGroup<CreateNetworkSwitchAccessPolicyPostBodyRadiusServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			port: new FormControl<number | null | undefined>(undefined, [Validators.required]),
			secret: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkSwitchAccessPolicyReturn {

		/** Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'. */
		accessPolicyType?: GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null;

		/** 802.1x Settings */
		dot1x?: GetNetworkSwitchAccessPolicyReturnDot1x;

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		guestPortBouncing?: boolean | null;

		/** ID for the guest VLAN allow unauthorized devices access to limited network resources */
		guestVlanId?: number | null;

		/** Choose the Host Mode for the access policy. */
		hostMode?: GetNetworkSwitchAccessPoliciesReturnHostMode | null;

		/** Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication. */
		increaseAccessSpeed?: boolean | null;

		/** Name of the access policy */
		name?: string | null;

		/** Object for RADIUS Settings */
		radius?: GetNetworkSwitchAccessPolicyReturnRadius;

		/** Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients */
		radiusAccountingEnabled?: boolean | null;

		/** List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access */
		GetNetworkSwitchAccessPolicyReturnRadiusAccountingServers?: Array<GetNetworkSwitchAccessPolicyReturnRadiusAccountingServers>;

		/** Change of authentication for RADIUS re-authentication and disconnection */
		radiusCoaSupportEnabled?: boolean | null;

		/** Acceptable values are `""` for None, or `"11"` for Group Policies ACL */
		radiusGroupAttribute?: string | null;

		/** List of RADIUS servers to require connecting devices to authenticate against before granting network access */
		GetNetworkSwitchAccessPolicyReturnRadiusServers?: Array<GetNetworkSwitchAccessPolicyReturnRadiusServers>;

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		radiusTestingEnabled?: boolean | null;

		/** Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenEnabled?: boolean | null;

		/** IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenRanges?: Array<string>;

		/** CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'. */
		voiceVlanClients?: boolean | null;
	}
	export interface GetNetworkSwitchAccessPolicyReturnFormProperties {

		/** Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'. */
		accessPolicyType: FormControl<GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null | undefined>,

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		guestPortBouncing: FormControl<boolean | null | undefined>,

		/** ID for the guest VLAN allow unauthorized devices access to limited network resources */
		guestVlanId: FormControl<number | null | undefined>,

		/** Choose the Host Mode for the access policy. */
		hostMode: FormControl<GetNetworkSwitchAccessPoliciesReturnHostMode | null | undefined>,

		/** Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication. */
		increaseAccessSpeed: FormControl<boolean | null | undefined>,

		/** Name of the access policy */
		name: FormControl<string | null | undefined>,

		/** Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients */
		radiusAccountingEnabled: FormControl<boolean | null | undefined>,

		/** Change of authentication for RADIUS re-authentication and disconnection */
		radiusCoaSupportEnabled: FormControl<boolean | null | undefined>,

		/** Acceptable values are `""` for None, or `"11"` for Group Policies ACL */
		radiusGroupAttribute: FormControl<string | null | undefined>,

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		radiusTestingEnabled: FormControl<boolean | null | undefined>,

		/** Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenEnabled: FormControl<boolean | null | undefined>,

		/** CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'. */
		voiceVlanClients: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessPolicyReturnFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessPolicyReturnFormProperties>({
			accessPolicyType: new FormControl<GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null | undefined>(undefined),
			guestPortBouncing: new FormControl<boolean | null | undefined>(undefined),
			guestVlanId: new FormControl<number | null | undefined>(undefined),
			hostMode: new FormControl<GetNetworkSwitchAccessPoliciesReturnHostMode | null | undefined>(undefined),
			increaseAccessSpeed: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			radiusAccountingEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusCoaSupportEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusGroupAttribute: new FormControl<string | null | undefined>(undefined),
			radiusTestingEnabled: new FormControl<boolean | null | undefined>(undefined),
			urlRedirectWalledGardenEnabled: new FormControl<boolean | null | undefined>(undefined),
			voiceVlanClients: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchAccessPolicyReturnDot1x {

		/** Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both' */
		controlDirection?: GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null;
	}
	export interface GetNetworkSwitchAccessPolicyReturnDot1xFormProperties {

		/** Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both' */
		controlDirection: FormControl<GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessPolicyReturnDot1xFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessPolicyReturnDot1xFormProperties>({
			controlDirection: new FormControl<GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchAccessPolicyReturnRadius {

		/** Critical auth settings for when authentication is rejected by the RADIUS server */
		criticalAuth?: GetNetworkSwitchAccessPolicyReturnRadiusCriticalAuth;

		/** VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		failedAuthVlanId?: number | null;

		/** Re-authentication period in seconds. Will be null if hostMode is Multi-Auth */
		reAuthenticationInterval?: number | null;
	}
	export interface GetNetworkSwitchAccessPolicyReturnRadiusFormProperties {

		/** VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		failedAuthVlanId: FormControl<number | null | undefined>,

		/** Re-authentication period in seconds. Will be null if hostMode is Multi-Auth */
		reAuthenticationInterval: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessPolicyReturnRadiusFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessPolicyReturnRadiusFormProperties>({
			failedAuthVlanId: new FormControl<number | null | undefined>(undefined),
			reAuthenticationInterval: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchAccessPolicyReturnRadiusCriticalAuth {

		/** VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		dataVlanId?: number | null;

		/** Enable to suspend port bounce when RADIUS servers are unreachable */
		suspendPortBounce?: boolean | null;

		/** VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		voiceVlanId?: number | null;
	}
	export interface GetNetworkSwitchAccessPolicyReturnRadiusCriticalAuthFormProperties {

		/** VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		dataVlanId: FormControl<number | null | undefined>,

		/** Enable to suspend port bounce when RADIUS servers are unreachable */
		suspendPortBounce: FormControl<boolean | null | undefined>,

		/** VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		voiceVlanId: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessPolicyReturnRadiusCriticalAuthFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessPolicyReturnRadiusCriticalAuthFormProperties>({
			dataVlanId: new FormControl<number | null | undefined>(undefined),
			suspendPortBounce: new FormControl<boolean | null | undefined>(undefined),
			voiceVlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchAccessPolicyReturnRadiusAccountingServers {

		/** Public IP address of the RADIUS accounting server */
		host?: string | null;

		/** UDP port that the RADIUS Accounting server listens on for access requests */
		port?: number | null;
	}
	export interface GetNetworkSwitchAccessPolicyReturnRadiusAccountingServersFormProperties {

		/** Public IP address of the RADIUS accounting server */
		host: FormControl<string | null | undefined>,

		/** UDP port that the RADIUS Accounting server listens on for access requests */
		port: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessPolicyReturnRadiusAccountingServersFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessPolicyReturnRadiusAccountingServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchAccessPolicyReturnRadiusServers {

		/** Public IP address of the RADIUS server */
		host?: string | null;

		/** UDP port that the RADIUS server listens on for access requests */
		port?: number | null;
	}
	export interface GetNetworkSwitchAccessPolicyReturnRadiusServersFormProperties {

		/** Public IP address of the RADIUS server */
		host: FormControl<string | null | undefined>,

		/** UDP port that the RADIUS server listens on for access requests */
		port: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchAccessPolicyReturnRadiusServersFormGroup() {
		return new FormGroup<GetNetworkSwitchAccessPolicyReturnRadiusServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAccessPolicyPutBody {

		/** Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'. */
		accessPolicyType?: GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null;

		/** 802.1x Settings */
		dot1x?: UpdateNetworkSwitchAccessPolicyPutBodyDot1x;

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		guestPortBouncing?: boolean | null;

		/** ID for the guest VLAN allow unauthorized devices access to limited network resources */
		guestVlanId?: number | null;

		/** Choose the Host Mode for the access policy. */
		hostMode?: GetNetworkSwitchAccessPoliciesReturnHostMode | null;

		/** Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication. */
		increaseAccessSpeed?: boolean | null;

		/** Name of the access policy */
		name?: string | null;

		/** Object for RADIUS Settings */
		radius?: UpdateNetworkSwitchAccessPolicyPutBodyRadius;

		/** Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients */
		radiusAccountingEnabled?: boolean | null;

		/** List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access */
		UpdateNetworkSwitchAccessPolicyPutBodyRadiusAccountingServers?: Array<UpdateNetworkSwitchAccessPolicyPutBodyRadiusAccountingServers>;

		/** Change of authentication for RADIUS re-authentication and disconnection */
		radiusCoaSupportEnabled?: boolean | null;

		/** Acceptable values are `""` for None, or `"11"` for Group Policies ACL */
		radiusGroupAttribute?: string | null;

		/** List of RADIUS servers to require connecting devices to authenticate against before granting network access */
		UpdateNetworkSwitchAccessPolicyPutBodyRadiusServers?: Array<UpdateNetworkSwitchAccessPolicyPutBodyRadiusServers>;

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		radiusTestingEnabled?: boolean | null;

		/** Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenEnabled?: boolean | null;

		/** IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenRanges?: Array<string>;

		/** CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'. */
		voiceVlanClients?: boolean | null;
	}
	export interface UpdateNetworkSwitchAccessPolicyPutBodyFormProperties {

		/** Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'. */
		accessPolicyType: FormControl<GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null | undefined>,

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		guestPortBouncing: FormControl<boolean | null | undefined>,

		/** ID for the guest VLAN allow unauthorized devices access to limited network resources */
		guestVlanId: FormControl<number | null | undefined>,

		/** Choose the Host Mode for the access policy. */
		hostMode: FormControl<GetNetworkSwitchAccessPoliciesReturnHostMode | null | undefined>,

		/** Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication. */
		increaseAccessSpeed: FormControl<boolean | null | undefined>,

		/** Name of the access policy */
		name: FormControl<string | null | undefined>,

		/** Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients */
		radiusAccountingEnabled: FormControl<boolean | null | undefined>,

		/** Change of authentication for RADIUS re-authentication and disconnection */
		radiusCoaSupportEnabled: FormControl<boolean | null | undefined>,

		/** Acceptable values are `""` for None, or `"11"` for Group Policies ACL */
		radiusGroupAttribute: FormControl<string | null | undefined>,

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		radiusTestingEnabled: FormControl<boolean | null | undefined>,

		/** Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenEnabled: FormControl<boolean | null | undefined>,

		/** CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'. */
		voiceVlanClients: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessPolicyPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessPolicyPutBodyFormProperties>({
			accessPolicyType: new FormControl<GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null | undefined>(undefined),
			guestPortBouncing: new FormControl<boolean | null | undefined>(undefined),
			guestVlanId: new FormControl<number | null | undefined>(undefined),
			hostMode: new FormControl<GetNetworkSwitchAccessPoliciesReturnHostMode | null | undefined>(undefined),
			increaseAccessSpeed: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			radiusAccountingEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusCoaSupportEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusGroupAttribute: new FormControl<string | null | undefined>(undefined),
			radiusTestingEnabled: new FormControl<boolean | null | undefined>(undefined),
			urlRedirectWalledGardenEnabled: new FormControl<boolean | null | undefined>(undefined),
			voiceVlanClients: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAccessPolicyPutBodyDot1x {

		/** Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both' */
		controlDirection?: GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null;
	}
	export interface UpdateNetworkSwitchAccessPolicyPutBodyDot1xFormProperties {

		/** Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both' */
		controlDirection: FormControl<GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessPolicyPutBodyDot1xFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessPolicyPutBodyDot1xFormProperties>({
			controlDirection: new FormControl<GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAccessPolicyPutBodyRadius {

		/** Critical auth settings for when authentication is rejected by the RADIUS server */
		criticalAuth?: UpdateNetworkSwitchAccessPolicyPutBodyRadiusCriticalAuth;

		/** VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		failedAuthVlanId?: number | null;

		/** Re-authentication period in seconds. Will be null if hostMode is Multi-Auth */
		reAuthenticationInterval?: number | null;
	}
	export interface UpdateNetworkSwitchAccessPolicyPutBodyRadiusFormProperties {

		/** VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		failedAuthVlanId: FormControl<number | null | undefined>,

		/** Re-authentication period in seconds. Will be null if hostMode is Multi-Auth */
		reAuthenticationInterval: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessPolicyPutBodyRadiusFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessPolicyPutBodyRadiusFormProperties>({
			failedAuthVlanId: new FormControl<number | null | undefined>(undefined),
			reAuthenticationInterval: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAccessPolicyPutBodyRadiusCriticalAuth {

		/** VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		dataVlanId?: number | null;

		/** Enable to suspend port bounce when RADIUS servers are unreachable */
		suspendPortBounce?: boolean | null;

		/** VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		voiceVlanId?: number | null;
	}
	export interface UpdateNetworkSwitchAccessPolicyPutBodyRadiusCriticalAuthFormProperties {

		/** VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		dataVlanId: FormControl<number | null | undefined>,

		/** Enable to suspend port bounce when RADIUS servers are unreachable */
		suspendPortBounce: FormControl<boolean | null | undefined>,

		/** VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		voiceVlanId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessPolicyPutBodyRadiusCriticalAuthFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessPolicyPutBodyRadiusCriticalAuthFormProperties>({
			dataVlanId: new FormControl<number | null | undefined>(undefined),
			suspendPortBounce: new FormControl<boolean | null | undefined>(undefined),
			voiceVlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAccessPolicyPutBodyRadiusAccountingServers {

		/**
		 * Public IP address of the RADIUS accounting server
		 * Required
		 */
		host: string;

		/**
		 * UDP port that the RADIUS Accounting server listens on for access requests
		 * Required
		 */
		port: number;

		/**
		 * RADIUS client shared secret
		 * Required
		 */
		secret: string;
	}
	export interface UpdateNetworkSwitchAccessPolicyPutBodyRadiusAccountingServersFormProperties {

		/**
		 * Public IP address of the RADIUS accounting server
		 * Required
		 */
		host: FormControl<string | null | undefined>,

		/**
		 * UDP port that the RADIUS Accounting server listens on for access requests
		 * Required
		 */
		port: FormControl<number | null | undefined>,

		/**
		 * RADIUS client shared secret
		 * Required
		 */
		secret: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessPolicyPutBodyRadiusAccountingServersFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessPolicyPutBodyRadiusAccountingServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			port: new FormControl<number | null | undefined>(undefined, [Validators.required]),
			secret: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSwitchAccessPolicyPutBodyRadiusServers {

		/**
		 * Public IP address of the RADIUS server
		 * Required
		 */
		host: string;

		/**
		 * UDP port that the RADIUS server listens on for access requests
		 * Required
		 */
		port: number;

		/**
		 * RADIUS client shared secret
		 * Required
		 */
		secret: string;
	}
	export interface UpdateNetworkSwitchAccessPolicyPutBodyRadiusServersFormProperties {

		/**
		 * Public IP address of the RADIUS server
		 * Required
		 */
		host: FormControl<string | null | undefined>,

		/**
		 * UDP port that the RADIUS server listens on for access requests
		 * Required
		 */
		port: FormControl<number | null | undefined>,

		/**
		 * RADIUS client shared secret
		 * Required
		 */
		secret: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessPolicyPutBodyRadiusServersFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessPolicyPutBodyRadiusServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			port: new FormControl<number | null | undefined>(undefined, [Validators.required]),
			secret: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSwitchAccessPolicyReturn {

		/** Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'. */
		accessPolicyType?: GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null;

		/** 802.1x Settings */
		dot1x?: UpdateNetworkSwitchAccessPolicyReturnDot1x;

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		guestPortBouncing?: boolean | null;

		/** ID for the guest VLAN allow unauthorized devices access to limited network resources */
		guestVlanId?: number | null;

		/** Choose the Host Mode for the access policy. */
		hostMode?: GetNetworkSwitchAccessPoliciesReturnHostMode | null;

		/** Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication. */
		increaseAccessSpeed?: boolean | null;

		/** Name of the access policy */
		name?: string | null;

		/** Object for RADIUS Settings */
		radius?: UpdateNetworkSwitchAccessPolicyReturnRadius;

		/** Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients */
		radiusAccountingEnabled?: boolean | null;

		/** List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access */
		UpdateNetworkSwitchAccessPolicyReturnRadiusAccountingServers?: Array<UpdateNetworkSwitchAccessPolicyReturnRadiusAccountingServers>;

		/** Change of authentication for RADIUS re-authentication and disconnection */
		radiusCoaSupportEnabled?: boolean | null;

		/** Acceptable values are `""` for None, or `"11"` for Group Policies ACL */
		radiusGroupAttribute?: string | null;

		/** List of RADIUS servers to require connecting devices to authenticate against before granting network access */
		UpdateNetworkSwitchAccessPolicyReturnRadiusServers?: Array<UpdateNetworkSwitchAccessPolicyReturnRadiusServers>;

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		radiusTestingEnabled?: boolean | null;

		/** Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenEnabled?: boolean | null;

		/** IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenRanges?: Array<string>;

		/** CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'. */
		voiceVlanClients?: boolean | null;
	}
	export interface UpdateNetworkSwitchAccessPolicyReturnFormProperties {

		/** Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'. */
		accessPolicyType: FormControl<GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null | undefined>,

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		guestPortBouncing: FormControl<boolean | null | undefined>,

		/** ID for the guest VLAN allow unauthorized devices access to limited network resources */
		guestVlanId: FormControl<number | null | undefined>,

		/** Choose the Host Mode for the access policy. */
		hostMode: FormControl<GetNetworkSwitchAccessPoliciesReturnHostMode | null | undefined>,

		/** Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication. */
		increaseAccessSpeed: FormControl<boolean | null | undefined>,

		/** Name of the access policy */
		name: FormControl<string | null | undefined>,

		/** Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients */
		radiusAccountingEnabled: FormControl<boolean | null | undefined>,

		/** Change of authentication for RADIUS re-authentication and disconnection */
		radiusCoaSupportEnabled: FormControl<boolean | null | undefined>,

		/** Acceptable values are `""` for None, or `"11"` for Group Policies ACL */
		radiusGroupAttribute: FormControl<string | null | undefined>,

		/** If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers */
		radiusTestingEnabled: FormControl<boolean | null | undefined>,

		/** Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication */
		urlRedirectWalledGardenEnabled: FormControl<boolean | null | undefined>,

		/** CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'. */
		voiceVlanClients: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessPolicyReturnFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessPolicyReturnFormProperties>({
			accessPolicyType: new FormControl<GetNetworkSwitchAccessPoliciesReturnAccessPolicyType | null | undefined>(undefined),
			guestPortBouncing: new FormControl<boolean | null | undefined>(undefined),
			guestVlanId: new FormControl<number | null | undefined>(undefined),
			hostMode: new FormControl<GetNetworkSwitchAccessPoliciesReturnHostMode | null | undefined>(undefined),
			increaseAccessSpeed: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			radiusAccountingEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusCoaSupportEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusGroupAttribute: new FormControl<string | null | undefined>(undefined),
			radiusTestingEnabled: new FormControl<boolean | null | undefined>(undefined),
			urlRedirectWalledGardenEnabled: new FormControl<boolean | null | undefined>(undefined),
			voiceVlanClients: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAccessPolicyReturnDot1x {

		/** Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both' */
		controlDirection?: GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null;
	}
	export interface UpdateNetworkSwitchAccessPolicyReturnDot1xFormProperties {

		/** Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both' */
		controlDirection: FormControl<GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessPolicyReturnDot1xFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessPolicyReturnDot1xFormProperties>({
			controlDirection: new FormControl<GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAccessPolicyReturnRadius {

		/** Critical auth settings for when authentication is rejected by the RADIUS server */
		criticalAuth?: UpdateNetworkSwitchAccessPolicyReturnRadiusCriticalAuth;

		/** VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		failedAuthVlanId?: number | null;

		/** Re-authentication period in seconds. Will be null if hostMode is Multi-Auth */
		reAuthenticationInterval?: number | null;
	}
	export interface UpdateNetworkSwitchAccessPolicyReturnRadiusFormProperties {

		/** VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		failedAuthVlanId: FormControl<number | null | undefined>,

		/** Re-authentication period in seconds. Will be null if hostMode is Multi-Auth */
		reAuthenticationInterval: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessPolicyReturnRadiusFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessPolicyReturnRadiusFormProperties>({
			failedAuthVlanId: new FormControl<number | null | undefined>(undefined),
			reAuthenticationInterval: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAccessPolicyReturnRadiusCriticalAuth {

		/** VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		dataVlanId?: number | null;

		/** Enable to suspend port bounce when RADIUS servers are unreachable */
		suspendPortBounce?: boolean | null;

		/** VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		voiceVlanId?: number | null;
	}
	export interface UpdateNetworkSwitchAccessPolicyReturnRadiusCriticalAuthFormProperties {

		/** VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		dataVlanId: FormControl<number | null | undefined>,

		/** Enable to suspend port bounce when RADIUS servers are unreachable */
		suspendPortBounce: FormControl<boolean | null | undefined>,

		/** VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth */
		voiceVlanId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessPolicyReturnRadiusCriticalAuthFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessPolicyReturnRadiusCriticalAuthFormProperties>({
			dataVlanId: new FormControl<number | null | undefined>(undefined),
			suspendPortBounce: new FormControl<boolean | null | undefined>(undefined),
			voiceVlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAccessPolicyReturnRadiusAccountingServers {

		/** Public IP address of the RADIUS accounting server */
		host?: string | null;

		/** UDP port that the RADIUS Accounting server listens on for access requests */
		port?: number | null;
	}
	export interface UpdateNetworkSwitchAccessPolicyReturnRadiusAccountingServersFormProperties {

		/** Public IP address of the RADIUS accounting server */
		host: FormControl<string | null | undefined>,

		/** UDP port that the RADIUS Accounting server listens on for access requests */
		port: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessPolicyReturnRadiusAccountingServersFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessPolicyReturnRadiusAccountingServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAccessPolicyReturnRadiusServers {

		/** Public IP address of the RADIUS server */
		host?: string | null;

		/** UDP port that the RADIUS server listens on for access requests */
		port?: number | null;
	}
	export interface UpdateNetworkSwitchAccessPolicyReturnRadiusServersFormProperties {

		/** Public IP address of the RADIUS server */
		host: FormControl<string | null | undefined>,

		/** UDP port that the RADIUS server listens on for access requests */
		port: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAccessPolicyReturnRadiusServersFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAccessPolicyReturnRadiusServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAlternateManagementInterfacePutBody {

		/** Boolean value to enable or disable AMI configuration. If enabled, VLAN and protocols must be set */
		enabled?: boolean | null;

		/** Can be one or more of the following values: 'radius', 'snmp' or 'syslog' */
		protocols?: Array<string>;

		/** Array of switch serial number and IP assignment. If parameter is present, it cannot have empty body. Note: switches parameter is not applicable for template networks, in other words, do not put 'switches' in the body when updating template networks. Also, an empty 'switches' array will remove all previous assignments */
		UpdateNetworkSwitchAlternateManagementInterfacePutBodySwitches?: Array<UpdateNetworkSwitchAlternateManagementInterfacePutBodySwitches>;

		/** Alternate management VLAN, must be between 1 and 4094 */
		vlanId?: number | null;
	}
	export interface UpdateNetworkSwitchAlternateManagementInterfacePutBodyFormProperties {

		/** Boolean value to enable or disable AMI configuration. If enabled, VLAN and protocols must be set */
		enabled: FormControl<boolean | null | undefined>,

		/** Alternate management VLAN, must be between 1 and 4094 */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAlternateManagementInterfacePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAlternateManagementInterfacePutBodyFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchAlternateManagementInterfacePutBodySwitches {

		/**
		 * Switch alternative management IP. To remove a prior IP setting, provide an empty string
		 * Required
		 */
		alternateManagementIp: string;

		/** Switch gateway must be in IP format. Only and must be specified for Polaris switches */
		gateway?: string | null;

		/**
		 * Switch serial number
		 * Required
		 */
		serial: string;

		/** Switch subnet mask must be in IP format. Only and must be specified for Polaris switches */
		subnetMask?: string | null;
	}
	export interface UpdateNetworkSwitchAlternateManagementInterfacePutBodySwitchesFormProperties {

		/**
		 * Switch alternative management IP. To remove a prior IP setting, provide an empty string
		 * Required
		 */
		alternateManagementIp: FormControl<string | null | undefined>,

		/** Switch gateway must be in IP format. Only and must be specified for Polaris switches */
		gateway: FormControl<string | null | undefined>,

		/**
		 * Switch serial number
		 * Required
		 */
		serial: FormControl<string | null | undefined>,

		/** Switch subnet mask must be in IP format. Only and must be specified for Polaris switches */
		subnetMask: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchAlternateManagementInterfacePutBodySwitchesFormGroup() {
		return new FormGroup<UpdateNetworkSwitchAlternateManagementInterfacePutBodySwitchesFormProperties>({
			alternateManagementIp: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			gateway: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			subnetMask: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturn {

		/** Client id of the server if available. */
		clientId?: string | null;

		/** Attributes of the server when it's a device. */
		device?: GetNetworkSwitchDhcpV4ServersSeenReturnDevice;

		/** IPv4 attributes of the server. */
		ipv4?: GetNetworkSwitchDhcpV4ServersSeenReturnIpv4;

		/** Whether the server is allowed or blocked. Always true for configured servers. */
		isAllowed?: boolean | null;

		/** Whether the server is configured. */
		isConfigured?: boolean | null;

		/** Attributes of the server's last ack. */
		lastAck?: GetNetworkSwitchDhcpV4ServersSeenReturnLastAck;

		/** Last packet the server received. */
		lastPacket?: GetNetworkSwitchDhcpV4ServersSeenReturnLastPacket;

		/** Last time the server was seen. */
		lastSeenAt?: Date | null;

		/** Mac address of the server. */
		mac?: string | null;

		/** Devices that saw the server. */
		GetNetworkSwitchDhcpV4ServersSeenReturnSeenBy?: Array<GetNetworkSwitchDhcpV4ServersSeenReturnSeenBy>;

		/** server type. Can be a 'device', 'stack', or 'discovered' (i.e client). */
		type?: GetNetworkSwitchDhcpV4ServersSeenReturnType | null;

		/** Vlan id of the server. */
		vlan?: number | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnFormProperties {

		/** Client id of the server if available. */
		clientId: FormControl<string | null | undefined>,

		/** Whether the server is allowed or blocked. Always true for configured servers. */
		isAllowed: FormControl<boolean | null | undefined>,

		/** Whether the server is configured. */
		isConfigured: FormControl<boolean | null | undefined>,

		/** Last time the server was seen. */
		lastSeenAt: FormControl<Date | null | undefined>,

		/** Mac address of the server. */
		mac: FormControl<string | null | undefined>,

		/** server type. Can be a 'device', 'stack', or 'discovered' (i.e client). */
		type: FormControl<GetNetworkSwitchDhcpV4ServersSeenReturnType | null | undefined>,

		/** Vlan id of the server. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnFormProperties>({
			clientId: new FormControl<string | null | undefined>(undefined),
			isAllowed: new FormControl<boolean | null | undefined>(undefined),
			isConfigured: new FormControl<boolean | null | undefined>(undefined),
			lastSeenAt: new FormControl<Date | null | undefined>(undefined),
			mac: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<GetNetworkSwitchDhcpV4ServersSeenReturnType | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnDevice {

		/** Interface attributes of the server. Only for configured servers. */
		interface?: GetNetworkSwitchDhcpV4ServersSeenReturnDeviceInterface;

		/** Device name. */
		name?: string | null;

		/** Device serial. */
		serial?: string | null;

		/** Url link to device. */
		url?: string | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnDeviceFormProperties {

		/** Device name. */
		name: FormControl<string | null | undefined>,

		/** Device serial. */
		serial: FormControl<string | null | undefined>,

		/** Url link to device. */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnDeviceFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnDeviceFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnDeviceInterface {

		/** Interface name. */
		name?: string | null;

		/** Url link to interface. */
		url?: string | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnDeviceInterfaceFormProperties {

		/** Interface name. */
		name: FormControl<string | null | undefined>,

		/** Url link to interface. */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnDeviceInterfaceFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnDeviceInterfaceFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnIpv4 {

		/** IPv4 address of the server. */
		address?: string | null;

		/** IPv4 gateway address of the server. */
		gateway?: string | null;

		/** Subnet of the server. */
		subnet?: string | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnIpv4FormProperties {

		/** IPv4 address of the server. */
		address: FormControl<string | null | undefined>,

		/** IPv4 gateway address of the server. */
		gateway: FormControl<string | null | undefined>,

		/** Subnet of the server. */
		subnet: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnIpv4FormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastAck {

		/** IPv4 attributes of the last ack. */
		ipv4?: GetNetworkSwitchDhcpV4ServersSeenReturnLastAckIpv4;

		/** Last time the server was acked. */
		ts?: Date | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastAckFormProperties {

		/** Last time the server was acked. */
		ts: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastAckFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastAckFormProperties>({
			ts: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastAckIpv4 {

		/** IPv4 address of the last ack. */
		address?: string | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastAckIpv4FormProperties {

		/** IPv4 address of the last ack. */
		address: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastAckIpv4FormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastAckIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacket {

		/** Destination of the packet. */
		destination?: GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestination;

		/** Additional ethernet attributes of the packet. */
		ethernet?: GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketEthernet;

		/** DHCP-specific fields of the packet. */
		fields?: GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFields;

		/** Additional IP attributes of the packet. */
		ip?: GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIp;

		/** Source of the packet. */
		source?: GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSource;

		/** Packet type. */
		type?: string | null;

		/** UDP attributes of the packet. */
		udp?: GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketUdp;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFormProperties {

		/** Packet type. */
		type: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFormProperties>({
			type: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestination {

		/** Destination ipv4 attributes of the packet. */
		ipv4?: GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestinationIpv4;

		/** Destination mac address of the packet. */
		mac?: string | null;

		/** Destination port of the packet. */
		port?: number | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestinationFormProperties {

		/** Destination mac address of the packet. */
		mac: FormControl<string | null | undefined>,

		/** Destination port of the packet. */
		port: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestinationFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestinationFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestinationIpv4 {

		/** Destination ipv4 address of the packet. */
		address?: string | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestinationIpv4FormProperties {

		/** Destination ipv4 address of the packet. */
		address: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestinationIpv4FormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestinationIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketEthernet {

		/** Ethernet type of the packet. */
		type?: string | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketEthernetFormProperties {

		/** Ethernet type of the packet. */
		type: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastPacketEthernetFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketEthernetFormProperties>({
			type: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFields {

		/** Client hardware address of the packet. */
		chaddr?: string | null;

		/** Client IP address of the packet. */
		ciaddr?: string | null;

		/** Packet flags. */
		flags?: string | null;

		/** Gateway IP address of the packet. */
		giaddr?: string | null;

		/** Hardware length of the packet. */
		hlen?: number | null;

		/** Number of hops the packet took. */
		hops?: number | null;

		/** Hardware type code of the packet. */
		htype?: number | null;

		/** Magic cookie of the packet. */
		magicCookie?: string | null;

		/** Operation code of the packet. */
		op?: number | null;

		/** Additional DHCP options of the packet. */
		GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFieldsOptions?: Array<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFieldsOptions>;

		/** Number of seconds since receiving the packet. */
		secs?: number | null;

		/** Server IP address of the packet. */
		siaddr?: string | null;

		/** Server identifier address of the packet. */
		sname?: string | null;

		/** Transaction id of the packet. */
		xid?: string | null;

		/** Assigned IP address of the packet. */
		yiaddr?: string | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFieldsFormProperties {

		/** Client hardware address of the packet. */
		chaddr: FormControl<string | null | undefined>,

		/** Client IP address of the packet. */
		ciaddr: FormControl<string | null | undefined>,

		/** Packet flags. */
		flags: FormControl<string | null | undefined>,

		/** Gateway IP address of the packet. */
		giaddr: FormControl<string | null | undefined>,

		/** Hardware length of the packet. */
		hlen: FormControl<number | null | undefined>,

		/** Number of hops the packet took. */
		hops: FormControl<number | null | undefined>,

		/** Hardware type code of the packet. */
		htype: FormControl<number | null | undefined>,

		/** Magic cookie of the packet. */
		magicCookie: FormControl<string | null | undefined>,

		/** Operation code of the packet. */
		op: FormControl<number | null | undefined>,

		/** Number of seconds since receiving the packet. */
		secs: FormControl<number | null | undefined>,

		/** Server IP address of the packet. */
		siaddr: FormControl<string | null | undefined>,

		/** Server identifier address of the packet. */
		sname: FormControl<string | null | undefined>,

		/** Transaction id of the packet. */
		xid: FormControl<string | null | undefined>,

		/** Assigned IP address of the packet. */
		yiaddr: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFieldsFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFieldsFormProperties>({
			chaddr: new FormControl<string | null | undefined>(undefined),
			ciaddr: new FormControl<string | null | undefined>(undefined),
			flags: new FormControl<string | null | undefined>(undefined),
			giaddr: new FormControl<string | null | undefined>(undefined),
			hlen: new FormControl<number | null | undefined>(undefined),
			hops: new FormControl<number | null | undefined>(undefined),
			htype: new FormControl<number | null | undefined>(undefined),
			magicCookie: new FormControl<string | null | undefined>(undefined),
			op: new FormControl<number | null | undefined>(undefined),
			secs: new FormControl<number | null | undefined>(undefined),
			siaddr: new FormControl<string | null | undefined>(undefined),
			sname: new FormControl<string | null | undefined>(undefined),
			xid: new FormControl<string | null | undefined>(undefined),
			yiaddr: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFieldsOptions {

		/** Option name. */
		name?: string | null;

		/** Option value. */
		value?: string | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFieldsOptionsFormProperties {

		/** Option name. */
		name: FormControl<string | null | undefined>,

		/** Option value. */
		value: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFieldsOptionsFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFieldsOptionsFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			value: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIp {

		/** DSCP attributes of the packet. */
		dscp?: GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpDscp;

		/** IP header length of the packet. */
		headerLength?: number | null;

		/** IP ID of the packet. */
		id?: string | null;

		/** IP length of the packet. */
		length?: number | null;

		/** IP protocol number of the packet. */
		protocol?: number | null;

		/** Time to live of the packet. */
		ttl?: number | null;

		/** IP version of the packet. */
		version?: GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpVersion;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpFormProperties {

		/** IP header length of the packet. */
		headerLength: FormControl<number | null | undefined>,

		/** IP ID of the packet. */
		id: FormControl<string | null | undefined>,

		/** IP length of the packet. */
		length: FormControl<number | null | undefined>,

		/** IP protocol number of the packet. */
		protocol: FormControl<number | null | undefined>,

		/** Time to live of the packet. */
		ttl: FormControl<number | null | undefined>,

		/** IP version of the packet. */
		version: FormControl<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpVersion | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpFormProperties>({
			headerLength: new FormControl<number | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			length: new FormControl<number | null | undefined>(undefined),
			protocol: new FormControl<number | null | undefined>(undefined),
			ttl: new FormControl<number | null | undefined>(undefined),
			version: new FormControl<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpVersion | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpDscp {

		/** ECN number of the packet. */
		ecn?: number | null;

		/** DSCP tag number of the packet. */
		tag?: number | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpDscpFormProperties {

		/** ECN number of the packet. */
		ecn: FormControl<number | null | undefined>,

		/** DSCP tag number of the packet. */
		tag: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpDscpFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpDscpFormProperties>({
			ecn: new FormControl<number | null | undefined>(undefined),
			tag: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpVersion { _4 = 0, _6 = 1 }

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSource {

		/** Source ipv4 attributes of the packet. */
		ipv4?: GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSourceIpv4;

		/** Source mac address of the packet. */
		mac?: string | null;

		/** Source port of the packet. */
		port?: number | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSourceFormProperties {

		/** Source mac address of the packet. */
		mac: FormControl<string | null | undefined>,

		/** Source port of the packet. */
		port: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSourceFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSourceFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSourceIpv4 {

		/** Source ipv4 address of the packet. */
		address?: string | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSourceIpv4FormProperties {

		/** Source ipv4 address of the packet. */
		address: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSourceIpv4FormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSourceIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketUdp {

		/** UDP checksum of the packet. */
		checksum?: string | null;

		/** UDP length of the packet. */
		length?: number | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketUdpFormProperties {

		/** UDP checksum of the packet. */
		checksum: FormControl<string | null | undefined>,

		/** UDP length of the packet. */
		length: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnLastPacketUdpFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketUdpFormProperties>({
			checksum: new FormControl<string | null | undefined>(undefined),
			length: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpV4ServersSeenReturnSeenBy {

		/** Device name. */
		name?: string | null;

		/** Device serial. */
		serial?: string | null;

		/** Url link to device. */
		url?: string | null;
	}
	export interface GetNetworkSwitchDhcpV4ServersSeenReturnSeenByFormProperties {

		/** Device name. */
		name: FormControl<string | null | undefined>,

		/** Device serial. */
		serial: FormControl<string | null | undefined>,

		/** Url link to device. */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpV4ServersSeenReturnSeenByFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpV4ServersSeenReturnSeenByFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetNetworkSwitchDhcpV4ServersSeenReturnType { device = 'device', discovered = 'discovered', stack = 'stack' }

	export interface UpdateNetworkSwitchDhcpServerPolicyPutBody {

		/** Alert settings for DHCP servers */
		alerts?: UpdateNetworkSwitchDhcpServerPolicyPutBodyAlerts;

		/** List the MAC addresses of DHCP servers to permit on the network when defaultPolicy is set to block. An empty array will clear the entries. */
		allowedServers?: Array<string>;

		/** Dynamic ARP Inspection settings */
		arpInspection?: UpdateNetworkSwitchDhcpServerPolicyPutBodyArpInspection;

		/** List the MAC addresses of DHCP servers to block on the network when defaultPolicy is set to allow. An empty array will clear the entries. */
		blockedServers?: Array<string>;

		/** 'allow' or 'block' new DHCP servers. Default value is 'allow'. */
		defaultPolicy?: UpdateNetworkSwitchDhcpServerPolicyPutBodyDefaultPolicy | null;
	}
	export interface UpdateNetworkSwitchDhcpServerPolicyPutBodyFormProperties {

		/** 'allow' or 'block' new DHCP servers. Default value is 'allow'. */
		defaultPolicy: FormControl<UpdateNetworkSwitchDhcpServerPolicyPutBodyDefaultPolicy | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchDhcpServerPolicyPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchDhcpServerPolicyPutBodyFormProperties>({
			defaultPolicy: new FormControl<UpdateNetworkSwitchDhcpServerPolicyPutBodyDefaultPolicy | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchDhcpServerPolicyPutBodyAlerts {

		/** Email alert settings for DHCP servers */
		email?: UpdateNetworkSwitchDhcpServerPolicyPutBodyAlertsEmail;
	}
	export interface UpdateNetworkSwitchDhcpServerPolicyPutBodyAlertsFormProperties {
	}
	export function CreateUpdateNetworkSwitchDhcpServerPolicyPutBodyAlertsFormGroup() {
		return new FormGroup<UpdateNetworkSwitchDhcpServerPolicyPutBodyAlertsFormProperties>({
		});

	}

	export interface UpdateNetworkSwitchDhcpServerPolicyPutBodyAlertsEmail {

		/** When enabled, send an email if a new DHCP server is seen. Default value is false. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkSwitchDhcpServerPolicyPutBodyAlertsEmailFormProperties {

		/** When enabled, send an email if a new DHCP server is seen. Default value is false. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchDhcpServerPolicyPutBodyAlertsEmailFormGroup() {
		return new FormGroup<UpdateNetworkSwitchDhcpServerPolicyPutBodyAlertsEmailFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchDhcpServerPolicyPutBodyArpInspection {

		/** Enable or disable Dynamic ARP Inspection on the network. Default value is false. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkSwitchDhcpServerPolicyPutBodyArpInspectionFormProperties {

		/** Enable or disable Dynamic ARP Inspection on the network. Default value is false. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchDhcpServerPolicyPutBodyArpInspectionFormGroup() {
		return new FormGroup<UpdateNetworkSwitchDhcpServerPolicyPutBodyArpInspectionFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkSwitchDhcpServerPolicyPutBodyDefaultPolicy { allow = 'allow', block = 'block' }

	export interface GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturn {

		/** IPv4 attributes of the trusted server. */
		ipv4?: GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturnIpv4;

		/** Mac address of the trusted server. */
		mac?: string | null;

		/** ID of the trusted server. */
		trustedServerId?: string | null;

		/** Vlan ID of the trusted server. */
		vlan?: number | null;
	}
	export interface GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturnFormProperties {

		/** Mac address of the trusted server. */
		mac: FormControl<string | null | undefined>,

		/** ID of the trusted server. */
		trustedServerId: FormControl<string | null | undefined>,

		/** Vlan ID of the trusted server. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturnFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturnFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			trustedServerId: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturnIpv4 {

		/** IPv4 address of the trusted server. */
		address?: string | null;
	}
	export interface GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturnIpv4FormProperties {

		/** IPv4 address of the trusted server. */
		address: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturnIpv4FormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturnIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBody {

		/**
		 * The IPv4 attributes of the trusted server being added
		 * Required
		 */
		ipv4: CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBodyIpv4;

		/**
		 * The mac address of the trusted server being added
		 * Required
		 */
		mac: string;

		/**
		 * The VLAN of the trusted server being added. It must be between 1 and 4094
		 * Required
		 */
		vlan: number;
	}
	export interface CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBodyFormProperties {

		/**
		 * The mac address of the trusted server being added
		 * Required
		 */
		mac: FormControl<string | null | undefined>,

		/**
		 * The VLAN of the trusted server being added. It must be between 1 and 4094
		 * Required
		 */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBodyFormGroup() {
		return new FormGroup<CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBodyFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			vlan: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBodyIpv4 {

		/** The IPv4 address of the trusted server being added */
		address?: string | null;
	}
	export interface CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBodyIpv4FormProperties {

		/** The IPv4 address of the trusted server being added */
		address: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBodyIpv4FormGroup() {
		return new FormGroup<CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBodyIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBody {

		/** The updated IPv4 attributes of the trusted server */
		ipv4?: UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBodyIpv4;

		/** The updated mac address of the trusted server */
		mac?: string | null;

		/** The updated VLAN of the trusted server. It must be between 1 and 4094 */
		vlan?: number | null;
	}
	export interface UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBodyFormProperties {

		/** The updated mac address of the trusted server */
		mac: FormControl<string | null | undefined>,

		/** The updated VLAN of the trusted server. It must be between 1 and 4094 */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBodyFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBodyIpv4 {

		/** The updated IPv4 address of the trusted server */
		address?: string | null;
	}
	export interface UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBodyIpv4FormProperties {

		/** The updated IPv4 address of the trusted server */
		address: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBodyIpv4FormGroup() {
		return new FormGroup<UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBodyIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturn {

		/** IPv4 attributes of the trusted server. */
		ipv4?: UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturnIpv4;

		/** Mac address of the trusted server. */
		mac?: string | null;

		/** ID of the trusted server. */
		trustedServerId?: string | null;

		/** Vlan ID of the trusted server. */
		vlan?: number | null;
	}
	export interface UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturnFormProperties {

		/** Mac address of the trusted server. */
		mac: FormControl<string | null | undefined>,

		/** ID of the trusted server. */
		trustedServerId: FormControl<string | null | undefined>,

		/** Vlan ID of the trusted server. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturnFormGroup() {
		return new FormGroup<UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturnFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			trustedServerId: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturnIpv4 {

		/** IPv4 address of the trusted server. */
		address?: string | null;
	}
	export interface UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturnIpv4FormProperties {

		/** IPv4 address of the trusted server. */
		address: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturnIpv4FormGroup() {
		return new FormGroup<UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturnIpv4FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceReturn {

		/** Whether this switch has a trusted DAI port. Always false if supportsInspection is false. */
		hasTrustedPort?: boolean | null;

		/** Switch name. */
		name?: string | null;

		/** Switch serial. */
		serial?: string | null;

		/** Whether this switch supports Dynamic ARP Inspection. */
		supportsInspection?: boolean | null;

		/** Url link to switch. */
		url?: string | null;
	}
	export interface GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceReturnFormProperties {

		/** Whether this switch has a trusted DAI port. Always false if supportsInspection is false. */
		hasTrustedPort: FormControl<boolean | null | undefined>,

		/** Switch name. */
		name: FormControl<string | null | undefined>,

		/** Switch serial. */
		serial: FormControl<string | null | undefined>,

		/** Whether this switch supports Dynamic ARP Inspection. */
		supportsInspection: FormControl<boolean | null | undefined>,

		/** Url link to switch. */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceReturnFormGroup() {
		return new FormGroup<GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceReturnFormProperties>({
			hasTrustedPort: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			supportsInspection: new FormControl<boolean | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchDscpToCosMappingsPutBody {

		/**
		 * An array of DSCP to CoS mappings. An empty array will reset the mappings to default.
		 * Required
		 */
		UpdateNetworkSwitchDscpToCosMappingsPutBodyMappings: Array<UpdateNetworkSwitchDscpToCosMappingsPutBodyMappings>;
	}
	export interface UpdateNetworkSwitchDscpToCosMappingsPutBodyFormProperties {
	}
	export function CreateUpdateNetworkSwitchDscpToCosMappingsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchDscpToCosMappingsPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkSwitchDscpToCosMappingsPutBodyMappings {

		/**
		 * The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
		 * Required
		 */
		cos: number;

		/**
		 * The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
		 * Required
		 */
		dscp: number;

		/** Label for the mapping (optional). */
		title?: string | null;
	}
	export interface UpdateNetworkSwitchDscpToCosMappingsPutBodyMappingsFormProperties {

		/**
		 * The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
		 * Required
		 */
		cos: FormControl<number | null | undefined>,

		/**
		 * The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
		 * Required
		 */
		dscp: FormControl<number | null | undefined>,

		/** Label for the mapping (optional). */
		title: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchDscpToCosMappingsPutBodyMappingsFormGroup() {
		return new FormGroup<UpdateNetworkSwitchDscpToCosMappingsPutBodyMappingsFormProperties>({
			cos: new FormControl<number | null | undefined>(undefined, [Validators.required]),
			dscp: new FormControl<number | null | undefined>(undefined, [Validators.required]),
			title: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchLinkAggregationPostBody {

		/** Array of switch or stack ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported. */
		CreateNetworkSwitchLinkAggregationPostBodySwitchPorts?: Array<CreateNetworkSwitchLinkAggregationPostBodySwitchPorts>;

		/** Array of switch profile ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported. */
		CreateNetworkSwitchLinkAggregationPostBodySwitchProfilePorts?: Array<CreateNetworkSwitchLinkAggregationPostBodySwitchProfilePorts>;
	}
	export interface CreateNetworkSwitchLinkAggregationPostBodyFormProperties {
	}
	export function CreateCreateNetworkSwitchLinkAggregationPostBodyFormGroup() {
		return new FormGroup<CreateNetworkSwitchLinkAggregationPostBodyFormProperties>({
		});

	}

	export interface CreateNetworkSwitchLinkAggregationPostBodySwitchPorts {

		/**
		 * Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		 * Required
		 */
		portId: string;

		/**
		 * Serial number of the switch.
		 * Required
		 */
		serial: string;
	}
	export interface CreateNetworkSwitchLinkAggregationPostBodySwitchPortsFormProperties {

		/**
		 * Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		 * Required
		 */
		portId: FormControl<string | null | undefined>,

		/**
		 * Serial number of the switch.
		 * Required
		 */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchLinkAggregationPostBodySwitchPortsFormGroup() {
		return new FormGroup<CreateNetworkSwitchLinkAggregationPostBodySwitchPortsFormProperties>({
			portId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			serial: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSwitchLinkAggregationPostBodySwitchProfilePorts {

		/**
		 * Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		 * Required
		 */
		portId: string;

		/**
		 * Profile identifier.
		 * Required
		 */
		profile: string;
	}
	export interface CreateNetworkSwitchLinkAggregationPostBodySwitchProfilePortsFormProperties {

		/**
		 * Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		 * Required
		 */
		portId: FormControl<string | null | undefined>,

		/**
		 * Profile identifier.
		 * Required
		 */
		profile: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchLinkAggregationPostBodySwitchProfilePortsFormGroup() {
		return new FormGroup<CreateNetworkSwitchLinkAggregationPostBodySwitchProfilePortsFormProperties>({
			portId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			profile: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSwitchLinkAggregationPutBody {

		/** Array of switch or stack ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported. */
		UpdateNetworkSwitchLinkAggregationPutBodySwitchPorts?: Array<UpdateNetworkSwitchLinkAggregationPutBodySwitchPorts>;

		/** Array of switch profile ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported. */
		UpdateNetworkSwitchLinkAggregationPutBodySwitchProfilePorts?: Array<UpdateNetworkSwitchLinkAggregationPutBodySwitchProfilePorts>;
	}
	export interface UpdateNetworkSwitchLinkAggregationPutBodyFormProperties {
	}
	export function CreateUpdateNetworkSwitchLinkAggregationPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchLinkAggregationPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkSwitchLinkAggregationPutBodySwitchPorts {

		/**
		 * Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		 * Required
		 */
		portId: string;

		/**
		 * Serial number of the switch.
		 * Required
		 */
		serial: string;
	}
	export interface UpdateNetworkSwitchLinkAggregationPutBodySwitchPortsFormProperties {

		/**
		 * Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		 * Required
		 */
		portId: FormControl<string | null | undefined>,

		/**
		 * Serial number of the switch.
		 * Required
		 */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchLinkAggregationPutBodySwitchPortsFormGroup() {
		return new FormGroup<UpdateNetworkSwitchLinkAggregationPutBodySwitchPortsFormProperties>({
			portId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			serial: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSwitchLinkAggregationPutBodySwitchProfilePorts {

		/**
		 * Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		 * Required
		 */
		portId: string;

		/**
		 * Profile identifier.
		 * Required
		 */
		profile: string;
	}
	export interface UpdateNetworkSwitchLinkAggregationPutBodySwitchProfilePortsFormProperties {

		/**
		 * Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		 * Required
		 */
		portId: FormControl<string | null | undefined>,

		/**
		 * Profile identifier.
		 * Required
		 */
		profile: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchLinkAggregationPutBodySwitchProfilePortsFormGroup() {
		return new FormGroup<UpdateNetworkSwitchLinkAggregationPutBodySwitchProfilePortsFormProperties>({
			portId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			profile: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkSwitchMtuReturn {

		/** MTU size for the entire network. Default value is 9578. */
		defaultMtuSize?: number | null;

		/**
		 * Override MTU size for individual switches or switch profiles.
		 * An empty array will clear overrides.
		 */
		GetNetworkSwitchMtuReturnOverrides?: Array<GetNetworkSwitchMtuReturnOverrides>;
	}
	export interface GetNetworkSwitchMtuReturnFormProperties {

		/** MTU size for the entire network. Default value is 9578. */
		defaultMtuSize: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchMtuReturnFormGroup() {
		return new FormGroup<GetNetworkSwitchMtuReturnFormProperties>({
			defaultMtuSize: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchMtuReturnOverrides {

		/**
		 * MTU size for the switches or switch profiles.
		 * Required
		 */
		mtuSize: number;

		/** List of switch profile IDs. Applicable only for template network. */
		switchProfiles?: Array<string>;

		/** List of switch serials. Applicable only for switch network. */
		switches?: Array<string>;
	}
	export interface GetNetworkSwitchMtuReturnOverridesFormProperties {

		/**
		 * MTU size for the switches or switch profiles.
		 * Required
		 */
		mtuSize: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchMtuReturnOverridesFormGroup() {
		return new FormGroup<GetNetworkSwitchMtuReturnOverridesFormProperties>({
			mtuSize: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSwitchMtuPutBody {

		/** MTU size for the entire network. Default value is 9578. */
		defaultMtuSize?: number | null;

		/** Override MTU size for individual switches or switch profiles. An empty array will clear overrides. */
		UpdateNetworkSwitchMtuPutBodyOverrides?: Array<UpdateNetworkSwitchMtuPutBodyOverrides>;
	}
	export interface UpdateNetworkSwitchMtuPutBodyFormProperties {

		/** MTU size for the entire network. Default value is 9578. */
		defaultMtuSize: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchMtuPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchMtuPutBodyFormProperties>({
			defaultMtuSize: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchMtuPutBodyOverrides {

		/**
		 * MTU size for the switches or switch profiles.
		 * Required
		 */
		mtuSize: number;

		/** List of switch profile IDs. Applicable only for template network. */
		switchProfiles?: Array<string>;

		/** List of switch serials. Applicable only for switch network. */
		switches?: Array<string>;
	}
	export interface UpdateNetworkSwitchMtuPutBodyOverridesFormProperties {

		/**
		 * MTU size for the switches or switch profiles.
		 * Required
		 */
		mtuSize: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchMtuPutBodyOverridesFormGroup() {
		return new FormGroup<UpdateNetworkSwitchMtuPutBodyOverridesFormProperties>({
			mtuSize: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSwitchPortSchedulePostBody {

		/**
		 * The name for your port schedule. Required
		 * Required
		 */
		name: string;

		/**
		 * The schedule for switch port scheduling. Schedules are applied to days of the week.
		 * When it's empty, default schedule with all days of a week are configured.
		 * Any unspecified day in the schedule is added as a default schedule configuration of the day.
		 */
		portSchedule?: CreateNetworkSwitchPortSchedulePostBodyPortSchedule;
	}
	export interface CreateNetworkSwitchPortSchedulePostBodyFormProperties {

		/**
		 * The name for your port schedule. Required
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchPortSchedulePostBodyFormGroup() {
		return new FormGroup<CreateNetworkSwitchPortSchedulePostBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSwitchPortSchedulePostBodyPortSchedule {

		/** The schedule object for Friday. */
		friday?: CreateNetworkSwitchPortSchedulePostBodyPortScheduleFriday;

		/** The schedule object for Monday. */
		monday?: CreateNetworkSwitchPortSchedulePostBodyPortScheduleMonday;

		/** The schedule object for Saturday. */
		saturday?: CreateNetworkSwitchPortSchedulePostBodyPortScheduleSaturday;

		/** The schedule object for Sunday. */
		sunday?: CreateNetworkSwitchPortSchedulePostBodyPortScheduleSunday;

		/** The schedule object for Thursday. */
		thursday?: CreateNetworkSwitchPortSchedulePostBodyPortScheduleThursday;

		/** The schedule object for Tuesday. */
		tuesday?: CreateNetworkSwitchPortSchedulePostBodyPortScheduleTuesday;

		/** The schedule object for Wednesday. */
		wednesday?: CreateNetworkSwitchPortSchedulePostBodyPortScheduleWednesday;
	}
	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleFormProperties {
	}
	export function CreateCreateNetworkSwitchPortSchedulePostBodyPortScheduleFormGroup() {
		return new FormGroup<CreateNetworkSwitchPortSchedulePostBodyPortScheduleFormProperties>({
		});

	}

	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleFriday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleFridayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchPortSchedulePostBodyPortScheduleFridayFormGroup() {
		return new FormGroup<CreateNetworkSwitchPortSchedulePostBodyPortScheduleFridayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleMonday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleMondayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchPortSchedulePostBodyPortScheduleMondayFormGroup() {
		return new FormGroup<CreateNetworkSwitchPortSchedulePostBodyPortScheduleMondayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleSaturday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleSaturdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchPortSchedulePostBodyPortScheduleSaturdayFormGroup() {
		return new FormGroup<CreateNetworkSwitchPortSchedulePostBodyPortScheduleSaturdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleSunday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleSundayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchPortSchedulePostBodyPortScheduleSundayFormGroup() {
		return new FormGroup<CreateNetworkSwitchPortSchedulePostBodyPortScheduleSundayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleThursday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleThursdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchPortSchedulePostBodyPortScheduleThursdayFormGroup() {
		return new FormGroup<CreateNetworkSwitchPortSchedulePostBodyPortScheduleThursdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleTuesday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleTuesdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchPortSchedulePostBodyPortScheduleTuesdayFormGroup() {
		return new FormGroup<CreateNetworkSwitchPortSchedulePostBodyPortScheduleTuesdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleWednesday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface CreateNetworkSwitchPortSchedulePostBodyPortScheduleWednesdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchPortSchedulePostBodyPortScheduleWednesdayFormGroup() {
		return new FormGroup<CreateNetworkSwitchPortSchedulePostBodyPortScheduleWednesdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchPortSchedulePutBody {

		/** The name for your port schedule. */
		name?: string | null;

		/**
		 * The schedule for switch port scheduling. Schedules are applied to days of the week.
		 * When it's empty, default schedule with all days of a week are configured.
		 * Any unspecified day in the schedule is added as a default schedule configuration of the day.
		 */
		portSchedule?: UpdateNetworkSwitchPortSchedulePutBodyPortSchedule;
	}
	export interface UpdateNetworkSwitchPortSchedulePutBodyFormProperties {

		/** The name for your port schedule. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchPortSchedulePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchPortSchedulePutBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchPortSchedulePutBodyPortSchedule {

		/** The schedule object for Friday. */
		friday?: UpdateNetworkSwitchPortSchedulePutBodyPortScheduleFriday;

		/** The schedule object for Monday. */
		monday?: UpdateNetworkSwitchPortSchedulePutBodyPortScheduleMonday;

		/** The schedule object for Saturday. */
		saturday?: UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSaturday;

		/** The schedule object for Sunday. */
		sunday?: UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSunday;

		/** The schedule object for Thursday. */
		thursday?: UpdateNetworkSwitchPortSchedulePutBodyPortScheduleThursday;

		/** The schedule object for Tuesday. */
		tuesday?: UpdateNetworkSwitchPortSchedulePutBodyPortScheduleTuesday;

		/** The schedule object for Wednesday. */
		wednesday?: UpdateNetworkSwitchPortSchedulePutBodyPortScheduleWednesday;
	}
	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleFormProperties {
	}
	export function CreateUpdateNetworkSwitchPortSchedulePutBodyPortScheduleFormGroup() {
		return new FormGroup<UpdateNetworkSwitchPortSchedulePutBodyPortScheduleFormProperties>({
		});

	}

	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleFriday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleFridayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchPortSchedulePutBodyPortScheduleFridayFormGroup() {
		return new FormGroup<UpdateNetworkSwitchPortSchedulePutBodyPortScheduleFridayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleMonday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleMondayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchPortSchedulePutBodyPortScheduleMondayFormGroup() {
		return new FormGroup<UpdateNetworkSwitchPortSchedulePutBodyPortScheduleMondayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSaturday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSaturdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchPortSchedulePutBodyPortScheduleSaturdayFormGroup() {
		return new FormGroup<UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSaturdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSunday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSundayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchPortSchedulePutBodyPortScheduleSundayFormGroup() {
		return new FormGroup<UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSundayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleThursday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleThursdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchPortSchedulePutBodyPortScheduleThursdayFormGroup() {
		return new FormGroup<UpdateNetworkSwitchPortSchedulePutBodyPortScheduleThursdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleTuesday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleTuesdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchPortSchedulePutBodyPortScheduleTuesdayFormGroup() {
		return new FormGroup<UpdateNetworkSwitchPortSchedulePutBodyPortScheduleTuesdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleWednesday {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active?: boolean | null;

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from?: string | null;

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to?: string | null;
	}
	export interface UpdateNetworkSwitchPortSchedulePutBodyPortScheduleWednesdayFormProperties {

		/** Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true. */
		active: FormControl<boolean | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed. */
		from: FormControl<string | null | undefined>,

		/** The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed. */
		to: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchPortSchedulePutBodyPortScheduleWednesdayFormGroup() {
		return new FormGroup<UpdateNetworkSwitchPortSchedulePutBodyPortScheduleWednesdayFormProperties>({
			active: new FormControl<boolean | null | undefined>(undefined),
			from: new FormControl<string | null | undefined>(undefined),
			to: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchQosRulePostBody {

		/** DSCP tag. Set this to -1 to trust incoming DSCP. Default value is 0 */
		dscp?: number | null;

		/** The destination port of the incoming packet. Applicable only if protocol is TCP or UDP. */
		dstPort?: number | null;

		/** The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80 */
		dstPortRange?: string | null;

		/** The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY" */
		protocol?: CreateNetworkSwitchQosRulePostBodyProtocol | null;

		/** The source port of the incoming packet. Applicable only if protocol is TCP or UDP. */
		srcPort?: number | null;

		/** The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80 */
		srcPortRange?: string | null;

		/**
		 * The VLAN of the incoming packet. A null value will match any VLAN.
		 * Required
		 */
		vlan: number;
	}
	export interface CreateNetworkSwitchQosRulePostBodyFormProperties {

		/** DSCP tag. Set this to -1 to trust incoming DSCP. Default value is 0 */
		dscp: FormControl<number | null | undefined>,

		/** The destination port of the incoming packet. Applicable only if protocol is TCP or UDP. */
		dstPort: FormControl<number | null | undefined>,

		/** The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80 */
		dstPortRange: FormControl<string | null | undefined>,

		/** The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY" */
		protocol: FormControl<CreateNetworkSwitchQosRulePostBodyProtocol | null | undefined>,

		/** The source port of the incoming packet. Applicable only if protocol is TCP or UDP. */
		srcPort: FormControl<number | null | undefined>,

		/** The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80 */
		srcPortRange: FormControl<string | null | undefined>,

		/**
		 * The VLAN of the incoming packet. A null value will match any VLAN.
		 * Required
		 */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkSwitchQosRulePostBodyFormGroup() {
		return new FormGroup<CreateNetworkSwitchQosRulePostBodyFormProperties>({
			dscp: new FormControl<number | null | undefined>(undefined),
			dstPort: new FormControl<number | null | undefined>(undefined),
			dstPortRange: new FormControl<string | null | undefined>(undefined),
			protocol: new FormControl<CreateNetworkSwitchQosRulePostBodyProtocol | null | undefined>(undefined),
			srcPort: new FormControl<number | null | undefined>(undefined),
			srcPortRange: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateNetworkSwitchQosRulePostBodyProtocol { ANY = 'ANY', TCP = 'TCP', UDP = 'UDP' }

	export interface UpdateNetworkSwitchQosRulesOrderPutBody {

		/**
		 * A list of quality of service rule IDs arranged in order in which they should be processed by the switch.
		 * Required
		 */
		ruleIds: Array<string>;
	}
	export interface UpdateNetworkSwitchQosRulesOrderPutBodyFormProperties {
	}
	export function CreateUpdateNetworkSwitchQosRulesOrderPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchQosRulesOrderPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkSwitchQosRulePutBody {

		/** DSCP tag that should be assigned to incoming packet. Set this to -1 to trust incoming DSCP. Default value is 0. */
		dscp?: number | null;

		/** The destination port of the incoming packet. Applicable only if protocol is TCP or UDP. */
		dstPort?: number | null;

		/** The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80 */
		dstPortRange?: string | null;

		/** The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY". */
		protocol?: CreateNetworkSwitchQosRulePostBodyProtocol | null;

		/** The source port of the incoming packet. Applicable only if protocol is TCP or UDP. */
		srcPort?: number | null;

		/** The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80 */
		srcPortRange?: string | null;

		/** The VLAN of the incoming packet. A null value will match any VLAN. */
		vlan?: number | null;
	}
	export interface UpdateNetworkSwitchQosRulePutBodyFormProperties {

		/** DSCP tag that should be assigned to incoming packet. Set this to -1 to trust incoming DSCP. Default value is 0. */
		dscp: FormControl<number | null | undefined>,

		/** The destination port of the incoming packet. Applicable only if protocol is TCP or UDP. */
		dstPort: FormControl<number | null | undefined>,

		/** The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80 */
		dstPortRange: FormControl<string | null | undefined>,

		/** The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY". */
		protocol: FormControl<CreateNetworkSwitchQosRulePostBodyProtocol | null | undefined>,

		/** The source port of the incoming packet. Applicable only if protocol is TCP or UDP. */
		srcPort: FormControl<number | null | undefined>,

		/** The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80 */
		srcPortRange: FormControl<string | null | undefined>,

		/** The VLAN of the incoming packet. A null value will match any VLAN. */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchQosRulePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchQosRulePutBodyFormProperties>({
			dscp: new FormControl<number | null | undefined>(undefined),
			dstPort: new FormControl<number | null | undefined>(undefined),
			dstPortRange: new FormControl<string | null | undefined>(undefined),
			protocol: new FormControl<CreateNetworkSwitchQosRulePostBodyProtocol | null | undefined>(undefined),
			srcPort: new FormControl<number | null | undefined>(undefined),
			srcPortRange: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchRoutingMulticastPutBody {

		/** Default multicast setting for entire network. IGMP snooping and Flood unknown multicast traffic settings are enabled by default. */
		defaultSettings?: UpdateNetworkSwitchRoutingMulticastPutBodyDefaultSettings;

		/** Array of paired switches/stacks/profiles and corresponding multicast settings. An empty array will clear the multicast settings. */
		UpdateNetworkSwitchRoutingMulticastPutBodyOverrides?: Array<UpdateNetworkSwitchRoutingMulticastPutBodyOverrides>;
	}
	export interface UpdateNetworkSwitchRoutingMulticastPutBodyFormProperties {
	}
	export function CreateUpdateNetworkSwitchRoutingMulticastPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchRoutingMulticastPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkSwitchRoutingMulticastPutBodyDefaultSettings {

		/** Flood unknown multicast traffic setting for entire network */
		floodUnknownMulticastTrafficEnabled?: boolean | null;

		/** IGMP snooping setting for entire network */
		igmpSnoopingEnabled?: boolean | null;
	}
	export interface UpdateNetworkSwitchRoutingMulticastPutBodyDefaultSettingsFormProperties {

		/** Flood unknown multicast traffic setting for entire network */
		floodUnknownMulticastTrafficEnabled: FormControl<boolean | null | undefined>,

		/** IGMP snooping setting for entire network */
		igmpSnoopingEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchRoutingMulticastPutBodyDefaultSettingsFormGroup() {
		return new FormGroup<UpdateNetworkSwitchRoutingMulticastPutBodyDefaultSettingsFormProperties>({
			floodUnknownMulticastTrafficEnabled: new FormControl<boolean | null | undefined>(undefined),
			igmpSnoopingEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchRoutingMulticastPutBodyOverrides {

		/**
		 * Flood unknown multicast traffic setting for switches, switch stacks or switch profiles
		 * Required
		 */
		floodUnknownMulticastTrafficEnabled: boolean;

		/**
		 * IGMP snooping setting for switches, switch stacks or switch profiles
		 * Required
		 */
		igmpSnoopingEnabled: boolean;

		/** List of switch stack ids for non-template network */
		stacks?: Array<string>;

		/** List of switch profiles ids for template network */
		switchProfiles?: Array<string>;

		/** List of switch serials for non-template network */
		switches?: Array<string>;
	}
	export interface UpdateNetworkSwitchRoutingMulticastPutBodyOverridesFormProperties {

		/**
		 * Flood unknown multicast traffic setting for switches, switch stacks or switch profiles
		 * Required
		 */
		floodUnknownMulticastTrafficEnabled: FormControl<boolean | null | undefined>,

		/**
		 * IGMP snooping setting for switches, switch stacks or switch profiles
		 * Required
		 */
		igmpSnoopingEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchRoutingMulticastPutBodyOverridesFormGroup() {
		return new FormGroup<UpdateNetworkSwitchRoutingMulticastPutBodyOverridesFormProperties>({
			floodUnknownMulticastTrafficEnabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
			igmpSnoopingEnabled: new FormControl<boolean | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSwitchRoutingMulticastRendezvousPointPostBody {

		/**
		 * The IP address of the interface where the RP needs to be created.
		 * Required
		 */
		interfaceIp: string;

		/**
		 * 'Any', or the IP address of a multicast group
		 * Required
		 */
		multicastGroup: string;
	}
	export interface CreateNetworkSwitchRoutingMulticastRendezvousPointPostBodyFormProperties {

		/**
		 * The IP address of the interface where the RP needs to be created.
		 * Required
		 */
		interfaceIp: FormControl<string | null | undefined>,

		/**
		 * 'Any', or the IP address of a multicast group
		 * Required
		 */
		multicastGroup: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchRoutingMulticastRendezvousPointPostBodyFormGroup() {
		return new FormGroup<CreateNetworkSwitchRoutingMulticastRendezvousPointPostBodyFormProperties>({
			interfaceIp: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			multicastGroup: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSwitchRoutingMulticastRendezvousPointPutBody {

		/**
		 * The IP address of the interface to use
		 * Required
		 */
		interfaceIp: string;

		/**
		 * 'Any', or the IP address of a multicast group
		 * Required
		 */
		multicastGroup: string;
	}
	export interface UpdateNetworkSwitchRoutingMulticastRendezvousPointPutBodyFormProperties {

		/**
		 * The IP address of the interface to use
		 * Required
		 */
		interfaceIp: FormControl<string | null | undefined>,

		/**
		 * 'Any', or the IP address of a multicast group
		 * Required
		 */
		multicastGroup: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchRoutingMulticastRendezvousPointPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchRoutingMulticastRendezvousPointPutBodyFormProperties>({
			interfaceIp: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			multicastGroup: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSwitchRoutingOspfPutBody {

		/** OSPF areas */
		UpdateNetworkSwitchRoutingOspfPutBodyAreas?: Array<UpdateNetworkSwitchRoutingOspfPutBodyAreas>;

		/** Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535 */
		deadTimerInSeconds?: number | null;

		/** Boolean value to enable or disable OSPF routing. OSPF routing is disabled by default. */
		enabled?: boolean | null;

		/** Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds. */
		helloTimerInSeconds?: number | null;

		/** Boolean value to enable or disable MD5 authentication. MD5 authentication is disabled by default. */
		md5AuthenticationEnabled?: boolean | null;

		/** MD5 authentication credentials. This param is only relevant if md5AuthenticationEnabled is true */
		md5AuthenticationKey?: UpdateNetworkSwitchRoutingOspfPutBodyMd5AuthenticationKey;

		/** OSPF v3 configuration */
		v3?: UpdateNetworkSwitchRoutingOspfPutBodyV3;
	}
	export interface UpdateNetworkSwitchRoutingOspfPutBodyFormProperties {

		/** Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535 */
		deadTimerInSeconds: FormControl<number | null | undefined>,

		/** Boolean value to enable or disable OSPF routing. OSPF routing is disabled by default. */
		enabled: FormControl<boolean | null | undefined>,

		/** Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds. */
		helloTimerInSeconds: FormControl<number | null | undefined>,

		/** Boolean value to enable or disable MD5 authentication. MD5 authentication is disabled by default. */
		md5AuthenticationEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchRoutingOspfPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchRoutingOspfPutBodyFormProperties>({
			deadTimerInSeconds: new FormControl<number | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			helloTimerInSeconds: new FormControl<number | null | undefined>(undefined),
			md5AuthenticationEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchRoutingOspfPutBodyAreas {

		/**
		 * OSPF area ID
		 * Required
		 */
		areaId: string;

		/**
		 * Name of the OSPF area
		 * Required
		 */
		areaName: string;

		/**
		 * Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
		 * Required
		 */
		areaType: UpdateNetworkSwitchRoutingOspfPutBodyAreasAreaType;
	}
	export interface UpdateNetworkSwitchRoutingOspfPutBodyAreasFormProperties {

		/**
		 * OSPF area ID
		 * Required
		 */
		areaId: FormControl<string | null | undefined>,

		/**
		 * Name of the OSPF area
		 * Required
		 */
		areaName: FormControl<string | null | undefined>,

		/**
		 * Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
		 * Required
		 */
		areaType: FormControl<UpdateNetworkSwitchRoutingOspfPutBodyAreasAreaType | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchRoutingOspfPutBodyAreasFormGroup() {
		return new FormGroup<UpdateNetworkSwitchRoutingOspfPutBodyAreasFormProperties>({
			areaId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			areaName: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			areaType: new FormControl<UpdateNetworkSwitchRoutingOspfPutBodyAreasAreaType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum UpdateNetworkSwitchRoutingOspfPutBodyAreasAreaType { normal = 'normal', nssa = 'nssa', stub = 'stub' }

	export interface UpdateNetworkSwitchRoutingOspfPutBodyMd5AuthenticationKey {

		/** MD5 authentication key index. Key index must be between 1 to 255 */
		id?: number | null;

		/** MD5 authentication passphrase */
		passphrase?: string | null;
	}
	export interface UpdateNetworkSwitchRoutingOspfPutBodyMd5AuthenticationKeyFormProperties {

		/** MD5 authentication key index. Key index must be between 1 to 255 */
		id: FormControl<number | null | undefined>,

		/** MD5 authentication passphrase */
		passphrase: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchRoutingOspfPutBodyMd5AuthenticationKeyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchRoutingOspfPutBodyMd5AuthenticationKeyFormProperties>({
			id: new FormControl<number | null | undefined>(undefined),
			passphrase: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchRoutingOspfPutBodyV3 {

		/** OSPF v3 areas */
		UpdateNetworkSwitchRoutingOspfPutBodyV3Areas?: Array<UpdateNetworkSwitchRoutingOspfPutBodyV3Areas>;

		/** Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535 */
		deadTimerInSeconds?: number | null;

		/** Boolean value to enable or disable V3 OSPF routing. OSPF V3 routing is disabled by default. */
		enabled?: boolean | null;

		/** Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds. */
		helloTimerInSeconds?: number | null;
	}
	export interface UpdateNetworkSwitchRoutingOspfPutBodyV3FormProperties {

		/** Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535 */
		deadTimerInSeconds: FormControl<number | null | undefined>,

		/** Boolean value to enable or disable V3 OSPF routing. OSPF V3 routing is disabled by default. */
		enabled: FormControl<boolean | null | undefined>,

		/** Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds. */
		helloTimerInSeconds: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchRoutingOspfPutBodyV3FormGroup() {
		return new FormGroup<UpdateNetworkSwitchRoutingOspfPutBodyV3FormProperties>({
			deadTimerInSeconds: new FormControl<number | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			helloTimerInSeconds: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchRoutingOspfPutBodyV3Areas {

		/**
		 * OSPF area ID
		 * Required
		 */
		areaId: string;

		/**
		 * Name of the OSPF area
		 * Required
		 */
		areaName: string;

		/**
		 * Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
		 * Required
		 */
		areaType: UpdateNetworkSwitchRoutingOspfPutBodyAreasAreaType;
	}
	export interface UpdateNetworkSwitchRoutingOspfPutBodyV3AreasFormProperties {

		/**
		 * OSPF area ID
		 * Required
		 */
		areaId: FormControl<string | null | undefined>,

		/**
		 * Name of the OSPF area
		 * Required
		 */
		areaName: FormControl<string | null | undefined>,

		/**
		 * Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
		 * Required
		 */
		areaType: FormControl<UpdateNetworkSwitchRoutingOspfPutBodyAreasAreaType | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchRoutingOspfPutBodyV3AreasFormGroup() {
		return new FormGroup<UpdateNetworkSwitchRoutingOspfPutBodyV3AreasFormProperties>({
			areaId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			areaName: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			areaType: new FormControl<UpdateNetworkSwitchRoutingOspfPutBodyAreasAreaType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkSwitchSettingsReturn {

		/** Exceptions on a per switch basis to "useCombinedPower" */
		GetNetworkSwitchSettingsReturnPowerExceptions?: Array<GetNetworkSwitchSettingsReturnPowerExceptions>;

		/** The use Combined Power as the default behavior of secondary power supplies on supported devices. */
		useCombinedPower?: boolean | null;

		/** Management VLAN */
		vlan?: number | null;
	}
	export interface GetNetworkSwitchSettingsReturnFormProperties {

		/** The use Combined Power as the default behavior of secondary power supplies on supported devices. */
		useCombinedPower: FormControl<boolean | null | undefined>,

		/** Management VLAN */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchSettingsReturnFormGroup() {
		return new FormGroup<GetNetworkSwitchSettingsReturnFormProperties>({
			useCombinedPower: new FormControl<boolean | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkSwitchSettingsReturnPowerExceptions {

		/** Per switch exception (combined, redundant, useNetworkSetting) */
		powerType?: GetNetworkSwitchSettingsReturnPowerExceptionsPowerType | null;

		/** Serial number of the switch */
		serial?: string | null;
	}
	export interface GetNetworkSwitchSettingsReturnPowerExceptionsFormProperties {

		/** Per switch exception (combined, redundant, useNetworkSetting) */
		powerType: FormControl<GetNetworkSwitchSettingsReturnPowerExceptionsPowerType | null | undefined>,

		/** Serial number of the switch */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchSettingsReturnPowerExceptionsFormGroup() {
		return new FormGroup<GetNetworkSwitchSettingsReturnPowerExceptionsFormProperties>({
			powerType: new FormControl<GetNetworkSwitchSettingsReturnPowerExceptionsPowerType | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetNetworkSwitchSettingsReturnPowerExceptionsPowerType { combined = 'combined', redundant = 'redundant', useNetworkSetting = 'useNetworkSetting' }

	export interface UpdateNetworkSwitchSettingsPutBody {

		/** Exceptions on a per switch basis to "useCombinedPower" */
		UpdateNetworkSwitchSettingsPutBodyPowerExceptions?: Array<UpdateNetworkSwitchSettingsPutBodyPowerExceptions>;

		/** The use Combined Power as the default behavior of secondary power supplies on supported devices. */
		useCombinedPower?: boolean | null;

		/** Management VLAN */
		vlan?: number | null;
	}
	export interface UpdateNetworkSwitchSettingsPutBodyFormProperties {

		/** The use Combined Power as the default behavior of secondary power supplies on supported devices. */
		useCombinedPower: FormControl<boolean | null | undefined>,

		/** Management VLAN */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchSettingsPutBodyFormProperties>({
			useCombinedPower: new FormControl<boolean | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchSettingsPutBodyPowerExceptions {

		/**
		 * Per switch exception (combined, redundant, useNetworkSetting)
		 * Required
		 */
		powerType: GetNetworkSwitchSettingsReturnPowerExceptionsPowerType;

		/**
		 * Serial number of the switch
		 * Required
		 */
		serial: string;
	}
	export interface UpdateNetworkSwitchSettingsPutBodyPowerExceptionsFormProperties {

		/**
		 * Per switch exception (combined, redundant, useNetworkSetting)
		 * Required
		 */
		powerType: FormControl<GetNetworkSwitchSettingsReturnPowerExceptionsPowerType | null | undefined>,

		/**
		 * Serial number of the switch
		 * Required
		 */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchSettingsPutBodyPowerExceptionsFormGroup() {
		return new FormGroup<UpdateNetworkSwitchSettingsPutBodyPowerExceptionsFormProperties>({
			powerType: new FormControl<GetNetworkSwitchSettingsReturnPowerExceptionsPowerType | null | undefined>(undefined, [Validators.required]),
			serial: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSwitchSettingsReturn {

		/** Exceptions on a per switch basis to "useCombinedPower" */
		UpdateNetworkSwitchSettingsReturnPowerExceptions?: Array<UpdateNetworkSwitchSettingsReturnPowerExceptions>;

		/** The use Combined Power as the default behavior of secondary power supplies on supported devices. */
		useCombinedPower?: boolean | null;

		/** Management VLAN */
		vlan?: number | null;
	}
	export interface UpdateNetworkSwitchSettingsReturnFormProperties {

		/** The use Combined Power as the default behavior of secondary power supplies on supported devices. */
		useCombinedPower: FormControl<boolean | null | undefined>,

		/** Management VLAN */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchSettingsReturnFormGroup() {
		return new FormGroup<UpdateNetworkSwitchSettingsReturnFormProperties>({
			useCombinedPower: new FormControl<boolean | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchSettingsReturnPowerExceptions {

		/** Per switch exception (combined, redundant, useNetworkSetting) */
		powerType?: GetNetworkSwitchSettingsReturnPowerExceptionsPowerType | null;

		/** Serial number of the switch */
		serial?: string | null;
	}
	export interface UpdateNetworkSwitchSettingsReturnPowerExceptionsFormProperties {

		/** Per switch exception (combined, redundant, useNetworkSetting) */
		powerType: FormControl<GetNetworkSwitchSettingsReturnPowerExceptionsPowerType | null | undefined>,

		/** Serial number of the switch */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchSettingsReturnPowerExceptionsFormGroup() {
		return new FormGroup<UpdateNetworkSwitchSettingsReturnPowerExceptionsFormProperties>({
			powerType: new FormControl<GetNetworkSwitchSettingsReturnPowerExceptionsPowerType | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchStackPostBody {

		/**
		 * The name of the new stack
		 * Required
		 */
		name: string;

		/**
		 * An array of switch serials to be added into the new stack
		 * Required
		 */
		serials: Array<string>;
	}
	export interface CreateNetworkSwitchStackPostBodyFormProperties {

		/**
		 * The name of the new stack
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchStackPostBodyFormGroup() {
		return new FormGroup<CreateNetworkSwitchStackPostBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkSwitchStackReturn {

		/** Switch stacks id */
		id?: string | null;

		/** Switch stacks name */
		name?: string | null;

		/** Serials of the switches in the switch stack */
		serials?: Array<string>;
	}
	export interface GetNetworkSwitchStackReturnFormProperties {

		/** Switch stacks id */
		id: FormControl<string | null | undefined>,

		/** Switch stacks name */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkSwitchStackReturnFormGroup() {
		return new FormGroup<GetNetworkSwitchStackReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface AddNetworkSwitchStackPostBody {

		/**
		 * The serial of the switch to be added
		 * Required
		 */
		serial: string;
	}
	export interface AddNetworkSwitchStackPostBodyFormProperties {

		/**
		 * The serial of the switch to be added
		 * Required
		 */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateAddNetworkSwitchStackPostBodyFormGroup() {
		return new FormGroup<AddNetworkSwitchStackPostBodyFormProperties>({
			serial: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface RemoveNetworkSwitchStackPostBody {

		/**
		 * The serial of the switch to be removed
		 * Required
		 */
		serial: string;
	}
	export interface RemoveNetworkSwitchStackPostBodyFormProperties {

		/**
		 * The serial of the switch to be removed
		 * Required
		 */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateRemoveNetworkSwitchStackPostBodyFormGroup() {
		return new FormGroup<RemoveNetworkSwitchStackPostBodyFormProperties>({
			serial: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSwitchStackRoutingInterfacePostBody {

		/** The next hop for any traffic that isn't going to a directly connected subnet or over a static route. This IP address must exist in a subnet with a routed interface. */
		defaultGateway?: string | null;

		/** The IP address this switch stack will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP. */
		interfaceIp?: string | null;

		/** The IPv6 settings of the interface. */
		ipv6?: CreateNetworkSwitchStackRoutingInterfacePostBodyIpv6;

		/** Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'. */
		multicastRouting?: CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceMulticastRouting | null;

		/**
		 * A friendly name or description for the interface or VLAN.
		 * Required
		 */
		name: string;

		/** The OSPF routing settings of the interface. */
		ospfSettings?: CreateNetworkSwitchStackRoutingInterfacePostBodyOspfSettings;

		/** The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24). */
		subnet?: string | null;

		/**
		 * The VLAN this routed interface is on. VLAN must be between 1 and 4094.
		 * Required
		 */
		vlanId: number;
	}
	export interface CreateNetworkSwitchStackRoutingInterfacePostBodyFormProperties {

		/** The next hop for any traffic that isn't going to a directly connected subnet or over a static route. This IP address must exist in a subnet with a routed interface. */
		defaultGateway: FormControl<string | null | undefined>,

		/** The IP address this switch stack will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP. */
		interfaceIp: FormControl<string | null | undefined>,

		/** Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'. */
		multicastRouting: FormControl<CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceMulticastRouting | null | undefined>,

		/**
		 * A friendly name or description for the interface or VLAN.
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/** The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24). */
		subnet: FormControl<string | null | undefined>,

		/**
		 * The VLAN this routed interface is on. VLAN must be between 1 and 4094.
		 * Required
		 */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkSwitchStackRoutingInterfacePostBodyFormGroup() {
		return new FormGroup<CreateNetworkSwitchStackRoutingInterfacePostBodyFormProperties>({
			defaultGateway: new FormControl<string | null | undefined>(undefined),
			interfaceIp: new FormControl<string | null | undefined>(undefined),
			multicastRouting: new FormControl<CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceMulticastRouting | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			subnet: new FormControl<string | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkSwitchStackRoutingInterfacePostBodyIpv6 {

		/** The IPv6 address of the interface. Required if assignmentMode is 'static'. Must not be included if assignmentMode is 'eui-64'. */
		address?: string | null;

		/** The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'. */
		assignmentMode?: string | null;

		/** The IPv6 default gateway of the interface. Required if prefix is defined and this is the first interface with IPv6 configured for the stack. */
		gateway?: string | null;

		/** The IPv6 prefix of the interface. Required if IPv6 object is included. */
		prefix?: string | null;
	}
	export interface CreateNetworkSwitchStackRoutingInterfacePostBodyIpv6FormProperties {

		/** The IPv6 address of the interface. Required if assignmentMode is 'static'. Must not be included if assignmentMode is 'eui-64'. */
		address: FormControl<string | null | undefined>,

		/** The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'. */
		assignmentMode: FormControl<string | null | undefined>,

		/** The IPv6 default gateway of the interface. Required if prefix is defined and this is the first interface with IPv6 configured for the stack. */
		gateway: FormControl<string | null | undefined>,

		/** The IPv6 prefix of the interface. Required if IPv6 object is included. */
		prefix: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkSwitchStackRoutingInterfacePostBodyIpv6FormGroup() {
		return new FormGroup<CreateNetworkSwitchStackRoutingInterfacePostBodyIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<string | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkSwitchStackRoutingInterfacePostBodyOspfSettings {

		/** The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an existing OSPF area. Defaults to 'disabled'. */
		area?: string | null;

		/** The path cost for this interface. Defaults to 1, but can be increased up to 65535 to give lower priority. */
		cost?: number | null;

		/** When enabled, OSPF will not run on the interface, but the subnet will still be advertised. */
		isPassiveEnabled?: boolean | null;
	}
	export interface CreateNetworkSwitchStackRoutingInterfacePostBodyOspfSettingsFormProperties {

		/** The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an existing OSPF area. Defaults to 'disabled'. */
		area: FormControl<string | null | undefined>,

		/** The path cost for this interface. Defaults to 1, but can be increased up to 65535 to give lower priority. */
		cost: FormControl<number | null | undefined>,

		/** When enabled, OSPF will not run on the interface, but the subnet will still be advertised. */
		isPassiveEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateNetworkSwitchStackRoutingInterfacePostBodyOspfSettingsFormGroup() {
		return new FormGroup<CreateNetworkSwitchStackRoutingInterfacePostBodyOspfSettingsFormProperties>({
			area: new FormControl<string | null | undefined>(undefined),
			cost: new FormControl<number | null | undefined>(undefined),
			isPassiveEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchStackRoutingInterfacePutBody {

		/** The next hop for any traffic that isn't going to a directly connected subnet or over a static route. This IP address must exist in a subnet with a routed interface. */
		defaultGateway?: string | null;

		/** The IP address this switch stack will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP. */
		interfaceIp?: string | null;

		/** The IPv6 settings of the interface. */
		ipv6?: UpdateNetworkSwitchStackRoutingInterfacePutBodyIpv6;

		/** Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'. */
		multicastRouting?: CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceMulticastRouting | null;

		/** A friendly name or description for the interface or VLAN. */
		name?: string | null;

		/** The OSPF routing settings of the interface. */
		ospfSettings?: UpdateNetworkSwitchStackRoutingInterfacePutBodyOspfSettings;

		/** The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24). */
		subnet?: string | null;

		/** The VLAN this routed interface is on. VLAN must be between 1 and 4094. */
		vlanId?: number | null;
	}
	export interface UpdateNetworkSwitchStackRoutingInterfacePutBodyFormProperties {

		/** The next hop for any traffic that isn't going to a directly connected subnet or over a static route. This IP address must exist in a subnet with a routed interface. */
		defaultGateway: FormControl<string | null | undefined>,

		/** The IP address this switch stack will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP. */
		interfaceIp: FormControl<string | null | undefined>,

		/** Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'. */
		multicastRouting: FormControl<CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceMulticastRouting | null | undefined>,

		/** A friendly name or description for the interface or VLAN. */
		name: FormControl<string | null | undefined>,

		/** The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24). */
		subnet: FormControl<string | null | undefined>,

		/** The VLAN this routed interface is on. VLAN must be between 1 and 4094. */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchStackRoutingInterfacePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchStackRoutingInterfacePutBodyFormProperties>({
			defaultGateway: new FormControl<string | null | undefined>(undefined),
			interfaceIp: new FormControl<string | null | undefined>(undefined),
			multicastRouting: new FormControl<CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceMulticastRouting | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			subnet: new FormControl<string | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchStackRoutingInterfacePutBodyIpv6 {

		/** The IPv6 address of the interface. Required if assignmentMode is included and set as 'static'. Must not be included if assignmentMode is 'eui-64'. */
		address?: string | null;

		/** The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'. */
		assignmentMode?: string | null;

		/** The IPv6 default gateway of the interface. Required if prefix is defined and this is the first interface with IPv6 configured for the stack. */
		gateway?: string | null;

		/** The IPv6 prefix of the interface. Required if IPv6 object is included and interface does not already have ipv6.prefix configured */
		prefix?: string | null;
	}
	export interface UpdateNetworkSwitchStackRoutingInterfacePutBodyIpv6FormProperties {

		/** The IPv6 address of the interface. Required if assignmentMode is included and set as 'static'. Must not be included if assignmentMode is 'eui-64'. */
		address: FormControl<string | null | undefined>,

		/** The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'. */
		assignmentMode: FormControl<string | null | undefined>,

		/** The IPv6 default gateway of the interface. Required if prefix is defined and this is the first interface with IPv6 configured for the stack. */
		gateway: FormControl<string | null | undefined>,

		/** The IPv6 prefix of the interface. Required if IPv6 object is included and interface does not already have ipv6.prefix configured */
		prefix: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchStackRoutingInterfacePutBodyIpv6FormGroup() {
		return new FormGroup<UpdateNetworkSwitchStackRoutingInterfacePutBodyIpv6FormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<string | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			prefix: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchStackRoutingInterfacePutBodyOspfSettings {

		/** The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an existing OSPF area. */
		area?: string | null;

		/** The path cost for this interface. Defaults to 1, but can be increased up to 65535 to give lower priority. */
		cost?: number | null;

		/** When enabled, OSPF will not run on the interface, but the subnet will still be advertised. */
		isPassiveEnabled?: boolean | null;
	}
	export interface UpdateNetworkSwitchStackRoutingInterfacePutBodyOspfSettingsFormProperties {

		/** The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an existing OSPF area. */
		area: FormControl<string | null | undefined>,

		/** The path cost for this interface. Defaults to 1, but can be increased up to 65535 to give lower priority. */
		cost: FormControl<number | null | undefined>,

		/** When enabled, OSPF will not run on the interface, but the subnet will still be advertised. */
		isPassiveEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchStackRoutingInterfacePutBodyOspfSettingsFormGroup() {
		return new FormGroup<UpdateNetworkSwitchStackRoutingInterfacePutBodyOspfSettingsFormProperties>({
			area: new FormControl<string | null | undefined>(undefined),
			cost: new FormControl<number | null | undefined>(undefined),
			isPassiveEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBody {

		/** The PXE boot server file name for the DHCP server running on the switch stack interface */
		bootFileName?: string | null;

		/** The PXE boot server IP for the DHCP server running on the switch stack interface */
		bootNextServer?: string | null;

		/** Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface */
		bootOptionsEnabled?: boolean | null;

		/** The DHCP lease time config for the dhcp server running on switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week') */
		dhcpLeaseTime?: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null;

		/** The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer') */
		dhcpMode?: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpMode | null;

		/** Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface */
		UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyDhcpOptions?: Array<UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyDhcpOptions>;

		/** The DHCP relay server IPs to which DHCP packets would get relayed for the switch stack interface */
		dhcpRelayServerIps?: Array<string>;

		/** The DHCP name server IPs when DHCP name server option is 'custom' */
		dnsCustomNameservers?: Array<string>;

		/** The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom') */
		dnsNameserversOption?: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDnsNameserversOption | null;

		/** Array of DHCP fixed IP assignments for the DHCP server running on the switch stack interface */
		UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyFixedIpAssignments?: Array<UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyFixedIpAssignments>;

		/** Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface */
		UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyReservedIpRanges?: Array<UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyReservedIpRanges>;
	}
	export interface UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyFormProperties {

		/** The PXE boot server file name for the DHCP server running on the switch stack interface */
		bootFileName: FormControl<string | null | undefined>,

		/** The PXE boot server IP for the DHCP server running on the switch stack interface */
		bootNextServer: FormControl<string | null | undefined>,

		/** Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface */
		bootOptionsEnabled: FormControl<boolean | null | undefined>,

		/** The DHCP lease time config for the dhcp server running on switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week') */
		dhcpLeaseTime: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>,

		/** The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer') */
		dhcpMode: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpMode | null | undefined>,

		/** The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom') */
		dnsNameserversOption: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDnsNameserversOption | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyFormProperties>({
			bootFileName: new FormControl<string | null | undefined>(undefined),
			bootNextServer: new FormControl<string | null | undefined>(undefined),
			bootOptionsEnabled: new FormControl<boolean | null | undefined>(undefined),
			dhcpLeaseTime: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime | null | undefined>(undefined),
			dhcpMode: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpMode | null | undefined>(undefined),
			dnsNameserversOption: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDnsNameserversOption | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyDhcpOptions {

		/**
		 * The code for DHCP option which should be from 2 to 254
		 * Required
		 */
		code: string;

		/**
		 * The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
		 * Required
		 */
		type: UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType;

		/**
		 * The value of the DHCP option
		 * Required
		 */
		value: string;
	}
	export interface UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyDhcpOptionsFormProperties {

		/**
		 * The code for DHCP option which should be from 2 to 254
		 * Required
		 */
		code: FormControl<string | null | undefined>,

		/**
		 * The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
		 * Required
		 */
		type: FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType | null | undefined>,

		/**
		 * The value of the DHCP option
		 * Required
		 */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyDhcpOptionsFormGroup() {
		return new FormGroup<UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyDhcpOptionsFormProperties>({
			code: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			type: new FormControl<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType | null | undefined>(undefined, [Validators.required]),
			value: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyFixedIpAssignments {

		/**
		 * The IP address of the client which has fixed IP address assigned to it
		 * Required
		 */
		ip: string;

		/**
		 * The MAC address of the client which has fixed IP address
		 * Required
		 */
		mac: string;

		/**
		 * The name of the client which has fixed IP address
		 * Required
		 */
		name: string;
	}
	export interface UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyFixedIpAssignmentsFormProperties {

		/**
		 * The IP address of the client which has fixed IP address assigned to it
		 * Required
		 */
		ip: FormControl<string | null | undefined>,

		/**
		 * The MAC address of the client which has fixed IP address
		 * Required
		 */
		mac: FormControl<string | null | undefined>,

		/**
		 * The name of the client which has fixed IP address
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyFixedIpAssignmentsFormGroup() {
		return new FormGroup<UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyFixedIpAssignmentsFormProperties>({
			ip: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			mac: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyReservedIpRanges {

		/** The comment for the reserved IP range */
		comment?: string | null;

		/**
		 * The ending IP address of the reserved IP range
		 * Required
		 */
		end: string;

		/**
		 * The starting IP address of the reserved IP range
		 * Required
		 */
		start: string;
	}
	export interface UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyReservedIpRangesFormProperties {

		/** The comment for the reserved IP range */
		comment: FormControl<string | null | undefined>,

		/**
		 * The ending IP address of the reserved IP range
		 * Required
		 */
		end: FormControl<string | null | undefined>,

		/**
		 * The starting IP address of the reserved IP range
		 * Required
		 */
		start: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyReservedIpRangesFormGroup() {
		return new FormGroup<UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyReservedIpRangesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			end: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			start: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkSwitchStormControlReturn {

		/** Broadcast threshold. */
		broadcastThreshold?: number | null;

		/** Multicast threshold. */
		multicastThreshold?: number | null;

		/** Unknown Unicast threshold. */
		unknownUnicastThreshold?: number | null;
	}
	export interface GetNetworkSwitchStormControlReturnFormProperties {

		/** Broadcast threshold. */
		broadcastThreshold: FormControl<number | null | undefined>,

		/** Multicast threshold. */
		multicastThreshold: FormControl<number | null | undefined>,

		/** Unknown Unicast threshold. */
		unknownUnicastThreshold: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSwitchStormControlReturnFormGroup() {
		return new FormGroup<GetNetworkSwitchStormControlReturnFormProperties>({
			broadcastThreshold: new FormControl<number | null | undefined>(undefined),
			multicastThreshold: new FormControl<number | null | undefined>(undefined),
			unknownUnicastThreshold: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchStormControlPutBody {

		/** Percentage (1 to 99) of total available port bandwidth for broadcast traffic type. Default value 100 percent rate is to clear the configuration. */
		broadcastThreshold?: number | null;

		/** Percentage (1 to 99) of total available port bandwidth for multicast traffic type. Default value 100 percent rate is to clear the configuration. */
		multicastThreshold?: number | null;

		/** Percentage (1 to 99) of total available port bandwidth for unknown unicast (dlf-destination lookup failure) traffic type. Default value 100 percent rate is to clear the configuration. */
		unknownUnicastThreshold?: number | null;
	}
	export interface UpdateNetworkSwitchStormControlPutBodyFormProperties {

		/** Percentage (1 to 99) of total available port bandwidth for broadcast traffic type. Default value 100 percent rate is to clear the configuration. */
		broadcastThreshold: FormControl<number | null | undefined>,

		/** Percentage (1 to 99) of total available port bandwidth for multicast traffic type. Default value 100 percent rate is to clear the configuration. */
		multicastThreshold: FormControl<number | null | undefined>,

		/** Percentage (1 to 99) of total available port bandwidth for unknown unicast (dlf-destination lookup failure) traffic type. Default value 100 percent rate is to clear the configuration. */
		unknownUnicastThreshold: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchStormControlPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchStormControlPutBodyFormProperties>({
			broadcastThreshold: new FormControl<number | null | undefined>(undefined),
			multicastThreshold: new FormControl<number | null | undefined>(undefined),
			unknownUnicastThreshold: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchStpPutBody {

		/** The spanning tree protocol status in network */
		rstpEnabled?: boolean | null;

		/** STP bridge priority for switches/stacks or switch profiles. An empty array will clear the STP bridge priority settings. */
		UpdateNetworkSwitchStpPutBodyStpBridgePriority?: Array<UpdateNetworkSwitchStpPutBodyStpBridgePriority>;
	}
	export interface UpdateNetworkSwitchStpPutBodyFormProperties {

		/** The spanning tree protocol status in network */
		rstpEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchStpPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSwitchStpPutBodyFormProperties>({
			rstpEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSwitchStpPutBodyStpBridgePriority {

		/** List of stack IDs */
		stacks?: Array<string>;

		/**
		 * STP priority for switch, stacks, or switch profiles
		 * Required
		 */
		stpPriority: number;

		/** List of switch profile IDs */
		switchProfiles?: Array<string>;

		/** List of switch serial numbers */
		switches?: Array<string>;
	}
	export interface UpdateNetworkSwitchStpPutBodyStpBridgePriorityFormProperties {

		/**
		 * STP priority for switch, stacks, or switch profiles
		 * Required
		 */
		stpPriority: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSwitchStpPutBodyStpBridgePriorityFormGroup() {
		return new FormGroup<UpdateNetworkSwitchStpPutBodyStpBridgePriorityFormProperties>({
			stpPriority: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkSyslogServersReturn {

		/** List of the syslog servers for this network */
		GetNetworkSyslogServersReturnServers?: Array<GetNetworkSyslogServersReturnServers>;
	}
	export interface GetNetworkSyslogServersReturnFormProperties {
	}
	export function CreateGetNetworkSyslogServersReturnFormGroup() {
		return new FormGroup<GetNetworkSyslogServersReturnFormProperties>({
		});

	}

	export interface GetNetworkSyslogServersReturnServers {

		/** The IP address of the syslog server */
		host?: string | null;

		/** The port of the syslog server */
		port?: number | null;

		/** A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events' */
		roles?: Array<string>;
	}
	export interface GetNetworkSyslogServersReturnServersFormProperties {

		/** The IP address of the syslog server */
		host: FormControl<string | null | undefined>,

		/** The port of the syslog server */
		port: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkSyslogServersReturnServersFormGroup() {
		return new FormGroup<GetNetworkSyslogServersReturnServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkSyslogServersPutBody {

		/**
		 * A list of the syslog servers for this network
		 * Required
		 */
		UpdateNetworkSyslogServersPutBodyServers: Array<UpdateNetworkSyslogServersPutBodyServers>;
	}
	export interface UpdateNetworkSyslogServersPutBodyFormProperties {
	}
	export function CreateUpdateNetworkSyslogServersPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkSyslogServersPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkSyslogServersPutBodyServers {

		/**
		 * The IP address of the syslog server
		 * Required
		 */
		host: string;

		/**
		 * The port of the syslog server
		 * Required
		 */
		port: number;

		/**
		 * A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
		 * Required
		 */
		roles: Array<string>;
	}
	export interface UpdateNetworkSyslogServersPutBodyServersFormProperties {

		/**
		 * The IP address of the syslog server
		 * Required
		 */
		host: FormControl<string | null | undefined>,

		/**
		 * The port of the syslog server
		 * Required
		 */
		port: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSyslogServersPutBodyServersFormGroup() {
		return new FormGroup<UpdateNetworkSyslogServersPutBodyServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			port: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkSyslogServersReturn {

		/** List of the syslog servers for this network */
		UpdateNetworkSyslogServersReturnServers?: Array<UpdateNetworkSyslogServersReturnServers>;
	}
	export interface UpdateNetworkSyslogServersReturnFormProperties {
	}
	export function CreateUpdateNetworkSyslogServersReturnFormGroup() {
		return new FormGroup<UpdateNetworkSyslogServersReturnFormProperties>({
		});

	}

	export interface UpdateNetworkSyslogServersReturnServers {

		/** The IP address of the syslog server */
		host?: string | null;

		/** The port of the syslog server */
		port?: number | null;

		/** A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events' */
		roles?: Array<string>;
	}
	export interface UpdateNetworkSyslogServersReturnServersFormProperties {

		/** The IP address of the syslog server */
		host: FormControl<string | null | undefined>,

		/** The port of the syslog server */
		port: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkSyslogServersReturnServersFormGroup() {
		return new FormGroup<UpdateNetworkSyslogServersReturnServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum GetNetworkTrafficDeviceType { appliance = 'appliance', combined = 'combined', switch = 'switch', wireless = 'wireless' }

	export interface UpdateNetworkTrafficAnalysisPutBody {

		/** The list of items that make up the custom pie chart for traffic reporting. */
		UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItems?: Array<UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItems>;

		/**
		 * The traffic analysis mode for the network. Can be one of 'disabled' (do not collect traffic types),
		 * 'basic' (collect generic traffic categories), or 'detailed' (collect destination hostnames).
		 */
		mode?: UpdateNetworkTrafficAnalysisPutBodyMode | null;
	}
	export interface UpdateNetworkTrafficAnalysisPutBodyFormProperties {

		/**
		 * The traffic analysis mode for the network. Can be one of 'disabled' (do not collect traffic types),
		 * 'basic' (collect generic traffic categories), or 'detailed' (collect destination hostnames).
		 */
		mode: FormControl<UpdateNetworkTrafficAnalysisPutBodyMode | null | undefined>,
	}
	export function CreateUpdateNetworkTrafficAnalysisPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkTrafficAnalysisPutBodyFormProperties>({
			mode: new FormControl<UpdateNetworkTrafficAnalysisPutBodyMode | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItems {

		/**
		 * The name of the custom pie chart item.
		 * Required
		 */
		name: string;

		/**
		 * The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
		 * Required
		 */
		type: UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItemsType;

		/**
		 * The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
		 * (see sample request/response for more details).
		 * Required
		 */
		value: string;
	}
	export interface UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItemsFormProperties {

		/**
		 * The name of the custom pie chart item.
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/**
		 * The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
		 * Required
		 */
		type: FormControl<UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItemsType | null | undefined>,

		/**
		 * The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
		 * (see sample request/response for more details).
		 * Required
		 */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkTrafficAnalysisPutBodyCustomPieChartItemsFormGroup() {
		return new FormGroup<UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItemsFormProperties>({
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			type: new FormControl<UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItemsType | null | undefined>(undefined, [Validators.required]),
			value: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItemsType { host = 'host', ipRange = 'ipRange', port = 'port' }

	export enum UpdateNetworkTrafficAnalysisPutBodyMode { basic = 'basic', detailed = 'detailed', disabled = 'disabled' }

	export interface UnbindNetworkPostBody {

		/** Optional boolean to retain all the current configs given by the template. */
		retainConfigs?: boolean | null;
	}
	export interface UnbindNetworkPostBodyFormProperties {

		/** Optional boolean to retain all the current configs given by the template. */
		retainConfigs: FormControl<boolean | null | undefined>,
	}
	export function CreateUnbindNetworkPostBodyFormGroup() {
		return new FormGroup<UnbindNetworkPostBodyFormProperties>({
			retainConfigs: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UnbindNetworkReturn {

		/** Enrollment string for the network */
		enrollmentString?: string | null;

		/** Network ID */
		id?: string | null;

		/** If the network is bound to a config template */
		isBoundToConfigTemplate?: boolean | null;

		/** Network name */
		name?: string | null;

		/** Notes for the network */
		notes?: string | null;

		/** Organization ID */
		organizationId?: string | null;

		/** List of the product types that the network supports */
		productTypes?: Array<string>;

		/** Network tags */
		tags?: Array<string>;

		/** Timezone of the network */
		timeZone?: string | null;

		/** URL to the network Dashboard UI */
		url?: string | null;
	}
	export interface UnbindNetworkReturnFormProperties {

		/** Enrollment string for the network */
		enrollmentString: FormControl<string | null | undefined>,

		/** Network ID */
		id: FormControl<string | null | undefined>,

		/** If the network is bound to a config template */
		isBoundToConfigTemplate: FormControl<boolean | null | undefined>,

		/** Network name */
		name: FormControl<string | null | undefined>,

		/** Notes for the network */
		notes: FormControl<string | null | undefined>,

		/** Organization ID */
		organizationId: FormControl<string | null | undefined>,

		/** Timezone of the network */
		timeZone: FormControl<string | null | undefined>,

		/** URL to the network Dashboard UI */
		url: FormControl<string | null | undefined>,
	}
	export function CreateUnbindNetworkReturnFormGroup() {
		return new FormGroup<UnbindNetworkReturnFormProperties>({
			enrollmentString: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isBoundToConfigTemplate: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
			organizationId: new FormControl<string | null | undefined>(undefined),
			timeZone: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWebhooksHttpServersReturn {

		/** A Base64 encoded ID. */
		id?: string | null;

		/** A name for easy reference to the HTTP server */
		name?: string | null;

		/** A Meraki network ID. */
		networkId?: string | null;

		/** The payload template to use when posting data to the HTTP server. */
		payloadTemplate?: GetNetworkWebhooksHttpServersReturnPayloadTemplate;

		/** The URL of the HTTP server. */
		url?: string | null;
	}
	export interface GetNetworkWebhooksHttpServersReturnFormProperties {

		/** A Base64 encoded ID. */
		id: FormControl<string | null | undefined>,

		/** A name for easy reference to the HTTP server */
		name: FormControl<string | null | undefined>,

		/** A Meraki network ID. */
		networkId: FormControl<string | null | undefined>,

		/** The URL of the HTTP server. */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWebhooksHttpServersReturnFormGroup() {
		return new FormGroup<GetNetworkWebhooksHttpServersReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWebhooksHttpServersReturnPayloadTemplate {

		/** The name of the payload template. */
		name?: string | null;

		/** The ID of the payload template. */
		payloadTemplateId?: string | null;
	}
	export interface GetNetworkWebhooksHttpServersReturnPayloadTemplateFormProperties {

		/** The name of the payload template. */
		name: FormControl<string | null | undefined>,

		/** The ID of the payload template. */
		payloadTemplateId: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWebhooksHttpServersReturnPayloadTemplateFormGroup() {
		return new FormGroup<GetNetworkWebhooksHttpServersReturnPayloadTemplateFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			payloadTemplateId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWebhooksHttpServerPostBody {

		/**
		 * A name for easy reference to the HTTP server
		 * Required
		 */
		name: string;

		/** The payload template to use when posting data to the HTTP server. */
		payloadTemplate?: CreateNetworkWebhooksHttpServerPostBodyPayloadTemplate;

		/** A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki. */
		sharedSecret?: string | null;

		/**
		 * The URL of the HTTP server. Once set, cannot be updated.
		 * Required
		 */
		url: string;
	}
	export interface CreateNetworkWebhooksHttpServerPostBodyFormProperties {

		/**
		 * A name for easy reference to the HTTP server
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/** A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki. */
		sharedSecret: FormControl<string | null | undefined>,

		/**
		 * The URL of the HTTP server. Once set, cannot be updated.
		 * Required
		 */
		url: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkWebhooksHttpServerPostBodyFormGroup() {
		return new FormGroup<CreateNetworkWebhooksHttpServerPostBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			sharedSecret: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkWebhooksHttpServerPostBodyPayloadTemplate {

		/** The name of the payload template. */
		name?: string | null;

		/** The ID of the payload template. Defaults to 'wpt_00001' for the Meraki template. For Meraki-included templates: for the Webex (included) template use 'wpt_00002'; for the Slack (included) template use 'wpt_00003'; for the Microsoft Teams (included) template use 'wpt_00004'; for the ServiceNow (included) template use 'wpt_00006' */
		payloadTemplateId?: string | null;
	}
	export interface CreateNetworkWebhooksHttpServerPostBodyPayloadTemplateFormProperties {

		/** The name of the payload template. */
		name: FormControl<string | null | undefined>,

		/** The ID of the payload template. Defaults to 'wpt_00001' for the Meraki template. For Meraki-included templates: for the Webex (included) template use 'wpt_00002'; for the Slack (included) template use 'wpt_00003'; for the Microsoft Teams (included) template use 'wpt_00004'; for the ServiceNow (included) template use 'wpt_00006' */
		payloadTemplateId: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkWebhooksHttpServerPostBodyPayloadTemplateFormGroup() {
		return new FormGroup<CreateNetworkWebhooksHttpServerPostBodyPayloadTemplateFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			payloadTemplateId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWebhooksHttpServerReturn {

		/** A Base64 encoded ID. */
		id?: string | null;

		/** A name for easy reference to the HTTP server */
		name?: string | null;

		/** A Meraki network ID. */
		networkId?: string | null;

		/** The payload template to use when posting data to the HTTP server. */
		payloadTemplate?: GetNetworkWebhooksHttpServerReturnPayloadTemplate;

		/** The URL of the HTTP server. */
		url?: string | null;
	}
	export interface GetNetworkWebhooksHttpServerReturnFormProperties {

		/** A Base64 encoded ID. */
		id: FormControl<string | null | undefined>,

		/** A name for easy reference to the HTTP server */
		name: FormControl<string | null | undefined>,

		/** A Meraki network ID. */
		networkId: FormControl<string | null | undefined>,

		/** The URL of the HTTP server. */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWebhooksHttpServerReturnFormGroup() {
		return new FormGroup<GetNetworkWebhooksHttpServerReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWebhooksHttpServerReturnPayloadTemplate {

		/** The name of the payload template. */
		name?: string | null;

		/** The ID of the payload template. */
		payloadTemplateId?: string | null;
	}
	export interface GetNetworkWebhooksHttpServerReturnPayloadTemplateFormProperties {

		/** The name of the payload template. */
		name: FormControl<string | null | undefined>,

		/** The ID of the payload template. */
		payloadTemplateId: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWebhooksHttpServerReturnPayloadTemplateFormGroup() {
		return new FormGroup<GetNetworkWebhooksHttpServerReturnPayloadTemplateFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			payloadTemplateId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWebhooksHttpServerPutBody {

		/** A name for easy reference to the HTTP server */
		name?: string | null;

		/** The payload template to use when posting data to the HTTP server. */
		payloadTemplate?: UpdateNetworkWebhooksHttpServerPutBodyPayloadTemplate;

		/** A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki. */
		sharedSecret?: string | null;
	}
	export interface UpdateNetworkWebhooksHttpServerPutBodyFormProperties {

		/** A name for easy reference to the HTTP server */
		name: FormControl<string | null | undefined>,

		/** A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki. */
		sharedSecret: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWebhooksHttpServerPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWebhooksHttpServerPutBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			sharedSecret: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWebhooksHttpServerPutBodyPayloadTemplate {

		/** The ID of the payload template. Defaults to 'wpt_00001' for the Meraki template. For Meraki-included templates: for the Webex (included) template use 'wpt_00002'; for the Slack (included) template use 'wpt_00003'; for the Microsoft Teams (included) template use 'wpt_00004'; for the ServiceNow (included) template use 'wpt_00006' */
		payloadTemplateId?: string | null;
	}
	export interface UpdateNetworkWebhooksHttpServerPutBodyPayloadTemplateFormProperties {

		/** The ID of the payload template. Defaults to 'wpt_00001' for the Meraki template. For Meraki-included templates: for the Webex (included) template use 'wpt_00002'; for the Slack (included) template use 'wpt_00003'; for the Microsoft Teams (included) template use 'wpt_00004'; for the ServiceNow (included) template use 'wpt_00006' */
		payloadTemplateId: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWebhooksHttpServerPutBodyPayloadTemplateFormGroup() {
		return new FormGroup<UpdateNetworkWebhooksHttpServerPutBodyPayloadTemplateFormProperties>({
			payloadTemplateId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWebhooksHttpServerReturn {

		/** A Base64 encoded ID. */
		id?: string | null;

		/** A name for easy reference to the HTTP server */
		name?: string | null;

		/** A Meraki network ID. */
		networkId?: string | null;

		/** The payload template to use when posting data to the HTTP server. */
		payloadTemplate?: UpdateNetworkWebhooksHttpServerReturnPayloadTemplate;

		/** The URL of the HTTP server. */
		url?: string | null;
	}
	export interface UpdateNetworkWebhooksHttpServerReturnFormProperties {

		/** A Base64 encoded ID. */
		id: FormControl<string | null | undefined>,

		/** A name for easy reference to the HTTP server */
		name: FormControl<string | null | undefined>,

		/** A Meraki network ID. */
		networkId: FormControl<string | null | undefined>,

		/** The URL of the HTTP server. */
		url: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWebhooksHttpServerReturnFormGroup() {
		return new FormGroup<UpdateNetworkWebhooksHttpServerReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWebhooksHttpServerReturnPayloadTemplate {

		/** The name of the payload template. */
		name?: string | null;

		/** The ID of the payload template. */
		payloadTemplateId?: string | null;
	}
	export interface UpdateNetworkWebhooksHttpServerReturnPayloadTemplateFormProperties {

		/** The name of the payload template. */
		name: FormControl<string | null | undefined>,

		/** The ID of the payload template. */
		payloadTemplateId: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWebhooksHttpServerReturnPayloadTemplateFormGroup() {
		return new FormGroup<UpdateNetworkWebhooksHttpServerReturnPayloadTemplateFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			payloadTemplateId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWebhooksPayloadTemplatesReturn {

		/** The body of the payload template, in liquid template */
		body?: string | null;

		/** The payload template headers, will be rendered as a key-value pair in the webhook. */
		GetNetworkWebhooksPayloadTemplatesReturnHeaders?: Array<GetNetworkWebhooksPayloadTemplatesReturnHeaders>;

		/** The name of the payload template */
		name?: string | null;

		/** Webhook payload template Id */
		payloadTemplateId?: string | null;

		/** The type of the payload template */
		type?: string | null;
	}
	export interface GetNetworkWebhooksPayloadTemplatesReturnFormProperties {

		/** The body of the payload template, in liquid template */
		body: FormControl<string | null | undefined>,

		/** The name of the payload template */
		name: FormControl<string | null | undefined>,

		/** Webhook payload template Id */
		payloadTemplateId: FormControl<string | null | undefined>,

		/** The type of the payload template */
		type: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWebhooksPayloadTemplatesReturnFormGroup() {
		return new FormGroup<GetNetworkWebhooksPayloadTemplatesReturnFormProperties>({
			body: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			payloadTemplateId: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWebhooksPayloadTemplatesReturnHeaders {

		/** The name of the header attribute */
		name?: string | null;

		/** The value returned in the header attribute, in liquid template */
		template?: string | null;
	}
	export interface GetNetworkWebhooksPayloadTemplatesReturnHeadersFormProperties {

		/** The name of the header attribute */
		name: FormControl<string | null | undefined>,

		/** The value returned in the header attribute, in liquid template */
		template: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWebhooksPayloadTemplatesReturnHeadersFormGroup() {
		return new FormGroup<GetNetworkWebhooksPayloadTemplatesReturnHeadersFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			template: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWebhooksPayloadTemplatePostBody {

		/** The liquid template used for the body of the webhook message. Either `body` or `bodyFile` must be specified. */
		body?: string | null;

		/** A file containing liquid template used for the body of the webhook message. Either `body` or `bodyFile` must be specified. */
		bodyFile?: string | null;

		/** The liquid template used with the webhook headers. */
		CreateNetworkWebhooksPayloadTemplatePostBodyHeaders?: Array<CreateNetworkWebhooksPayloadTemplatePostBodyHeaders>;

		/** A file containing the liquid template used with the webhook headers. */
		headersFile?: string | null;

		/**
		 * The name of the new template
		 * Required
		 */
		name: string;
	}
	export interface CreateNetworkWebhooksPayloadTemplatePostBodyFormProperties {

		/** The liquid template used for the body of the webhook message. Either `body` or `bodyFile` must be specified. */
		body: FormControl<string | null | undefined>,

		/** A file containing liquid template used for the body of the webhook message. Either `body` or `bodyFile` must be specified. */
		bodyFile: FormControl<string | null | undefined>,

		/** A file containing the liquid template used with the webhook headers. */
		headersFile: FormControl<string | null | undefined>,

		/**
		 * The name of the new template
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkWebhooksPayloadTemplatePostBodyFormGroup() {
		return new FormGroup<CreateNetworkWebhooksPayloadTemplatePostBodyFormProperties>({
			body: new FormControl<string | null | undefined>(undefined),
			bodyFile: new FormControl<string | null | undefined>(undefined),
			headersFile: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkWebhooksPayloadTemplatePostBodyHeaders {

		/** The name of the header template */
		name?: string | null;

		/** The liquid template for the headers */
		template?: string | null;
	}
	export interface CreateNetworkWebhooksPayloadTemplatePostBodyHeadersFormProperties {

		/** The name of the header template */
		name: FormControl<string | null | undefined>,

		/** The liquid template for the headers */
		template: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkWebhooksPayloadTemplatePostBodyHeadersFormGroup() {
		return new FormGroup<CreateNetworkWebhooksPayloadTemplatePostBodyHeadersFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			template: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWebhooksPayloadTemplateReturn {

		/** The body of the payload template, in liquid template */
		body?: string | null;

		/** The payload template headers, will be rendered as a key-value pair in the webhook. */
		GetNetworkWebhooksPayloadTemplateReturnHeaders?: Array<GetNetworkWebhooksPayloadTemplateReturnHeaders>;

		/** The name of the payload template */
		name?: string | null;

		/** Webhook payload template Id */
		payloadTemplateId?: string | null;

		/** The type of the payload template */
		type?: string | null;
	}
	export interface GetNetworkWebhooksPayloadTemplateReturnFormProperties {

		/** The body of the payload template, in liquid template */
		body: FormControl<string | null | undefined>,

		/** The name of the payload template */
		name: FormControl<string | null | undefined>,

		/** Webhook payload template Id */
		payloadTemplateId: FormControl<string | null | undefined>,

		/** The type of the payload template */
		type: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWebhooksPayloadTemplateReturnFormGroup() {
		return new FormGroup<GetNetworkWebhooksPayloadTemplateReturnFormProperties>({
			body: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			payloadTemplateId: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWebhooksPayloadTemplateReturnHeaders {

		/** The name of the header attribute */
		name?: string | null;

		/** The value returned in the header attribute, in liquid template */
		template?: string | null;
	}
	export interface GetNetworkWebhooksPayloadTemplateReturnHeadersFormProperties {

		/** The name of the header attribute */
		name: FormControl<string | null | undefined>,

		/** The value returned in the header attribute, in liquid template */
		template: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWebhooksPayloadTemplateReturnHeadersFormGroup() {
		return new FormGroup<GetNetworkWebhooksPayloadTemplateReturnHeadersFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			template: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWebhooksPayloadTemplatePutBody {

		/** The liquid template used for the body of the webhook message. */
		body?: string | null;

		/** A file containing liquid template used for the body of the webhook message. */
		bodyFile?: string | null;

		/** The liquid template used with the webhook headers. */
		UpdateNetworkWebhooksPayloadTemplatePutBodyHeaders?: Array<UpdateNetworkWebhooksPayloadTemplatePutBodyHeaders>;

		/** A file containing the liquid template used with the webhook headers. */
		headersFile?: string | null;

		/** The name of the template */
		name?: string | null;
	}
	export interface UpdateNetworkWebhooksPayloadTemplatePutBodyFormProperties {

		/** The liquid template used for the body of the webhook message. */
		body: FormControl<string | null | undefined>,

		/** A file containing liquid template used for the body of the webhook message. */
		bodyFile: FormControl<string | null | undefined>,

		/** A file containing the liquid template used with the webhook headers. */
		headersFile: FormControl<string | null | undefined>,

		/** The name of the template */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWebhooksPayloadTemplatePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWebhooksPayloadTemplatePutBodyFormProperties>({
			body: new FormControl<string | null | undefined>(undefined),
			bodyFile: new FormControl<string | null | undefined>(undefined),
			headersFile: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWebhooksPayloadTemplatePutBodyHeaders {

		/** The name of the header template */
		name?: string | null;

		/** The liquid template for the headers */
		template?: string | null;
	}
	export interface UpdateNetworkWebhooksPayloadTemplatePutBodyHeadersFormProperties {

		/** The name of the header template */
		name: FormControl<string | null | undefined>,

		/** The liquid template for the headers */
		template: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWebhooksPayloadTemplatePutBodyHeadersFormGroup() {
		return new FormGroup<UpdateNetworkWebhooksPayloadTemplatePutBodyHeadersFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			template: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWebhooksPayloadTemplateReturn {

		/** The body of the payload template, in liquid template */
		body?: string | null;

		/** The payload template headers, will be rendered as a key-value pair in the webhook. */
		UpdateNetworkWebhooksPayloadTemplateReturnHeaders?: Array<UpdateNetworkWebhooksPayloadTemplateReturnHeaders>;

		/** The name of the payload template */
		name?: string | null;

		/** Webhook payload template Id */
		payloadTemplateId?: string | null;

		/** The type of the payload template */
		type?: string | null;
	}
	export interface UpdateNetworkWebhooksPayloadTemplateReturnFormProperties {

		/** The body of the payload template, in liquid template */
		body: FormControl<string | null | undefined>,

		/** The name of the payload template */
		name: FormControl<string | null | undefined>,

		/** Webhook payload template Id */
		payloadTemplateId: FormControl<string | null | undefined>,

		/** The type of the payload template */
		type: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWebhooksPayloadTemplateReturnFormGroup() {
		return new FormGroup<UpdateNetworkWebhooksPayloadTemplateReturnFormProperties>({
			body: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			payloadTemplateId: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWebhooksPayloadTemplateReturnHeaders {

		/** The name of the header attribute */
		name?: string | null;

		/** The value returned in the header attribute, in liquid template */
		template?: string | null;
	}
	export interface UpdateNetworkWebhooksPayloadTemplateReturnHeadersFormProperties {

		/** The name of the header attribute */
		name: FormControl<string | null | undefined>,

		/** The value returned in the header attribute, in liquid template */
		template: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWebhooksPayloadTemplateReturnHeadersFormGroup() {
		return new FormGroup<UpdateNetworkWebhooksPayloadTemplateReturnHeadersFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			template: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWebhooksWebhookTestPostBody {

		/** The type of alert which the test webhook will send. Optional. Defaults to power_supply_down. */
		alertTypeId?: string | null;

		/** The ID of the payload template of the test webhook. Defaults to the HTTP server's template ID if one exists for the given URL, or Generic template ID otherwise */
		payloadTemplateId?: string | null;

		/** The name of the payload template. */
		payloadTemplateName?: string | null;

		/** The shared secret the test webhook will send. Optional. Defaults to an empty string. */
		sharedSecret?: string | null;

		/**
		 * The URL where the test webhook will be sent
		 * Required
		 */
		url: string;
	}
	export interface CreateNetworkWebhooksWebhookTestPostBodyFormProperties {

		/** The type of alert which the test webhook will send. Optional. Defaults to power_supply_down. */
		alertTypeId: FormControl<string | null | undefined>,

		/** The ID of the payload template of the test webhook. Defaults to the HTTP server's template ID if one exists for the given URL, or Generic template ID otherwise */
		payloadTemplateId: FormControl<string | null | undefined>,

		/** The name of the payload template. */
		payloadTemplateName: FormControl<string | null | undefined>,

		/** The shared secret the test webhook will send. Optional. Defaults to an empty string. */
		sharedSecret: FormControl<string | null | undefined>,

		/**
		 * The URL where the test webhook will be sent
		 * Required
		 */
		url: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkWebhooksWebhookTestPostBodyFormGroup() {
		return new FormGroup<CreateNetworkWebhooksWebhookTestPostBodyFormProperties>({
			alertTypeId: new FormControl<string | null | undefined>(undefined),
			payloadTemplateId: new FormControl<string | null | undefined>(undefined),
			payloadTemplateName: new FormControl<string | null | undefined>(undefined),
			sharedSecret: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkWebhooksWebhookTestReturn {

		/** Webhook delivery identifier */
		id?: string | null;

		/** Current status of the webhook delivery */
		status?: GetNetworkWebhooksWebhookTestReturnStatus | null;

		/** URL where the webhook was delivered */
		url?: string | null;
	}
	export interface GetNetworkWebhooksWebhookTestReturnFormProperties {

		/** Webhook delivery identifier */
		id: FormControl<string | null | undefined>,

		/** Current status of the webhook delivery */
		status: FormControl<GetNetworkWebhooksWebhookTestReturnStatus | null | undefined>,

		/** URL where the webhook was delivered */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWebhooksWebhookTestReturnFormGroup() {
		return new FormGroup<GetNetworkWebhooksWebhookTestReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<GetNetworkWebhooksWebhookTestReturnStatus | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetNetworkWebhooksWebhookTestReturnStatus { abandoned = 'abandoned', delivered = 'delivered', enqueued = 'enqueued', processing = 'processing', retrying = 'retrying' }

	export interface UpdateNetworkWirelessAlternateManagementInterfacePutBody {

		/** Array of access point serial number and IP assignment. Note: accessPoints IP assignment is not applicable for template networks, in other words, do not put 'accessPoints' in the body when updating template networks. Also, an empty 'accessPoints' array will remove all previous static IP assignments */
		UpdateNetworkWirelessAlternateManagementInterfacePutBodyAccessPoints?: Array<UpdateNetworkWirelessAlternateManagementInterfacePutBodyAccessPoints>;

		/** Boolean value to enable or disable alternate management interface */
		enabled?: boolean | null;

		/** Can be one or more of the following values: 'radius', 'snmp', 'syslog' or 'ldap' */
		protocols?: Array<string>;

		/** Alternate management interface VLAN, must be between 1 and 4094 */
		vlanId?: number | null;
	}
	export interface UpdateNetworkWirelessAlternateManagementInterfacePutBodyFormProperties {

		/** Boolean value to enable or disable alternate management interface */
		enabled: FormControl<boolean | null | undefined>,

		/** Alternate management interface VLAN, must be between 1 and 4094 */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessAlternateManagementInterfacePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessAlternateManagementInterfacePutBodyFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessAlternateManagementInterfacePutBodyAccessPoints {

		/**
		 * Wireless alternate management interface device IP. Provide an empty string to remove alternate management IP assignment
		 * Required
		 */
		alternateManagementIp: string;

		/** Primary DNS must be in IP format */
		dns1?: string | null;

		/** Optional secondary DNS must be in IP format */
		dns2?: string | null;

		/** Gateway must be in IP format */
		gateway?: string | null;

		/**
		 * Serial number of access point to be configured with alternate management IP
		 * Required
		 */
		serial: string;

		/** Subnet mask must be in IP format */
		subnetMask?: string | null;
	}
	export interface UpdateNetworkWirelessAlternateManagementInterfacePutBodyAccessPointsFormProperties {

		/**
		 * Wireless alternate management interface device IP. Provide an empty string to remove alternate management IP assignment
		 * Required
		 */
		alternateManagementIp: FormControl<string | null | undefined>,

		/** Primary DNS must be in IP format */
		dns1: FormControl<string | null | undefined>,

		/** Optional secondary DNS must be in IP format */
		dns2: FormControl<string | null | undefined>,

		/** Gateway must be in IP format */
		gateway: FormControl<string | null | undefined>,

		/**
		 * Serial number of access point to be configured with alternate management IP
		 * Required
		 */
		serial: FormControl<string | null | undefined>,

		/** Subnet mask must be in IP format */
		subnetMask: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessAlternateManagementInterfacePutBodyAccessPointsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessAlternateManagementInterfacePutBodyAccessPointsFormProperties>({
			alternateManagementIp: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			dns1: new FormControl<string | null | undefined>(undefined),
			dns2: new FormControl<string | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			subnetMask: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessBillingPutBody {

		/** The currency code of this node group's billing plans */
		currency?: string | null;

		/** Array of billing plans in the node group. (Can configure a maximum of 5) */
		UpdateNetworkWirelessBillingPutBodyPlans?: Array<UpdateNetworkWirelessBillingPutBodyPlans>;
	}
	export interface UpdateNetworkWirelessBillingPutBodyFormProperties {

		/** The currency code of this node group's billing plans */
		currency: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessBillingPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessBillingPutBodyFormProperties>({
			currency: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessBillingPutBodyPlans {

		/**
		 * The uplink bandwidth settings for the pricing plan.
		 * Required
		 */
		bandwidthLimits: UpdateNetworkWirelessBillingPutBodyPlansBandwidthLimits;

		/** The id of the pricing plan to update. */
		id?: string | null;

		/**
		 * The price of the billing plan.
		 * Required
		 */
		price: number;

		/**
		 * The time limit of the pricing plan in minutes. Can be '1 hour', '1 day', '1 week', or '30 days'.
		 * Required
		 */
		timeLimit: UpdateNetworkWirelessBillingPutBodyPlansTimeLimit;
	}
	export interface UpdateNetworkWirelessBillingPutBodyPlansFormProperties {

		/** The id of the pricing plan to update. */
		id: FormControl<string | null | undefined>,

		/**
		 * The price of the billing plan.
		 * Required
		 */
		price: FormControl<number | null | undefined>,

		/**
		 * The time limit of the pricing plan in minutes. Can be '1 hour', '1 day', '1 week', or '30 days'.
		 * Required
		 */
		timeLimit: FormControl<UpdateNetworkWirelessBillingPutBodyPlansTimeLimit | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessBillingPutBodyPlansFormGroup() {
		return new FormGroup<UpdateNetworkWirelessBillingPutBodyPlansFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			price: new FormControl<number | null | undefined>(undefined, [Validators.required]),
			timeLimit: new FormControl<UpdateNetworkWirelessBillingPutBodyPlansTimeLimit | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkWirelessBillingPutBodyPlansBandwidthLimits {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown?: number | null;

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp?: number | null;
	}
	export interface UpdateNetworkWirelessBillingPutBodyPlansBandwidthLimitsFormProperties {

		/** The maximum download limit (integer, in Kbps). null indicates no limit */
		limitDown: FormControl<number | null | undefined>,

		/** The maximum upload limit (integer, in Kbps). null indicates no limit */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessBillingPutBodyPlansBandwidthLimitsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessBillingPutBodyPlansBandwidthLimitsFormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessBillingPutBodyPlansTimeLimit { '1 day' = '1 day', '1 hour' = '1 hour', '1 week' = '1 week', '30 days' = '30 days' }

	export interface GetNetworkWirelessBluetoothSettingsReturn {

		/** Whether APs will advertise beacons. */
		advertisingEnabled?: boolean | null;

		/** Whether ESL is enabled on this network. */
		eslEnabled?: boolean | null;

		/** The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */
		major?: number | null;

		/** The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique') */
		majorMinorAssignmentMode?: string | null;

		/** The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */
		minor?: number | null;

		/** Whether APs will scan for Bluetooth enabled clients. */
		scanningEnabled?: boolean | null;

		/** The UUID to be used in the beacon identifier. */
		uuid?: string | null;
	}
	export interface GetNetworkWirelessBluetoothSettingsReturnFormProperties {

		/** Whether APs will advertise beacons. */
		advertisingEnabled: FormControl<boolean | null | undefined>,

		/** Whether ESL is enabled on this network. */
		eslEnabled: FormControl<boolean | null | undefined>,

		/** The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */
		major: FormControl<number | null | undefined>,

		/** The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique') */
		majorMinorAssignmentMode: FormControl<string | null | undefined>,

		/** The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */
		minor: FormControl<number | null | undefined>,

		/** Whether APs will scan for Bluetooth enabled clients. */
		scanningEnabled: FormControl<boolean | null | undefined>,

		/** The UUID to be used in the beacon identifier. */
		uuid: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWirelessBluetoothSettingsReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessBluetoothSettingsReturnFormProperties>({
			advertisingEnabled: new FormControl<boolean | null | undefined>(undefined),
			eslEnabled: new FormControl<boolean | null | undefined>(undefined),
			major: new FormControl<number | null | undefined>(undefined),
			majorMinorAssignmentMode: new FormControl<string | null | undefined>(undefined),
			minor: new FormControl<number | null | undefined>(undefined),
			scanningEnabled: new FormControl<boolean | null | undefined>(undefined),
			uuid: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessBluetoothSettingsPutBody {

		/** Whether APs will advertise beacons. */
		advertisingEnabled?: boolean | null;

		/** The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */
		major?: number | null;

		/** The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique') */
		majorMinorAssignmentMode?: UpdateNetworkWirelessBluetoothSettingsPutBodyMajorMinorAssignmentMode | null;

		/** The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */
		minor?: number | null;

		/** Whether APs will scan for Bluetooth enabled clients. */
		scanningEnabled?: boolean | null;

		/** The UUID to be used in the beacon identifier. */
		uuid?: string | null;
	}
	export interface UpdateNetworkWirelessBluetoothSettingsPutBodyFormProperties {

		/** Whether APs will advertise beacons. */
		advertisingEnabled: FormControl<boolean | null | undefined>,

		/** The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */
		major: FormControl<number | null | undefined>,

		/** The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique') */
		majorMinorAssignmentMode: FormControl<UpdateNetworkWirelessBluetoothSettingsPutBodyMajorMinorAssignmentMode | null | undefined>,

		/** The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */
		minor: FormControl<number | null | undefined>,

		/** Whether APs will scan for Bluetooth enabled clients. */
		scanningEnabled: FormControl<boolean | null | undefined>,

		/** The UUID to be used in the beacon identifier. */
		uuid: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessBluetoothSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessBluetoothSettingsPutBodyFormProperties>({
			advertisingEnabled: new FormControl<boolean | null | undefined>(undefined),
			major: new FormControl<number | null | undefined>(undefined),
			majorMinorAssignmentMode: new FormControl<UpdateNetworkWirelessBluetoothSettingsPutBodyMajorMinorAssignmentMode | null | undefined>(undefined),
			minor: new FormControl<number | null | undefined>(undefined),
			scanningEnabled: new FormControl<boolean | null | undefined>(undefined),
			uuid: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessBluetoothSettingsPutBodyMajorMinorAssignmentMode { 'Non-unique' = 'Non-unique', Unique = 'Unique' }

	export interface UpdateNetworkWirelessBluetoothSettingsReturn {

		/** Whether APs will advertise beacons. */
		advertisingEnabled?: boolean | null;

		/** Whether ESL is enabled on this network. */
		eslEnabled?: boolean | null;

		/** The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */
		major?: number | null;

		/** The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique') */
		majorMinorAssignmentMode?: string | null;

		/** The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */
		minor?: number | null;

		/** Whether APs will scan for Bluetooth enabled clients. */
		scanningEnabled?: boolean | null;

		/** The UUID to be used in the beacon identifier. */
		uuid?: string | null;
	}
	export interface UpdateNetworkWirelessBluetoothSettingsReturnFormProperties {

		/** Whether APs will advertise beacons. */
		advertisingEnabled: FormControl<boolean | null | undefined>,

		/** Whether ESL is enabled on this network. */
		eslEnabled: FormControl<boolean | null | undefined>,

		/** The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */
		major: FormControl<number | null | undefined>,

		/** The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique') */
		majorMinorAssignmentMode: FormControl<string | null | undefined>,

		/** The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode. */
		minor: FormControl<number | null | undefined>,

		/** Whether APs will scan for Bluetooth enabled clients. */
		scanningEnabled: FormControl<boolean | null | undefined>,

		/** The UUID to be used in the beacon identifier. */
		uuid: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessBluetoothSettingsReturnFormGroup() {
		return new FormGroup<UpdateNetworkWirelessBluetoothSettingsReturnFormProperties>({
			advertisingEnabled: new FormControl<boolean | null | undefined>(undefined),
			eslEnabled: new FormControl<boolean | null | undefined>(undefined),
			major: new FormControl<number | null | undefined>(undefined),
			majorMinorAssignmentMode: new FormControl<string | null | undefined>(undefined),
			minor: new FormControl<number | null | undefined>(undefined),
			scanningEnabled: new FormControl<boolean | null | undefined>(undefined),
			uuid: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessChannelUtilizationHistoryReturn {

		/** The end time of the query range */
		endTs?: Date | null;

		/** The start time of the query range */
		startTs?: Date | null;

		/** Average wifi utilization */
		utilization80211?: number | null;

		/** Average signal interference */
		utilizationNon80211?: number | null;

		/** Total channel utilization */
		utilizationTotal?: number | null;
	}
	export interface GetNetworkWirelessChannelUtilizationHistoryReturnFormProperties {

		/** The end time of the query range */
		endTs: FormControl<Date | null | undefined>,

		/** The start time of the query range */
		startTs: FormControl<Date | null | undefined>,

		/** Average wifi utilization */
		utilization80211: FormControl<number | null | undefined>,

		/** Average signal interference */
		utilizationNon80211: FormControl<number | null | undefined>,

		/** Total channel utilization */
		utilizationTotal: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkWirelessChannelUtilizationHistoryReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessChannelUtilizationHistoryReturnFormProperties>({
			endTs: new FormControl<Date | null | undefined>(undefined),
			startTs: new FormControl<Date | null | undefined>(undefined),
			utilization80211: new FormControl<number | null | undefined>(undefined),
			utilizationNon80211: new FormControl<number | null | undefined>(undefined),
			utilizationTotal: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessClientCountHistoryReturn {

		/** Number of connected clients */
		clientCount?: number | null;

		/** The end time of the query range */
		endTs?: Date | null;

		/** The start time of the query range */
		startTs?: Date | null;
	}
	export interface GetNetworkWirelessClientCountHistoryReturnFormProperties {

		/** Number of connected clients */
		clientCount: FormControl<number | null | undefined>,

		/** The end time of the query range */
		endTs: FormControl<Date | null | undefined>,

		/** The start time of the query range */
		startTs: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkWirelessClientCountHistoryReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessClientCountHistoryReturnFormProperties>({
			clientCount: new FormControl<number | null | undefined>(undefined),
			endTs: new FormControl<Date | null | undefined>(undefined),
			startTs: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export enum GetNetworkWirelessClientConnectivityEventsSsidNumber { _0 = 0, _1 = 1, _2 = 2, _3 = 3, _4 = 4, _5 = 5, _6 = 6, _7 = 7, _8 = 8, _9 = 9, _10 = 10, _11 = 11, _12 = 12, _13 = 13, _14 = 14 }

	export interface GetNetworkWirelessConnectionStatsReturn {

		/** The number of failed association attempts */
		assoc?: number | null;

		/** The number of failed authentication attempts */
		auth?: number | null;

		/** The number of failed DHCP attempts */
		dhcp?: number | null;

		/** The number of failed DNS attempts */
		dns?: number | null;

		/** The number of successful connection attempts */
		success?: number | null;
	}
	export interface GetNetworkWirelessConnectionStatsReturnFormProperties {

		/** The number of failed association attempts */
		assoc: FormControl<number | null | undefined>,

		/** The number of failed authentication attempts */
		auth: FormControl<number | null | undefined>,

		/** The number of failed DHCP attempts */
		dhcp: FormControl<number | null | undefined>,

		/** The number of failed DNS attempts */
		dns: FormControl<number | null | undefined>,

		/** The number of successful connection attempts */
		success: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkWirelessConnectionStatsReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessConnectionStatsReturnFormProperties>({
			assoc: new FormControl<number | null | undefined>(undefined),
			auth: new FormControl<number | null | undefined>(undefined),
			dhcp: new FormControl<number | null | undefined>(undefined),
			dns: new FormControl<number | null | undefined>(undefined),
			success: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessDataRateHistoryReturn {

		/** Average data rate in kilobytes-per-second */
		averageKbps?: number | null;

		/** Download rate in kilobytes-per-second */
		downloadKbps?: number | null;

		/** The end time of the query range */
		endTs?: Date | null;

		/** The start time of the query range */
		startTs?: Date | null;

		/** Upload rate in kilobytes-per-second */
		uploadKbps?: number | null;
	}
	export interface GetNetworkWirelessDataRateHistoryReturnFormProperties {

		/** Average data rate in kilobytes-per-second */
		averageKbps: FormControl<number | null | undefined>,

		/** Download rate in kilobytes-per-second */
		downloadKbps: FormControl<number | null | undefined>,

		/** The end time of the query range */
		endTs: FormControl<Date | null | undefined>,

		/** The start time of the query range */
		startTs: FormControl<Date | null | undefined>,

		/** Upload rate in kilobytes-per-second */
		uploadKbps: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkWirelessDataRateHistoryReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessDataRateHistoryReturnFormProperties>({
			averageKbps: new FormControl<number | null | undefined>(undefined),
			downloadKbps: new FormControl<number | null | undefined>(undefined),
			endTs: new FormControl<Date | null | undefined>(undefined),
			startTs: new FormControl<Date | null | undefined>(undefined),
			uploadKbps: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessDevicesConnectionStatsReturn {

		/** The connection stats of the device */
		connectionStats?: GetNetworkWirelessDevicesConnectionStatsReturnConnectionStats;

		/** The serial number for the device */
		serial?: string | null;
	}
	export interface GetNetworkWirelessDevicesConnectionStatsReturnFormProperties {

		/** The serial number for the device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWirelessDevicesConnectionStatsReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessDevicesConnectionStatsReturnFormProperties>({
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessDevicesConnectionStatsReturnConnectionStats {

		/** The number of failed association attempts */
		assoc?: number | null;

		/** The number of failed authentication attempts */
		auth?: number | null;

		/** The number of failed DHCP attempts */
		dhcp?: number | null;

		/** The number of failed DNS attempts */
		dns?: number | null;

		/** The number of successful connection attempts */
		success?: number | null;
	}
	export interface GetNetworkWirelessDevicesConnectionStatsReturnConnectionStatsFormProperties {

		/** The number of failed association attempts */
		assoc: FormControl<number | null | undefined>,

		/** The number of failed authentication attempts */
		auth: FormControl<number | null | undefined>,

		/** The number of failed DHCP attempts */
		dhcp: FormControl<number | null | undefined>,

		/** The number of failed DNS attempts */
		dns: FormControl<number | null | undefined>,

		/** The number of successful connection attempts */
		success: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkWirelessDevicesConnectionStatsReturnConnectionStatsFormGroup() {
		return new FormGroup<GetNetworkWirelessDevicesConnectionStatsReturnConnectionStatsFormProperties>({
			assoc: new FormControl<number | null | undefined>(undefined),
			auth: new FormControl<number | null | undefined>(undefined),
			dhcp: new FormControl<number | null | undefined>(undefined),
			dns: new FormControl<number | null | undefined>(undefined),
			success: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessFailedConnectionsReturn {

		/** Client Mac */
		clientMac?: string | null;

		/** The failed onboarding step. One of: assoc, auth, dhcp, dns. */
		failureStep?: string | null;

		/** Serial Number */
		serial?: string | null;

		/** SSID Number */
		ssidNumber?: number | null;

		/** The timestamp when the client mac failed */
		ts?: Date | null;

		/** The failure type in the onboarding step */
		type?: string | null;

		/** LAN */
		vlan?: number | null;
	}
	export interface GetNetworkWirelessFailedConnectionsReturnFormProperties {

		/** Client Mac */
		clientMac: FormControl<string | null | undefined>,

		/** The failed onboarding step. One of: assoc, auth, dhcp, dns. */
		failureStep: FormControl<string | null | undefined>,

		/** Serial Number */
		serial: FormControl<string | null | undefined>,

		/** SSID Number */
		ssidNumber: FormControl<number | null | undefined>,

		/** The timestamp when the client mac failed */
		ts: FormControl<Date | null | undefined>,

		/** The failure type in the onboarding step */
		type: FormControl<string | null | undefined>,

		/** LAN */
		vlan: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkWirelessFailedConnectionsReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessFailedConnectionsReturnFormProperties>({
			clientMac: new FormControl<string | null | undefined>(undefined),
			failureStep: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			ssidNumber: new FormControl<number | null | undefined>(undefined),
			ts: new FormControl<Date | null | undefined>(undefined),
			type: new FormControl<string | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum GetNetworkWirelessLatencyHistoryAccessCategory { backgroundTraffic = 'backgroundTraffic', bestEffortTraffic = 'bestEffortTraffic', videoTraffic = 'videoTraffic', voiceTraffic = 'voiceTraffic' }

	export interface GetNetworkWirelessLatencyHistoryReturn {

		/** Average latency in milliseconds */
		avgLatencyMs?: number | null;

		/** The end time of the query range */
		endTs?: Date | null;

		/** The start time of the query range */
		startTs?: Date | null;
	}
	export interface GetNetworkWirelessLatencyHistoryReturnFormProperties {

		/** Average latency in milliseconds */
		avgLatencyMs: FormControl<number | null | undefined>,

		/** The end time of the query range */
		endTs: FormControl<Date | null | undefined>,

		/** The start time of the query range */
		startTs: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkWirelessLatencyHistoryReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessLatencyHistoryReturnFormProperties>({
			avgLatencyMs: new FormControl<number | null | undefined>(undefined),
			endTs: new FormControl<Date | null | undefined>(undefined),
			startTs: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBody {

		/** Settings that will be enabled if selectionType is set to 'ap'. */
		apBandSettings?: CreateNetworkWirelessRfProfilePostBodyApBandSettings;

		/**
		 * Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.
		 * Required
		 */
		bandSelectionType: CreateNetworkWirelessRfProfilePostBodyBandSelectionType;

		/** Steers client to best available access point. Can be either true or false. Defaults to true. */
		clientBalancingEnabled?: boolean | null;

		/** Settings related to 5Ghz band */
		fiveGhzSettings?: CreateNetworkWirelessRfProfilePostBodyFiveGhzSettings;

		/** Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band. */
		minBitrateType?: CreateNetworkWirelessRfProfilePostBodyMinBitrateType | null;

		/**
		 * The name of the new profile. Must be unique. This param is required on creation.
		 * Required
		 */
		name: string;

		/** Per-SSID radio settings by number. */
		perSsidSettings?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings;

		/** Settings related to radio transmission. */
		transmission?: CreateNetworkWirelessRfProfilePostBodyTransmission;

		/** Settings related to 2.4Ghz band */
		twoFourGhzSettings?: CreateNetworkWirelessRfProfilePostBodyTwoFourGhzSettings;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyFormProperties {

		/**
		 * Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.
		 * Required
		 */
		bandSelectionType: FormControl<CreateNetworkWirelessRfProfilePostBodyBandSelectionType | null | undefined>,

		/** Steers client to best available access point. Can be either true or false. Defaults to true. */
		clientBalancingEnabled: FormControl<boolean | null | undefined>,

		/** Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band. */
		minBitrateType: FormControl<CreateNetworkWirelessRfProfilePostBodyMinBitrateType | null | undefined>,

		/**
		 * The name of the new profile. Must be unique. This param is required on creation.
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyFormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyFormProperties>({
			bandSelectionType: new FormControl<CreateNetworkWirelessRfProfilePostBodyBandSelectionType | null | undefined>(undefined, [Validators.required]),
			clientBalancingEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrateType: new FormControl<CreateNetworkWirelessRfProfilePostBodyMinBitrateType | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyApBandSettings {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. Defaults to dual. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band. Can be either true or false. Defaults to true. */
		bandSteeringEnabled?: boolean | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyApBandSettingsFormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. Defaults to dual. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band. Can be either true or false. Defaults to true. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyApBandSettingsFormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyApBandSettingsFormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode { '2.4ghz' = '2.4ghz', '5ghz' = '5ghz', dual = 'dual' }

	export enum CreateNetworkWirelessRfProfilePostBodyBandSelectionType { ap = 'ap', ssid = 'ssid' }

	export interface CreateNetworkWirelessRfProfilePostBodyFiveGhzSettings {

		/** Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto. */
		channelWidth?: string | null;

		/** Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30. */
		maxPower?: number | null;

		/** Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12. */
		minBitrate?: number | null;

		/** Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8. */
		minPower?: number | null;

		/** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */
		rxsop?: number | null;

		/** Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165]. */
		validAutoChannels?: Array<number>;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyFiveGhzSettingsFormProperties {

		/** Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto. */
		channelWidth: FormControl<string | null | undefined>,

		/** Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30. */
		maxPower: FormControl<number | null | undefined>,

		/** Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12. */
		minBitrate: FormControl<number | null | undefined>,

		/** Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8. */
		minPower: FormControl<number | null | undefined>,

		/** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */
		rxsop: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyFiveGhzSettingsFormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyFiveGhzSettingsFormProperties>({
			channelWidth: new FormControl<string | null | undefined>(undefined),
			maxPower: new FormControl<number | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			minPower: new FormControl<number | null | undefined>(undefined),
			rxsop: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum CreateNetworkWirelessRfProfilePostBodyMinBitrateType { band = 'band', ssid = 'ssid' }

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings {

		/** Settings for SSID 0 */
		'0'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_0_;

		/** Settings for SSID 1 */
		'1'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_1_;

		/** Settings for SSID 2 */
		'2'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_2_;

		/** Settings for SSID 3 */
		'3'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_3_;

		/** Settings for SSID 4 */
		'4'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_4_;

		/** Settings for SSID 5 */
		'5'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_5_;

		/** Settings for SSID 6 */
		'6'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_6_;

		/** Settings for SSID 7 */
		'7'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_7_;

		/** Settings for SSID 8 */
		'8'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_8_;

		/** Settings for SSID 9 */
		'9'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_9_;

		/** Settings for SSID 10 */
		'10'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_10_;

		/** Settings for SSID 11 */
		'11'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_11_;

		/** Settings for SSID 12 */
		'12'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_12_;

		/** Settings for SSID 13 */
		'13'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_13_;

		/** Settings for SSID 14 */
		'14'?: CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_14_;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettingsFormProperties {
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettingsFormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettingsFormProperties>({
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_0_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_0_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_0_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_0_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_1_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_1_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_1_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_1_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_2_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_2_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_2_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_2_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_3_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_3_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_3_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_3_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_4_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_4_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_4_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_4_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_5_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_5_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_5_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_5_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_6_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_6_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_6_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_6_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_7_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_7_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_7_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_7_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_8_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_8_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_8_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_8_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_9_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_9_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_9_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_9_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_10_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_10_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_10_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_10_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_11_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_11_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_11_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_11_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_12_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_12_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_12_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_12_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_13_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_13_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_13_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_13_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_14_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_14_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyPerSsidSettings_14_FormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_14_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyTransmission {

		/** Toggle for radio transmission. When false, radios will not transmit at all. */
		enabled?: boolean | null;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyTransmissionFormProperties {

		/** Toggle for radio transmission. When false, radios will not transmit at all. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyTransmissionFormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyTransmissionFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessRfProfilePostBodyTwoFourGhzSettings {

		/** Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true. */
		axEnabled?: boolean | null;

		/** Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30. */
		maxPower?: number | null;

		/** Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11. */
		minBitrate?: number | null;

		/** Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5. */
		minPower?: number | null;

		/** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */
		rxsop?: number | null;

		/** Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11]. */
		validAutoChannels?: Array<number>;
	}
	export interface CreateNetworkWirelessRfProfilePostBodyTwoFourGhzSettingsFormProperties {

		/** Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true. */
		axEnabled: FormControl<boolean | null | undefined>,

		/** Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30. */
		maxPower: FormControl<number | null | undefined>,

		/** Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11. */
		minBitrate: FormControl<number | null | undefined>,

		/** Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5. */
		minPower: FormControl<number | null | undefined>,

		/** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */
		rxsop: FormControl<number | null | undefined>,
	}
	export function CreateCreateNetworkWirelessRfProfilePostBodyTwoFourGhzSettingsFormGroup() {
		return new FormGroup<CreateNetworkWirelessRfProfilePostBodyTwoFourGhzSettingsFormProperties>({
			axEnabled: new FormControl<boolean | null | undefined>(undefined),
			maxPower: new FormControl<number | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			minPower: new FormControl<number | null | undefined>(undefined),
			rxsop: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBody {

		/** Settings that will be enabled if selectionType is set to 'ap'. */
		apBandSettings?: UpdateNetworkWirelessRfProfilePutBodyApBandSettings;

		/** Band selection can be set to either 'ssid' or 'ap'. */
		bandSelectionType?: CreateNetworkWirelessRfProfilePostBodyBandSelectionType | null;

		/** Steers client to best available access point. Can be either true or false. */
		clientBalancingEnabled?: boolean | null;

		/** Settings related to 5Ghz band */
		fiveGhzSettings?: UpdateNetworkWirelessRfProfilePutBodyFiveGhzSettings;

		/** Minimum bitrate can be set to either 'band' or 'ssid'. */
		minBitrateType?: CreateNetworkWirelessRfProfilePostBodyMinBitrateType | null;

		/** The name of the new profile. Must be unique. */
		name?: string | null;

		/** Per-SSID radio settings by number. */
		perSsidSettings?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings;

		/** Settings related to radio transmission. */
		transmission?: UpdateNetworkWirelessRfProfilePutBodyTransmission;

		/** Settings related to 2.4Ghz band */
		twoFourGhzSettings?: UpdateNetworkWirelessRfProfilePutBodyTwoFourGhzSettings;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyFormProperties {

		/** Band selection can be set to either 'ssid' or 'ap'. */
		bandSelectionType: FormControl<CreateNetworkWirelessRfProfilePostBodyBandSelectionType | null | undefined>,

		/** Steers client to best available access point. Can be either true or false. */
		clientBalancingEnabled: FormControl<boolean | null | undefined>,

		/** Minimum bitrate can be set to either 'band' or 'ssid'. */
		minBitrateType: FormControl<CreateNetworkWirelessRfProfilePostBodyMinBitrateType | null | undefined>,

		/** The name of the new profile. Must be unique. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyFormProperties>({
			bandSelectionType: new FormControl<CreateNetworkWirelessRfProfilePostBodyBandSelectionType | null | undefined>(undefined),
			clientBalancingEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrateType: new FormControl<CreateNetworkWirelessRfProfilePostBodyMinBitrateType | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyApBandSettings {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyApBandSettingsFormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyApBandSettingsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyApBandSettingsFormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyFiveGhzSettings {

		/** Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. */
		channelWidth?: string | null;

		/** Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. */
		maxPower?: number | null;

		/** Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. */
		minPower?: number | null;

		/** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */
		rxsop?: number | null;

		/** Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'. */
		validAutoChannels?: Array<number>;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyFiveGhzSettingsFormProperties {

		/** Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. */
		channelWidth: FormControl<string | null | undefined>,

		/** Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. */
		maxPower: FormControl<number | null | undefined>,

		/** Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. */
		minPower: FormControl<number | null | undefined>,

		/** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */
		rxsop: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyFiveGhzSettingsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyFiveGhzSettingsFormProperties>({
			channelWidth: new FormControl<string | null | undefined>(undefined),
			maxPower: new FormControl<number | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			minPower: new FormControl<number | null | undefined>(undefined),
			rxsop: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings {

		/** Settings for SSID 0 */
		'0'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_0_;

		/** Settings for SSID 1 */
		'1'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_1_;

		/** Settings for SSID 2 */
		'2'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_2_;

		/** Settings for SSID 3 */
		'3'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_3_;

		/** Settings for SSID 4 */
		'4'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_4_;

		/** Settings for SSID 5 */
		'5'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_5_;

		/** Settings for SSID 6 */
		'6'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_6_;

		/** Settings for SSID 7 */
		'7'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_7_;

		/** Settings for SSID 8 */
		'8'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_8_;

		/** Settings for SSID 9 */
		'9'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_9_;

		/** Settings for SSID 10 */
		'10'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_10_;

		/** Settings for SSID 11 */
		'11'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_11_;

		/** Settings for SSID 12 */
		'12'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_12_;

		/** Settings for SSID 13 */
		'13'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_13_;

		/** Settings for SSID 14 */
		'14'?: UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_14_;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettingsFormProperties {
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettingsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettingsFormProperties>({
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_0_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_0_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_0_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_0_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_1_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_1_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_1_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_1_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_2_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_2_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_2_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_2_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_3_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_3_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_3_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_3_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_4_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_4_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_4_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_4_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_5_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_5_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_5_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_5_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_6_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_6_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_6_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_6_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_7_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_7_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_7_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_7_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_8_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_8_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_8_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_8_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_9_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_9_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_9_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_9_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_10_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_10_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_10_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_10_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_11_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_11_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_11_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_11_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_12_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_12_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_12_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_12_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_13_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_13_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_13_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_13_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_14_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_14_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_14_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_14_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyTransmission {

		/** Toggle for radio transmission. When false, radios will not transmit at all. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyTransmissionFormProperties {

		/** Toggle for radio transmission. When false, radios will not transmit at all. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyTransmissionFormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyTransmissionFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfilePutBodyTwoFourGhzSettings {

		/** Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. */
		axEnabled?: boolean | null;

		/** Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. */
		maxPower?: number | null;

		/** Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. */
		minPower?: number | null;

		/** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */
		rxsop?: number | null;

		/** Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. */
		validAutoChannels?: Array<number>;
	}
	export interface UpdateNetworkWirelessRfProfilePutBodyTwoFourGhzSettingsFormProperties {

		/** Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. */
		axEnabled: FormControl<boolean | null | undefined>,

		/** Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. */
		maxPower: FormControl<number | null | undefined>,

		/** Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. */
		minPower: FormControl<number | null | undefined>,

		/** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */
		rxsop: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfilePutBodyTwoFourGhzSettingsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfilePutBodyTwoFourGhzSettingsFormProperties>({
			axEnabled: new FormControl<boolean | null | undefined>(undefined),
			maxPower: new FormControl<number | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			minPower: new FormControl<number | null | undefined>(undefined),
			rxsop: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturn {

		/** Settings that will be enabled if selectionType is set to 'ap'. */
		apBandSettings?: UpdateNetworkWirelessRfProfileReturnApBandSettings;

		/** Band selection can be set to either 'ssid' or 'ap'. This param is required on creation. */
		bandSelectionType?: string | null;

		/** Steers client to best available access point. Can be either true or false. Defaults to true. */
		clientBalancingEnabled?: boolean | null;

		/** Settings related to 5Ghz band */
		fiveGhzSettings?: UpdateNetworkWirelessRfProfileReturnFiveGhzSettings;

		/** The name of the new profile. Must be unique. */
		id?: string | null;

		/** Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band. */
		minBitrateType?: string | null;

		/** The name of the new profile. Must be unique. This param is required on creation. */
		name?: string | null;

		/** The network ID of the RF Profile */
		networkId?: string | null;

		/** Per-SSID radio settings by number. */
		perSsidSettings?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings;

		/** Settings related to radio transmission. */
		transmission?: UpdateNetworkWirelessRfProfileReturnTransmission;

		/** Settings related to 2.4Ghz band */
		twoFourGhzSettings?: UpdateNetworkWirelessRfProfileReturnTwoFourGhzSettings;
	}
	export interface UpdateNetworkWirelessRfProfileReturnFormProperties {

		/** Band selection can be set to either 'ssid' or 'ap'. This param is required on creation. */
		bandSelectionType: FormControl<string | null | undefined>,

		/** Steers client to best available access point. Can be either true or false. Defaults to true. */
		clientBalancingEnabled: FormControl<boolean | null | undefined>,

		/** The name of the new profile. Must be unique. */
		id: FormControl<string | null | undefined>,

		/** Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band. */
		minBitrateType: FormControl<string | null | undefined>,

		/** The name of the new profile. Must be unique. This param is required on creation. */
		name: FormControl<string | null | undefined>,

		/** The network ID of the RF Profile */
		networkId: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnFormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnFormProperties>({
			bandSelectionType: new FormControl<string | null | undefined>(undefined),
			clientBalancingEnabled: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			minBitrateType: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnApBandSettings {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. Defaults to dual. */
		bandOperationMode?: string | null;

		/** Steers client to most open band. Can be either true or false. Defaults to true. */
		bandSteeringEnabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnApBandSettingsFormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. Defaults to dual. */
		bandOperationMode: FormControl<string | null | undefined>,

		/** Steers client to most open band. Can be either true or false. Defaults to true. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnApBandSettingsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnApBandSettingsFormProperties>({
			bandOperationMode: new FormControl<string | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnFiveGhzSettings {

		/** Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto. */
		channelWidth?: string | null;

		/** Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30. */
		maxPower?: number | null;

		/** Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12. */
		minBitrate?: number | null;

		/** Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8. */
		minPower?: number | null;

		/** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */
		rxsop?: number | null;

		/** Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165]. */
		validAutoChannels?: Array<number>;
	}
	export interface UpdateNetworkWirelessRfProfileReturnFiveGhzSettingsFormProperties {

		/** Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto. */
		channelWidth: FormControl<string | null | undefined>,

		/** Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30. */
		maxPower: FormControl<number | null | undefined>,

		/** Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12. */
		minBitrate: FormControl<number | null | undefined>,

		/** Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8. */
		minPower: FormControl<number | null | undefined>,

		/** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */
		rxsop: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnFiveGhzSettingsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnFiveGhzSettingsFormProperties>({
			channelWidth: new FormControl<string | null | undefined>(undefined),
			maxPower: new FormControl<number | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			minPower: new FormControl<number | null | undefined>(undefined),
			rxsop: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings {

		/** Settings for SSID 0 */
		'0'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_0_;

		/** Settings for SSID 1 */
		'1'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_1_;

		/** Settings for SSID 2 */
		'2'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_2_;

		/** Settings for SSID 3 */
		'3'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_3_;

		/** Settings for SSID 4 */
		'4'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_4_;

		/** Settings for SSID 5 */
		'5'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_5_;

		/** Settings for SSID 6 */
		'6'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_6_;

		/** Settings for SSID 7 */
		'7'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_7_;

		/** Settings for SSID 8 */
		'8'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_8_;

		/** Settings for SSID 9 */
		'9'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_9_;

		/** Settings for SSID 10 */
		'10'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_10_;

		/** Settings for SSID 11 */
		'11'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_11_;

		/** Settings for SSID 12 */
		'12'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_12_;

		/** Settings for SSID 13 */
		'13'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_13_;

		/** Settings for SSID 14 */
		'14'?: UpdateNetworkWirelessRfProfileReturnPerSsidSettings_14_;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettingsFormProperties {
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettingsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettingsFormProperties>({
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_0_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_0_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_0_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_0_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_1_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_1_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_1_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_1_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_2_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_2_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_2_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_2_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_3_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_3_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_3_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_3_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_4_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_4_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_4_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_4_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_5_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_5_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_5_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_5_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_6_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_6_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_6_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_6_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_7_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_7_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_7_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_7_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_8_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_8_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_8_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_8_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_9_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_9_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_9_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_9_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_10_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_10_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_10_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_10_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_11_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_11_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_11_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_11_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_12_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_12_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_12_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_12_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_13_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_13_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_13_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_13_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_14_ {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode?: CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null;

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled?: boolean | null;

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate?: number | null;

		/** Name of SSID */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnPerSsidSettings_14_FormProperties {

		/** Choice between 'dual', '2.4ghz' or '5ghz'. */
		bandOperationMode: FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>,

		/** Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false. */
		bandSteeringEnabled: FormControl<boolean | null | undefined>,

		/** Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. */
		minBitrate: FormControl<number | null | undefined>,

		/** Name of SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnPerSsidSettings_14_FormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_14_FormProperties>({
			bandOperationMode: new FormControl<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode | null | undefined>(undefined),
			bandSteeringEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnTransmission {

		/** Toggle for radio transmission. When false, radios will not transmit at all. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessRfProfileReturnTransmissionFormProperties {

		/** Toggle for radio transmission. When false, radios will not transmit at all. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnTransmissionFormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnTransmissionFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessRfProfileReturnTwoFourGhzSettings {

		/** Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true. */
		axEnabled?: boolean | null;

		/** Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30. */
		maxPower?: number | null;

		/** Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11. */
		minBitrate?: number | null;

		/** Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5. */
		minPower?: number | null;

		/** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */
		rxsop?: number | null;

		/** Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11]. */
		validAutoChannels?: Array<number>;
	}
	export interface UpdateNetworkWirelessRfProfileReturnTwoFourGhzSettingsFormProperties {

		/** Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true. */
		axEnabled: FormControl<boolean | null | undefined>,

		/** Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30. */
		maxPower: FormControl<number | null | undefined>,

		/** Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11. */
		minBitrate: FormControl<number | null | undefined>,

		/** Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5. */
		minPower: FormControl<number | null | undefined>,

		/** The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default. */
		rxsop: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessRfProfileReturnTwoFourGhzSettingsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessRfProfileReturnTwoFourGhzSettingsFormProperties>({
			axEnabled: new FormControl<boolean | null | undefined>(undefined),
			maxPower: new FormControl<number | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			minPower: new FormControl<number | null | undefined>(undefined),
			rxsop: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSettingsReturn {

		/** Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode) */
		ipv6BridgeEnabled?: boolean | null;

		/** Toggle for enabling or disabling LED lights on all APs in the network (making them run dark) */
		ledLightsOn?: boolean | null;

		/** Toggle for enabling or disabling location analytics for your network */
		locationAnalyticsEnabled?: boolean | null;

		/** Toggle for enabling or disabling meshing in a network */
		meshingEnabled?: boolean | null;

		/** Named VLAN settings for wireless networks. */
		namedVlans?: GetNetworkWirelessSettingsReturnNamedVlans;

		/** The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher' */
		upgradeStrategy?: GetNetworkWirelessSettingsReturnUpgradeStrategy | null;
	}
	export interface GetNetworkWirelessSettingsReturnFormProperties {

		/** Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode) */
		ipv6BridgeEnabled: FormControl<boolean | null | undefined>,

		/** Toggle for enabling or disabling LED lights on all APs in the network (making them run dark) */
		ledLightsOn: FormControl<boolean | null | undefined>,

		/** Toggle for enabling or disabling location analytics for your network */
		locationAnalyticsEnabled: FormControl<boolean | null | undefined>,

		/** Toggle for enabling or disabling meshing in a network */
		meshingEnabled: FormControl<boolean | null | undefined>,

		/** The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher' */
		upgradeStrategy: FormControl<GetNetworkWirelessSettingsReturnUpgradeStrategy | null | undefined>,
	}
	export function CreateGetNetworkWirelessSettingsReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessSettingsReturnFormProperties>({
			ipv6BridgeEnabled: new FormControl<boolean | null | undefined>(undefined),
			ledLightsOn: new FormControl<boolean | null | undefined>(undefined),
			locationAnalyticsEnabled: new FormControl<boolean | null | undefined>(undefined),
			meshingEnabled: new FormControl<boolean | null | undefined>(undefined),
			upgradeStrategy: new FormControl<GetNetworkWirelessSettingsReturnUpgradeStrategy | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSettingsReturnNamedVlans {

		/** Named VLAN Pool DHCP Monitoring settings. */
		poolDhcpMonitoring?: GetNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoring;
	}
	export interface GetNetworkWirelessSettingsReturnNamedVlansFormProperties {
	}
	export function CreateGetNetworkWirelessSettingsReturnNamedVlansFormGroup() {
		return new FormGroup<GetNetworkWirelessSettingsReturnNamedVlansFormProperties>({
		});

	}

	export interface GetNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoring {

		/** The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool. */
		duration?: number | null;

		/** Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP */
		enabled?: boolean | null;
	}
	export interface GetNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoringFormProperties {

		/** The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool. */
		duration: FormControl<number | null | undefined>,

		/** Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoringFormGroup() {
		return new FormGroup<GetNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoringFormProperties>({
			duration: new FormControl<number | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum GetNetworkWirelessSettingsReturnUpgradeStrategy { minimizeClientDowntime = 'minimizeClientDowntime', minimizeUpgradeTime = 'minimizeUpgradeTime' }

	export interface UpdateNetworkWirelessSettingsPutBody {

		/** Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode) */
		ipv6BridgeEnabled?: boolean | null;

		/** Toggle for enabling or disabling LED lights on all APs in the network (making them run dark) */
		ledLightsOn?: boolean | null;

		/** Toggle for enabling or disabling location analytics for your network */
		locationAnalyticsEnabled?: boolean | null;

		/** Toggle for enabling or disabling meshing in a network */
		meshingEnabled?: boolean | null;

		/** The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher' */
		upgradeStrategy?: GetNetworkWirelessSettingsReturnUpgradeStrategy | null;
	}
	export interface UpdateNetworkWirelessSettingsPutBodyFormProperties {

		/** Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode) */
		ipv6BridgeEnabled: FormControl<boolean | null | undefined>,

		/** Toggle for enabling or disabling LED lights on all APs in the network (making them run dark) */
		ledLightsOn: FormControl<boolean | null | undefined>,

		/** Toggle for enabling or disabling location analytics for your network */
		locationAnalyticsEnabled: FormControl<boolean | null | undefined>,

		/** Toggle for enabling or disabling meshing in a network */
		meshingEnabled: FormControl<boolean | null | undefined>,

		/** The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher' */
		upgradeStrategy: FormControl<GetNetworkWirelessSettingsReturnUpgradeStrategy | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSettingsPutBodyFormProperties>({
			ipv6BridgeEnabled: new FormControl<boolean | null | undefined>(undefined),
			ledLightsOn: new FormControl<boolean | null | undefined>(undefined),
			locationAnalyticsEnabled: new FormControl<boolean | null | undefined>(undefined),
			meshingEnabled: new FormControl<boolean | null | undefined>(undefined),
			upgradeStrategy: new FormControl<GetNetworkWirelessSettingsReturnUpgradeStrategy | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSettingsReturn {

		/** Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode) */
		ipv6BridgeEnabled?: boolean | null;

		/** Toggle for enabling or disabling LED lights on all APs in the network (making them run dark) */
		ledLightsOn?: boolean | null;

		/** Toggle for enabling or disabling location analytics for your network */
		locationAnalyticsEnabled?: boolean | null;

		/** Toggle for enabling or disabling meshing in a network */
		meshingEnabled?: boolean | null;

		/** Named VLAN settings for wireless networks. */
		namedVlans?: UpdateNetworkWirelessSettingsReturnNamedVlans;

		/** The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher' */
		upgradeStrategy?: GetNetworkWirelessSettingsReturnUpgradeStrategy | null;
	}
	export interface UpdateNetworkWirelessSettingsReturnFormProperties {

		/** Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode) */
		ipv6BridgeEnabled: FormControl<boolean | null | undefined>,

		/** Toggle for enabling or disabling LED lights on all APs in the network (making them run dark) */
		ledLightsOn: FormControl<boolean | null | undefined>,

		/** Toggle for enabling or disabling location analytics for your network */
		locationAnalyticsEnabled: FormControl<boolean | null | undefined>,

		/** Toggle for enabling or disabling meshing in a network */
		meshingEnabled: FormControl<boolean | null | undefined>,

		/** The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher' */
		upgradeStrategy: FormControl<GetNetworkWirelessSettingsReturnUpgradeStrategy | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSettingsReturnFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSettingsReturnFormProperties>({
			ipv6BridgeEnabled: new FormControl<boolean | null | undefined>(undefined),
			ledLightsOn: new FormControl<boolean | null | undefined>(undefined),
			locationAnalyticsEnabled: new FormControl<boolean | null | undefined>(undefined),
			meshingEnabled: new FormControl<boolean | null | undefined>(undefined),
			upgradeStrategy: new FormControl<GetNetworkWirelessSettingsReturnUpgradeStrategy | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSettingsReturnNamedVlans {

		/** Named VLAN Pool DHCP Monitoring settings. */
		poolDhcpMonitoring?: UpdateNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoring;
	}
	export interface UpdateNetworkWirelessSettingsReturnNamedVlansFormProperties {
	}
	export function CreateUpdateNetworkWirelessSettingsReturnNamedVlansFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSettingsReturnNamedVlansFormProperties>({
		});

	}

	export interface UpdateNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoring {

		/** The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool. */
		duration?: number | null;

		/** Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoringFormProperties {

		/** The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool. */
		duration: FormControl<number | null | undefined>,

		/** Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoringFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoringFormProperties>({
			duration: new FormControl<number | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSignalQualityHistoryReturn {

		/** The end time of the query range */
		endTs?: Date | null;

		/** Received signal strength indicator */
		rssi?: number | null;

		/** Signal to noise ratio */
		snr?: number | null;

		/** The start time of the query range */
		startTs?: Date | null;
	}
	export interface GetNetworkWirelessSignalQualityHistoryReturnFormProperties {

		/** The end time of the query range */
		endTs: FormControl<Date | null | undefined>,

		/** Received signal strength indicator */
		rssi: FormControl<number | null | undefined>,

		/** Signal to noise ratio */
		snr: FormControl<number | null | undefined>,

		/** The start time of the query range */
		startTs: FormControl<Date | null | undefined>,
	}
	export function CreateGetNetworkWirelessSignalQualityHistoryReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessSignalQualityHistoryReturnFormProperties>({
			endTs: new FormControl<Date | null | undefined>(undefined),
			rssi: new FormControl<number | null | undefined>(undefined),
			snr: new FormControl<number | null | undefined>(undefined),
			startTs: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBody {

		/** The current setting for Active Directory. Only valid if splashPage is 'Password-protected with Active Directory' */
		activeDirectory?: UpdateNetworkWirelessSsidPutBodyActiveDirectory;

		/** Boolean indicating whether or not adult content will be blocked */
		adultContentFilteringEnabled?: boolean | null;

		/** The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming' */
		UpdateNetworkWirelessSsidPutBodyApTagsAndVlanIds?: Array<UpdateNetworkWirelessSsidPutBodyApTagsAndVlanIds>;

		/** The association control method for the SSID ('open', 'open-enhanced', 'psk', 'open-with-radius', 'open-with-nac', '8021x-meraki', '8021x-nac', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius') */
		authMode?: UpdateNetworkWirelessSsidPutBodyAuthMode | null;

		/** Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list. */
		availabilityTags?: Array<string>;

		/** Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags. */
		availableOnAllAps?: boolean | null;

		/** The client-serving radio frequencies of this SSID in the default indoor RF profile. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering') */
		bandSelection?: string | null;

		/** The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'. */
		concentratorNetworkId?: string | null;

		/** The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming' */
		defaultVlanId?: number | null;

		/** Disassociate clients when 'VPN' concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is 'VPN'. */
		disassociateClientsOnVpnFailover?: boolean | null;

		/** DNS servers rewrite settings */
		dnsRewrite?: UpdateNetworkWirelessSsidPutBodyDnsRewrite;

		/** The current setting for 802.11r */
		dot11r?: UpdateNetworkWirelessSsidPutBodyDot11r;

		/** The current setting for Protected Management Frames (802.11w). */
		dot11w?: UpdateNetworkWirelessSsidPutBodyDot11w;

		/** Whether or not the SSID is enabled */
		enabled?: boolean | null;

		/** The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk' */
		encryptionMode?: UpdateNetworkApplianceSsidPutBodyEncryptionMode | null;

		/** Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled') */
		enterpriseAdminAccess?: UpdateNetworkWirelessSsidPutBodyEnterpriseAdminAccess | null;

		/** Ethernet over GRE settings */
		gre?: UpdateNetworkWirelessSsidPutBodyGre;

		/** The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Ethernet over GRE', 'Layer 3 roaming with a concentrator' or 'VPN') */
		ipAssignmentMode?: string | null;

		/** Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'. */
		lanIsolationEnabled?: boolean | null;

		/** The current setting for LDAP. Only valid if splashPage is 'Password-protected with LDAP'. */
		ldap?: UpdateNetworkWirelessSsidPutBodyLdap;

		/** The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is '8021x-localradius'. */
		localRadius?: UpdateNetworkWirelessSsidPutBodyLocalRadius;

		/** If true, Mandatory DHCP will enforce that clients connecting to this SSID must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. */
		mandatoryDhcpEnabled?: boolean | null;

		/** The minimum bitrate in Mbps of this SSID in the default indoor RF profile. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54') */
		minBitrate?: number | null;

		/** The name of the SSID */
		name?: string | null;

		/** The OAuth settings of this SSID. Only valid if splashPage is 'Google OAuth'. */
		oauth?: UpdateNetworkWirelessSsidPutBodyOauth;

		/** The download bandwidth limit in Kbps. (0 represents no limit.) */
		perClientBandwidthLimitDown?: number | null;

		/** The upload bandwidth limit in Kbps. (0 represents no limit.) */
		perClientBandwidthLimitUp?: number | null;

		/** The total download bandwidth limit in Kbps. (0 represents no limit.) */
		perSsidBandwidthLimitDown?: number | null;

		/** The total upload bandwidth limit in Kbps. (0 represents no limit.) */
		perSsidBandwidthLimitUp?: number | null;

		/** The passkey for the SSID. This param is only valid if the authMode is 'psk' */
		psk?: string | null;

		/** Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' */
		radiusAccountingEnabled?: boolean | null;

		/** The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server. */
		radiusAccountingInterimInterval?: number | null;

		/** The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true' */
		UpdateNetworkWirelessSsidPutBodyRadiusAccountingServers?: Array<UpdateNetworkWirelessSsidPutBodyRadiusAccountingServers>;

		/** Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message */
		radiusAttributeForGroupPolicies?: UpdateNetworkWirelessSsidPutBodyRadiusAttributeForGroupPolicies | null;

		/** The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE_MAC$:$VAP_NUM$). */
		radiusAuthenticationNasId?: string | null;

		/** The template of the called station identifier to be used for RADIUS (ex. $NODE_MAC$:$VAP_NUM$). */
		radiusCalledStationId?: string | null;

		/** If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server. */
		radiusCoaEnabled?: boolean | null;

		/** This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access') */
		radiusFailoverPolicy?: UpdateNetworkWirelessSsidPutBodyRadiusFailoverPolicy | null;

		/** Whether or not higher priority RADIUS servers should be retried after 60 seconds. */
		radiusFallbackEnabled?: boolean | null;

		/** Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode */
		radiusGuestVlanEnabled?: boolean | null;

		/** VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode */
		radiusGuestVlanId?: number | null;

		/** This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin') */
		radiusLoadBalancingPolicy?: UpdateNetworkWirelessSsidPutBodyRadiusLoadBalancingPolicy | null;

		/** If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'. */
		radiusOverride?: boolean | null;

		/** If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers. */
		radiusProxyEnabled?: boolean | null;

		/** The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5). */
		radiusServerAttemptsLimit?: number | null;

		/** The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds). */
		radiusServerTimeout?: number | null;

		/** The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' */
		UpdateNetworkWirelessSsidPutBodyRadiusServers?: Array<UpdateNetworkWirelessSsidPutBodyRadiusServers>;

		/** If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity 'meraki_8021x_test' to ensure that the RADIUS servers are reachable. */
		radiusTestingEnabled?: boolean | null;

		/** The secondary concentrator to use when the ipAssignmentMode is 'VPN'. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. ('disabled' represents no secondary concentrator.) */
		secondaryConcentratorNetworkId?: string | null;

		/** The SpeedBurst setting for this SSID' */
		speedBurst?: UpdateNetworkWirelessSsidPutBodySpeedBurst;

		/** Array of valid sponsor email domains for sponsored guest splash type. */
		splashGuestSponsorDomains?: Array<string>;

		/** The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children. */
		splashPage?: UpdateNetworkWirelessSsidPutBodySplashPage | null;

		/** Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming' */
		useVlanTagging?: boolean | null;

		/** Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true */
		visible?: boolean | null;

		/** The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN' */
		vlanId?: number | null;

		/** Allow access to a configurable list of IP ranges, which users may access prior to sign-on. */
		walledGardenEnabled?: boolean | null;

		/** Specify your walled garden by entering an array of addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. '192.168.1.1/24', '192.168.37.10/32', 'www.yahoo.com', '*.google.com']). Meraki's splash page is automatically included in your walled garden. */
		walledGardenRanges?: Array<string>;

		/** The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode', 'WPA3 only' or 'WPA3 192-bit Security') */
		wpaEncryptionMode?: UpdateNetworkWirelessSsidPutBodyWpaEncryptionMode | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyFormProperties {

		/** Boolean indicating whether or not adult content will be blocked */
		adultContentFilteringEnabled: FormControl<boolean | null | undefined>,

		/** The association control method for the SSID ('open', 'open-enhanced', 'psk', 'open-with-radius', 'open-with-nac', '8021x-meraki', '8021x-nac', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius') */
		authMode: FormControl<UpdateNetworkWirelessSsidPutBodyAuthMode | null | undefined>,

		/** Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags. */
		availableOnAllAps: FormControl<boolean | null | undefined>,

		/** The client-serving radio frequencies of this SSID in the default indoor RF profile. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering') */
		bandSelection: FormControl<string | null | undefined>,

		/** The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'. */
		concentratorNetworkId: FormControl<string | null | undefined>,

		/** The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming' */
		defaultVlanId: FormControl<number | null | undefined>,

		/** Disassociate clients when 'VPN' concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is 'VPN'. */
		disassociateClientsOnVpnFailover: FormControl<boolean | null | undefined>,

		/** Whether or not the SSID is enabled */
		enabled: FormControl<boolean | null | undefined>,

		/** The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk' */
		encryptionMode: FormControl<UpdateNetworkApplianceSsidPutBodyEncryptionMode | null | undefined>,

		/** Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled') */
		enterpriseAdminAccess: FormControl<UpdateNetworkWirelessSsidPutBodyEnterpriseAdminAccess | null | undefined>,

		/** The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Ethernet over GRE', 'Layer 3 roaming with a concentrator' or 'VPN') */
		ipAssignmentMode: FormControl<string | null | undefined>,

		/** Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'. */
		lanIsolationEnabled: FormControl<boolean | null | undefined>,

		/** If true, Mandatory DHCP will enforce that clients connecting to this SSID must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. */
		mandatoryDhcpEnabled: FormControl<boolean | null | undefined>,

		/** The minimum bitrate in Mbps of this SSID in the default indoor RF profile. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54') */
		minBitrate: FormControl<number | null | undefined>,

		/** The name of the SSID */
		name: FormControl<string | null | undefined>,

		/** The download bandwidth limit in Kbps. (0 represents no limit.) */
		perClientBandwidthLimitDown: FormControl<number | null | undefined>,

		/** The upload bandwidth limit in Kbps. (0 represents no limit.) */
		perClientBandwidthLimitUp: FormControl<number | null | undefined>,

		/** The total download bandwidth limit in Kbps. (0 represents no limit.) */
		perSsidBandwidthLimitDown: FormControl<number | null | undefined>,

		/** The total upload bandwidth limit in Kbps. (0 represents no limit.) */
		perSsidBandwidthLimitUp: FormControl<number | null | undefined>,

		/** The passkey for the SSID. This param is only valid if the authMode is 'psk' */
		psk: FormControl<string | null | undefined>,

		/** Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' */
		radiusAccountingEnabled: FormControl<boolean | null | undefined>,

		/** The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server. */
		radiusAccountingInterimInterval: FormControl<number | null | undefined>,

		/** Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message */
		radiusAttributeForGroupPolicies: FormControl<UpdateNetworkWirelessSsidPutBodyRadiusAttributeForGroupPolicies | null | undefined>,

		/** The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE_MAC$:$VAP_NUM$). */
		radiusAuthenticationNasId: FormControl<string | null | undefined>,

		/** The template of the called station identifier to be used for RADIUS (ex. $NODE_MAC$:$VAP_NUM$). */
		radiusCalledStationId: FormControl<string | null | undefined>,

		/** If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server. */
		radiusCoaEnabled: FormControl<boolean | null | undefined>,

		/** This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access') */
		radiusFailoverPolicy: FormControl<UpdateNetworkWirelessSsidPutBodyRadiusFailoverPolicy | null | undefined>,

		/** Whether or not higher priority RADIUS servers should be retried after 60 seconds. */
		radiusFallbackEnabled: FormControl<boolean | null | undefined>,

		/** Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode */
		radiusGuestVlanEnabled: FormControl<boolean | null | undefined>,

		/** VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode */
		radiusGuestVlanId: FormControl<number | null | undefined>,

		/** This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin') */
		radiusLoadBalancingPolicy: FormControl<UpdateNetworkWirelessSsidPutBodyRadiusLoadBalancingPolicy | null | undefined>,

		/** If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'. */
		radiusOverride: FormControl<boolean | null | undefined>,

		/** If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers. */
		radiusProxyEnabled: FormControl<boolean | null | undefined>,

		/** The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5). */
		radiusServerAttemptsLimit: FormControl<number | null | undefined>,

		/** The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds). */
		radiusServerTimeout: FormControl<number | null | undefined>,

		/** If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity 'meraki_8021x_test' to ensure that the RADIUS servers are reachable. */
		radiusTestingEnabled: FormControl<boolean | null | undefined>,

		/** The secondary concentrator to use when the ipAssignmentMode is 'VPN'. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. ('disabled' represents no secondary concentrator.) */
		secondaryConcentratorNetworkId: FormControl<string | null | undefined>,

		/** The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children. */
		splashPage: FormControl<UpdateNetworkWirelessSsidPutBodySplashPage | null | undefined>,

		/** Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming' */
		useVlanTagging: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true */
		visible: FormControl<boolean | null | undefined>,

		/** The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN' */
		vlanId: FormControl<number | null | undefined>,

		/** Allow access to a configurable list of IP ranges, which users may access prior to sign-on. */
		walledGardenEnabled: FormControl<boolean | null | undefined>,

		/** The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode', 'WPA3 only' or 'WPA3 192-bit Security') */
		wpaEncryptionMode: FormControl<UpdateNetworkWirelessSsidPutBodyWpaEncryptionMode | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyFormProperties>({
			adultContentFilteringEnabled: new FormControl<boolean | null | undefined>(undefined),
			authMode: new FormControl<UpdateNetworkWirelessSsidPutBodyAuthMode | null | undefined>(undefined),
			availableOnAllAps: new FormControl<boolean | null | undefined>(undefined),
			bandSelection: new FormControl<string | null | undefined>(undefined),
			concentratorNetworkId: new FormControl<string | null | undefined>(undefined),
			defaultVlanId: new FormControl<number | null | undefined>(undefined),
			disassociateClientsOnVpnFailover: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			encryptionMode: new FormControl<UpdateNetworkApplianceSsidPutBodyEncryptionMode | null | undefined>(undefined),
			enterpriseAdminAccess: new FormControl<UpdateNetworkWirelessSsidPutBodyEnterpriseAdminAccess | null | undefined>(undefined),
			ipAssignmentMode: new FormControl<string | null | undefined>(undefined),
			lanIsolationEnabled: new FormControl<boolean | null | undefined>(undefined),
			mandatoryDhcpEnabled: new FormControl<boolean | null | undefined>(undefined),
			minBitrate: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			perClientBandwidthLimitDown: new FormControl<number | null | undefined>(undefined),
			perClientBandwidthLimitUp: new FormControl<number | null | undefined>(undefined),
			perSsidBandwidthLimitDown: new FormControl<number | null | undefined>(undefined),
			perSsidBandwidthLimitUp: new FormControl<number | null | undefined>(undefined),
			psk: new FormControl<string | null | undefined>(undefined),
			radiusAccountingEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusAccountingInterimInterval: new FormControl<number | null | undefined>(undefined),
			radiusAttributeForGroupPolicies: new FormControl<UpdateNetworkWirelessSsidPutBodyRadiusAttributeForGroupPolicies | null | undefined>(undefined),
			radiusAuthenticationNasId: new FormControl<string | null | undefined>(undefined),
			radiusCalledStationId: new FormControl<string | null | undefined>(undefined),
			radiusCoaEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusFailoverPolicy: new FormControl<UpdateNetworkWirelessSsidPutBodyRadiusFailoverPolicy | null | undefined>(undefined),
			radiusFallbackEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusGuestVlanEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusGuestVlanId: new FormControl<number | null | undefined>(undefined),
			radiusLoadBalancingPolicy: new FormControl<UpdateNetworkWirelessSsidPutBodyRadiusLoadBalancingPolicy | null | undefined>(undefined),
			radiusOverride: new FormControl<boolean | null | undefined>(undefined),
			radiusProxyEnabled: new FormControl<boolean | null | undefined>(undefined),
			radiusServerAttemptsLimit: new FormControl<number | null | undefined>(undefined),
			radiusServerTimeout: new FormControl<number | null | undefined>(undefined),
			radiusTestingEnabled: new FormControl<boolean | null | undefined>(undefined),
			secondaryConcentratorNetworkId: new FormControl<string | null | undefined>(undefined),
			splashPage: new FormControl<UpdateNetworkWirelessSsidPutBodySplashPage | null | undefined>(undefined),
			useVlanTagging: new FormControl<boolean | null | undefined>(undefined),
			visible: new FormControl<boolean | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
			walledGardenEnabled: new FormControl<boolean | null | undefined>(undefined),
			wpaEncryptionMode: new FormControl<UpdateNetworkWirelessSsidPutBodyWpaEncryptionMode | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyActiveDirectory {

		/** (Optional) The credentials of the user account to be used by the AP to bind to your Active Directory server. The Active Directory account should have permissions on all your Active Directory servers. Only valid if the splashPage is 'Password-protected with Active Directory'. */
		credentials?: UpdateNetworkWirelessSsidPutBodyActiveDirectoryCredentials;

		/** The Active Directory servers to be used for authentication. */
		UpdateNetworkWirelessSsidPutBodyActiveDirectoryServers?: Array<UpdateNetworkWirelessSsidPutBodyActiveDirectoryServers>;
	}
	export interface UpdateNetworkWirelessSsidPutBodyActiveDirectoryFormProperties {
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyActiveDirectoryFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyActiveDirectoryFormProperties>({
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyActiveDirectoryCredentials {

		/** The logon name of the Active Directory account. */
		logonName?: string | null;

		/** The password to the Active Directory user account. */
		password?: string | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyActiveDirectoryCredentialsFormProperties {

		/** The logon name of the Active Directory account. */
		logonName: FormControl<string | null | undefined>,

		/** The password to the Active Directory user account. */
		password: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyActiveDirectoryCredentialsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyActiveDirectoryCredentialsFormProperties>({
			logonName: new FormControl<string | null | undefined>(undefined),
			password: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyActiveDirectoryServers {

		/**
		 * IP address of your Active Directory server.
		 * Required
		 */
		host: string;

		/** (Optional) UDP port the Active Directory server listens on. By default, uses port 3268. */
		port?: number | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyActiveDirectoryServersFormProperties {

		/**
		 * IP address of your Active Directory server.
		 * Required
		 */
		host: FormControl<string | null | undefined>,

		/** (Optional) UDP port the Active Directory server listens on. By default, uses port 3268. */
		port: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyActiveDirectoryServersFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyActiveDirectoryServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			port: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyApTagsAndVlanIds {

		/** Array of AP tags */
		tags?: Array<string>;

		/** Numerical identifier that is assigned to the VLAN */
		vlanId?: number | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyApTagsAndVlanIdsFormProperties {

		/** Numerical identifier that is assigned to the VLAN */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyApTagsAndVlanIdsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyApTagsAndVlanIdsFormProperties>({
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessSsidPutBodyAuthMode { '8021x-google' = '8021x-google', '8021x-localradius' = '8021x-localradius', '8021x-meraki' = '8021x-meraki', '8021x-nac' = '8021x-nac', '8021x-radius' = '8021x-radius', 'ipsk-with-radius' = 'ipsk-with-radius', 'ipsk-without-radius' = 'ipsk-without-radius', open = 'open', 'open-enhanced' = 'open-enhanced', 'open-with-nac' = 'open-with-nac', 'open-with-radius' = 'open-with-radius', psk = 'psk' }

	export interface UpdateNetworkWirelessSsidPutBodyDnsRewrite {

		/** User specified DNS servers (up to two servers) */
		dnsCustomNameservers?: Array<string>;

		/** Boolean indicating whether or not DNS server rewrite is enabled. If disabled, upstream DNS will be used */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyDnsRewriteFormProperties {

		/** Boolean indicating whether or not DNS server rewrite is enabled. If disabled, upstream DNS will be used */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyDnsRewriteFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyDnsRewriteFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyDot11r {

		/** (Optional) Whether 802.11r is adaptive or not. */
		adaptive?: boolean | null;

		/** Whether 802.11r is enabled or not. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyDot11rFormProperties {

		/** (Optional) Whether 802.11r is adaptive or not. */
		adaptive: FormControl<boolean | null | undefined>,

		/** Whether 802.11r is enabled or not. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyDot11rFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyDot11rFormProperties>({
			adaptive: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyDot11w {

		/** Whether 802.11w is enabled or not. */
		enabled?: boolean | null;

		/** (Optional) Whether 802.11w is required or not. */
		required?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyDot11wFormProperties {

		/** Whether 802.11w is enabled or not. */
		enabled: FormControl<boolean | null | undefined>,

		/** (Optional) Whether 802.11w is required or not. */
		required: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyDot11wFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyDot11wFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			required: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessSsidPutBodyEnterpriseAdminAccess { 'access disabled' = 'access disabled', 'access enabled' = 'access enabled' }

	export interface UpdateNetworkWirelessSsidPutBodyGre {

		/** The EoGRE concentrator's settings */
		concentrator?: UpdateNetworkWirelessSsidPutBodyGreConcentrator;

		/** Optional numerical identifier that will add the GRE key field to the GRE header. Used to identify an individual traffic flow within a tunnel. */
		key?: number | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyGreFormProperties {

		/** Optional numerical identifier that will add the GRE key field to the GRE header. Used to identify an individual traffic flow within a tunnel. */
		key: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyGreFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyGreFormProperties>({
			key: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyGreConcentrator {

		/**
		 * The EoGRE concentrator's IP or FQDN. This param is required when ipAssignmentMode is 'Ethernet over GRE'.
		 * Required
		 */
		host: string;
	}
	export interface UpdateNetworkWirelessSsidPutBodyGreConcentratorFormProperties {

		/**
		 * The EoGRE concentrator's IP or FQDN. This param is required when ipAssignmentMode is 'Ethernet over GRE'.
		 * Required
		 */
		host: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyGreConcentratorFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyGreConcentratorFormProperties>({
			host: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyLdap {

		/** The base distinguished name of users on the LDAP server. */
		baseDistinguishedName?: string | null;

		/** (Optional) The credentials of the user account to be used by the AP to bind to your LDAP server. The LDAP account should have permissions on all your LDAP servers. */
		credentials?: UpdateNetworkWirelessSsidPutBodyLdapCredentials;

		/** The CA certificate used to sign the LDAP server's key. */
		serverCaCertificate?: UpdateNetworkWirelessSsidPutBodyLdapServerCaCertificate;

		/** The LDAP servers to be used for authentication. */
		UpdateNetworkWirelessSsidPutBodyLdapServers?: Array<UpdateNetworkWirelessSsidPutBodyLdapServers>;
	}
	export interface UpdateNetworkWirelessSsidPutBodyLdapFormProperties {

		/** The base distinguished name of users on the LDAP server. */
		baseDistinguishedName: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyLdapFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyLdapFormProperties>({
			baseDistinguishedName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyLdapCredentials {

		/** The distinguished name of the LDAP user account (example: cn=user,dc=meraki,dc=com). */
		distinguishedName?: string | null;

		/** The password of the LDAP user account. */
		password?: string | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyLdapCredentialsFormProperties {

		/** The distinguished name of the LDAP user account (example: cn=user,dc=meraki,dc=com). */
		distinguishedName: FormControl<string | null | undefined>,

		/** The password of the LDAP user account. */
		password: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyLdapCredentialsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyLdapCredentialsFormProperties>({
			distinguishedName: new FormControl<string | null | undefined>(undefined),
			password: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyLdapServerCaCertificate {

		/** The contents of the CA certificate. Must be in PEM or DER format. */
		contents?: string | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyLdapServerCaCertificateFormProperties {

		/** The contents of the CA certificate. Must be in PEM or DER format. */
		contents: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyLdapServerCaCertificateFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyLdapServerCaCertificateFormProperties>({
			contents: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyLdapServers {

		/**
		 * IP address of your LDAP server.
		 * Required
		 */
		host: string;

		/**
		 * UDP port the LDAP server listens on.
		 * Required
		 */
		port: number;
	}
	export interface UpdateNetworkWirelessSsidPutBodyLdapServersFormProperties {

		/**
		 * IP address of your LDAP server.
		 * Required
		 */
		host: FormControl<string | null | undefined>,

		/**
		 * UDP port the LDAP server listens on.
		 * Required
		 */
		port: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyLdapServersFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyLdapServersFormProperties>({
			host: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			port: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyLocalRadius {

		/** The duration (in seconds) for which LDAP and OCSP lookups are cached. */
		cacheTimeout?: number | null;

		/** The current setting for certificate verification. */
		certificateAuthentication?: UpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthentication;

		/** The current setting for password-based authentication. */
		passwordAuthentication?: UpdateNetworkWirelessSsidPutBodyLocalRadiusPasswordAuthentication;
	}
	export interface UpdateNetworkWirelessSsidPutBodyLocalRadiusFormProperties {

		/** The duration (in seconds) for which LDAP and OCSP lookups are cached. */
		cacheTimeout: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyLocalRadiusFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyLocalRadiusFormProperties>({
			cacheTimeout: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthentication {

		/** The Client CA Certificate used to sign the client certificate. */
		clientRootCaCertificate?: UpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate;

		/** Whether or not to use EAP-TLS certificate-based authentication to validate wireless clients. */
		enabled?: boolean | null;

		/** (Optional) The URL of the OCSP responder to verify client certificate status. */
		ocspResponderUrl?: string | null;

		/** Whether or not to verify the certificate with LDAP. */
		useLdap?: boolean | null;

		/** Whether or not to verify the certificate with OCSP. */
		useOcsp?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthenticationFormProperties {

		/** Whether or not to use EAP-TLS certificate-based authentication to validate wireless clients. */
		enabled: FormControl<boolean | null | undefined>,

		/** (Optional) The URL of the OCSP responder to verify client certificate status. */
		ocspResponderUrl: FormControl<string | null | undefined>,

		/** Whether or not to verify the certificate with LDAP. */
		useLdap: FormControl<boolean | null | undefined>,

		/** Whether or not to verify the certificate with OCSP. */
		useOcsp: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthenticationFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthenticationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			ocspResponderUrl: new FormControl<string | null | undefined>(undefined),
			useLdap: new FormControl<boolean | null | undefined>(undefined),
			useOcsp: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate {

		/** The contents of the Client CA Certificate. Must be in PEM or DER format. */
		contents?: string | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthenticationClientRootCaCertificateFormProperties {

		/** The contents of the Client CA Certificate. Must be in PEM or DER format. */
		contents: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthenticationClientRootCaCertificateFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthenticationClientRootCaCertificateFormProperties>({
			contents: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyLocalRadiusPasswordAuthentication {

		/** Whether or not to use EAP-TTLS/PAP or PEAP-GTC password-based authentication via LDAP lookup. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyLocalRadiusPasswordAuthenticationFormProperties {

		/** Whether or not to use EAP-TTLS/PAP or PEAP-GTC password-based authentication via LDAP lookup. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyLocalRadiusPasswordAuthenticationFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyLocalRadiusPasswordAuthenticationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyOauth {

		/** (Optional) The list of domains allowed access to the network. */
		allowedDomains?: Array<string>;
	}
	export interface UpdateNetworkWirelessSsidPutBodyOauthFormProperties {
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyOauthFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyOauthFormProperties>({
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodyRadiusAccountingServers {

		/** Certificate used for authorization for the RADSEC Server */
		caCertificate?: string | null;

		/**
		 * IP address to which the APs will send RADIUS accounting messages
		 * Required
		 */
		host: string;

		/** Port on the RADIUS server that is listening for accounting messages */
		port?: number | null;

		/** Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled. */
		radsecEnabled?: boolean | null;

		/** Shared key used to authenticate messages between the APs and RADIUS server */
		secret?: string | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyRadiusAccountingServersFormProperties {

		/** Certificate used for authorization for the RADSEC Server */
		caCertificate: FormControl<string | null | undefined>,

		/**
		 * IP address to which the APs will send RADIUS accounting messages
		 * Required
		 */
		host: FormControl<string | null | undefined>,

		/** Port on the RADIUS server that is listening for accounting messages */
		port: FormControl<number | null | undefined>,

		/** Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled. */
		radsecEnabled: FormControl<boolean | null | undefined>,

		/** Shared key used to authenticate messages between the APs and RADIUS server */
		secret: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyRadiusAccountingServersFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyRadiusAccountingServersFormProperties>({
			caCertificate: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			port: new FormControl<number | null | undefined>(undefined),
			radsecEnabled: new FormControl<boolean | null | undefined>(undefined),
			secret: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessSsidPutBodyRadiusAttributeForGroupPolicies { 'Airespace-ACL-Name' = 'Airespace-ACL-Name', 'Aruba-User-Role' = 'Aruba-User-Role', 'Filter-Id' = 'Filter-Id', 'Reply-Message' = 'Reply-Message' }

	export enum UpdateNetworkWirelessSsidPutBodyRadiusFailoverPolicy { 'Allow access' = 'Allow access', 'Deny access' = 'Deny access' }

	export enum UpdateNetworkWirelessSsidPutBodyRadiusLoadBalancingPolicy { 'Round robin' = 'Round robin', 'Strict priority order' = 'Strict priority order' }

	export interface UpdateNetworkWirelessSsidPutBodyRadiusServers {

		/** Certificate used for authorization for the RADSEC Server */
		caCertificate?: string | null;

		/**
		 * IP address of your RADIUS server
		 * Required
		 */
		host: string;

		/** The ID of the Openroaming Certificate attached to radius server. */
		openRoamingCertificateId?: number | null;

		/** UDP port the RADIUS server listens on for Access-requests */
		port?: number | null;

		/** Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled. */
		radsecEnabled?: boolean | null;

		/** RADIUS client shared secret */
		secret?: string | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodyRadiusServersFormProperties {

		/** Certificate used for authorization for the RADSEC Server */
		caCertificate: FormControl<string | null | undefined>,

		/**
		 * IP address of your RADIUS server
		 * Required
		 */
		host: FormControl<string | null | undefined>,

		/** The ID of the Openroaming Certificate attached to radius server. */
		openRoamingCertificateId: FormControl<number | null | undefined>,

		/** UDP port the RADIUS server listens on for Access-requests */
		port: FormControl<number | null | undefined>,

		/** Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled. */
		radsecEnabled: FormControl<boolean | null | undefined>,

		/** RADIUS client shared secret */
		secret: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodyRadiusServersFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodyRadiusServersFormProperties>({
			caCertificate: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			openRoamingCertificateId: new FormControl<number | null | undefined>(undefined),
			port: new FormControl<number | null | undefined>(undefined),
			radsecEnabled: new FormControl<boolean | null | undefined>(undefined),
			secret: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidPutBodySpeedBurst {

		/** Boolean indicating whether or not to allow users to temporarily exceed the bandwidth limit for short periods while still keeping them under the bandwidth limit over time. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidPutBodySpeedBurstFormProperties {

		/** Boolean indicating whether or not to allow users to temporarily exceed the bandwidth limit for short periods while still keeping them under the bandwidth limit over time. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidPutBodySpeedBurstFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidPutBodySpeedBurstFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessSsidPutBodySplashPage { Billing = 'Billing', 'Cisco ISE' = 'Cisco ISE', 'Click-through splash page' = 'Click-through splash page', 'Facebook Wi-Fi' = 'Facebook Wi-Fi', 'Google Apps domain' = 'Google Apps domain', 'Google OAuth' = 'Google OAuth', None = 'None', 'Password-protected with Active Directory' = 'Password-protected with Active Directory', 'Password-protected with LDAP' = 'Password-protected with LDAP', 'Password-protected with Meraki RADIUS' = 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS' = 'Password-protected with custom RADIUS', 'SMS authentication' = 'SMS authentication', 'Sponsored guest' = 'Sponsored guest', 'Systems Manager Sentry' = 'Systems Manager Sentry' }

	export enum UpdateNetworkWirelessSsidPutBodyWpaEncryptionMode { 'WPA1 and WPA2' = 'WPA1 and WPA2', 'WPA1 only' = 'WPA1 only', 'WPA2 only' = 'WPA2 only', 'WPA3 192-bit Security' = 'WPA3 192-bit Security', 'WPA3 Transition Mode' = 'WPA3 Transition Mode', 'WPA3 only' = 'WPA3 only' }

	export interface UpdateNetworkWirelessSsidBonjourForwardingPutBody {

		/** If true, Bonjour forwarding is enabled on this SSID. */
		enabled?: boolean | null;

		/** List of bonjour forwarding rules. */
		UpdateNetworkWirelessSsidBonjourForwardingPutBodyRules?: Array<UpdateNetworkWirelessSsidBonjourForwardingPutBodyRules>;
	}
	export interface UpdateNetworkWirelessSsidBonjourForwardingPutBodyFormProperties {

		/** If true, Bonjour forwarding is enabled on this SSID. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidBonjourForwardingPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidBonjourForwardingPutBodyFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidBonjourForwardingPutBodyRules {

		/** A description for your Bonjour forwarding rule. Optional. */
		description?: string | null;

		/**
		 * A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
		 * Required
		 */
		services: Array<string>;

		/**
		 * The ID of the service VLAN. Required.
		 * Required
		 */
		vlanId: string;
	}
	export interface UpdateNetworkWirelessSsidBonjourForwardingPutBodyRulesFormProperties {

		/** A description for your Bonjour forwarding rule. Optional. */
		description: FormControl<string | null | undefined>,

		/**
		 * The ID of the service VLAN. Required.
		 * Required
		 */
		vlanId: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidBonjourForwardingPutBodyRulesFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidBonjourForwardingPutBodyRulesFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			vlanId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBody {

		/** List of device type policies. */
		UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePolicies?: Array<UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePolicies>;

		/** If true, the SSID device type group policies are enabled. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyFormProperties {

		/** If true, the SSID device type group policies are enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePolicies {

		/**
		 * The device policy. Can be one of 'Allowed', 'Blocked' or 'Group policy'
		 * Required
		 */
		devicePolicy: UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesDevicePolicy;

		/**
		 * The device type. Can be one of 'Android', 'BlackBerry', 'Chrome OS', 'iPad', 'iPhone', 'iPod', 'Mac OS X', 'Windows', 'Windows Phone', 'B&N Nook' or 'Other OS'
		 * Required
		 */
		deviceType: UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesDeviceType;

		/** ID of the group policy object. */
		groupPolicyId?: number | null;
	}
	export interface UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesFormProperties {

		/**
		 * The device policy. Can be one of 'Allowed', 'Blocked' or 'Group policy'
		 * Required
		 */
		devicePolicy: FormControl<UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesDevicePolicy | null | undefined>,

		/**
		 * The device type. Can be one of 'Android', 'BlackBerry', 'Chrome OS', 'iPad', 'iPhone', 'iPod', 'Mac OS X', 'Windows', 'Windows Phone', 'B&N Nook' or 'Other OS'
		 * Required
		 */
		deviceType: FormControl<UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesDeviceType | null | undefined>,

		/** ID of the group policy object. */
		groupPolicyId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesFormProperties>({
			devicePolicy: new FormControl<UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesDevicePolicy | null | undefined>(undefined, [Validators.required]),
			deviceType: new FormControl<UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesDeviceType | null | undefined>(undefined, [Validators.required]),
			groupPolicyId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesDevicePolicy { Allowed = 'Allowed', Blocked = 'Blocked', 'Group policy' = 'Group policy' }

	export enum UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesDeviceType { Android = 'Android', 'B&N Nook' = 'B&N Nook', BlackBerry = 'BlackBerry', 'Chrome OS' = 'Chrome OS', 'Mac OS X' = 'Mac OS X', 'Other OS' = 'Other OS', Windows = 'Windows', 'Windows Phone' = 'Windows Phone', iPad = 'iPad', iPhone = 'iPhone', iPod = 'iPod' }

	export interface GetNetworkWirelessSsidEapOverrideReturn {

		/** EAPOL Key settings. */
		eapolKey?: GetNetworkWirelessSsidEapOverrideReturnEapolKey;

		/** EAP settings for identity requests. */
		identity?: GetNetworkWirelessSsidEapOverrideReturnIdentity;

		/** Maximum number of general EAP retries. */
		maxRetries?: number | null;

		/** General EAP timeout in seconds. */
		timeout?: number | null;
	}
	export interface GetNetworkWirelessSsidEapOverrideReturnFormProperties {

		/** Maximum number of general EAP retries. */
		maxRetries: FormControl<number | null | undefined>,

		/** General EAP timeout in seconds. */
		timeout: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidEapOverrideReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidEapOverrideReturnFormProperties>({
			maxRetries: new FormControl<number | null | undefined>(undefined),
			timeout: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSsidEapOverrideReturnEapolKey {

		/** Maximum number of EAPOL key retries. */
		retries?: number | null;

		/** EAPOL Key timeout in milliseconds. */
		timeoutInMs?: number | null;
	}
	export interface GetNetworkWirelessSsidEapOverrideReturnEapolKeyFormProperties {

		/** Maximum number of EAPOL key retries. */
		retries: FormControl<number | null | undefined>,

		/** EAPOL Key timeout in milliseconds. */
		timeoutInMs: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidEapOverrideReturnEapolKeyFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidEapOverrideReturnEapolKeyFormProperties>({
			retries: new FormControl<number | null | undefined>(undefined),
			timeoutInMs: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSsidEapOverrideReturnIdentity {

		/** Maximum number of EAP retries. */
		retries?: number | null;

		/** EAP timeout in seconds. */
		timeout?: number | null;
	}
	export interface GetNetworkWirelessSsidEapOverrideReturnIdentityFormProperties {

		/** Maximum number of EAP retries. */
		retries: FormControl<number | null | undefined>,

		/** EAP timeout in seconds. */
		timeout: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidEapOverrideReturnIdentityFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidEapOverrideReturnIdentityFormProperties>({
			retries: new FormControl<number | null | undefined>(undefined),
			timeout: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidEapOverridePutBody {

		/** EAPOL Key settings. */
		eapolKey?: UpdateNetworkWirelessSsidEapOverridePutBodyEapolKey;

		/** EAP settings for identity requests. */
		identity?: UpdateNetworkWirelessSsidEapOverridePutBodyIdentity;

		/** Maximum number of general EAP retries. */
		maxRetries?: number | null;

		/** General EAP timeout in seconds. */
		timeout?: number | null;
	}
	export interface UpdateNetworkWirelessSsidEapOverridePutBodyFormProperties {

		/** Maximum number of general EAP retries. */
		maxRetries: FormControl<number | null | undefined>,

		/** General EAP timeout in seconds. */
		timeout: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidEapOverridePutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidEapOverridePutBodyFormProperties>({
			maxRetries: new FormControl<number | null | undefined>(undefined),
			timeout: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidEapOverridePutBodyEapolKey {

		/** Maximum number of EAPOL key retries. */
		retries?: number | null;

		/** EAPOL Key timeout in milliseconds. */
		timeoutInMs?: number | null;
	}
	export interface UpdateNetworkWirelessSsidEapOverridePutBodyEapolKeyFormProperties {

		/** Maximum number of EAPOL key retries. */
		retries: FormControl<number | null | undefined>,

		/** EAPOL Key timeout in milliseconds. */
		timeoutInMs: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidEapOverridePutBodyEapolKeyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidEapOverridePutBodyEapolKeyFormProperties>({
			retries: new FormControl<number | null | undefined>(undefined),
			timeoutInMs: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidEapOverridePutBodyIdentity {

		/** Maximum number of EAP retries. */
		retries?: number | null;

		/** EAP timeout in seconds. */
		timeout?: number | null;
	}
	export interface UpdateNetworkWirelessSsidEapOverridePutBodyIdentityFormProperties {

		/** Maximum number of EAP retries. */
		retries: FormControl<number | null | undefined>,

		/** EAP timeout in seconds. */
		timeout: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidEapOverridePutBodyIdentityFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidEapOverridePutBodyIdentityFormProperties>({
			retries: new FormControl<number | null | undefined>(undefined),
			timeout: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidEapOverrideReturn {

		/** EAPOL Key settings. */
		eapolKey?: UpdateNetworkWirelessSsidEapOverrideReturnEapolKey;

		/** EAP settings for identity requests. */
		identity?: UpdateNetworkWirelessSsidEapOverrideReturnIdentity;

		/** Maximum number of general EAP retries. */
		maxRetries?: number | null;

		/** General EAP timeout in seconds. */
		timeout?: number | null;
	}
	export interface UpdateNetworkWirelessSsidEapOverrideReturnFormProperties {

		/** Maximum number of general EAP retries. */
		maxRetries: FormControl<number | null | undefined>,

		/** General EAP timeout in seconds. */
		timeout: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidEapOverrideReturnFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidEapOverrideReturnFormProperties>({
			maxRetries: new FormControl<number | null | undefined>(undefined),
			timeout: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidEapOverrideReturnEapolKey {

		/** Maximum number of EAPOL key retries. */
		retries?: number | null;

		/** EAPOL Key timeout in milliseconds. */
		timeoutInMs?: number | null;
	}
	export interface UpdateNetworkWirelessSsidEapOverrideReturnEapolKeyFormProperties {

		/** Maximum number of EAPOL key retries. */
		retries: FormControl<number | null | undefined>,

		/** EAPOL Key timeout in milliseconds. */
		timeoutInMs: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidEapOverrideReturnEapolKeyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidEapOverrideReturnEapolKeyFormProperties>({
			retries: new FormControl<number | null | undefined>(undefined),
			timeoutInMs: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidEapOverrideReturnIdentity {

		/** Maximum number of EAP retries. */
		retries?: number | null;

		/** EAP timeout in seconds. */
		timeout?: number | null;
	}
	export interface UpdateNetworkWirelessSsidEapOverrideReturnIdentityFormProperties {

		/** Maximum number of EAP retries. */
		retries: FormControl<number | null | undefined>,

		/** EAP timeout in seconds. */
		timeout: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidEapOverrideReturnIdentityFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidEapOverrideReturnIdentityFormProperties>({
			retries: new FormControl<number | null | undefined>(undefined),
			timeout: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBody {

		/** Allow wireless client access to local LAN (boolean value - true allows access and false denies access) (optional) */
		allowLanAccess?: boolean | null;

		/** An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule) */
		UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBodyRules?: Array<UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBodyRules>;
	}
	export interface UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBodyFormProperties {

		/** Allow wireless client access to local LAN (boolean value - true allows access and false denies access) (optional) */
		allowLanAccess: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBodyFormProperties>({
			allowLanAccess: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBodyRules {

		/** Description of the rule (optional) */
		comment?: string | null;

		/**
		 * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
		 * Required
		 */
		destCidr: string;

		/** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */
		destPort?: string | null;

		/**
		 * 'allow' or 'deny' traffic specified by this rule
		 * Required
		 */
		policy: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy;

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		 * Required
		 */
		protocol: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol;
	}
	export interface UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBodyRulesFormProperties {

		/** Description of the rule (optional) */
		comment: FormControl<string | null | undefined>,

		/**
		 * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
		 * Required
		 */
		destCidr: FormControl<string | null | undefined>,

		/** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */
		destPort: FormControl<string | null | undefined>,

		/**
		 * 'allow' or 'deny' traffic specified by this rule
		 * Required
		 */
		policy: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>,

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		 * Required
		 */
		protocol: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBodyRulesFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBodyRulesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			destCidr: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			destPort: new FormControl<string | null | undefined>(undefined),
			policy: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>(undefined, [Validators.required]),
			protocol: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBody {

		/** An array of L7 firewall rules for this SSID. Rules will get applied in the same order user has specified in request. Empty array will clear the L7 firewall rule configuration. */
		UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBodyRules?: Array<UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBodyRules>;
	}
	export interface UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBodyFormProperties {
	}
	export function CreateUpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBodyRules {

		/** 'Deny' traffic specified by this rule */
		policy?: UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy | null;

		/** Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange' */
		type?: UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType | null;

		/** The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected. */
		value?: string | null;
	}
	export interface UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBodyRulesFormProperties {

		/** 'Deny' traffic specified by this rule */
		policy: FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy | null | undefined>,

		/** Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange' */
		type: FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType | null | undefined>,

		/** The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected. */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBodyRulesFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBodyRulesFormProperties>({
			policy: new FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy | null | undefined>(undefined),
			type: new FormControl<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType | null | undefined>(undefined),
			value: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidHotspot20PutBody {

		/** An array of domain names */
		domains?: Array<string>;

		/** Whether or not Hotspot 2.0 for this SSID is enabled */
		enabled?: boolean | null;

		/** An array of MCC/MNC pairs */
		UpdateNetworkWirelessSsidHotspot20PutBodyMccMncs?: Array<UpdateNetworkWirelessSsidHotspot20PutBodyMccMncs>;

		/** An array of NAI realms */
		UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealms?: Array<UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealms>;

		/** The network type of this SSID ('Private network', 'Private network with guest access', 'Chargeable public network', 'Free public network', 'Personal device network', 'Emergency services only network', 'Test or experimental', 'Wildcard') */
		networkAccessType?: UpdateNetworkWirelessSsidHotspot20PutBodyNetworkAccessType | null;

		/** Operator settings for this SSID */
		operator?: UpdateNetworkWirelessSsidHotspot20PutBodyOperator;

		/** An array of roaming consortium OIs (hexadecimal number 3-5 octets in length) */
		roamConsortOis?: Array<string>;

		/** Venue settings for this SSID */
		venue?: UpdateNetworkWirelessSsidHotspot20PutBodyVenue;
	}
	export interface UpdateNetworkWirelessSsidHotspot20PutBodyFormProperties {

		/** Whether or not Hotspot 2.0 for this SSID is enabled */
		enabled: FormControl<boolean | null | undefined>,

		/** The network type of this SSID ('Private network', 'Private network with guest access', 'Chargeable public network', 'Free public network', 'Personal device network', 'Emergency services only network', 'Test or experimental', 'Wildcard') */
		networkAccessType: FormControl<UpdateNetworkWirelessSsidHotspot20PutBodyNetworkAccessType | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidHotspot20PutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidHotspot20PutBodyFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			networkAccessType: new FormControl<UpdateNetworkWirelessSsidHotspot20PutBodyNetworkAccessType | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidHotspot20PutBodyMccMncs {

		/** MCC value */
		mcc?: string | null;

		/** MNC value */
		mnc?: string | null;
	}
	export interface UpdateNetworkWirelessSsidHotspot20PutBodyMccMncsFormProperties {

		/** MCC value */
		mcc: FormControl<string | null | undefined>,

		/** MNC value */
		mnc: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidHotspot20PutBodyMccMncsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidHotspot20PutBodyMccMncsFormProperties>({
			mcc: new FormControl<string | null | undefined>(undefined),
			mnc: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealms {

		/** The format for the realm ('1' or '0') */
		format?: UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsFormat | null;

		/** An array of EAP methods for the realm. */
		UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsMethods?: Array<UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsMethods>;

		/** The name of the realm */
		realm?: string | null;
	}
	export interface UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsFormProperties {

		/** The format for the realm ('1' or '0') */
		format: FormControl<UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsFormat | null | undefined>,

		/** The name of the realm */
		realm: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsFormProperties>({
			format: new FormControl<UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsFormat | null | undefined>(undefined),
			realm: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsFormat { _0 = '0', _1 = '1' }

	export interface UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsMethods {

		/** The authentication types for the method. These should be formatted as an object with the EAP method category in camelcase as the key and the list of types as the value (nonEapInnerAuthentication: Reserved, PAP, CHAP, MSCHAP, MSCHAPV2; eapInnerAuthentication: EAP-TLS, EAP-SIM, EAP-AKA, EAP-TTLS with MSCHAPv2; credentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, none, Reserved, Vendor Specific; tunneledEapMethodCredentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, Reserved, Anonymous, Vendor Specific) */
		authenticationTypes?: string | null;

		/** ID of method */
		id?: string | null;
	}
	export interface UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsMethodsFormProperties {

		/** The authentication types for the method. These should be formatted as an object with the EAP method category in camelcase as the key and the list of types as the value (nonEapInnerAuthentication: Reserved, PAP, CHAP, MSCHAP, MSCHAPV2; eapInnerAuthentication: EAP-TLS, EAP-SIM, EAP-AKA, EAP-TTLS with MSCHAPv2; credentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, none, Reserved, Vendor Specific; tunneledEapMethodCredentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, Reserved, Anonymous, Vendor Specific) */
		authenticationTypes: FormControl<string | null | undefined>,

		/** ID of method */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsMethodsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsMethodsFormProperties>({
			authenticationTypes: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessSsidHotspot20PutBodyNetworkAccessType { 'Chargeable public network' = 'Chargeable public network', 'Emergency services only network' = 'Emergency services only network', 'Free public network' = 'Free public network', 'Personal device network' = 'Personal device network', 'Private network' = 'Private network', 'Private network with guest access' = 'Private network with guest access', 'Test or experimental' = 'Test or experimental', Wildcard = 'Wildcard' }

	export interface UpdateNetworkWirelessSsidHotspot20PutBodyOperator {

		/** Operator name */
		name?: string | null;
	}
	export interface UpdateNetworkWirelessSsidHotspot20PutBodyOperatorFormProperties {

		/** Operator name */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidHotspot20PutBodyOperatorFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidHotspot20PutBodyOperatorFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidHotspot20PutBodyVenue {

		/** Venue name */
		name?: string | null;

		/** Venue type ('Unspecified', 'Unspecified Assembly', 'Arena', 'Stadium', 'Passenger Terminal', 'Amphitheater', 'Amusement Park', 'Place of Worship', 'Convention Center', 'Library', 'Museum', 'Restaurant', 'Theater', 'Bar', 'Coffee Shop', 'Zoo or Aquarium', 'Emergency Coordination Center', 'Unspecified Business', 'Doctor or Dentist office', 'Bank', 'Fire Station', 'Police Station', 'Post Office', 'Professional Office', 'Research and Development Facility', 'Attorney Office', 'Unspecified Educational', 'School, Primary', 'School, Secondary', 'University or College', 'Unspecified Factory and Industrial', 'Factory', 'Unspecified Institutional', 'Hospital', 'Long-Term Care Facility', 'Alcohol and Drug Rehabilitation Center', 'Group Home', 'Prison or Jail', 'Unspecified Mercantile', 'Retail Store', 'Grocery Market', 'Automotive Service Station', 'Shopping Mall', 'Gas Station', 'Unspecified Residential', 'Private Residence', 'Hotel or Motel', 'Dormitory', 'Boarding House', 'Unspecified Storage', 'Unspecified Utility and Miscellaneous', 'Unspecified Vehicular', 'Automobile or Truck', 'Airplane', 'Bus', 'Ferry', 'Ship or Boat', 'Train', 'Motor Bike', 'Unspecified Outdoor', 'Muni-mesh Network', 'City Park', 'Rest Area', 'Traffic Control', 'Bus Stop', 'Kiosk') */
		type?: UpdateNetworkWirelessSsidHotspot20PutBodyVenueType | null;
	}
	export interface UpdateNetworkWirelessSsidHotspot20PutBodyVenueFormProperties {

		/** Venue name */
		name: FormControl<string | null | undefined>,

		/** Venue type ('Unspecified', 'Unspecified Assembly', 'Arena', 'Stadium', 'Passenger Terminal', 'Amphitheater', 'Amusement Park', 'Place of Worship', 'Convention Center', 'Library', 'Museum', 'Restaurant', 'Theater', 'Bar', 'Coffee Shop', 'Zoo or Aquarium', 'Emergency Coordination Center', 'Unspecified Business', 'Doctor or Dentist office', 'Bank', 'Fire Station', 'Police Station', 'Post Office', 'Professional Office', 'Research and Development Facility', 'Attorney Office', 'Unspecified Educational', 'School, Primary', 'School, Secondary', 'University or College', 'Unspecified Factory and Industrial', 'Factory', 'Unspecified Institutional', 'Hospital', 'Long-Term Care Facility', 'Alcohol and Drug Rehabilitation Center', 'Group Home', 'Prison or Jail', 'Unspecified Mercantile', 'Retail Store', 'Grocery Market', 'Automotive Service Station', 'Shopping Mall', 'Gas Station', 'Unspecified Residential', 'Private Residence', 'Hotel or Motel', 'Dormitory', 'Boarding House', 'Unspecified Storage', 'Unspecified Utility and Miscellaneous', 'Unspecified Vehicular', 'Automobile or Truck', 'Airplane', 'Bus', 'Ferry', 'Ship or Boat', 'Train', 'Motor Bike', 'Unspecified Outdoor', 'Muni-mesh Network', 'City Park', 'Rest Area', 'Traffic Control', 'Bus Stop', 'Kiosk') */
		type: FormControl<UpdateNetworkWirelessSsidHotspot20PutBodyVenueType | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidHotspot20PutBodyVenueFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidHotspot20PutBodyVenueFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<UpdateNetworkWirelessSsidHotspot20PutBodyVenueType | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessSsidHotspot20PutBodyVenueType { Airplane = 'Airplane', 'Alcohol and Drug Rehabilitation Center' = 'Alcohol and Drug Rehabilitation Center', Amphitheater = 'Amphitheater', 'Amusement Park' = 'Amusement Park', Arena = 'Arena', 'Attorney Office' = 'Attorney Office', 'Automobile or Truck' = 'Automobile or Truck', 'Automotive Service Station' = 'Automotive Service Station', Bank = 'Bank', Bar = 'Bar', 'Boarding House' = 'Boarding House', Bus = 'Bus', 'Bus Stop' = 'Bus Stop', 'City Park' = 'City Park', 'Coffee Shop' = 'Coffee Shop', 'Convention Center' = 'Convention Center', 'Doctor or Dentist office' = 'Doctor or Dentist office', Dormitory = 'Dormitory', 'Emergency Coordination Center' = 'Emergency Coordination Center', Factory = 'Factory', Ferry = 'Ferry', 'Fire Station' = 'Fire Station', 'Gas Station' = 'Gas Station', 'Grocery Market' = 'Grocery Market', 'Group Home' = 'Group Home', Hospital = 'Hospital', 'Hotel or Motel' = 'Hotel or Motel', Kiosk = 'Kiosk', Library = 'Library', 'Long-Term Care Facility' = 'Long-Term Care Facility', 'Motor Bike' = 'Motor Bike', 'Muni-mesh Network' = 'Muni-mesh Network', Museum = 'Museum', 'Passenger Terminal' = 'Passenger Terminal', 'Place of Worship' = 'Place of Worship', 'Police Station' = 'Police Station', 'Post Office' = 'Post Office', 'Prison or Jail' = 'Prison or Jail', 'Private Residence' = 'Private Residence', 'Professional Office' = 'Professional Office', 'Research and Development Facility' = 'Research and Development Facility', 'Rest Area' = 'Rest Area', Restaurant = 'Restaurant', 'Retail Store' = 'Retail Store', 'School, Primary' = 'School, Primary', 'School, Secondary' = 'School, Secondary', 'Ship or Boat' = 'Ship or Boat', 'Shopping Mall' = 'Shopping Mall', Stadium = 'Stadium', Theater = 'Theater', 'Traffic Control' = 'Traffic Control', Train = 'Train', 'University or College' = 'University or College', Unspecified = 'Unspecified', 'Unspecified Assembly' = 'Unspecified Assembly', 'Unspecified Business' = 'Unspecified Business', 'Unspecified Educational' = 'Unspecified Educational', 'Unspecified Factory and Industrial' = 'Unspecified Factory and Industrial', 'Unspecified Institutional' = 'Unspecified Institutional', 'Unspecified Mercantile' = 'Unspecified Mercantile', 'Unspecified Outdoor' = 'Unspecified Outdoor', 'Unspecified Residential' = 'Unspecified Residential', 'Unspecified Storage' = 'Unspecified Storage', 'Unspecified Utility and Miscellaneous' = 'Unspecified Utility and Miscellaneous', 'Unspecified Vehicular' = 'Unspecified Vehicular', 'Zoo or Aquarium' = 'Zoo or Aquarium' }

	export interface GetNetworkWirelessSsidIdentityPsksReturn {

		/** The email associated with the System's Manager User */
		email?: string | null;

		/** Timestamp for when the Identity PSK expires, or 'null' to never expire */
		expiresAt?: string | null;

		/** The group policy to be applied to clients */
		groupPolicyId?: string | null;

		/** The unique identifier of the Identity PSK */
		id?: string | null;

		/** The name of the Identity PSK */
		name?: string | null;

		/** The passphrase for client authentication */
		passphrase?: string | null;

		/** The WiFi Personal Network unique identifier */
		wifiPersonalNetworkId?: string | null;
	}
	export interface GetNetworkWirelessSsidIdentityPsksReturnFormProperties {

		/** The email associated with the System's Manager User */
		email: FormControl<string | null | undefined>,

		/** Timestamp for when the Identity PSK expires, or 'null' to never expire */
		expiresAt: FormControl<string | null | undefined>,

		/** The group policy to be applied to clients */
		groupPolicyId: FormControl<string | null | undefined>,

		/** The unique identifier of the Identity PSK */
		id: FormControl<string | null | undefined>,

		/** The name of the Identity PSK */
		name: FormControl<string | null | undefined>,

		/** The passphrase for client authentication */
		passphrase: FormControl<string | null | undefined>,

		/** The WiFi Personal Network unique identifier */
		wifiPersonalNetworkId: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidIdentityPsksReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidIdentityPsksReturnFormProperties>({
			email: new FormControl<string | null | undefined>(undefined),
			expiresAt: new FormControl<string | null | undefined>(undefined),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			passphrase: new FormControl<string | null | undefined>(undefined),
			wifiPersonalNetworkId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateNetworkWirelessSsidIdentityPskPostBody {

		/**
		 * The group policy to be applied to clients
		 * Required
		 */
		groupPolicyId: string;

		/**
		 * The name of the Identity PSK
		 * Required
		 */
		name: string;

		/** The passphrase for client authentication. If left blank, one will be auto-generated. */
		passphrase?: string | null;
	}
	export interface CreateNetworkWirelessSsidIdentityPskPostBodyFormProperties {

		/**
		 * The group policy to be applied to clients
		 * Required
		 */
		groupPolicyId: FormControl<string | null | undefined>,

		/**
		 * The name of the Identity PSK
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/** The passphrase for client authentication. If left blank, one will be auto-generated. */
		passphrase: FormControl<string | null | undefined>,
	}
	export function CreateCreateNetworkWirelessSsidIdentityPskPostBodyFormGroup() {
		return new FormGroup<CreateNetworkWirelessSsidIdentityPskPostBodyFormProperties>({
			groupPolicyId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			passphrase: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSsidIdentityPskReturn {

		/** The email associated with the System's Manager User */
		email?: string | null;

		/** Timestamp for when the Identity PSK expires, or 'null' to never expire */
		expiresAt?: string | null;

		/** The group policy to be applied to clients */
		groupPolicyId?: string | null;

		/** The unique identifier of the Identity PSK */
		id?: string | null;

		/** The name of the Identity PSK */
		name?: string | null;

		/** The passphrase for client authentication */
		passphrase?: string | null;

		/** The WiFi Personal Network unique identifier */
		wifiPersonalNetworkId?: string | null;
	}
	export interface GetNetworkWirelessSsidIdentityPskReturnFormProperties {

		/** The email associated with the System's Manager User */
		email: FormControl<string | null | undefined>,

		/** Timestamp for when the Identity PSK expires, or 'null' to never expire */
		expiresAt: FormControl<string | null | undefined>,

		/** The group policy to be applied to clients */
		groupPolicyId: FormControl<string | null | undefined>,

		/** The unique identifier of the Identity PSK */
		id: FormControl<string | null | undefined>,

		/** The name of the Identity PSK */
		name: FormControl<string | null | undefined>,

		/** The passphrase for client authentication */
		passphrase: FormControl<string | null | undefined>,

		/** The WiFi Personal Network unique identifier */
		wifiPersonalNetworkId: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidIdentityPskReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidIdentityPskReturnFormProperties>({
			email: new FormControl<string | null | undefined>(undefined),
			expiresAt: new FormControl<string | null | undefined>(undefined),
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			passphrase: new FormControl<string | null | undefined>(undefined),
			wifiPersonalNetworkId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidIdentityPskPutBody {

		/** The group policy to be applied to clients */
		groupPolicyId?: string | null;

		/** The name of the Identity PSK */
		name?: string | null;

		/** The passphrase for client authentication */
		passphrase?: string | null;
	}
	export interface UpdateNetworkWirelessSsidIdentityPskPutBodyFormProperties {

		/** The group policy to be applied to clients */
		groupPolicyId: FormControl<string | null | undefined>,

		/** The name of the Identity PSK */
		name: FormControl<string | null | undefined>,

		/** The passphrase for client authentication */
		passphrase: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidIdentityPskPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidIdentityPskPutBodyFormProperties>({
			groupPolicyId: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			passphrase: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSchedulesPutBody {

		/** If true, the SSID outage schedule is enabled. */
		enabled?: boolean | null;

		/** List of outage ranges. Has a start date and time, and end date and time. If this parameter is passed in along with rangesInSeconds parameter, this will take precedence. */
		UpdateNetworkWirelessSsidSchedulesPutBodyRanges?: Array<UpdateNetworkWirelessSsidSchedulesPutBodyRanges>;

		/** List of outage ranges in seconds since Sunday at Midnight. Has a start and end. If this parameter is passed in along with the ranges parameter, ranges will take precedence. */
		UpdateNetworkWirelessSsidSchedulesPutBodyRangesInSeconds?: Array<UpdateNetworkWirelessSsidSchedulesPutBodyRangesInSeconds>;
	}
	export interface UpdateNetworkWirelessSsidSchedulesPutBodyFormProperties {

		/** If true, the SSID outage schedule is enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSchedulesPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSchedulesPutBodyFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSchedulesPutBodyRanges {

		/**
		 * Day of when the outage ends. Can be either full day name, or three letter abbreviation
		 * Required
		 */
		endDay: string;

		/**
		 * 24 hour time when the outage ends.
		 * Required
		 */
		endTime: string;

		/**
		 * Day of when the outage starts. Can be either full day name, or three letter abbreviation.
		 * Required
		 */
		startDay: string;

		/**
		 * 24 hour time when the outage starts.
		 * Required
		 */
		startTime: string;
	}
	export interface UpdateNetworkWirelessSsidSchedulesPutBodyRangesFormProperties {

		/**
		 * Day of when the outage ends. Can be either full day name, or three letter abbreviation
		 * Required
		 */
		endDay: FormControl<string | null | undefined>,

		/**
		 * 24 hour time when the outage ends.
		 * Required
		 */
		endTime: FormControl<string | null | undefined>,

		/**
		 * Day of when the outage starts. Can be either full day name, or three letter abbreviation.
		 * Required
		 */
		startDay: FormControl<string | null | undefined>,

		/**
		 * 24 hour time when the outage starts.
		 * Required
		 */
		startTime: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSchedulesPutBodyRangesFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSchedulesPutBodyRangesFormProperties>({
			endDay: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			endTime: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			startDay: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			startTime: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkWirelessSsidSchedulesPutBodyRangesInSeconds {

		/**
		 * Seconds since Sunday at midnight when that outage range ends.
		 * Required
		 */
		end: number;

		/**
		 * Seconds since Sunday at midnight when the outage range starts.
		 * Required
		 */
		start: number;
	}
	export interface UpdateNetworkWirelessSsidSchedulesPutBodyRangesInSecondsFormProperties {

		/**
		 * Seconds since Sunday at midnight when that outage range ends.
		 * Required
		 */
		end: FormControl<number | null | undefined>,

		/**
		 * Seconds since Sunday at midnight when the outage range starts.
		 * Required
		 */
		start: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSchedulesPutBodyRangesInSecondsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSchedulesPutBodyRangesInSecondsFormProperties>({
			end: new FormControl<number | null | undefined>(undefined, [Validators.required]),
			start: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetNetworkWirelessSsidSplashSettingsReturn {

		/** Whether or not to allow simultaneous logins from different devices. */
		allowSimultaneousLogins?: boolean | null;

		/** Details associated with billing splash */
		billing?: GetNetworkWirelessSsidSplashSettingsReturnBilling;

		/** How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged. */
		blockAllTrafficBeforeSignOn?: boolean | null;

		/** How login attempts should be handled when the controller is unreachable. */
		controllerDisconnectionBehavior?: string | null;

		/** Details associated with guest sponsored splash */
		guestSponsorship?: GetNetworkWirelessSsidSplashSettingsReturnGuestSponsorship;

		/** The custom redirect URL where the users will go after the splash page. */
		redirectUrl?: string | null;

		/** Self-registration for splash with Meraki authentication. */
		selfRegistration?: GetNetworkWirelessSsidSplashSettingsReturnSelfRegistration;

		/** Systems Manager sentry enrollment splash settings. */
		sentryEnrollment?: GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollment;

		/** The image used in the splash page. */
		splashImage?: GetNetworkWirelessSsidSplashSettingsReturnSplashImage;

		/** The logo used in the splash page. */
		splashLogo?: GetNetworkWirelessSsidSplashSettingsReturnSplashLogo;

		/** The type of splash page for this SSID */
		splashPage?: string | null;

		/** The prepaid front image used in the splash page. */
		splashPrepaidFront?: GetNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFront;

		/** Splash timeout in minutes. */
		splashTimeout?: number | null;

		/** The custom splash URL of the click-through splash page. */
		splashUrl?: string | null;

		/** SSID number */
		ssidNumber?: number | null;

		/** The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page. */
		useRedirectUrl?: boolean | null;

		/** Boolean indicating whether the users will be redirected to the custom splash url */
		useSplashUrl?: boolean | null;

		/** The welcome message for the users on the splash page. */
		welcomeMessage?: string | null;
	}
	export interface GetNetworkWirelessSsidSplashSettingsReturnFormProperties {

		/** Whether or not to allow simultaneous logins from different devices. */
		allowSimultaneousLogins: FormControl<boolean | null | undefined>,

		/** How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged. */
		blockAllTrafficBeforeSignOn: FormControl<boolean | null | undefined>,

		/** How login attempts should be handled when the controller is unreachable. */
		controllerDisconnectionBehavior: FormControl<string | null | undefined>,

		/** The custom redirect URL where the users will go after the splash page. */
		redirectUrl: FormControl<string | null | undefined>,

		/** The type of splash page for this SSID */
		splashPage: FormControl<string | null | undefined>,

		/** Splash timeout in minutes. */
		splashTimeout: FormControl<number | null | undefined>,

		/** The custom splash URL of the click-through splash page. */
		splashUrl: FormControl<string | null | undefined>,

		/** SSID number */
		ssidNumber: FormControl<number | null | undefined>,

		/** The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page. */
		useRedirectUrl: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether the users will be redirected to the custom splash url */
		useSplashUrl: FormControl<boolean | null | undefined>,

		/** The welcome message for the users on the splash page. */
		welcomeMessage: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidSplashSettingsReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidSplashSettingsReturnFormProperties>({
			allowSimultaneousLogins: new FormControl<boolean | null | undefined>(undefined),
			blockAllTrafficBeforeSignOn: new FormControl<boolean | null | undefined>(undefined),
			controllerDisconnectionBehavior: new FormControl<string | null | undefined>(undefined),
			redirectUrl: new FormControl<string | null | undefined>(undefined),
			splashPage: new FormControl<string | null | undefined>(undefined),
			splashTimeout: new FormControl<number | null | undefined>(undefined),
			splashUrl: new FormControl<string | null | undefined>(undefined),
			ssidNumber: new FormControl<number | null | undefined>(undefined),
			useRedirectUrl: new FormControl<boolean | null | undefined>(undefined),
			useSplashUrl: new FormControl<boolean | null | undefined>(undefined),
			welcomeMessage: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSsidSplashSettingsReturnBilling {

		/** Details associated with a free access plan with limits */
		freeAccess?: GetNetworkWirelessSsidSplashSettingsReturnBillingFreeAccess;

		/** Whether or not billing uses the fast login prepaid access option. */
		prepaidAccessFastLoginEnabled?: boolean | null;

		/** The email address that reeceives replies from clients */
		replyToEmailAddress?: string | null;
	}
	export interface GetNetworkWirelessSsidSplashSettingsReturnBillingFormProperties {

		/** Whether or not billing uses the fast login prepaid access option. */
		prepaidAccessFastLoginEnabled: FormControl<boolean | null | undefined>,

		/** The email address that reeceives replies from clients */
		replyToEmailAddress: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidSplashSettingsReturnBillingFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidSplashSettingsReturnBillingFormProperties>({
			prepaidAccessFastLoginEnabled: new FormControl<boolean | null | undefined>(undefined),
			replyToEmailAddress: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSsidSplashSettingsReturnBillingFreeAccess {

		/** How long a device can use a network for free. */
		durationInMinutes?: number | null;

		/** Whether or not free access is enabled. */
		enabled?: boolean | null;
	}
	export interface GetNetworkWirelessSsidSplashSettingsReturnBillingFreeAccessFormProperties {

		/** How long a device can use a network for free. */
		durationInMinutes: FormControl<number | null | undefined>,

		/** Whether or not free access is enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidSplashSettingsReturnBillingFreeAccessFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidSplashSettingsReturnBillingFreeAccessFormProperties>({
			durationInMinutes: new FormControl<number | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSsidSplashSettingsReturnGuestSponsorship {

		/** Duration in minutes of sponsored guest authorization. */
		durationInMinutes?: number | null;

		/** Whether or not guests can specify how much time they are requesting. */
		guestCanRequestTimeframe?: boolean | null;
	}
	export interface GetNetworkWirelessSsidSplashSettingsReturnGuestSponsorshipFormProperties {

		/** Duration in minutes of sponsored guest authorization. */
		durationInMinutes: FormControl<number | null | undefined>,

		/** Whether or not guests can specify how much time they are requesting. */
		guestCanRequestTimeframe: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidSplashSettingsReturnGuestSponsorshipFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidSplashSettingsReturnGuestSponsorshipFormProperties>({
			durationInMinutes: new FormControl<number | null | undefined>(undefined),
			guestCanRequestTimeframe: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSsidSplashSettingsReturnSelfRegistration {

		/** How created user accounts should be authorized. */
		authorizationType?: GetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationAuthorizationType | null;

		/** Whether or not to allow users to create their own account on the network. */
		enabled?: boolean | null;
	}
	export interface GetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationFormProperties {

		/** How created user accounts should be authorized. */
		authorizationType: FormControl<GetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationAuthorizationType | null | undefined>,

		/** Whether or not to allow users to create their own account on the network. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationFormProperties>({
			authorizationType: new FormControl<GetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationAuthorizationType | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum GetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationAuthorizationType { admin = 'admin', auto = 'auto', self_email = 'self_email' }

	export interface GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollment {

		/** The system types that the Sentry enforces. */
		enforcedSystems?: Array<string>;

		/** The strength of the enforcement of selected system types. */
		strength?: GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength | null;

		/** Systems Manager network targeted for sentry enrollment. */
		systemsManagerNetwork?: GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetwork;
	}
	export interface GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentFormProperties {

		/** The strength of the enforcement of selected system types. */
		strength: FormControl<GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentFormProperties>({
			strength: new FormControl<GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength | null | undefined>(undefined),
		});

	}

	export enum GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength { 'click-through' = 'click-through', focused = 'focused', strict = 'strict' }

	export interface GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetwork {

		/** The network ID of the Systems Manager network. */
		id?: string | null;
	}
	export interface GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetworkFormProperties {

		/** The network ID of the Systems Manager network. */
		id: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetworkFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSsidSplashSettingsReturnSplashImage {

		/** The extension of the image file. */
		extension?: string | null;

		/** The MD5 value of the image file. */
		md5?: string | null;
	}
	export interface GetNetworkWirelessSsidSplashSettingsReturnSplashImageFormProperties {

		/** The extension of the image file. */
		extension: FormControl<string | null | undefined>,

		/** The MD5 value of the image file. */
		md5: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidSplashSettingsReturnSplashImageFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidSplashSettingsReturnSplashImageFormProperties>({
			extension: new FormControl<string | null | undefined>(undefined),
			md5: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSsidSplashSettingsReturnSplashLogo {

		/** The extension of the logo file. */
		extension?: string | null;

		/** The MD5 value of the logo file. */
		md5?: string | null;
	}
	export interface GetNetworkWirelessSsidSplashSettingsReturnSplashLogoFormProperties {

		/** The extension of the logo file. */
		extension: FormControl<string | null | undefined>,

		/** The MD5 value of the logo file. */
		md5: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidSplashSettingsReturnSplashLogoFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidSplashSettingsReturnSplashLogoFormProperties>({
			extension: new FormControl<string | null | undefined>(undefined),
			md5: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFront {

		/** The extension of the prepaid front image file. */
		extension?: string | null;

		/** The MD5 value of the prepaid front image file. */
		md5?: string | null;
	}
	export interface GetNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFrontFormProperties {

		/** The extension of the prepaid front image file. */
		extension: FormControl<string | null | undefined>,

		/** The MD5 value of the prepaid front image file. */
		md5: FormControl<string | null | undefined>,
	}
	export function CreateGetNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFrontFormGroup() {
		return new FormGroup<GetNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFrontFormProperties>({
			extension: new FormControl<string | null | undefined>(undefined),
			md5: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsPutBody {

		/** Whether or not to allow simultaneous logins from different devices. */
		allowSimultaneousLogins?: boolean | null;

		/** Details associated with billing splash. */
		billing?: UpdateNetworkWirelessSsidSplashSettingsPutBodyBilling;

		/** How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged. */
		blockAllTrafficBeforeSignOn?: boolean | null;

		/** How login attempts should be handled when the controller is unreachable. Can be either 'open', 'restricted', or 'default'. */
		controllerDisconnectionBehavior?: UpdateNetworkWirelessSsidSplashSettingsPutBodyControllerDisconnectionBehavior | null;

		/** Details associated with guest sponsored splash. */
		guestSponsorship?: UpdateNetworkWirelessSsidSplashSettingsPutBodyGuestSponsorship;

		/** The custom redirect URL where the users will go after the splash page. */
		redirectUrl?: string | null;

		/** Systems Manager sentry enrollment splash settings. */
		sentryEnrollment?: UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollment;

		/** The image used in the splash page. */
		splashImage?: UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImage;

		/** The logo used in the splash page. */
		splashLogo?: UpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogo;

		/** The prepaid front image used in the splash page. */
		splashPrepaidFront?: UpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFront;

		/** Splash timeout in minutes. This will determine how often users will see the splash page. */
		splashTimeout?: number | null;

		/** [optional] The custom splash URL of the click-through splash page. Note that the URL can be configured without necessarily being used. In order to enable the custom URL, see 'useSplashUrl' */
		splashUrl?: string | null;

		/** The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page. A custom redirect URL must be set if this is true. */
		useRedirectUrl?: boolean | null;

		/** [optional] Boolean indicating whether the users will be redirected to the custom splash url. A custom splash URL must be set if this is true. Note that depending on your SSID's access control settings, it may not be possible to use the custom splash URL. */
		useSplashUrl?: boolean | null;

		/** The welcome message for the users on the splash page. */
		welcomeMessage?: string | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodyFormProperties {

		/** Whether or not to allow simultaneous logins from different devices. */
		allowSimultaneousLogins: FormControl<boolean | null | undefined>,

		/** How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged. */
		blockAllTrafficBeforeSignOn: FormControl<boolean | null | undefined>,

		/** How login attempts should be handled when the controller is unreachable. Can be either 'open', 'restricted', or 'default'. */
		controllerDisconnectionBehavior: FormControl<UpdateNetworkWirelessSsidSplashSettingsPutBodyControllerDisconnectionBehavior | null | undefined>,

		/** The custom redirect URL where the users will go after the splash page. */
		redirectUrl: FormControl<string | null | undefined>,

		/** Splash timeout in minutes. This will determine how often users will see the splash page. */
		splashTimeout: FormControl<number | null | undefined>,

		/** [optional] The custom splash URL of the click-through splash page. Note that the URL can be configured without necessarily being used. In order to enable the custom URL, see 'useSplashUrl' */
		splashUrl: FormControl<string | null | undefined>,

		/** The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page. A custom redirect URL must be set if this is true. */
		useRedirectUrl: FormControl<boolean | null | undefined>,

		/** [optional] Boolean indicating whether the users will be redirected to the custom splash url. A custom splash URL must be set if this is true. Note that depending on your SSID's access control settings, it may not be possible to use the custom splash URL. */
		useSplashUrl: FormControl<boolean | null | undefined>,

		/** The welcome message for the users on the splash page. */
		welcomeMessage: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsPutBodyFormProperties>({
			allowSimultaneousLogins: new FormControl<boolean | null | undefined>(undefined),
			blockAllTrafficBeforeSignOn: new FormControl<boolean | null | undefined>(undefined),
			controllerDisconnectionBehavior: new FormControl<UpdateNetworkWirelessSsidSplashSettingsPutBodyControllerDisconnectionBehavior | null | undefined>(undefined),
			redirectUrl: new FormControl<string | null | undefined>(undefined),
			splashTimeout: new FormControl<number | null | undefined>(undefined),
			splashUrl: new FormControl<string | null | undefined>(undefined),
			useRedirectUrl: new FormControl<boolean | null | undefined>(undefined),
			useSplashUrl: new FormControl<boolean | null | undefined>(undefined),
			welcomeMessage: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodyBilling {

		/** Details associated with a free access plan with limits. */
		freeAccess?: UpdateNetworkWirelessSsidSplashSettingsPutBodyBillingFreeAccess;

		/** Whether or not billing uses the fast login prepaid access option. */
		prepaidAccessFastLoginEnabled?: boolean | null;

		/** The email address that receives replies from clients. */
		replyToEmailAddress?: string | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodyBillingFormProperties {

		/** Whether or not billing uses the fast login prepaid access option. */
		prepaidAccessFastLoginEnabled: FormControl<boolean | null | undefined>,

		/** The email address that receives replies from clients. */
		replyToEmailAddress: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsPutBodyBillingFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsPutBodyBillingFormProperties>({
			prepaidAccessFastLoginEnabled: new FormControl<boolean | null | undefined>(undefined),
			replyToEmailAddress: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodyBillingFreeAccess {

		/** How long a device can use a network for free. */
		durationInMinutes?: number | null;

		/** Whether or not free access is enabled. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodyBillingFreeAccessFormProperties {

		/** How long a device can use a network for free. */
		durationInMinutes: FormControl<number | null | undefined>,

		/** Whether or not free access is enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsPutBodyBillingFreeAccessFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsPutBodyBillingFreeAccessFormProperties>({
			durationInMinutes: new FormControl<number | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessSsidSplashSettingsPutBodyControllerDisconnectionBehavior { default = 'default', open = 'open', restricted = 'restricted' }

	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodyGuestSponsorship {

		/** Duration in minutes of sponsored guest authorization. Must be between 1 and 60480 (6 weeks) */
		durationInMinutes?: number | null;

		/** Whether or not guests can specify how much time they are requesting. */
		guestCanRequestTimeframe?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodyGuestSponsorshipFormProperties {

		/** Duration in minutes of sponsored guest authorization. Must be between 1 and 60480 (6 weeks) */
		durationInMinutes: FormControl<number | null | undefined>,

		/** Whether or not guests can specify how much time they are requesting. */
		guestCanRequestTimeframe: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsPutBodyGuestSponsorshipFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsPutBodyGuestSponsorshipFormProperties>({
			durationInMinutes: new FormControl<number | null | undefined>(undefined),
			guestCanRequestTimeframe: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollment {

		/** The system types that the Sentry enforces. Must be included in: 'iOS, 'Android', 'macOS', and 'Windows'. */
		enforcedSystems?: Array<string>;

		/** The strength of the enforcement of selected system types. Must be one of: 'focused', 'click-through', and 'strict'. */
		strength?: GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength | null;

		/** Systems Manager network targeted for sentry enrollment. */
		systemsManagerNetwork?: UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollmentSystemsManagerNetwork;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollmentFormProperties {

		/** The strength of the enforcement of selected system types. Must be one of: 'focused', 'click-through', and 'strict'. */
		strength: FormControl<GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollmentFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollmentFormProperties>({
			strength: new FormControl<GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollmentSystemsManagerNetwork {

		/**
		 * The network ID of the Systems Manager network.
		 * Required
		 */
		id: string;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollmentSystemsManagerNetworkFormProperties {

		/**
		 * The network ID of the Systems Manager network.
		 * Required
		 */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollmentSystemsManagerNetworkFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollmentSystemsManagerNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImage {

		/** The extension of the image file. */
		extension?: string | null;

		/** Properties for setting a new image. */
		image?: UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImage;

		/** The MD5 value of the image file. Setting this to null will remove the image from the splash page. */
		md5?: string | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageFormProperties {

		/** The extension of the image file. */
		extension: FormControl<string | null | undefined>,

		/** The MD5 value of the image file. Setting this to null will remove the image from the splash page. */
		md5: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageFormProperties>({
			extension: new FormControl<string | null | undefined>(undefined),
			md5: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImage {

		/** The file contents (a base 64 encoded string) of your new image. */
		contents?: string | null;

		/** The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'. */
		format?: UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormProperties {

		/** The file contents (a base 64 encoded string) of your new image. */
		contents: FormControl<string | null | undefined>,

		/** The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'. */
		format: FormControl<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormProperties>({
			contents: new FormControl<string | null | undefined>(undefined),
			format: new FormControl<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat { gif = 'gif', jpg = 'jpg', png = 'png' }

	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogo {

		/** The extension of the logo file. */
		extension?: string | null;

		/** Properties for setting a new image. */
		image?: UpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogoImage;

		/** The MD5 value of the logo file. Setting this to null will remove the logo from the splash page. */
		md5?: string | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogoFormProperties {

		/** The extension of the logo file. */
		extension: FormControl<string | null | undefined>,

		/** The MD5 value of the logo file. Setting this to null will remove the logo from the splash page. */
		md5: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogoFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogoFormProperties>({
			extension: new FormControl<string | null | undefined>(undefined),
			md5: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogoImage {

		/** The file contents (a base 64 encoded string) of your new logo. */
		contents?: string | null;

		/** The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'. */
		format?: UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogoImageFormProperties {

		/** The file contents (a base 64 encoded string) of your new logo. */
		contents: FormControl<string | null | undefined>,

		/** The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'. */
		format: FormControl<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogoImageFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogoImageFormProperties>({
			contents: new FormControl<string | null | undefined>(undefined),
			format: new FormControl<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFront {

		/** The extension of the prepaid front image file. */
		extension?: string | null;

		/** Properties for setting a new image. */
		image?: UpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFrontImage;

		/** The MD5 value of the prepaid front image file. Setting this to null will remove the prepaid front from the splash page. */
		md5?: string | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFrontFormProperties {

		/** The extension of the prepaid front image file. */
		extension: FormControl<string | null | undefined>,

		/** The MD5 value of the prepaid front image file. Setting this to null will remove the prepaid front from the splash page. */
		md5: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFrontFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFrontFormProperties>({
			extension: new FormControl<string | null | undefined>(undefined),
			md5: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFrontImage {

		/** The file contents (a base 64 encoded string) of your new prepaid front. */
		contents?: string | null;

		/** The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'. */
		format?: UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFrontImageFormProperties {

		/** The file contents (a base 64 encoded string) of your new prepaid front. */
		contents: FormControl<string | null | undefined>,

		/** The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'. */
		format: FormControl<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFrontImageFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFrontImageFormProperties>({
			contents: new FormControl<string | null | undefined>(undefined),
			format: new FormControl<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsReturn {

		/** Whether or not to allow simultaneous logins from different devices. */
		allowSimultaneousLogins?: boolean | null;

		/** Details associated with billing splash */
		billing?: UpdateNetworkWirelessSsidSplashSettingsReturnBilling;

		/** How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged. */
		blockAllTrafficBeforeSignOn?: boolean | null;

		/** How login attempts should be handled when the controller is unreachable. */
		controllerDisconnectionBehavior?: string | null;

		/** Details associated with guest sponsored splash */
		guestSponsorship?: UpdateNetworkWirelessSsidSplashSettingsReturnGuestSponsorship;

		/** The custom redirect URL where the users will go after the splash page. */
		redirectUrl?: string | null;

		/** Self-registration for splash with Meraki authentication. */
		selfRegistration?: UpdateNetworkWirelessSsidSplashSettingsReturnSelfRegistration;

		/** Systems Manager sentry enrollment splash settings. */
		sentryEnrollment?: UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollment;

		/** The image used in the splash page. */
		splashImage?: UpdateNetworkWirelessSsidSplashSettingsReturnSplashImage;

		/** The logo used in the splash page. */
		splashLogo?: UpdateNetworkWirelessSsidSplashSettingsReturnSplashLogo;

		/** The type of splash page for this SSID */
		splashPage?: string | null;

		/** The prepaid front image used in the splash page. */
		splashPrepaidFront?: UpdateNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFront;

		/** Splash timeout in minutes. */
		splashTimeout?: number | null;

		/** The custom splash URL of the click-through splash page. */
		splashUrl?: string | null;

		/** SSID number */
		ssidNumber?: number | null;

		/** The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page. */
		useRedirectUrl?: boolean | null;

		/** Boolean indicating whether the users will be redirected to the custom splash url */
		useSplashUrl?: boolean | null;

		/** The welcome message for the users on the splash page. */
		welcomeMessage?: string | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsReturnFormProperties {

		/** Whether or not to allow simultaneous logins from different devices. */
		allowSimultaneousLogins: FormControl<boolean | null | undefined>,

		/** How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged. */
		blockAllTrafficBeforeSignOn: FormControl<boolean | null | undefined>,

		/** How login attempts should be handled when the controller is unreachable. */
		controllerDisconnectionBehavior: FormControl<string | null | undefined>,

		/** The custom redirect URL where the users will go after the splash page. */
		redirectUrl: FormControl<string | null | undefined>,

		/** The type of splash page for this SSID */
		splashPage: FormControl<string | null | undefined>,

		/** Splash timeout in minutes. */
		splashTimeout: FormControl<number | null | undefined>,

		/** The custom splash URL of the click-through splash page. */
		splashUrl: FormControl<string | null | undefined>,

		/** SSID number */
		ssidNumber: FormControl<number | null | undefined>,

		/** The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page. */
		useRedirectUrl: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether the users will be redirected to the custom splash url */
		useSplashUrl: FormControl<boolean | null | undefined>,

		/** The welcome message for the users on the splash page. */
		welcomeMessage: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsReturnFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsReturnFormProperties>({
			allowSimultaneousLogins: new FormControl<boolean | null | undefined>(undefined),
			blockAllTrafficBeforeSignOn: new FormControl<boolean | null | undefined>(undefined),
			controllerDisconnectionBehavior: new FormControl<string | null | undefined>(undefined),
			redirectUrl: new FormControl<string | null | undefined>(undefined),
			splashPage: new FormControl<string | null | undefined>(undefined),
			splashTimeout: new FormControl<number | null | undefined>(undefined),
			splashUrl: new FormControl<string | null | undefined>(undefined),
			ssidNumber: new FormControl<number | null | undefined>(undefined),
			useRedirectUrl: new FormControl<boolean | null | undefined>(undefined),
			useSplashUrl: new FormControl<boolean | null | undefined>(undefined),
			welcomeMessage: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsReturnBilling {

		/** Details associated with a free access plan with limits */
		freeAccess?: UpdateNetworkWirelessSsidSplashSettingsReturnBillingFreeAccess;

		/** Whether or not billing uses the fast login prepaid access option. */
		prepaidAccessFastLoginEnabled?: boolean | null;

		/** The email address that reeceives replies from clients */
		replyToEmailAddress?: string | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsReturnBillingFormProperties {

		/** Whether or not billing uses the fast login prepaid access option. */
		prepaidAccessFastLoginEnabled: FormControl<boolean | null | undefined>,

		/** The email address that reeceives replies from clients */
		replyToEmailAddress: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsReturnBillingFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsReturnBillingFormProperties>({
			prepaidAccessFastLoginEnabled: new FormControl<boolean | null | undefined>(undefined),
			replyToEmailAddress: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsReturnBillingFreeAccess {

		/** How long a device can use a network for free. */
		durationInMinutes?: number | null;

		/** Whether or not free access is enabled. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsReturnBillingFreeAccessFormProperties {

		/** How long a device can use a network for free. */
		durationInMinutes: FormControl<number | null | undefined>,

		/** Whether or not free access is enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsReturnBillingFreeAccessFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsReturnBillingFreeAccessFormProperties>({
			durationInMinutes: new FormControl<number | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsReturnGuestSponsorship {

		/** Duration in minutes of sponsored guest authorization. */
		durationInMinutes?: number | null;

		/** Whether or not guests can specify how much time they are requesting. */
		guestCanRequestTimeframe?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsReturnGuestSponsorshipFormProperties {

		/** Duration in minutes of sponsored guest authorization. */
		durationInMinutes: FormControl<number | null | undefined>,

		/** Whether or not guests can specify how much time they are requesting. */
		guestCanRequestTimeframe: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsReturnGuestSponsorshipFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsReturnGuestSponsorshipFormProperties>({
			durationInMinutes: new FormControl<number | null | undefined>(undefined),
			guestCanRequestTimeframe: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsReturnSelfRegistration {

		/** How created user accounts should be authorized. */
		authorizationType?: GetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationAuthorizationType | null;

		/** Whether or not to allow users to create their own account on the network. */
		enabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsReturnSelfRegistrationFormProperties {

		/** How created user accounts should be authorized. */
		authorizationType: FormControl<GetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationAuthorizationType | null | undefined>,

		/** Whether or not to allow users to create their own account on the network. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsReturnSelfRegistrationFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsReturnSelfRegistrationFormProperties>({
			authorizationType: new FormControl<GetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationAuthorizationType | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollment {

		/** The system types that the Sentry enforces. */
		enforcedSystems?: Array<string>;

		/** The strength of the enforcement of selected system types. */
		strength?: GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength | null;

		/** Systems Manager network targeted for sentry enrollment. */
		systemsManagerNetwork?: UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetwork;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentFormProperties {

		/** The strength of the enforcement of selected system types. */
		strength: FormControl<GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentFormProperties>({
			strength: new FormControl<GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetwork {

		/** The network ID of the Systems Manager network. */
		id?: string | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetworkFormProperties {

		/** The network ID of the Systems Manager network. */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetworkFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsReturnSplashImage {

		/** The extension of the image file. */
		extension?: string | null;

		/** The MD5 value of the image file. */
		md5?: string | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsReturnSplashImageFormProperties {

		/** The extension of the image file. */
		extension: FormControl<string | null | undefined>,

		/** The MD5 value of the image file. */
		md5: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsReturnSplashImageFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsReturnSplashImageFormProperties>({
			extension: new FormControl<string | null | undefined>(undefined),
			md5: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsReturnSplashLogo {

		/** The extension of the logo file. */
		extension?: string | null;

		/** The MD5 value of the logo file. */
		md5?: string | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsReturnSplashLogoFormProperties {

		/** The extension of the logo file. */
		extension: FormControl<string | null | undefined>,

		/** The MD5 value of the logo file. */
		md5: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsReturnSplashLogoFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsReturnSplashLogoFormProperties>({
			extension: new FormControl<string | null | undefined>(undefined),
			md5: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFront {

		/** The extension of the prepaid front image file. */
		extension?: string | null;

		/** The MD5 value of the prepaid front image file. */
		md5?: string | null;
	}
	export interface UpdateNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFrontFormProperties {

		/** The extension of the prepaid front image file. */
		extension: FormControl<string | null | undefined>,

		/** The MD5 value of the prepaid front image file. */
		md5: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFrontFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFrontFormProperties>({
			extension: new FormControl<string | null | undefined>(undefined),
			md5: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidTrafficShapingRulesPutBody {

		/** Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8. */
		defaultRulesEnabled?: boolean | null;

		/**
		 * An array of traffic shaping rules. Rules are applied in the order that
		 * they are specified in. An empty list (or null) means no rules. Note that
		 * you are allowed a maximum of 8 rules.
		 */
		UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRules?: Array<UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRules>;

		/** Whether traffic shaping rules are applied to clients on your SSID. */
		trafficShapingEnabled?: boolean | null;
	}
	export interface UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyFormProperties {

		/** Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8. */
		defaultRulesEnabled: FormControl<boolean | null | undefined>,

		/** Whether traffic shaping rules are applied to clients on your SSID. */
		trafficShapingEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidTrafficShapingRulesPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyFormProperties>({
			defaultRulesEnabled: new FormControl<boolean | null | undefined>(undefined),
			trafficShapingEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRules {

		/**
		 * A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
		 * Required
		 */
		UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesDefinitions: Array<UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesDefinitions>;

		/**
		 * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
		 * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
		 */
		dscpTagValue?: number | null;

		/**
		 * The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
		 * null means 'Do not set PCP tag'.
		 */
		pcpTagValue?: number | null;

		/**
		 * An object describing the bandwidth settings for your rule.
		 */
		perClientBandwidthLimits?: UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimits;
	}
	export interface UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesFormProperties {

		/**
		 * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
		 * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
		 */
		dscpTagValue: FormControl<number | null | undefined>,

		/**
		 * The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
		 * null means 'Do not set PCP tag'.
		 */
		pcpTagValue: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesFormProperties>({
			dscpTagValue: new FormControl<number | null | undefined>(undefined),
			pcpTagValue: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesDefinitions {

		/**
		 * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
		 * Required
		 */
		type: UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType;

		/**
		 * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
		 * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
		 * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
		 * custom ports.
		 * If "type" is 'application' or 'applicationCategory', then "value" must be an object
		 * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
		 * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
		 * endpoint).
		 * Required
		 */
		value: string;
	}
	export interface UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesDefinitionsFormProperties {

		/**
		 * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
		 * Required
		 */
		type: FormControl<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType | null | undefined>,

		/**
		 * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
		 * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
		 * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
		 * custom ports.
		 * If "type" is 'application' or 'applicationCategory', then "value" must be an object
		 * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
		 * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
		 * endpoint).
		 * Required
		 */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesDefinitionsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesDefinitionsFormProperties>({
			type: new FormControl<UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType | null | undefined>(undefined, [Validators.required]),
			value: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimits {

		/** The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'. */
		bandwidthLimits?: UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimits;

		/** How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'. */
		settings?: string | null;
	}
	export interface UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsFormProperties {

		/** How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'. */
		settings: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsFormProperties>({
			settings: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimits {

		/** The maximum download limit (integer, in Kbps). */
		limitDown?: number | null;

		/** The maximum upload limit (integer, in Kbps). */
		limitUp?: number | null;
	}
	export interface UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimitsFormProperties {

		/** The maximum download limit (integer, in Kbps). */
		limitDown: FormControl<number | null | undefined>,

		/** The maximum upload limit (integer, in Kbps). */
		limitUp: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimitsFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimitsFormProperties>({
			limitDown: new FormControl<number | null | undefined>(undefined),
			limitUp: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidVpnPutBody {

		/** The VPN concentrator settings for this SSID. */
		concentrator?: UpdateNetworkWirelessSsidVpnPutBodyConcentrator;

		/** Secondary VPN concentrator settings. This is only used when two VPN concentrators are configured on the SSID. */
		failover?: UpdateNetworkWirelessSsidVpnPutBodyFailover;

		/** The VPN split tunnel settings for this SSID. */
		splitTunnel?: UpdateNetworkWirelessSsidVpnPutBodySplitTunnel;
	}
	export interface UpdateNetworkWirelessSsidVpnPutBodyFormProperties {
	}
	export function CreateUpdateNetworkWirelessSsidVpnPutBodyFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidVpnPutBodyFormProperties>({
		});

	}

	export interface UpdateNetworkWirelessSsidVpnPutBodyConcentrator {

		/** The NAT ID of the concentrator that should be set. */
		networkId?: string | null;

		/** The VLAN that should be tagged for the concentrator. */
		vlanId?: number | null;
	}
	export interface UpdateNetworkWirelessSsidVpnPutBodyConcentratorFormProperties {

		/** The NAT ID of the concentrator that should be set. */
		networkId: FormControl<string | null | undefined>,

		/** The VLAN that should be tagged for the concentrator. */
		vlanId: FormControl<number | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidVpnPutBodyConcentratorFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidVpnPutBodyConcentratorFormProperties>({
			networkId: new FormControl<string | null | undefined>(undefined),
			vlanId: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidVpnPutBodyFailover {

		/** Idle timer interval in seconds. */
		heartbeatInterval?: number | null;

		/** Idle timer timeout in seconds. */
		idleTimeout?: number | null;

		/** IP addressed reserved on DHCP server where SSID will terminate. */
		requestIp?: string | null;
	}
	export interface UpdateNetworkWirelessSsidVpnPutBodyFailoverFormProperties {

		/** Idle timer interval in seconds. */
		heartbeatInterval: FormControl<number | null | undefined>,

		/** Idle timer timeout in seconds. */
		idleTimeout: FormControl<number | null | undefined>,

		/** IP addressed reserved on DHCP server where SSID will terminate. */
		requestIp: FormControl<string | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidVpnPutBodyFailoverFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidVpnPutBodyFailoverFormProperties>({
			heartbeatInterval: new FormControl<number | null | undefined>(undefined),
			idleTimeout: new FormControl<number | null | undefined>(undefined),
			requestIp: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidVpnPutBodySplitTunnel {

		/** If true, VPN split tunnel is enabled. */
		enabled?: boolean | null;

		/** List of VPN split tunnel rules. */
		UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRules?: Array<UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRules>;
	}
	export interface UpdateNetworkWirelessSsidVpnPutBodySplitTunnelFormProperties {

		/** If true, VPN split tunnel is enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidVpnPutBodySplitTunnelFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidVpnPutBodySplitTunnelFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRules {

		/** Description for this split tunnel rule (optional). */
		comment?: string | null;

		/**
		 * Destination for this split tunnel rule. IP address, fully-qualified domain names (FQDN) or 'any'.
		 * Required
		 */
		destCidr: string;

		/** Destination port for this split tunnel rule, (integer in the range 1-65535), or 'any'. */
		destPort?: string | null;

		/**
		 * Traffic policy specified for this split tunnel rule, 'allow' or 'deny'.
		 * Required
		 */
		policy: string;

		/** Protocol for this split tunnel rule. */
		protocol?: UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRulesProtocol | null;
	}
	export interface UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRulesFormProperties {

		/** Description for this split tunnel rule (optional). */
		comment: FormControl<string | null | undefined>,

		/**
		 * Destination for this split tunnel rule. IP address, fully-qualified domain names (FQDN) or 'any'.
		 * Required
		 */
		destCidr: FormControl<string | null | undefined>,

		/** Destination port for this split tunnel rule, (integer in the range 1-65535), or 'any'. */
		destPort: FormControl<string | null | undefined>,

		/**
		 * Traffic policy specified for this split tunnel rule, 'allow' or 'deny'.
		 * Required
		 */
		policy: FormControl<string | null | undefined>,

		/** Protocol for this split tunnel rule. */
		protocol: FormControl<UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRulesProtocol | null | undefined>,
	}
	export function CreateUpdateNetworkWirelessSsidVpnPutBodySplitTunnelRulesFormGroup() {
		return new FormGroup<UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRulesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			destCidr: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			destPort: new FormControl<string | null | undefined>(undefined),
			policy: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			protocol: new FormControl<UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRulesProtocol | null | undefined>(undefined),
		});

	}

	export enum UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRulesProtocol { Any = 'Any', TCP = 'TCP', UDP = 'UDP' }

	export interface GetNetworkWirelessUsageHistoryReturn {

		/** The end time of the query range */
		endTs?: Date | null;

		/** Received kilobytes-per-second */
		receivedKbps?: number | null;

		/** Sent kilobytes-per-second */
		sentKbps?: number | null;

		/** The start time of the query range */
		startTs?: Date | null;

		/** Total usage in kilobytes-per-second */
		totalKbps?: number | null;
	}
	export interface GetNetworkWirelessUsageHistoryReturnFormProperties {

		/** The end time of the query range */
		endTs: FormControl<Date | null | undefined>,

		/** Received kilobytes-per-second */
		receivedKbps: FormControl<number | null | undefined>,

		/** Sent kilobytes-per-second */
		sentKbps: FormControl<number | null | undefined>,

		/** The start time of the query range */
		startTs: FormControl<Date | null | undefined>,

		/** Total usage in kilobytes-per-second */
		totalKbps: FormControl<number | null | undefined>,
	}
	export function CreateGetNetworkWirelessUsageHistoryReturnFormGroup() {
		return new FormGroup<GetNetworkWirelessUsageHistoryReturnFormProperties>({
			endTs: new FormControl<Date | null | undefined>(undefined),
			receivedKbps: new FormControl<number | null | undefined>(undefined),
			sentKbps: new FormControl<number | null | undefined>(undefined),
			startTs: new FormControl<Date | null | undefined>(undefined),
			totalKbps: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationsReturn {

		/** API related settings */
		api?: GetOrganizationsReturnApi;

		/** Data for this organization */
		cloud?: GetOrganizationsReturnCloud;

		/** Organization ID */
		id?: string | null;

		/** Licensing related settings */
		licensing?: GetOrganizationsReturnLicensing;

		/** Information about the organization's management system */
		management?: GetOrganizationsReturnManagement;

		/** Organization name */
		name?: string | null;

		/** Organization URL */
		url?: string | null;
	}
	export interface GetOrganizationsReturnFormProperties {

		/** Organization ID */
		id: FormControl<string | null | undefined>,

		/** Organization name */
		name: FormControl<string | null | undefined>,

		/** Organization URL */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationsReturnFormGroup() {
		return new FormGroup<GetOrganizationsReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationsReturnApi {

		/** Enable API access */
		enabled?: boolean | null;
	}
	export interface GetOrganizationsReturnApiFormProperties {

		/** Enable API access */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationsReturnApiFormGroup() {
		return new FormGroup<GetOrganizationsReturnApiFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationsReturnCloud {

		/** Region info */
		region?: GetOrganizationsReturnCloudRegion;
	}
	export interface GetOrganizationsReturnCloudFormProperties {
	}
	export function CreateGetOrganizationsReturnCloudFormGroup() {
		return new FormGroup<GetOrganizationsReturnCloudFormProperties>({
		});

	}

	export interface GetOrganizationsReturnCloudRegion {

		/** Name of region */
		name?: string | null;
	}
	export interface GetOrganizationsReturnCloudRegionFormProperties {

		/** Name of region */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationsReturnCloudRegionFormGroup() {
		return new FormGroup<GetOrganizationsReturnCloudRegionFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationsReturnLicensing {

		/** Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'. */
		model?: GetOrganizationsReturnLicensingModel | null;
	}
	export interface GetOrganizationsReturnLicensingFormProperties {

		/** Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'. */
		model: FormControl<GetOrganizationsReturnLicensingModel | null | undefined>,
	}
	export function CreateGetOrganizationsReturnLicensingFormGroup() {
		return new FormGroup<GetOrganizationsReturnLicensingFormProperties>({
			model: new FormControl<GetOrganizationsReturnLicensingModel | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationsReturnLicensingModel { 'co-term' = 'co-term', 'per-device' = 'per-device', subscription = 'subscription' }

	export interface GetOrganizationsReturnManagement {

		/** Details related to organization management, possibly empty */
		GetOrganizationsReturnManagementDetails?: Array<GetOrganizationsReturnManagementDetails>;
	}
	export interface GetOrganizationsReturnManagementFormProperties {
	}
	export function CreateGetOrganizationsReturnManagementFormGroup() {
		return new FormGroup<GetOrganizationsReturnManagementFormProperties>({
		});

	}

	export interface GetOrganizationsReturnManagementDetails {

		/** Name of management data */
		name?: string | null;

		/** Value of management data */
		value?: string | null;
	}
	export interface GetOrganizationsReturnManagementDetailsFormProperties {

		/** Name of management data */
		name: FormControl<string | null | undefined>,

		/** Value of management data */
		value: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationsReturnManagementDetailsFormGroup() {
		return new FormGroup<GetOrganizationsReturnManagementDetailsFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			value: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationPostBody {

		/** Information about the organization's management system */
		management?: CreateOrganizationPostBodyManagement;

		/**
		 * The name of the organization
		 * Required
		 */
		name: string;
	}
	export interface CreateOrganizationPostBodyFormProperties {

		/**
		 * The name of the organization
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationPostBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateOrganizationPostBodyManagement {

		/** Details related to organization management, possibly empty */
		CreateOrganizationPostBodyManagementDetails?: Array<CreateOrganizationPostBodyManagementDetails>;
	}
	export interface CreateOrganizationPostBodyManagementFormProperties {
	}
	export function CreateCreateOrganizationPostBodyManagementFormGroup() {
		return new FormGroup<CreateOrganizationPostBodyManagementFormProperties>({
		});

	}

	export interface CreateOrganizationPostBodyManagementDetails {

		/** Name of management data */
		name?: string | null;

		/** Value of management data */
		value?: string | null;
	}
	export interface CreateOrganizationPostBodyManagementDetailsFormProperties {

		/** Name of management data */
		name: FormControl<string | null | undefined>,

		/** Value of management data */
		value: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationPostBodyManagementDetailsFormGroup() {
		return new FormGroup<CreateOrganizationPostBodyManagementDetailsFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			value: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationReturn {

		/** API related settings */
		api?: GetOrganizationReturnApi;

		/** Data for this organization */
		cloud?: GetOrganizationReturnCloud;

		/** Organization ID */
		id?: string | null;

		/** Licensing related settings */
		licensing?: GetOrganizationReturnLicensing;

		/** Information about the organization's management system */
		management?: GetOrganizationReturnManagement;

		/** Organization name */
		name?: string | null;

		/** Organization URL */
		url?: string | null;
	}
	export interface GetOrganizationReturnFormProperties {

		/** Organization ID */
		id: FormControl<string | null | undefined>,

		/** Organization name */
		name: FormControl<string | null | undefined>,

		/** Organization URL */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationReturnFormGroup() {
		return new FormGroup<GetOrganizationReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationReturnApi {

		/** Enable API access */
		enabled?: boolean | null;
	}
	export interface GetOrganizationReturnApiFormProperties {

		/** Enable API access */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationReturnApiFormGroup() {
		return new FormGroup<GetOrganizationReturnApiFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationReturnCloud {

		/** Region info */
		region?: GetOrganizationReturnCloudRegion;
	}
	export interface GetOrganizationReturnCloudFormProperties {
	}
	export function CreateGetOrganizationReturnCloudFormGroup() {
		return new FormGroup<GetOrganizationReturnCloudFormProperties>({
		});

	}

	export interface GetOrganizationReturnCloudRegion {

		/** Name of region */
		name?: string | null;
	}
	export interface GetOrganizationReturnCloudRegionFormProperties {

		/** Name of region */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationReturnCloudRegionFormGroup() {
		return new FormGroup<GetOrganizationReturnCloudRegionFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationReturnLicensing {

		/** Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'. */
		model?: GetOrganizationsReturnLicensingModel | null;
	}
	export interface GetOrganizationReturnLicensingFormProperties {

		/** Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'. */
		model: FormControl<GetOrganizationsReturnLicensingModel | null | undefined>,
	}
	export function CreateGetOrganizationReturnLicensingFormGroup() {
		return new FormGroup<GetOrganizationReturnLicensingFormProperties>({
			model: new FormControl<GetOrganizationsReturnLicensingModel | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationReturnManagement {

		/** Details related to organization management, possibly empty */
		GetOrganizationReturnManagementDetails?: Array<GetOrganizationReturnManagementDetails>;
	}
	export interface GetOrganizationReturnManagementFormProperties {
	}
	export function CreateGetOrganizationReturnManagementFormGroup() {
		return new FormGroup<GetOrganizationReturnManagementFormProperties>({
		});

	}

	export interface GetOrganizationReturnManagementDetails {

		/** Name of management data */
		name?: string | null;

		/** Value of management data */
		value?: string | null;
	}
	export interface GetOrganizationReturnManagementDetailsFormProperties {

		/** Name of management data */
		name: FormControl<string | null | undefined>,

		/** Value of management data */
		value: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationReturnManagementDetailsFormGroup() {
		return new FormGroup<GetOrganizationReturnManagementDetailsFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			value: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationPutBody {

		/** API-specific settings */
		api?: UpdateOrganizationPutBodyApi;

		/** Information about the organization's management system */
		management?: UpdateOrganizationPutBodyManagement;

		/** The name of the organization */
		name?: string | null;
	}
	export interface UpdateOrganizationPutBodyFormProperties {

		/** The name of the organization */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationPutBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationPutBodyApi {

		/** If true, enable the access to the Cisco Meraki Dashboard API */
		enabled?: boolean | null;
	}
	export interface UpdateOrganizationPutBodyApiFormProperties {

		/** If true, enable the access to the Cisco Meraki Dashboard API */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateOrganizationPutBodyApiFormGroup() {
		return new FormGroup<UpdateOrganizationPutBodyApiFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationPutBodyManagement {

		/** Details related to organization management, possibly empty */
		UpdateOrganizationPutBodyManagementDetails?: Array<UpdateOrganizationPutBodyManagementDetails>;
	}
	export interface UpdateOrganizationPutBodyManagementFormProperties {
	}
	export function CreateUpdateOrganizationPutBodyManagementFormGroup() {
		return new FormGroup<UpdateOrganizationPutBodyManagementFormProperties>({
		});

	}

	export interface UpdateOrganizationPutBodyManagementDetails {

		/** Name of management data */
		name?: string | null;

		/** Value of management data */
		value?: string | null;
	}
	export interface UpdateOrganizationPutBodyManagementDetailsFormProperties {

		/** Name of management data */
		name: FormControl<string | null | undefined>,

		/** Value of management data */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationPutBodyManagementDetailsFormGroup() {
		return new FormGroup<UpdateOrganizationPutBodyManagementDetailsFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			value: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationReturn {

		/** API related settings */
		api?: UpdateOrganizationReturnApi;

		/** Data for this organization */
		cloud?: UpdateOrganizationReturnCloud;

		/** Organization ID */
		id?: string | null;

		/** Licensing related settings */
		licensing?: UpdateOrganizationReturnLicensing;

		/** Information about the organization's management system */
		management?: UpdateOrganizationReturnManagement;

		/** Organization name */
		name?: string | null;

		/** Organization URL */
		url?: string | null;
	}
	export interface UpdateOrganizationReturnFormProperties {

		/** Organization ID */
		id: FormControl<string | null | undefined>,

		/** Organization name */
		name: FormControl<string | null | undefined>,

		/** Organization URL */
		url: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationReturnFormGroup() {
		return new FormGroup<UpdateOrganizationReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationReturnApi {

		/** Enable API access */
		enabled?: boolean | null;
	}
	export interface UpdateOrganizationReturnApiFormProperties {

		/** Enable API access */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateOrganizationReturnApiFormGroup() {
		return new FormGroup<UpdateOrganizationReturnApiFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationReturnCloud {

		/** Region info */
		region?: UpdateOrganizationReturnCloudRegion;
	}
	export interface UpdateOrganizationReturnCloudFormProperties {
	}
	export function CreateUpdateOrganizationReturnCloudFormGroup() {
		return new FormGroup<UpdateOrganizationReturnCloudFormProperties>({
		});

	}

	export interface UpdateOrganizationReturnCloudRegion {

		/** Name of region */
		name?: string | null;
	}
	export interface UpdateOrganizationReturnCloudRegionFormProperties {

		/** Name of region */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationReturnCloudRegionFormGroup() {
		return new FormGroup<UpdateOrganizationReturnCloudRegionFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationReturnLicensing {

		/** Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'. */
		model?: GetOrganizationsReturnLicensingModel | null;
	}
	export interface UpdateOrganizationReturnLicensingFormProperties {

		/** Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'. */
		model: FormControl<GetOrganizationsReturnLicensingModel | null | undefined>,
	}
	export function CreateUpdateOrganizationReturnLicensingFormGroup() {
		return new FormGroup<UpdateOrganizationReturnLicensingFormProperties>({
			model: new FormControl<GetOrganizationsReturnLicensingModel | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationReturnManagement {

		/** Details related to organization management, possibly empty */
		UpdateOrganizationReturnManagementDetails?: Array<UpdateOrganizationReturnManagementDetails>;
	}
	export interface UpdateOrganizationReturnManagementFormProperties {
	}
	export function CreateUpdateOrganizationReturnManagementFormGroup() {
		return new FormGroup<UpdateOrganizationReturnManagementFormProperties>({
		});

	}

	export interface UpdateOrganizationReturnManagementDetails {

		/** Name of management data */
		name?: string | null;

		/** Value of management data */
		value?: string | null;
	}
	export interface UpdateOrganizationReturnManagementDetailsFormProperties {

		/** Name of management data */
		name: FormControl<string | null | undefined>,

		/** Value of management data */
		value: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationReturnManagementDetailsFormGroup() {
		return new FormGroup<UpdateOrganizationReturnManagementDetailsFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			value: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationActionBatchesStatus { completed = 'completed', failed = 'failed', pending = 'pending' }

	export interface CreateOrganizationActionBatchPostBody {

		/**
		 * A set of changes to make as part of this action (<a href='https://developer.cisco.com/meraki/api/#/rest/guides/action-batches/'>more details</a>)
		 * Required
		 */
		CreateOrganizationActionBatchPostBodyActions: Array<CreateOrganizationActionBatchPostBodyActions>;

		/** Set to true for immediate execution. Set to false if the action should be previewed before executing. This property cannot be unset once it is true. Defaults to false. */
		confirmed?: boolean | null;

		/** Set to true to force the batch to run synchronous. There can be at most 20 actions in synchronous batch. Defaults to false. */
		synchronous?: boolean | null;
	}
	export interface CreateOrganizationActionBatchPostBodyFormProperties {

		/** Set to true for immediate execution. Set to false if the action should be previewed before executing. This property cannot be unset once it is true. Defaults to false. */
		confirmed: FormControl<boolean | null | undefined>,

		/** Set to true to force the batch to run synchronous. There can be at most 20 actions in synchronous batch. Defaults to false. */
		synchronous: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateOrganizationActionBatchPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationActionBatchPostBodyFormProperties>({
			confirmed: new FormControl<boolean | null | undefined>(undefined),
			synchronous: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationActionBatchPostBodyActions {

		/** The body of the action */
		body?: string | null;

		/**
		 * The operation to be used
		 * Required
		 */
		operation: string;

		/**
		 * Unique identifier for the resource to be acted on
		 * Required
		 */
		resource: string;
	}
	export interface CreateOrganizationActionBatchPostBodyActionsFormProperties {

		/** The body of the action */
		body: FormControl<string | null | undefined>,

		/**
		 * The operation to be used
		 * Required
		 */
		operation: FormControl<string | null | undefined>,

		/**
		 * Unique identifier for the resource to be acted on
		 * Required
		 */
		resource: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationActionBatchPostBodyActionsFormGroup() {
		return new FormGroup<CreateOrganizationActionBatchPostBodyActionsFormProperties>({
			body: new FormControl<string | null | undefined>(undefined),
			operation: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			resource: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetOrganizationActionBatchReturn {

		/**
		 * A set of changes made as part of this action (<a href='https://developer.cisco.com/meraki/api/#/rest/guides/action-batches/'>more details</a>)
		 * Required
		 */
		GetOrganizationActionBatchReturnActions: Array<GetOrganizationActionBatchReturnActions>;

		/** Flag describing whether the action should be previewed before executing or not */
		confirmed?: boolean | null;

		/** ID of the action batch. Can be used to check the status of the action batch at /organizations/{organizationId}/actionBatches/{actionBatchId} */
		id?: string | null;

		/** ID of the organization this action batch belongs to */
		organizationId?: string | null;

		/** Status of action batch */
		status?: GetOrganizationActionBatchReturnStatus;

		/** Flag describing whether actions should run synchronously or asynchronously */
		synchronous?: boolean | null;
	}
	export interface GetOrganizationActionBatchReturnFormProperties {

		/** Flag describing whether the action should be previewed before executing or not */
		confirmed: FormControl<boolean | null | undefined>,

		/** ID of the action batch. Can be used to check the status of the action batch at /organizations/{organizationId}/actionBatches/{actionBatchId} */
		id: FormControl<string | null | undefined>,

		/** ID of the organization this action batch belongs to */
		organizationId: FormControl<string | null | undefined>,

		/** Flag describing whether actions should run synchronously or asynchronously */
		synchronous: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationActionBatchReturnFormGroup() {
		return new FormGroup<GetOrganizationActionBatchReturnFormProperties>({
			confirmed: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			organizationId: new FormControl<string | null | undefined>(undefined),
			synchronous: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationActionBatchReturnActions {

		/**
		 * The operation to be used by this action
		 * Required
		 */
		operation: string;

		/**
		 * Unique identifier for the resource to be acted on
		 * Required
		 */
		resource: string;
	}
	export interface GetOrganizationActionBatchReturnActionsFormProperties {

		/**
		 * The operation to be used by this action
		 * Required
		 */
		operation: FormControl<string | null | undefined>,

		/**
		 * Unique identifier for the resource to be acted on
		 * Required
		 */
		resource: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationActionBatchReturnActionsFormGroup() {
		return new FormGroup<GetOrganizationActionBatchReturnActionsFormProperties>({
			operation: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			resource: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetOrganizationActionBatchReturnStatus {

		/** Flag describing whether all actions in the action batch have completed */
		completed?: boolean | null;

		/**
		 * Resources created as a result of this action batch
		 * Required
		 */
		GetOrganizationActionBatchReturnStatusCreatedResources: Array<GetOrganizationActionBatchReturnStatusCreatedResources>;

		/** List of errors encountered when running actions in the action batch */
		errors?: Array<string>;

		/** Flag describing whether any actions in the action batch failed */
		failed?: boolean | null;
	}
	export interface GetOrganizationActionBatchReturnStatusFormProperties {

		/** Flag describing whether all actions in the action batch have completed */
		completed: FormControl<boolean | null | undefined>,

		/** Flag describing whether any actions in the action batch failed */
		failed: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationActionBatchReturnStatusFormGroup() {
		return new FormGroup<GetOrganizationActionBatchReturnStatusFormProperties>({
			completed: new FormControl<boolean | null | undefined>(undefined),
			failed: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationActionBatchReturnStatusCreatedResources {

		/** ID of the created resource */
		id?: string | null;

		/** URI, not including base, of the created resource */
		uri?: string | null;
	}
	export interface GetOrganizationActionBatchReturnStatusCreatedResourcesFormProperties {

		/** ID of the created resource */
		id: FormControl<string | null | undefined>,

		/** URI, not including base, of the created resource */
		uri: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationActionBatchReturnStatusCreatedResourcesFormGroup() {
		return new FormGroup<GetOrganizationActionBatchReturnStatusCreatedResourcesFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			uri: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationActionBatchPutBody {

		/** A boolean representing whether or not the batch has been confirmed. This property cannot be unset once it is true. */
		confirmed?: boolean | null;

		/** Set to true to force the batch to run synchronous. There can be at most 20 actions in synchronous batch. */
		synchronous?: boolean | null;
	}
	export interface UpdateOrganizationActionBatchPutBodyFormProperties {

		/** A boolean representing whether or not the batch has been confirmed. This property cannot be unset once it is true. */
		confirmed: FormControl<boolean | null | undefined>,

		/** Set to true to force the batch to run synchronous. There can be at most 20 actions in synchronous batch. */
		synchronous: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateOrganizationActionBatchPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationActionBatchPutBodyFormProperties>({
			confirmed: new FormControl<boolean | null | undefined>(undefined),
			synchronous: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationAdaptivePolicyAclPostBody {

		/** Description of the adaptive policy ACL */
		description?: string | null;

		/**
		 * IP version of adpative policy ACL. One of: 'any', 'ipv4' or 'ipv6'
		 * Required
		 */
		ipVersion: GetNetworkSwitchAccessControlListsReturnRulesIpVersion;

		/**
		 * Name of the adaptive policy ACL
		 * Required
		 */
		name: string;

		/**
		 * An ordered array of the adaptive policy ACL rules.
		 * Required
		 */
		CreateOrganizationAdaptivePolicyAclPostBodyRules: Array<CreateOrganizationAdaptivePolicyAclPostBodyRules>;
	}
	export interface CreateOrganizationAdaptivePolicyAclPostBodyFormProperties {

		/** Description of the adaptive policy ACL */
		description: FormControl<string | null | undefined>,

		/**
		 * IP version of adpative policy ACL. One of: 'any', 'ipv4' or 'ipv6'
		 * Required
		 */
		ipVersion: FormControl<GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null | undefined>,

		/**
		 * Name of the adaptive policy ACL
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationAdaptivePolicyAclPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationAdaptivePolicyAclPostBodyFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			ipVersion: new FormControl<GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateOrganizationAdaptivePolicyAclPostBodyRules {

		/** Destination port. Must be in the format of single port: '1', port list: '1,2' or port range: '1-10', and in the range of 1-65535, or 'any'. Default is 'any'. */
		dstPort?: string | null;

		/**
		 * 'allow' or 'deny' traffic specified by this rule.
		 * Required
		 */
		policy: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy;

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp' or 'any').
		 * Required
		 */
		protocol: CreateOrganizationAdaptivePolicyAclPostBodyRulesProtocol;

		/** Source port. Must be in the format of single port: '1', port list: '1,2' or port range: '1-10', and in the range of 1-65535, or 'any'. Default is 'any'. */
		srcPort?: string | null;
	}
	export interface CreateOrganizationAdaptivePolicyAclPostBodyRulesFormProperties {

		/** Destination port. Must be in the format of single port: '1', port list: '1,2' or port range: '1-10', and in the range of 1-65535, or 'any'. Default is 'any'. */
		dstPort: FormControl<string | null | undefined>,

		/**
		 * 'allow' or 'deny' traffic specified by this rule.
		 * Required
		 */
		policy: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>,

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp' or 'any').
		 * Required
		 */
		protocol: FormControl<CreateOrganizationAdaptivePolicyAclPostBodyRulesProtocol | null | undefined>,

		/** Source port. Must be in the format of single port: '1', port list: '1,2' or port range: '1-10', and in the range of 1-65535, or 'any'. Default is 'any'. */
		srcPort: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationAdaptivePolicyAclPostBodyRulesFormGroup() {
		return new FormGroup<CreateOrganizationAdaptivePolicyAclPostBodyRulesFormProperties>({
			dstPort: new FormControl<string | null | undefined>(undefined),
			policy: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>(undefined, [Validators.required]),
			protocol: new FormControl<CreateOrganizationAdaptivePolicyAclPostBodyRulesProtocol | null | undefined>(undefined, [Validators.required]),
			srcPort: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum CreateOrganizationAdaptivePolicyAclPostBodyRulesProtocol { any = 'any', icmp = 'icmp', tcp = 'tcp', udp = 'udp' }

	export interface UpdateOrganizationAdaptivePolicyAclPutBody {

		/** Description of the adaptive policy ACL */
		description?: string | null;

		/** IP version of adpative policy ACL. One of: 'any', 'ipv4' or 'ipv6' */
		ipVersion?: GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null;

		/** Name of the adaptive policy ACL */
		name?: string | null;

		/** An ordered array of the adaptive policy ACL rules. An empty array will clear the rules. */
		UpdateOrganizationAdaptivePolicyAclPutBodyRules?: Array<UpdateOrganizationAdaptivePolicyAclPutBodyRules>;
	}
	export interface UpdateOrganizationAdaptivePolicyAclPutBodyFormProperties {

		/** Description of the adaptive policy ACL */
		description: FormControl<string | null | undefined>,

		/** IP version of adpative policy ACL. One of: 'any', 'ipv4' or 'ipv6' */
		ipVersion: FormControl<GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null | undefined>,

		/** Name of the adaptive policy ACL */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationAdaptivePolicyAclPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationAdaptivePolicyAclPutBodyFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			ipVersion: new FormControl<GetNetworkSwitchAccessControlListsReturnRulesIpVersion | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationAdaptivePolicyAclPutBodyRules {

		/** Destination port. Must be in the format of single port: '1', port list: '1,2' or port range: '1-10', and in the range of 1-65535, or 'any'. Default is 'any'. */
		dstPort?: string | null;

		/**
		 * 'allow' or 'deny' traffic specified by this rule.
		 * Required
		 */
		policy: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy;

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp' or 'any').
		 * Required
		 */
		protocol: CreateOrganizationAdaptivePolicyAclPostBodyRulesProtocol;

		/** Source port. Must be in the format of single port: '1', port list: '1,2' or port range: '1-10', and in the range of 1-65535, or 'any'. Default is 'any'. */
		srcPort?: string | null;
	}
	export interface UpdateOrganizationAdaptivePolicyAclPutBodyRulesFormProperties {

		/** Destination port. Must be in the format of single port: '1', port list: '1,2' or port range: '1-10', and in the range of 1-65535, or 'any'. Default is 'any'. */
		dstPort: FormControl<string | null | undefined>,

		/**
		 * 'allow' or 'deny' traffic specified by this rule.
		 * Required
		 */
		policy: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>,

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp' or 'any').
		 * Required
		 */
		protocol: FormControl<CreateOrganizationAdaptivePolicyAclPostBodyRulesProtocol | null | undefined>,

		/** Source port. Must be in the format of single port: '1', port list: '1,2' or port range: '1-10', and in the range of 1-65535, or 'any'. Default is 'any'. */
		srcPort: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationAdaptivePolicyAclPutBodyRulesFormGroup() {
		return new FormGroup<UpdateOrganizationAdaptivePolicyAclPutBodyRulesFormProperties>({
			dstPort: new FormControl<string | null | undefined>(undefined),
			policy: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>(undefined, [Validators.required]),
			protocol: new FormControl<CreateOrganizationAdaptivePolicyAclPostBodyRulesProtocol | null | undefined>(undefined, [Validators.required]),
			srcPort: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationAdaptivePolicyGroupPostBody {

		/** Description of the group (default: "") */
		description?: string | null;

		/**
		 * Name of the group
		 * Required
		 */
		name: string;

		/** The policy objects that belong to this group; traffic from addresses specified by these policy objects will be tagged with this group's SGT value if no other tagging scheme is being used (each requires one unique attribute) (default: []) */
		CreateOrganizationAdaptivePolicyGroupPostBodyPolicyObjects?: Array<CreateOrganizationAdaptivePolicyGroupPostBodyPolicyObjects>;

		/**
		 * SGT value of the group
		 * Required
		 */
		sgt: number;
	}
	export interface CreateOrganizationAdaptivePolicyGroupPostBodyFormProperties {

		/** Description of the group (default: "") */
		description: FormControl<string | null | undefined>,

		/**
		 * Name of the group
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/**
		 * SGT value of the group
		 * Required
		 */
		sgt: FormControl<number | null | undefined>,
	}
	export function CreateCreateOrganizationAdaptivePolicyGroupPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationAdaptivePolicyGroupPostBodyFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			sgt: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateOrganizationAdaptivePolicyGroupPostBodyPolicyObjects {

		/** The ID of the policy object */
		id?: string | null;

		/** The name of the policy object */
		name?: string | null;
	}
	export interface CreateOrganizationAdaptivePolicyGroupPostBodyPolicyObjectsFormProperties {

		/** The ID of the policy object */
		id: FormControl<string | null | undefined>,

		/** The name of the policy object */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationAdaptivePolicyGroupPostBodyPolicyObjectsFormGroup() {
		return new FormGroup<CreateOrganizationAdaptivePolicyGroupPostBodyPolicyObjectsFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationAdaptivePolicyGroupPutBody {

		/** Description of the group */
		description?: string | null;

		/** Name of the group */
		name?: string | null;

		/** The policy objects that belong to this group; traffic from addresses specified by these policy objects will be tagged with this group's SGT value if no other tagging scheme is being used (each requires one unique attribute) */
		UpdateOrganizationAdaptivePolicyGroupPutBodyPolicyObjects?: Array<UpdateOrganizationAdaptivePolicyGroupPutBodyPolicyObjects>;

		/** SGT value of the group */
		sgt?: number | null;
	}
	export interface UpdateOrganizationAdaptivePolicyGroupPutBodyFormProperties {

		/** Description of the group */
		description: FormControl<string | null | undefined>,

		/** Name of the group */
		name: FormControl<string | null | undefined>,

		/** SGT value of the group */
		sgt: FormControl<number | null | undefined>,
	}
	export function CreateUpdateOrganizationAdaptivePolicyGroupPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationAdaptivePolicyGroupPutBodyFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			sgt: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationAdaptivePolicyGroupPutBodyPolicyObjects {

		/** The ID of the policy object */
		id?: string | null;

		/** The name of the policy object */
		name?: string | null;
	}
	export interface UpdateOrganizationAdaptivePolicyGroupPutBodyPolicyObjectsFormProperties {

		/** The ID of the policy object */
		id: FormControl<string | null | undefined>,

		/** The name of the policy object */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationAdaptivePolicyGroupPutBodyPolicyObjectsFormGroup() {
		return new FormGroup<UpdateOrganizationAdaptivePolicyGroupPutBodyPolicyObjectsFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationAdaptivePolicyOverviewReturn {

		/** The current amount of various adaptive policy objects. */
		counts?: GetOrganizationAdaptivePolicyOverviewReturnCounts;

		/** The current limits of various adaptive policy objects. */
		limits?: GetOrganizationAdaptivePolicyOverviewReturnLimits;
	}
	export interface GetOrganizationAdaptivePolicyOverviewReturnFormProperties {
	}
	export function CreateGetOrganizationAdaptivePolicyOverviewReturnFormGroup() {
		return new FormGroup<GetOrganizationAdaptivePolicyOverviewReturnFormProperties>({
		});

	}

	export interface GetOrganizationAdaptivePolicyOverviewReturnCounts {

		/** Number of adaptive policies currently in the organization that allow all traffic. */
		allowPolicies?: number | null;

		/** Number of user-created adaptive policy ACLs currently in the organization. */
		customAcls?: number | null;

		/** Number of user-created adaptive policy groups currently in the organization. */
		customGroups?: number | null;

		/** Number of adaptive policies currently in the organization that deny all traffic. */
		denyPolicies?: number | null;

		/** Number of adaptive policy groups currently in the organization. */
		groups?: number | null;

		/** Number of adaptive policies currently in the organization. */
		policies?: number | null;

		/** Number of policy objects (with the adaptive policy type) currently in the organization. */
		policyObjects?: number | null;
	}
	export interface GetOrganizationAdaptivePolicyOverviewReturnCountsFormProperties {

		/** Number of adaptive policies currently in the organization that allow all traffic. */
		allowPolicies: FormControl<number | null | undefined>,

		/** Number of user-created adaptive policy ACLs currently in the organization. */
		customAcls: FormControl<number | null | undefined>,

		/** Number of user-created adaptive policy groups currently in the organization. */
		customGroups: FormControl<number | null | undefined>,

		/** Number of adaptive policies currently in the organization that deny all traffic. */
		denyPolicies: FormControl<number | null | undefined>,

		/** Number of adaptive policy groups currently in the organization. */
		groups: FormControl<number | null | undefined>,

		/** Number of adaptive policies currently in the organization. */
		policies: FormControl<number | null | undefined>,

		/** Number of policy objects (with the adaptive policy type) currently in the organization. */
		policyObjects: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationAdaptivePolicyOverviewReturnCountsFormGroup() {
		return new FormGroup<GetOrganizationAdaptivePolicyOverviewReturnCountsFormProperties>({
			allowPolicies: new FormControl<number | null | undefined>(undefined),
			customAcls: new FormControl<number | null | undefined>(undefined),
			customGroups: new FormControl<number | null | undefined>(undefined),
			denyPolicies: new FormControl<number | null | undefined>(undefined),
			groups: new FormControl<number | null | undefined>(undefined),
			policies: new FormControl<number | null | undefined>(undefined),
			policyObjects: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationAdaptivePolicyOverviewReturnLimits {

		/** Maximum number of adaptive policy ACLs that can be assigned to an adaptive policy in the organization. */
		aclsInAPolicy?: number | null;

		/** Maximum number of user-created adaptive policy groups allowed in the organization. */
		customGroups?: number | null;

		/** Maximum number of policy objects (with the adaptive policy type) allowed in the organization. */
		policyObjects?: number | null;

		/** Maximum number of rules allowed in an adaptive policy ACL in the organization. */
		rulesInAnAcl?: number | null;
	}
	export interface GetOrganizationAdaptivePolicyOverviewReturnLimitsFormProperties {

		/** Maximum number of adaptive policy ACLs that can be assigned to an adaptive policy in the organization. */
		aclsInAPolicy: FormControl<number | null | undefined>,

		/** Maximum number of user-created adaptive policy groups allowed in the organization. */
		customGroups: FormControl<number | null | undefined>,

		/** Maximum number of policy objects (with the adaptive policy type) allowed in the organization. */
		policyObjects: FormControl<number | null | undefined>,

		/** Maximum number of rules allowed in an adaptive policy ACL in the organization. */
		rulesInAnAcl: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationAdaptivePolicyOverviewReturnLimitsFormGroup() {
		return new FormGroup<GetOrganizationAdaptivePolicyOverviewReturnLimitsFormProperties>({
			aclsInAPolicy: new FormControl<number | null | undefined>(undefined),
			customGroups: new FormControl<number | null | undefined>(undefined),
			policyObjects: new FormControl<number | null | undefined>(undefined),
			rulesInAnAcl: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationAdaptivePolicyPolicyPostBody {

		/** An ordered array of adaptive policy ACLs (each requires one unique attribute) that apply to this policy (default: []) */
		CreateOrganizationAdaptivePolicyPolicyPostBodyAcls?: Array<CreateOrganizationAdaptivePolicyPolicyPostBodyAcls>;

		/**
		 * The destination adaptive policy group (requires one unique attribute)
		 * Required
		 */
		destinationGroup: CreateOrganizationAdaptivePolicyPolicyPostBodyDestinationGroup;

		/** The rule to apply if there is no matching ACL (default: "default") */
		lastEntryRule?: CreateOrganizationAdaptivePolicyPolicyPostBodyLastEntryRule | null;

		/**
		 * The source adaptive policy group (requires one unique attribute)
		 * Required
		 */
		sourceGroup: CreateOrganizationAdaptivePolicyPolicyPostBodySourceGroup;
	}
	export interface CreateOrganizationAdaptivePolicyPolicyPostBodyFormProperties {

		/** The rule to apply if there is no matching ACL (default: "default") */
		lastEntryRule: FormControl<CreateOrganizationAdaptivePolicyPolicyPostBodyLastEntryRule | null | undefined>,
	}
	export function CreateCreateOrganizationAdaptivePolicyPolicyPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationAdaptivePolicyPolicyPostBodyFormProperties>({
			lastEntryRule: new FormControl<CreateOrganizationAdaptivePolicyPolicyPostBodyLastEntryRule | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationAdaptivePolicyPolicyPostBodyAcls {

		/** The ID of the adaptive policy ACL */
		id?: string | null;

		/** The name of the adaptive policy ACL */
		name?: string | null;
	}
	export interface CreateOrganizationAdaptivePolicyPolicyPostBodyAclsFormProperties {

		/** The ID of the adaptive policy ACL */
		id: FormControl<string | null | undefined>,

		/** The name of the adaptive policy ACL */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationAdaptivePolicyPolicyPostBodyAclsFormGroup() {
		return new FormGroup<CreateOrganizationAdaptivePolicyPolicyPostBodyAclsFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationAdaptivePolicyPolicyPostBodyDestinationGroup {

		/** The ID of the destination adaptive policy group */
		id?: string | null;

		/** The name of the destination adaptive policy group */
		name?: string | null;

		/** The SGT of the destination adaptive policy group */
		sgt?: number | null;
	}
	export interface CreateOrganizationAdaptivePolicyPolicyPostBodyDestinationGroupFormProperties {

		/** The ID of the destination adaptive policy group */
		id: FormControl<string | null | undefined>,

		/** The name of the destination adaptive policy group */
		name: FormControl<string | null | undefined>,

		/** The SGT of the destination adaptive policy group */
		sgt: FormControl<number | null | undefined>,
	}
	export function CreateCreateOrganizationAdaptivePolicyPolicyPostBodyDestinationGroupFormGroup() {
		return new FormGroup<CreateOrganizationAdaptivePolicyPolicyPostBodyDestinationGroupFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			sgt: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum CreateOrganizationAdaptivePolicyPolicyPostBodyLastEntryRule { allow = 'allow', default = 'default', deny = 'deny' }

	export interface CreateOrganizationAdaptivePolicyPolicyPostBodySourceGroup {

		/** The ID of the source adaptive policy group */
		id?: string | null;

		/** The name of the source adaptive policy group */
		name?: string | null;

		/** The SGT of the source adaptive policy group */
		sgt?: number | null;
	}
	export interface CreateOrganizationAdaptivePolicyPolicyPostBodySourceGroupFormProperties {

		/** The ID of the source adaptive policy group */
		id: FormControl<string | null | undefined>,

		/** The name of the source adaptive policy group */
		name: FormControl<string | null | undefined>,

		/** The SGT of the source adaptive policy group */
		sgt: FormControl<number | null | undefined>,
	}
	export function CreateCreateOrganizationAdaptivePolicyPolicyPostBodySourceGroupFormGroup() {
		return new FormGroup<CreateOrganizationAdaptivePolicyPolicyPostBodySourceGroupFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			sgt: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationAdaptivePolicyPolicyPutBody {

		/** An ordered array of adaptive policy ACLs (each requires one unique attribute) that apply to this policy */
		UpdateOrganizationAdaptivePolicyPolicyPutBodyAcls?: Array<UpdateOrganizationAdaptivePolicyPolicyPutBodyAcls>;

		/** The destination adaptive policy group (requires one unique attribute) */
		destinationGroup?: UpdateOrganizationAdaptivePolicyPolicyPutBodyDestinationGroup;

		/** The rule to apply if there is no matching ACL */
		lastEntryRule?: CreateOrganizationAdaptivePolicyPolicyPostBodyLastEntryRule | null;

		/** The source adaptive policy group (requires one unique attribute) */
		sourceGroup?: UpdateOrganizationAdaptivePolicyPolicyPutBodySourceGroup;
	}
	export interface UpdateOrganizationAdaptivePolicyPolicyPutBodyFormProperties {

		/** The rule to apply if there is no matching ACL */
		lastEntryRule: FormControl<CreateOrganizationAdaptivePolicyPolicyPostBodyLastEntryRule | null | undefined>,
	}
	export function CreateUpdateOrganizationAdaptivePolicyPolicyPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationAdaptivePolicyPolicyPutBodyFormProperties>({
			lastEntryRule: new FormControl<CreateOrganizationAdaptivePolicyPolicyPostBodyLastEntryRule | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationAdaptivePolicyPolicyPutBodyAcls {

		/** The ID of the adaptive policy ACL */
		id?: string | null;

		/** The name of the adaptive policy ACL */
		name?: string | null;
	}
	export interface UpdateOrganizationAdaptivePolicyPolicyPutBodyAclsFormProperties {

		/** The ID of the adaptive policy ACL */
		id: FormControl<string | null | undefined>,

		/** The name of the adaptive policy ACL */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationAdaptivePolicyPolicyPutBodyAclsFormGroup() {
		return new FormGroup<UpdateOrganizationAdaptivePolicyPolicyPutBodyAclsFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationAdaptivePolicyPolicyPutBodyDestinationGroup {

		/** The ID of the destination adaptive policy group */
		id?: string | null;

		/** The name of the destination adaptive policy group */
		name?: string | null;

		/** The SGT of the destination adaptive policy group */
		sgt?: number | null;
	}
	export interface UpdateOrganizationAdaptivePolicyPolicyPutBodyDestinationGroupFormProperties {

		/** The ID of the destination adaptive policy group */
		id: FormControl<string | null | undefined>,

		/** The name of the destination adaptive policy group */
		name: FormControl<string | null | undefined>,

		/** The SGT of the destination adaptive policy group */
		sgt: FormControl<number | null | undefined>,
	}
	export function CreateUpdateOrganizationAdaptivePolicyPolicyPutBodyDestinationGroupFormGroup() {
		return new FormGroup<UpdateOrganizationAdaptivePolicyPolicyPutBodyDestinationGroupFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			sgt: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationAdaptivePolicyPolicyPutBodySourceGroup {

		/** The ID of the source adaptive policy group */
		id?: string | null;

		/** The name of the source adaptive policy group */
		name?: string | null;

		/** The SGT of the source adaptive policy group */
		sgt?: number | null;
	}
	export interface UpdateOrganizationAdaptivePolicyPolicyPutBodySourceGroupFormProperties {

		/** The ID of the source adaptive policy group */
		id: FormControl<string | null | undefined>,

		/** The name of the source adaptive policy group */
		name: FormControl<string | null | undefined>,

		/** The SGT of the source adaptive policy group */
		sgt: FormControl<number | null | undefined>,
	}
	export function CreateUpdateOrganizationAdaptivePolicyPolicyPutBodySourceGroupFormGroup() {
		return new FormGroup<UpdateOrganizationAdaptivePolicyPolicyPutBodySourceGroupFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			sgt: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationAdaptivePolicySettingsPutBody {

		/** List of network IDs with adaptive policy enabled */
		enabledNetworks?: Array<string>;
	}
	export interface UpdateOrganizationAdaptivePolicySettingsPutBodyFormProperties {
	}
	export function CreateUpdateOrganizationAdaptivePolicySettingsPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationAdaptivePolicySettingsPutBodyFormProperties>({
		});

	}

	export interface CreateOrganizationAdminPostBody {

		/** The method of authentication the user will use to sign in to the Meraki dashboard. Can be one of 'Email' or 'Cisco SecureX Sign-On'. The default is Email authentication */
		authenticationMethod?: CreateOrganizationAdminPostBodyAuthenticationMethod | null;

		/**
		 * The email of the dashboard administrator. This attribute can not be updated.
		 * Required
		 */
		email: string;

		/**
		 * The name of the dashboard administrator
		 * Required
		 */
		name: string;

		/** The list of networks that the dashboard administrator has privileges on */
		CreateOrganizationAdminPostBodyNetworks?: Array<CreateOrganizationAdminPostBodyNetworks>;

		/**
		 * The privilege of the dashboard administrator on the organization. Can be one of 'full', 'read-only', 'enterprise' or 'none'
		 * Required
		 */
		orgAccess: CreateOrganizationAdminPostBodyOrgAccess;

		/** The list of tags that the dashboard administrator has privileges on */
		CreateOrganizationAdminPostBodyTags?: Array<CreateOrganizationAdminPostBodyTags>;
	}
	export interface CreateOrganizationAdminPostBodyFormProperties {

		/** The method of authentication the user will use to sign in to the Meraki dashboard. Can be one of 'Email' or 'Cisco SecureX Sign-On'. The default is Email authentication */
		authenticationMethod: FormControl<CreateOrganizationAdminPostBodyAuthenticationMethod | null | undefined>,

		/**
		 * The email of the dashboard administrator. This attribute can not be updated.
		 * Required
		 */
		email: FormControl<string | null | undefined>,

		/**
		 * The name of the dashboard administrator
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/**
		 * The privilege of the dashboard administrator on the organization. Can be one of 'full', 'read-only', 'enterprise' or 'none'
		 * Required
		 */
		orgAccess: FormControl<CreateOrganizationAdminPostBodyOrgAccess | null | undefined>,
	}
	export function CreateCreateOrganizationAdminPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationAdminPostBodyFormProperties>({
			authenticationMethod: new FormControl<CreateOrganizationAdminPostBodyAuthenticationMethod | null | undefined>(undefined),
			email: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			orgAccess: new FormControl<CreateOrganizationAdminPostBodyOrgAccess | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateOrganizationAdminPostBodyAuthenticationMethod { 'Cisco SecureX Sign-On' = 'Cisco SecureX Sign-On', Email = 'Email' }

	export interface CreateOrganizationAdminPostBodyNetworks {

		/**
		 * The privilege of the dashboard administrator on the network. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		 * Required
		 */
		access: string;

		/**
		 * The network ID
		 * Required
		 */
		id: string;
	}
	export interface CreateOrganizationAdminPostBodyNetworksFormProperties {

		/**
		 * The privilege of the dashboard administrator on the network. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		 * Required
		 */
		access: FormControl<string | null | undefined>,

		/**
		 * The network ID
		 * Required
		 */
		id: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationAdminPostBodyNetworksFormGroup() {
		return new FormGroup<CreateOrganizationAdminPostBodyNetworksFormProperties>({
			access: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			id: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateOrganizationAdminPostBodyOrgAccess { enterprise = 'enterprise', full = 'full', none = 'none', 'read-only' = 'read-only' }

	export interface CreateOrganizationAdminPostBodyTags {

		/**
		 * The privilege of the dashboard administrator on the tag. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		 * Required
		 */
		access: CreateOrganizationAdminPostBodyTagsAccess;

		/**
		 * The name of the tag
		 * Required
		 */
		tag: string;
	}
	export interface CreateOrganizationAdminPostBodyTagsFormProperties {

		/**
		 * The privilege of the dashboard administrator on the tag. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		 * Required
		 */
		access: FormControl<CreateOrganizationAdminPostBodyTagsAccess | null | undefined>,

		/**
		 * The name of the tag
		 * Required
		 */
		tag: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationAdminPostBodyTagsFormGroup() {
		return new FormGroup<CreateOrganizationAdminPostBodyTagsFormProperties>({
			access: new FormControl<CreateOrganizationAdminPostBodyTagsAccess | null | undefined>(undefined, [Validators.required]),
			tag: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateOrganizationAdminPostBodyTagsAccess { full = 'full', 'guest-ambassador' = 'guest-ambassador', 'monitor-only' = 'monitor-only', 'read-only' = 'read-only' }

	export interface UpdateOrganizationAdminPutBody {

		/** The name of the dashboard administrator */
		name?: string | null;

		/** The list of networks that the dashboard administrator has privileges on */
		UpdateOrganizationAdminPutBodyNetworks?: Array<UpdateOrganizationAdminPutBodyNetworks>;

		/** The privilege of the dashboard administrator on the organization. Can be one of 'full', 'read-only', 'enterprise' or 'none' */
		orgAccess?: CreateOrganizationAdminPostBodyOrgAccess | null;

		/** The list of tags that the dashboard administrator has privileges on */
		UpdateOrganizationAdminPutBodyTags?: Array<UpdateOrganizationAdminPutBodyTags>;
	}
	export interface UpdateOrganizationAdminPutBodyFormProperties {

		/** The name of the dashboard administrator */
		name: FormControl<string | null | undefined>,

		/** The privilege of the dashboard administrator on the organization. Can be one of 'full', 'read-only', 'enterprise' or 'none' */
		orgAccess: FormControl<CreateOrganizationAdminPostBodyOrgAccess | null | undefined>,
	}
	export function CreateUpdateOrganizationAdminPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationAdminPutBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			orgAccess: new FormControl<CreateOrganizationAdminPostBodyOrgAccess | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationAdminPutBodyNetworks {

		/**
		 * The privilege of the dashboard administrator on the network. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		 * Required
		 */
		access: string;

		/**
		 * The network ID
		 * Required
		 */
		id: string;
	}
	export interface UpdateOrganizationAdminPutBodyNetworksFormProperties {

		/**
		 * The privilege of the dashboard administrator on the network. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		 * Required
		 */
		access: FormControl<string | null | undefined>,

		/**
		 * The network ID
		 * Required
		 */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationAdminPutBodyNetworksFormGroup() {
		return new FormGroup<UpdateOrganizationAdminPutBodyNetworksFormProperties>({
			access: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			id: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateOrganizationAdminPutBodyTags {

		/**
		 * The privilege of the dashboard administrator on the tag. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		 * Required
		 */
		access: CreateOrganizationAdminPostBodyTagsAccess;

		/**
		 * The name of the tag
		 * Required
		 */
		tag: string;
	}
	export interface UpdateOrganizationAdminPutBodyTagsFormProperties {

		/**
		 * The privilege of the dashboard administrator on the tag. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		 * Required
		 */
		access: FormControl<CreateOrganizationAdminPostBodyTagsAccess | null | undefined>,

		/**
		 * The name of the tag
		 * Required
		 */
		tag: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationAdminPutBodyTagsFormGroup() {
		return new FormGroup<UpdateOrganizationAdminPutBodyTagsFormProperties>({
			access: new FormControl<CreateOrganizationAdminPostBodyTagsAccess | null | undefined>(undefined, [Validators.required]),
			tag: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateOrganizationAlertsProfilePostBody {

		/**
		 * The conditions that determine if the alert triggers
		 * Required
		 */
		alertCondition: CreateOrganizationAlertsProfilePostBodyAlertCondition;

		/** User supplied description of the alert */
		description?: string | null;

		/**
		 * Networks with these tags will be monitored for the alert
		 * Required
		 */
		networkTags: Array<string>;

		/**
		 * List of recipients that will recieve the alert.
		 * Required
		 */
		recipients: CreateOrganizationAlertsProfilePostBodyRecipients;

		/**
		 * The alert type
		 * Required
		 */
		type: CreateOrganizationAlertsProfilePostBodyType;
	}
	export interface CreateOrganizationAlertsProfilePostBodyFormProperties {

		/** User supplied description of the alert */
		description: FormControl<string | null | undefined>,

		/**
		 * The alert type
		 * Required
		 */
		type: FormControl<CreateOrganizationAlertsProfilePostBodyType | null | undefined>,
	}
	export function CreateCreateOrganizationAlertsProfilePostBodyFormGroup() {
		return new FormGroup<CreateOrganizationAlertsProfilePostBodyFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			type: new FormControl<CreateOrganizationAlertsProfilePostBodyType | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateOrganizationAlertsProfilePostBodyAlertCondition {

		/** The threshold the metric must cross to be valid for alerting. Used only for WAN Utilization alerts. */
		bit_rate_bps?: number | null;

		/** The total duration in seconds that the threshold should be crossed before alerting */
		duration?: number | null;

		/** The uplink observed for the alert.  interface must be one of the following: wan1, wan2, cellular */
		interface?: GetDeviceLossAndLatencyHistoryUplink | null;

		/** The threshold the metric must cross to be valid for alerting. Used only for VoIP Jitter alerts. */
		jitter_ms?: number | null;

		/** The threshold the metric must cross to be valid for alerting. Used only for WAN Latency alerts. */
		latency_ms?: number | null;

		/** The threshold the metric must cross to be valid for alerting. Used only for Packet Loss alerts. */
		loss_ratio?: number | null;

		/** The threshold the metric must drop below to be valid for alerting. Used only for VoIP MOS alerts. */
		mos?: number | null;

		/** The look back period in seconds for sensing the alert */
		window?: number | null;
	}
	export interface CreateOrganizationAlertsProfilePostBodyAlertConditionFormProperties {

		/** The threshold the metric must cross to be valid for alerting. Used only for WAN Utilization alerts. */
		bit_rate_bps: FormControl<number | null | undefined>,

		/** The total duration in seconds that the threshold should be crossed before alerting */
		duration: FormControl<number | null | undefined>,

		/** The uplink observed for the alert.  interface must be one of the following: wan1, wan2, cellular */
		interface: FormControl<GetDeviceLossAndLatencyHistoryUplink | null | undefined>,

		/** The threshold the metric must cross to be valid for alerting. Used only for VoIP Jitter alerts. */
		jitter_ms: FormControl<number | null | undefined>,

		/** The threshold the metric must cross to be valid for alerting. Used only for WAN Latency alerts. */
		latency_ms: FormControl<number | null | undefined>,

		/** The threshold the metric must cross to be valid for alerting. Used only for Packet Loss alerts. */
		loss_ratio: FormControl<number | null | undefined>,

		/** The threshold the metric must drop below to be valid for alerting. Used only for VoIP MOS alerts. */
		mos: FormControl<number | null | undefined>,

		/** The look back period in seconds for sensing the alert */
		window: FormControl<number | null | undefined>,
	}
	export function CreateCreateOrganizationAlertsProfilePostBodyAlertConditionFormGroup() {
		return new FormGroup<CreateOrganizationAlertsProfilePostBodyAlertConditionFormProperties>({
			bit_rate_bps: new FormControl<number | null | undefined>(undefined),
			duration: new FormControl<number | null | undefined>(undefined),
			interface: new FormControl<GetDeviceLossAndLatencyHistoryUplink | null | undefined>(undefined),
			jitter_ms: new FormControl<number | null | undefined>(undefined),
			latency_ms: new FormControl<number | null | undefined>(undefined),
			loss_ratio: new FormControl<number | null | undefined>(undefined),
			mos: new FormControl<number | null | undefined>(undefined),
			window: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationAlertsProfilePostBodyRecipients {

		/** A list of emails that will receive information about the alert */
		emails?: Array<string>;

		/** A list base64 encoded urls of webhook endpoints that will receive information about the alert */
		httpServerIds?: Array<string>;
	}
	export interface CreateOrganizationAlertsProfilePostBodyRecipientsFormProperties {
	}
	export function CreateCreateOrganizationAlertsProfilePostBodyRecipientsFormGroup() {
		return new FormGroup<CreateOrganizationAlertsProfilePostBodyRecipientsFormProperties>({
		});

	}

	export enum CreateOrganizationAlertsProfilePostBodyType { appOutage = 'appOutage', voipJitter = 'voipJitter', voipMos = 'voipMos', voipPacketLoss = 'voipPacketLoss', wanLatency = 'wanLatency', wanPacketLoss = 'wanPacketLoss', wanStatus = 'wanStatus', wanUtilization = 'wanUtilization' }

	export interface UpdateOrganizationAlertsProfilePutBody {

		/** The conditions that determine if the alert triggers */
		alertCondition?: UpdateOrganizationAlertsProfilePutBodyAlertCondition;

		/** User supplied description of the alert */
		description?: string | null;

		/** Is the alert config enabled */
		enabled?: boolean | null;

		/** Networks with these tags will be monitored for the alert */
		networkTags?: Array<string>;

		/** List of recipients that will recieve the alert. */
		recipients?: UpdateOrganizationAlertsProfilePutBodyRecipients;

		/** The alert type */
		type?: CreateOrganizationAlertsProfilePostBodyType | null;
	}
	export interface UpdateOrganizationAlertsProfilePutBodyFormProperties {

		/** User supplied description of the alert */
		description: FormControl<string | null | undefined>,

		/** Is the alert config enabled */
		enabled: FormControl<boolean | null | undefined>,

		/** The alert type */
		type: FormControl<CreateOrganizationAlertsProfilePostBodyType | null | undefined>,
	}
	export function CreateUpdateOrganizationAlertsProfilePutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationAlertsProfilePutBodyFormProperties>({
			description: new FormControl<string | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			type: new FormControl<CreateOrganizationAlertsProfilePostBodyType | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationAlertsProfilePutBodyAlertCondition {

		/** The threshold the metric must cross to be valid for alerting. Used only for WAN Utilization alerts. */
		bit_rate_bps?: number | null;

		/** The total duration in seconds that the threshold should be crossed before alerting */
		duration?: number | null;

		/** The uplink observed for the alert.  interface must be one of the following: wan1, wan2, cellular */
		interface?: GetDeviceLossAndLatencyHistoryUplink | null;

		/** The threshold the metric must cross to be valid for alerting. Used only for VoIP Jitter alerts. */
		jitter_ms?: number | null;

		/** The threshold the metric must cross to be valid for alerting. Used only for WAN Latency alerts. */
		latency_ms?: number | null;

		/** The threshold the metric must cross to be valid for alerting. Used only for Packet Loss alerts. */
		loss_ratio?: number | null;

		/** The threshold the metric must drop below to be valid for alerting. Used only for VoIP MOS alerts. */
		mos?: number | null;

		/** The look back period in seconds for sensing the alert */
		window?: number | null;
	}
	export interface UpdateOrganizationAlertsProfilePutBodyAlertConditionFormProperties {

		/** The threshold the metric must cross to be valid for alerting. Used only for WAN Utilization alerts. */
		bit_rate_bps: FormControl<number | null | undefined>,

		/** The total duration in seconds that the threshold should be crossed before alerting */
		duration: FormControl<number | null | undefined>,

		/** The uplink observed for the alert.  interface must be one of the following: wan1, wan2, cellular */
		interface: FormControl<GetDeviceLossAndLatencyHistoryUplink | null | undefined>,

		/** The threshold the metric must cross to be valid for alerting. Used only for VoIP Jitter alerts. */
		jitter_ms: FormControl<number | null | undefined>,

		/** The threshold the metric must cross to be valid for alerting. Used only for WAN Latency alerts. */
		latency_ms: FormControl<number | null | undefined>,

		/** The threshold the metric must cross to be valid for alerting. Used only for Packet Loss alerts. */
		loss_ratio: FormControl<number | null | undefined>,

		/** The threshold the metric must drop below to be valid for alerting. Used only for VoIP MOS alerts. */
		mos: FormControl<number | null | undefined>,

		/** The look back period in seconds for sensing the alert */
		window: FormControl<number | null | undefined>,
	}
	export function CreateUpdateOrganizationAlertsProfilePutBodyAlertConditionFormGroup() {
		return new FormGroup<UpdateOrganizationAlertsProfilePutBodyAlertConditionFormProperties>({
			bit_rate_bps: new FormControl<number | null | undefined>(undefined),
			duration: new FormControl<number | null | undefined>(undefined),
			interface: new FormControl<GetDeviceLossAndLatencyHistoryUplink | null | undefined>(undefined),
			jitter_ms: new FormControl<number | null | undefined>(undefined),
			latency_ms: new FormControl<number | null | undefined>(undefined),
			loss_ratio: new FormControl<number | null | undefined>(undefined),
			mos: new FormControl<number | null | undefined>(undefined),
			window: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationAlertsProfilePutBodyRecipients {

		/** A list of emails that will receive information about the alert */
		emails?: Array<string>;

		/** A list base64 encoded urls of webhook endpoints that will receive information about the alert */
		httpServerIds?: Array<string>;
	}
	export interface UpdateOrganizationAlertsProfilePutBodyRecipientsFormProperties {
	}
	export function CreateUpdateOrganizationAlertsProfilePutBodyRecipientsFormGroup() {
		return new FormGroup<UpdateOrganizationAlertsProfilePutBodyRecipientsFormProperties>({
		});

	}

	export enum GetOrganizationApiRequestsMethod { DELETE = 'DELETE', GET = 'GET', POST = 'POST', PUT = 'PUT' }

	export enum GetOrganizationApiRequestsVersion { _0 = 0, _1 = 1 }

	export interface GetOrganizationApiRequestsReturn {

		/** Database ID for the admin user who made the API request. */
		adminId?: string | null;

		/** The host which the API request was directed at. */
		host?: string | null;

		/** HTTP method used in the API request. */
		method?: string | null;

		/** Operation ID for the endpoint. */
		operationId?: string | null;

		/** The API request path. */
		path?: string | null;

		/** The query string sent with the API request. */
		queryString?: string | null;

		/** API request response code. */
		responseCode?: number | null;

		/** Public IP address from which the API request was made. */
		sourceIp?: string | null;

		/** Timestamp, in iso8601 format, indicating when the API request was made. */
		ts?: Date | null;

		/** The API request user agent. */
		userAgent?: string | null;

		/** API version of the endpoint. */
		version?: GetOrganizationApiRequestsReturnVersion;
	}
	export interface GetOrganizationApiRequestsReturnFormProperties {

		/** Database ID for the admin user who made the API request. */
		adminId: FormControl<string | null | undefined>,

		/** The host which the API request was directed at. */
		host: FormControl<string | null | undefined>,

		/** HTTP method used in the API request. */
		method: FormControl<string | null | undefined>,

		/** Operation ID for the endpoint. */
		operationId: FormControl<string | null | undefined>,

		/** The API request path. */
		path: FormControl<string | null | undefined>,

		/** The query string sent with the API request. */
		queryString: FormControl<string | null | undefined>,

		/** API request response code. */
		responseCode: FormControl<number | null | undefined>,

		/** Public IP address from which the API request was made. */
		sourceIp: FormControl<string | null | undefined>,

		/** Timestamp, in iso8601 format, indicating when the API request was made. */
		ts: FormControl<Date | null | undefined>,

		/** The API request user agent. */
		userAgent: FormControl<string | null | undefined>,

		/** API version of the endpoint. */
		version: FormControl<GetOrganizationApiRequestsReturnVersion | null | undefined>,
	}
	export function CreateGetOrganizationApiRequestsReturnFormGroup() {
		return new FormGroup<GetOrganizationApiRequestsReturnFormProperties>({
			adminId: new FormControl<string | null | undefined>(undefined),
			host: new FormControl<string | null | undefined>(undefined),
			method: new FormControl<string | null | undefined>(undefined),
			operationId: new FormControl<string | null | undefined>(undefined),
			path: new FormControl<string | null | undefined>(undefined),
			queryString: new FormControl<string | null | undefined>(undefined),
			responseCode: new FormControl<number | null | undefined>(undefined),
			sourceIp: new FormControl<string | null | undefined>(undefined),
			ts: new FormControl<Date | null | undefined>(undefined),
			userAgent: new FormControl<string | null | undefined>(undefined),
			version: new FormControl<GetOrganizationApiRequestsReturnVersion | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationApiRequestsReturnVersion { _0 = 0, _1 = 1 }

	export enum GetOrganizationApiRequestsOverviewResponseCodesByIntervalVersion { _0 = 0, _1 = 1 }

	export interface GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturn {

		/** list of response codes and a count of how many requests had that code in the given time period */
		GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturnCounts?: Array<GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturnCounts>;

		/** The end time of the access period */
		endTs?: Date | null;

		/** The start time of the access period */
		startTs?: Date | null;
	}
	export interface GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturnFormProperties {

		/** The end time of the access period */
		endTs: FormControl<Date | null | undefined>,

		/** The start time of the access period */
		startTs: FormControl<Date | null | undefined>,
	}
	export function CreateGetOrganizationApiRequestsOverviewResponseCodesByIntervalReturnFormGroup() {
		return new FormGroup<GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturnFormProperties>({
			endTs: new FormControl<Date | null | undefined>(undefined),
			startTs: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturnCounts {

		/** Response status code of the API response */
		code?: number | null;

		/** Number of records that match the status code */
		count?: number | null;
	}
	export interface GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturnCountsFormProperties {

		/** Response status code of the API response */
		code: FormControl<number | null | undefined>,

		/** Number of records that match the status code */
		count: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationApiRequestsOverviewResponseCodesByIntervalReturnCountsFormGroup() {
		return new FormGroup<GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturnCountsFormProperties>({
			code: new FormControl<number | null | undefined>(undefined),
			count: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationApplianceSecurityIntrusionPutBody {

		/**
		 * Sets a list of specific SNORT signatures to allow
		 * Required
		 */
		UpdateOrganizationApplianceSecurityIntrusionPutBodyAllowedRules: Array<UpdateOrganizationApplianceSecurityIntrusionPutBodyAllowedRules>;
	}
	export interface UpdateOrganizationApplianceSecurityIntrusionPutBodyFormProperties {
	}
	export function CreateUpdateOrganizationApplianceSecurityIntrusionPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationApplianceSecurityIntrusionPutBodyFormProperties>({
		});

	}

	export interface UpdateOrganizationApplianceSecurityIntrusionPutBodyAllowedRules {

		/** Message is optional and is ignored on a PUT call. It is allowed in order for PUT to be compatible with GET */
		message?: string | null;

		/**
		 * A rule identifier of the format meraki:intrusion/snort/GID/<gid>/SID/<sid>. gid and sid can be obtained from either https://www.snort.org/rule-docs or as ruleIds from the security events in /organization/[orgId]/securityEvents
		 * Required
		 */
		ruleId: string;
	}
	export interface UpdateOrganizationApplianceSecurityIntrusionPutBodyAllowedRulesFormProperties {

		/** Message is optional and is ignored on a PUT call. It is allowed in order for PUT to be compatible with GET */
		message: FormControl<string | null | undefined>,

		/**
		 * A rule identifier of the format meraki:intrusion/snort/GID/<gid>/SID/<sid>. gid and sid can be obtained from either https://www.snort.org/rule-docs or as ruleIds from the security events in /organization/[orgId]/securityEvents
		 * Required
		 */
		ruleId: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationApplianceSecurityIntrusionPutBodyAllowedRulesFormGroup() {
		return new FormGroup<UpdateOrganizationApplianceSecurityIntrusionPutBodyAllowedRulesFormProperties>({
			message: new FormControl<string | null | undefined>(undefined),
			ruleId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetOrganizationApplianceVpnThirdPartyVPNPeersReturn {

		/** The list of VPN peers */
		GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeers?: Array<GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeers>;
	}
	export interface GetOrganizationApplianceVpnThirdPartyVPNPeersReturnFormProperties {
	}
	export function CreateGetOrganizationApplianceVpnThirdPartyVPNPeersReturnFormGroup() {
		return new FormGroup<GetOrganizationApplianceVpnThirdPartyVPNPeersReturnFormProperties>({
		});

	}

	export interface GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeers {

		/** [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted. */
		ikeVersion?: UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion | null;

		/** Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used. */
		ipsecPolicies?: GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPolicies;

		/** One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored. */
		ipsecPoliciesPreset?: string | null;

		/** [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to. */
		localId?: string | null;

		/** The name of the VPN peer */
		name?: string | null;

		/** A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all']. */
		networkTags?: Array<string>;

		/** The list of the private subnets of the VPN peer */
		privateSubnets?: Array<string>;

		/** [optional] The public IP of the VPN peer */
		publicIp?: string | null;

		/** [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN. */
		remoteId?: string | null;

		/** The shared secret with the VPN peer */
		secret?: string | null;
	}
	export interface GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersFormProperties {

		/** [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted. */
		ikeVersion: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion | null | undefined>,

		/** One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored. */
		ipsecPoliciesPreset: FormControl<string | null | undefined>,

		/** [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to. */
		localId: FormControl<string | null | undefined>,

		/** The name of the VPN peer */
		name: FormControl<string | null | undefined>,

		/** [optional] The public IP of the VPN peer */
		publicIp: FormControl<string | null | undefined>,

		/** [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN. */
		remoteId: FormControl<string | null | undefined>,

		/** The shared secret with the VPN peer */
		secret: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersFormGroup() {
		return new FormGroup<GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersFormProperties>({
			ikeVersion: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion | null | undefined>(undefined),
			ipsecPoliciesPreset: new FormControl<string | null | undefined>(undefined),
			localId: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			publicIp: new FormControl<string | null | undefined>(undefined),
			remoteId: new FormControl<string | null | undefined>(undefined),
			secret: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPolicies {

		/** This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5' */
		childAuthAlgo?: Array<string>;

		/** This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null' */
		childCipherAlgo?: Array<string>;

		/** The lifetime of the Phase 2 SA in seconds. */
		childLifetime?: number | null;

		/** This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1' */
		childPfsGroup?: Array<string>;

		/** This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5' */
		ikeAuthAlgo?: Array<string>;

		/** This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des' */
		ikeCipherAlgo?: Array<string>;

		/** This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1' */
		ikeDiffieHellmanGroup?: Array<string>;

		/** The lifetime of the Phase 1 SA in seconds. */
		ikeLifetime?: number | null;

		/** [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm. */
		ikePrfAlgo?: Array<string>;
	}
	export interface GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPoliciesFormProperties {

		/** The lifetime of the Phase 2 SA in seconds. */
		childLifetime: FormControl<number | null | undefined>,

		/** The lifetime of the Phase 1 SA in seconds. */
		ikeLifetime: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPoliciesFormGroup() {
		return new FormGroup<GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPoliciesFormProperties>({
			childLifetime: new FormControl<number | null | undefined>(undefined),
			ikeLifetime: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBody {

		/**
		 * The list of VPN peers
		 * Required
		 */
		UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeers: Array<UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeers>;
	}
	export interface UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyFormProperties {
	}
	export function CreateUpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyFormProperties>({
		});

	}

	export interface UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeers {

		/** [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted. */
		ikeVersion?: UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion | null;

		/** Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used. */
		ipsecPolicies?: UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeersIpsecPolicies;

		/** One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored. */
		ipsecPoliciesPreset?: string | null;

		/** [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to. */
		localId?: string | null;

		/**
		 * The name of the VPN peer
		 * Required
		 */
		name: string;

		/** A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all']. */
		networkTags?: Array<string>;

		/**
		 * The list of the private subnets of the VPN peer
		 * Required
		 */
		privateSubnets: Array<string>;

		/** [optional] The public IP of the VPN peer */
		publicIp?: string | null;

		/** [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN. */
		remoteId?: string | null;

		/**
		 * The shared secret with the VPN peer
		 * Required
		 */
		secret: string;
	}
	export interface UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeersFormProperties {

		/** [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted. */
		ikeVersion: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion | null | undefined>,

		/** One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored. */
		ipsecPoliciesPreset: FormControl<string | null | undefined>,

		/** [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to. */
		localId: FormControl<string | null | undefined>,

		/**
		 * The name of the VPN peer
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/** [optional] The public IP of the VPN peer */
		publicIp: FormControl<string | null | undefined>,

		/** [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN. */
		remoteId: FormControl<string | null | undefined>,

		/**
		 * The shared secret with the VPN peer
		 * Required
		 */
		secret: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeersFormGroup() {
		return new FormGroup<UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeersFormProperties>({
			ikeVersion: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion | null | undefined>(undefined),
			ipsecPoliciesPreset: new FormControl<string | null | undefined>(undefined),
			localId: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			publicIp: new FormControl<string | null | undefined>(undefined),
			remoteId: new FormControl<string | null | undefined>(undefined),
			secret: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeersIpsecPolicies {

		/** This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5' */
		childAuthAlgo?: Array<string>;

		/** This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null' */
		childCipherAlgo?: Array<string>;

		/** The lifetime of the Phase 2 SA in seconds. */
		childLifetime?: number | null;

		/** This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1' */
		childPfsGroup?: Array<string>;

		/** This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5' */
		ikeAuthAlgo?: Array<string>;

		/** This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des' */
		ikeCipherAlgo?: Array<string>;

		/** This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1' */
		ikeDiffieHellmanGroup?: Array<string>;

		/** The lifetime of the Phase 1 SA in seconds. */
		ikeLifetime?: number | null;

		/** [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm. */
		ikePrfAlgo?: Array<string>;
	}
	export interface UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeersIpsecPoliciesFormProperties {

		/** The lifetime of the Phase 2 SA in seconds. */
		childLifetime: FormControl<number | null | undefined>,

		/** The lifetime of the Phase 1 SA in seconds. */
		ikeLifetime: FormControl<number | null | undefined>,
	}
	export function CreateUpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeersIpsecPoliciesFormGroup() {
		return new FormGroup<UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeersIpsecPoliciesFormProperties>({
			childLifetime: new FormControl<number | null | undefined>(undefined),
			ikeLifetime: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturn {

		/** The list of VPN peers */
		UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeers?: Array<UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeers>;
	}
	export interface UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnFormProperties {
	}
	export function CreateUpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnFormGroup() {
		return new FormGroup<UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnFormProperties>({
		});

	}

	export interface UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeers {

		/** [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted. */
		ikeVersion?: UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion | null;

		/** Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used. */
		ipsecPolicies?: UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPolicies;

		/** One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored. */
		ipsecPoliciesPreset?: string | null;

		/** [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to. */
		localId?: string | null;

		/** The name of the VPN peer */
		name?: string | null;

		/** A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all']. */
		networkTags?: Array<string>;

		/** The list of the private subnets of the VPN peer */
		privateSubnets?: Array<string>;

		/** [optional] The public IP of the VPN peer */
		publicIp?: string | null;

		/** [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN. */
		remoteId?: string | null;

		/** The shared secret with the VPN peer */
		secret?: string | null;
	}
	export interface UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersFormProperties {

		/** [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted. */
		ikeVersion: FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion | null | undefined>,

		/** One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored. */
		ipsecPoliciesPreset: FormControl<string | null | undefined>,

		/** [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to. */
		localId: FormControl<string | null | undefined>,

		/** The name of the VPN peer */
		name: FormControl<string | null | undefined>,

		/** [optional] The public IP of the VPN peer */
		publicIp: FormControl<string | null | undefined>,

		/** [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN. */
		remoteId: FormControl<string | null | undefined>,

		/** The shared secret with the VPN peer */
		secret: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersFormGroup() {
		return new FormGroup<UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersFormProperties>({
			ikeVersion: new FormControl<UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion | null | undefined>(undefined),
			ipsecPoliciesPreset: new FormControl<string | null | undefined>(undefined),
			localId: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			publicIp: new FormControl<string | null | undefined>(undefined),
			remoteId: new FormControl<string | null | undefined>(undefined),
			secret: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPolicies {

		/** This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5' */
		childAuthAlgo?: Array<string>;

		/** This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null' */
		childCipherAlgo?: Array<string>;

		/** The lifetime of the Phase 2 SA in seconds. */
		childLifetime?: number | null;

		/** This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1' */
		childPfsGroup?: Array<string>;

		/** This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5' */
		ikeAuthAlgo?: Array<string>;

		/** This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des' */
		ikeCipherAlgo?: Array<string>;

		/** This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1' */
		ikeDiffieHellmanGroup?: Array<string>;

		/** The lifetime of the Phase 1 SA in seconds. */
		ikeLifetime?: number | null;

		/** [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm. */
		ikePrfAlgo?: Array<string>;
	}
	export interface UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPoliciesFormProperties {

		/** The lifetime of the Phase 2 SA in seconds. */
		childLifetime: FormControl<number | null | undefined>,

		/** The lifetime of the Phase 1 SA in seconds. */
		ikeLifetime: FormControl<number | null | undefined>,
	}
	export function CreateUpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPoliciesFormGroup() {
		return new FormGroup<UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPoliciesFormProperties>({
			childLifetime: new FormControl<number | null | undefined>(undefined),
			ikeLifetime: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationApplianceVpnVpnFirewallRulesPutBody {

		/** An ordered array of the firewall rules (not including the default rule) */
		UpdateOrganizationApplianceVpnVpnFirewallRulesPutBodyRules?: Array<UpdateOrganizationApplianceVpnVpnFirewallRulesPutBodyRules>;

		/** Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional) */
		syslogDefaultRule?: boolean | null;
	}
	export interface UpdateOrganizationApplianceVpnVpnFirewallRulesPutBodyFormProperties {

		/** Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional) */
		syslogDefaultRule: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateOrganizationApplianceVpnVpnFirewallRulesPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationApplianceVpnVpnFirewallRulesPutBodyFormProperties>({
			syslogDefaultRule: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationApplianceVpnVpnFirewallRulesPutBodyRules {

		/** Description of the rule (optional) */
		comment?: string | null;

		/**
		 * Comma-separated list of destination IP address(es) (in IP or CIDR notation) or 'any' (FQDN not supported)
		 * Required
		 */
		destCidr: string;

		/** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */
		destPort?: string | null;

		/**
		 * 'allow' or 'deny' traffic specified by this rule
		 * Required
		 */
		policy: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy;

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		 * Required
		 */
		protocol: UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol;

		/**
		 * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (FQDN not supported)
		 * Required
		 */
		srcCidr: string;

		/** Comma-separated list of source port(s) (integer in the range 1-65535), or 'any' */
		srcPort?: string | null;

		/** Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional) */
		syslogEnabled?: boolean | null;
	}
	export interface UpdateOrganizationApplianceVpnVpnFirewallRulesPutBodyRulesFormProperties {

		/** Description of the rule (optional) */
		comment: FormControl<string | null | undefined>,

		/**
		 * Comma-separated list of destination IP address(es) (in IP or CIDR notation) or 'any' (FQDN not supported)
		 * Required
		 */
		destCidr: FormControl<string | null | undefined>,

		/** Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any' */
		destPort: FormControl<string | null | undefined>,

		/**
		 * 'allow' or 'deny' traffic specified by this rule
		 * Required
		 */
		policy: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>,

		/**
		 * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		 * Required
		 */
		protocol: FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>,

		/**
		 * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (FQDN not supported)
		 * Required
		 */
		srcCidr: FormControl<string | null | undefined>,

		/** Comma-separated list of source port(s) (integer in the range 1-65535), or 'any' */
		srcPort: FormControl<string | null | undefined>,

		/** Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional) */
		syslogEnabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateOrganizationApplianceVpnVpnFirewallRulesPutBodyRulesFormGroup() {
		return new FormGroup<UpdateOrganizationApplianceVpnVpnFirewallRulesPutBodyRulesFormProperties>({
			comment: new FormControl<string | null | undefined>(undefined),
			destCidr: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			destPort: new FormControl<string | null | undefined>(undefined),
			policy: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy | null | undefined>(undefined, [Validators.required]),
			protocol: new FormControl<UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol | null | undefined>(undefined, [Validators.required]),
			srcCidr: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			srcPort: new FormControl<string | null | undefined>(undefined),
			syslogEnabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationBrandingPoliciesReturn {

		/** Settings for describing which kinds of admins this policy applies to. */
		adminSettings?: GetOrganizationBrandingPoliciesReturnAdminSettings;

		/** Properties describing the custom logo attached to the branding policy. */
		customLogo?: GetOrganizationBrandingPoliciesReturnCustomLogo;

		/** Boolean indicating whether this policy is enabled. */
		enabled?: boolean | null;

		/**
		 * Settings for describing the modifications to various Help page features. Each property in this object accepts one of
		 * 'default or inherit' (do not modify functionality), 'hide' (remove the section from Dashboard), or 'show' (always show
		 * the section on Dashboard). Some properties in this object also accept custom HTML used to replace the section on
		 * Dashboard; see the documentation for each property to see the allowed values.
		 */
		helpSettings?: GetOrganizationBrandingPoliciesReturnHelpSettings;

		/** Name of the Dashboard branding policy. */
		name?: string | null;
	}
	export interface GetOrganizationBrandingPoliciesReturnFormProperties {

		/** Boolean indicating whether this policy is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** Name of the Dashboard branding policy. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationBrandingPoliciesReturnFormGroup() {
		return new FormGroup<GetOrganizationBrandingPoliciesReturnFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationBrandingPoliciesReturnAdminSettings {

		/** Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'. */
		appliesTo?: GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null;

		/**
		 * If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
		 * entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
		 * networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
		 * specify an array of tag names.
		 */
		values?: Array<string>;
	}
	export interface GetOrganizationBrandingPoliciesReturnAdminSettingsFormProperties {

		/** Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'. */
		appliesTo: FormControl<GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null | undefined>,
	}
	export function CreateGetOrganizationBrandingPoliciesReturnAdminSettingsFormGroup() {
		return new FormGroup<GetOrganizationBrandingPoliciesReturnAdminSettingsFormProperties>({
			appliesTo: new FormControl<GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo { 'All SAML admins' = 'All SAML admins', 'All admins' = 'All admins', 'All admins of networks tagged...' = 'All admins of networks tagged...', 'All admins of networks...' = 'All admins of networks...', 'All enterprise admins' = 'All enterprise admins', 'All network admins' = 'All network admins', 'All organization admins' = 'All organization admins', 'Specific admins...' = 'Specific admins...' }

	export interface GetOrganizationBrandingPoliciesReturnCustomLogo {

		/** Whether or not there is a custom logo enabled. */
		enabled?: boolean | null;

		/** Properties of the image. */
		image?: GetOrganizationBrandingPoliciesReturnCustomLogoImage;
	}
	export interface GetOrganizationBrandingPoliciesReturnCustomLogoFormProperties {

		/** Whether or not there is a custom logo enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationBrandingPoliciesReturnCustomLogoFormGroup() {
		return new FormGroup<GetOrganizationBrandingPoliciesReturnCustomLogoFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationBrandingPoliciesReturnCustomLogoImage {

		/** Preview of the image */
		preview?: GetOrganizationBrandingPoliciesReturnCustomLogoImagePreview;
	}
	export interface GetOrganizationBrandingPoliciesReturnCustomLogoImageFormProperties {
	}
	export function CreateGetOrganizationBrandingPoliciesReturnCustomLogoImageFormGroup() {
		return new FormGroup<GetOrganizationBrandingPoliciesReturnCustomLogoImageFormProperties>({
		});

	}

	export interface GetOrganizationBrandingPoliciesReturnCustomLogoImagePreview {

		/** Timestamp of the preview image */
		expiresAt?: Date | null;

		/** Url of the preview image */
		url?: string | null;
	}
	export interface GetOrganizationBrandingPoliciesReturnCustomLogoImagePreviewFormProperties {

		/** Timestamp of the preview image */
		expiresAt: FormControl<Date | null | undefined>,

		/** Url of the preview image */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationBrandingPoliciesReturnCustomLogoImagePreviewFormGroup() {
		return new FormGroup<GetOrganizationBrandingPoliciesReturnCustomLogoImagePreviewFormProperties>({
			expiresAt: new FormControl<Date | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationBrandingPoliciesReturnHelpSettings {

		/**
		 * The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		apiDocsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		 * of 'default or inherit', 'hide' or 'show'.
		 */
		casesSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		ciscoMerakiProductDocumentation?: string | null;

		/**
		 * The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		communitySubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		 * be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		dataProtectionRequestsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		 * listed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		firewallInfoSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		 * that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		 * and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		getHelpSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		getHelpSubtabKnowledgeBaseSearch?: string | null;

		/**
		 * The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		hardwareReplacementsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		 * customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpTab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		 * and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpWidget?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		newFeaturesSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		 * organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		smForums?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		supportContactInfo?: string | null;

		/**
		 * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		 * whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		universalSearchKnowledgeBaseSearch?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;
	}
	export interface GetOrganizationBrandingPoliciesReturnHelpSettingsFormProperties {

		/**
		 * The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		apiDocsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		 * of 'default or inherit', 'hide' or 'show'.
		 */
		casesSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		ciscoMerakiProductDocumentation: FormControl<string | null | undefined>,

		/**
		 * The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		communitySubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		 * be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		dataProtectionRequestsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		 * listed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		firewallInfoSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		 * that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		 * and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		getHelpSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		getHelpSubtabKnowledgeBaseSearch: FormControl<string | null | undefined>,

		/**
		 * The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		hardwareReplacementsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		 * customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpTab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		 * and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpWidget: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		newFeaturesSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		 * organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		smForums: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		supportContactInfo: FormControl<string | null | undefined>,

		/**
		 * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		 * whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		universalSearchKnowledgeBaseSearch: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,
	}
	export function CreateGetOrganizationBrandingPoliciesReturnHelpSettingsFormGroup() {
		return new FormGroup<GetOrganizationBrandingPoliciesReturnHelpSettingsFormProperties>({
			apiDocsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			casesSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			ciscoMerakiProductDocumentation: new FormControl<string | null | undefined>(undefined),
			communitySubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			dataProtectionRequestsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			firewallInfoSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			getHelpSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			getHelpSubtabKnowledgeBaseSearch: new FormControl<string | null | undefined>(undefined),
			hardwareReplacementsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			helpTab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			helpWidget: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			newFeaturesSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			smForums: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			supportContactInfo: new FormControl<string | null | undefined>(undefined),
			universalSearchKnowledgeBaseSearch: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab { 'default or inherit' = 'default or inherit', hide = 'hide', show = 'show' }

	export interface CreateOrganizationBrandingPolicyPostBody {

		/** Settings for describing which kinds of admins this policy applies to. */
		adminSettings?: CreateOrganizationBrandingPolicyPostBodyAdminSettings;

		/** Properties describing the custom logo attached to the branding policy. */
		customLogo?: CreateOrganizationBrandingPolicyPostBodyCustomLogo;

		/** Boolean indicating whether this policy is enabled. */
		enabled?: boolean | null;

		/**
		 * Settings for describing the modifications to various Help page features. Each property in this object accepts one of
		 * 'default or inherit' (do not modify functionality), 'hide' (remove the section from Dashboard), or 'show' (always show
		 * the section on Dashboard). Some properties in this object also accept custom HTML used to replace the section on
		 * Dashboard; see the documentation for each property to see the allowed values.
		 * Each property defaults to 'default or inherit' when not provided.
		 */
		helpSettings?: CreateOrganizationBrandingPolicyPostBodyHelpSettings;

		/** Name of the Dashboard branding policy. */
		name?: string | null;
	}
	export interface CreateOrganizationBrandingPolicyPostBodyFormProperties {

		/** Boolean indicating whether this policy is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** Name of the Dashboard branding policy. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationBrandingPolicyPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationBrandingPolicyPostBodyFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationBrandingPolicyPostBodyAdminSettings {

		/** Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'. */
		appliesTo?: GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null;

		/**
		 * If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
		 * entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
		 * networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
		 * specify an array of tag names.
		 */
		values?: Array<string>;
	}
	export interface CreateOrganizationBrandingPolicyPostBodyAdminSettingsFormProperties {

		/** Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'. */
		appliesTo: FormControl<GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null | undefined>,
	}
	export function CreateCreateOrganizationBrandingPolicyPostBodyAdminSettingsFormGroup() {
		return new FormGroup<CreateOrganizationBrandingPolicyPostBodyAdminSettingsFormProperties>({
			appliesTo: new FormControl<GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationBrandingPolicyPostBodyCustomLogo {

		/** Whether or not there is a custom logo enabled. */
		enabled?: boolean | null;

		/** Properties for setting the image. */
		image?: CreateOrganizationBrandingPolicyPostBodyCustomLogoImage;
	}
	export interface CreateOrganizationBrandingPolicyPostBodyCustomLogoFormProperties {

		/** Whether or not there is a custom logo enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateCreateOrganizationBrandingPolicyPostBodyCustomLogoFormGroup() {
		return new FormGroup<CreateOrganizationBrandingPolicyPostBodyCustomLogoFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationBrandingPolicyPostBodyCustomLogoImage {

		/** The file contents (a base 64 encoded string) of your new logo. */
		contents?: string | null;

		/** The format of the encoded contents.  Supported formats are 'png', 'gif', and jpg'. */
		format?: UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null;
	}
	export interface CreateOrganizationBrandingPolicyPostBodyCustomLogoImageFormProperties {

		/** The file contents (a base 64 encoded string) of your new logo. */
		contents: FormControl<string | null | undefined>,

		/** The format of the encoded contents.  Supported formats are 'png', 'gif', and jpg'. */
		format: FormControl<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null | undefined>,
	}
	export function CreateCreateOrganizationBrandingPolicyPostBodyCustomLogoImageFormGroup() {
		return new FormGroup<CreateOrganizationBrandingPolicyPostBodyCustomLogoImageFormProperties>({
			contents: new FormControl<string | null | undefined>(undefined),
			format: new FormControl<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationBrandingPolicyPostBodyHelpSettings {

		/**
		 * The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		apiDocsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		 * of 'default or inherit', 'hide' or 'show'.
		 */
		casesSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		ciscoMerakiProductDocumentation?: string | null;

		/**
		 * The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		communitySubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		 * be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		dataProtectionRequestsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		 * listed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		firewallInfoSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		 * that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		 * and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		getHelpSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		getHelpSubtabKnowledgeBaseSearch?: string | null;

		/**
		 * The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		hardwareReplacementsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		 * customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpTab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		 * and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpWidget?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		newFeaturesSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		 * organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		smForums?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		supportContactInfo?: string | null;

		/**
		 * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		 * whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		universalSearchKnowledgeBaseSearch?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;
	}
	export interface CreateOrganizationBrandingPolicyPostBodyHelpSettingsFormProperties {

		/**
		 * The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		apiDocsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		 * of 'default or inherit', 'hide' or 'show'.
		 */
		casesSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		ciscoMerakiProductDocumentation: FormControl<string | null | undefined>,

		/**
		 * The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		communitySubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		 * be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		dataProtectionRequestsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		 * listed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		firewallInfoSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		 * that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		 * and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		getHelpSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		getHelpSubtabKnowledgeBaseSearch: FormControl<string | null | undefined>,

		/**
		 * The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		hardwareReplacementsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		 * customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpTab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		 * and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpWidget: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		newFeaturesSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		 * organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		smForums: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		supportContactInfo: FormControl<string | null | undefined>,

		/**
		 * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		 * whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		universalSearchKnowledgeBaseSearch: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,
	}
	export function CreateCreateOrganizationBrandingPolicyPostBodyHelpSettingsFormGroup() {
		return new FormGroup<CreateOrganizationBrandingPolicyPostBodyHelpSettingsFormProperties>({
			apiDocsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			casesSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			ciscoMerakiProductDocumentation: new FormControl<string | null | undefined>(undefined),
			communitySubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			dataProtectionRequestsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			firewallInfoSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			getHelpSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			getHelpSubtabKnowledgeBaseSearch: new FormControl<string | null | undefined>(undefined),
			hardwareReplacementsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			helpTab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			helpWidget: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			newFeaturesSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			smForums: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			supportContactInfo: new FormControl<string | null | undefined>(undefined),
			universalSearchKnowledgeBaseSearch: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationBrandingPoliciesPrioritiesReturn {

		/**
		 * An ordered list of branding policy IDs that determines the priority order of how to apply the policies
		 */
		brandingPolicyIds?: Array<string>;
	}
	export interface GetOrganizationBrandingPoliciesPrioritiesReturnFormProperties {
	}
	export function CreateGetOrganizationBrandingPoliciesPrioritiesReturnFormGroup() {
		return new FormGroup<GetOrganizationBrandingPoliciesPrioritiesReturnFormProperties>({
		});

	}

	export interface UpdateOrganizationBrandingPoliciesPrioritiesPutBody {

		/**
		 * An ordered list of branding policy IDs that determines the priority order of how to apply the policies
		 */
		brandingPolicyIds?: Array<string>;
	}
	export interface UpdateOrganizationBrandingPoliciesPrioritiesPutBodyFormProperties {
	}
	export function CreateUpdateOrganizationBrandingPoliciesPrioritiesPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPoliciesPrioritiesPutBodyFormProperties>({
		});

	}

	export interface UpdateOrganizationBrandingPoliciesPrioritiesReturn {

		/**
		 * An ordered list of branding policy IDs that determines the priority order of how to apply the policies
		 */
		brandingPolicyIds?: Array<string>;
	}
	export interface UpdateOrganizationBrandingPoliciesPrioritiesReturnFormProperties {
	}
	export function CreateUpdateOrganizationBrandingPoliciesPrioritiesReturnFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPoliciesPrioritiesReturnFormProperties>({
		});

	}

	export interface GetOrganizationBrandingPolicyReturn {

		/** Settings for describing which kinds of admins this policy applies to. */
		adminSettings?: GetOrganizationBrandingPolicyReturnAdminSettings;

		/** Properties describing the custom logo attached to the branding policy. */
		customLogo?: GetOrganizationBrandingPolicyReturnCustomLogo;

		/** Boolean indicating whether this policy is enabled. */
		enabled?: boolean | null;

		/**
		 * Settings for describing the modifications to various Help page features. Each property in this object accepts one of
		 * 'default or inherit' (do not modify functionality), 'hide' (remove the section from Dashboard), or 'show' (always show
		 * the section on Dashboard). Some properties in this object also accept custom HTML used to replace the section on
		 * Dashboard; see the documentation for each property to see the allowed values.
		 */
		helpSettings?: GetOrganizationBrandingPolicyReturnHelpSettings;

		/** Name of the Dashboard branding policy. */
		name?: string | null;
	}
	export interface GetOrganizationBrandingPolicyReturnFormProperties {

		/** Boolean indicating whether this policy is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** Name of the Dashboard branding policy. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationBrandingPolicyReturnFormGroup() {
		return new FormGroup<GetOrganizationBrandingPolicyReturnFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationBrandingPolicyReturnAdminSettings {

		/** Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'. */
		appliesTo?: GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null;

		/**
		 * If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
		 * entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
		 * networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
		 * specify an array of tag names.
		 */
		values?: Array<string>;
	}
	export interface GetOrganizationBrandingPolicyReturnAdminSettingsFormProperties {

		/** Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'. */
		appliesTo: FormControl<GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null | undefined>,
	}
	export function CreateGetOrganizationBrandingPolicyReturnAdminSettingsFormGroup() {
		return new FormGroup<GetOrganizationBrandingPolicyReturnAdminSettingsFormProperties>({
			appliesTo: new FormControl<GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationBrandingPolicyReturnCustomLogo {

		/** Whether or not there is a custom logo enabled. */
		enabled?: boolean | null;

		/** Properties of the image. */
		image?: GetOrganizationBrandingPolicyReturnCustomLogoImage;
	}
	export interface GetOrganizationBrandingPolicyReturnCustomLogoFormProperties {

		/** Whether or not there is a custom logo enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationBrandingPolicyReturnCustomLogoFormGroup() {
		return new FormGroup<GetOrganizationBrandingPolicyReturnCustomLogoFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationBrandingPolicyReturnCustomLogoImage {

		/** Preview of the image */
		preview?: GetOrganizationBrandingPolicyReturnCustomLogoImagePreview;
	}
	export interface GetOrganizationBrandingPolicyReturnCustomLogoImageFormProperties {
	}
	export function CreateGetOrganizationBrandingPolicyReturnCustomLogoImageFormGroup() {
		return new FormGroup<GetOrganizationBrandingPolicyReturnCustomLogoImageFormProperties>({
		});

	}

	export interface GetOrganizationBrandingPolicyReturnCustomLogoImagePreview {

		/** Timestamp of the preview image */
		expiresAt?: Date | null;

		/** Url of the preview image */
		url?: string | null;
	}
	export interface GetOrganizationBrandingPolicyReturnCustomLogoImagePreviewFormProperties {

		/** Timestamp of the preview image */
		expiresAt: FormControl<Date | null | undefined>,

		/** Url of the preview image */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationBrandingPolicyReturnCustomLogoImagePreviewFormGroup() {
		return new FormGroup<GetOrganizationBrandingPolicyReturnCustomLogoImagePreviewFormProperties>({
			expiresAt: new FormControl<Date | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationBrandingPolicyReturnHelpSettings {

		/**
		 * The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		apiDocsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		 * of 'default or inherit', 'hide' or 'show'.
		 */
		casesSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		ciscoMerakiProductDocumentation?: string | null;

		/**
		 * The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		communitySubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		 * be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		dataProtectionRequestsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		 * listed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		firewallInfoSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		 * that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		 * and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		getHelpSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		getHelpSubtabKnowledgeBaseSearch?: string | null;

		/**
		 * The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		hardwareReplacementsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		 * customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpTab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		 * and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpWidget?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		newFeaturesSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		 * organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		smForums?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		supportContactInfo?: string | null;

		/**
		 * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		 * whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		universalSearchKnowledgeBaseSearch?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;
	}
	export interface GetOrganizationBrandingPolicyReturnHelpSettingsFormProperties {

		/**
		 * The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		apiDocsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		 * of 'default or inherit', 'hide' or 'show'.
		 */
		casesSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		ciscoMerakiProductDocumentation: FormControl<string | null | undefined>,

		/**
		 * The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		communitySubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		 * be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		dataProtectionRequestsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		 * listed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		firewallInfoSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		 * that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		 * and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		getHelpSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		getHelpSubtabKnowledgeBaseSearch: FormControl<string | null | undefined>,

		/**
		 * The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		hardwareReplacementsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		 * customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpTab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		 * and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpWidget: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		newFeaturesSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		 * organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		smForums: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		supportContactInfo: FormControl<string | null | undefined>,

		/**
		 * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		 * whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		universalSearchKnowledgeBaseSearch: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,
	}
	export function CreateGetOrganizationBrandingPolicyReturnHelpSettingsFormGroup() {
		return new FormGroup<GetOrganizationBrandingPolicyReturnHelpSettingsFormProperties>({
			apiDocsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			casesSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			ciscoMerakiProductDocumentation: new FormControl<string | null | undefined>(undefined),
			communitySubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			dataProtectionRequestsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			firewallInfoSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			getHelpSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			getHelpSubtabKnowledgeBaseSearch: new FormControl<string | null | undefined>(undefined),
			hardwareReplacementsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			helpTab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			helpWidget: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			newFeaturesSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			smForums: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			supportContactInfo: new FormControl<string | null | undefined>(undefined),
			universalSearchKnowledgeBaseSearch: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationBrandingPolicyPutBody {

		/** Settings for describing which kinds of admins this policy applies to. */
		adminSettings?: UpdateOrganizationBrandingPolicyPutBodyAdminSettings;

		/** Properties describing the custom logo attached to the branding policy. */
		customLogo?: UpdateOrganizationBrandingPolicyPutBodyCustomLogo;

		/** Boolean indicating whether this policy is enabled. */
		enabled?: boolean | null;

		/**
		 * Settings for describing the modifications to various Help page features. Each property in this object accepts one of
		 * 'default or inherit' (do not modify functionality), 'hide' (remove the section from Dashboard), or 'show' (always show
		 * the section on Dashboard). Some properties in this object also accept custom HTML used to replace the section on
		 * Dashboard; see the documentation for each property to see the allowed values.
		 */
		helpSettings?: UpdateOrganizationBrandingPolicyPutBodyHelpSettings;

		/** Name of the Dashboard branding policy. */
		name?: string | null;
	}
	export interface UpdateOrganizationBrandingPolicyPutBodyFormProperties {

		/** Boolean indicating whether this policy is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** Name of the Dashboard branding policy. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationBrandingPolicyPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPolicyPutBodyFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationBrandingPolicyPutBodyAdminSettings {

		/** Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'. */
		appliesTo?: GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null;

		/**
		 * If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
		 * entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
		 * networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
		 * specify an array of tag names.
		 */
		values?: Array<string>;
	}
	export interface UpdateOrganizationBrandingPolicyPutBodyAdminSettingsFormProperties {

		/** Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'. */
		appliesTo: FormControl<GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null | undefined>,
	}
	export function CreateUpdateOrganizationBrandingPolicyPutBodyAdminSettingsFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPolicyPutBodyAdminSettingsFormProperties>({
			appliesTo: new FormControl<GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationBrandingPolicyPutBodyCustomLogo {

		/** Whether or not there is a custom logo enabled. */
		enabled?: boolean | null;

		/** Properties for setting the image. */
		image?: UpdateOrganizationBrandingPolicyPutBodyCustomLogoImage;
	}
	export interface UpdateOrganizationBrandingPolicyPutBodyCustomLogoFormProperties {

		/** Whether or not there is a custom logo enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateOrganizationBrandingPolicyPutBodyCustomLogoFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPolicyPutBodyCustomLogoFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationBrandingPolicyPutBodyCustomLogoImage {

		/** The file contents (a base 64 encoded string) of your new logo. */
		contents?: string | null;

		/** The format of the encoded contents.  Supported formats are 'png', 'gif', and jpg'. */
		format?: UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null;
	}
	export interface UpdateOrganizationBrandingPolicyPutBodyCustomLogoImageFormProperties {

		/** The file contents (a base 64 encoded string) of your new logo. */
		contents: FormControl<string | null | undefined>,

		/** The format of the encoded contents.  Supported formats are 'png', 'gif', and jpg'. */
		format: FormControl<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null | undefined>,
	}
	export function CreateUpdateOrganizationBrandingPolicyPutBodyCustomLogoImageFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPolicyPutBodyCustomLogoImageFormProperties>({
			contents: new FormControl<string | null | undefined>(undefined),
			format: new FormControl<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationBrandingPolicyPutBodyHelpSettings {

		/**
		 * The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		apiDocsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		 * of 'default or inherit', 'hide' or 'show'.
		 */
		casesSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		ciscoMerakiProductDocumentation?: string | null;

		/**
		 * The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		communitySubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		 * be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		dataProtectionRequestsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		 * listed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		firewallInfoSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		 * that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		 * and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		getHelpSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		getHelpSubtabKnowledgeBaseSearch?: string | null;

		/**
		 * The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		hardwareReplacementsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		 * customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpTab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		 * and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpWidget?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		newFeaturesSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		 * organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		smForums?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		supportContactInfo?: string | null;

		/**
		 * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		 * whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		universalSearchKnowledgeBaseSearch?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;
	}
	export interface UpdateOrganizationBrandingPolicyPutBodyHelpSettingsFormProperties {

		/**
		 * The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		apiDocsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		 * of 'default or inherit', 'hide' or 'show'.
		 */
		casesSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		ciscoMerakiProductDocumentation: FormControl<string | null | undefined>,

		/**
		 * The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		communitySubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		 * be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		dataProtectionRequestsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		 * listed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		firewallInfoSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		 * that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		 * and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		getHelpSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		getHelpSubtabKnowledgeBaseSearch: FormControl<string | null | undefined>,

		/**
		 * The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		hardwareReplacementsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		 * customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpTab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		 * and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpWidget: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		newFeaturesSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		 * organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		smForums: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		supportContactInfo: FormControl<string | null | undefined>,

		/**
		 * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		 * whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		universalSearchKnowledgeBaseSearch: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,
	}
	export function CreateUpdateOrganizationBrandingPolicyPutBodyHelpSettingsFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsFormProperties>({
			apiDocsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			casesSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			ciscoMerakiProductDocumentation: new FormControl<string | null | undefined>(undefined),
			communitySubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			dataProtectionRequestsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			firewallInfoSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			getHelpSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			getHelpSubtabKnowledgeBaseSearch: new FormControl<string | null | undefined>(undefined),
			hardwareReplacementsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			helpTab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			helpWidget: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			newFeaturesSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			smForums: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			supportContactInfo: new FormControl<string | null | undefined>(undefined),
			universalSearchKnowledgeBaseSearch: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationBrandingPolicyReturn {

		/** Settings for describing which kinds of admins this policy applies to. */
		adminSettings?: UpdateOrganizationBrandingPolicyReturnAdminSettings;

		/** Properties describing the custom logo attached to the branding policy. */
		customLogo?: UpdateOrganizationBrandingPolicyReturnCustomLogo;

		/** Boolean indicating whether this policy is enabled. */
		enabled?: boolean | null;

		/**
		 * Settings for describing the modifications to various Help page features. Each property in this object accepts one of
		 * 'default or inherit' (do not modify functionality), 'hide' (remove the section from Dashboard), or 'show' (always show
		 * the section on Dashboard). Some properties in this object also accept custom HTML used to replace the section on
		 * Dashboard; see the documentation for each property to see the allowed values.
		 */
		helpSettings?: UpdateOrganizationBrandingPolicyReturnHelpSettings;

		/** Name of the Dashboard branding policy. */
		name?: string | null;
	}
	export interface UpdateOrganizationBrandingPolicyReturnFormProperties {

		/** Boolean indicating whether this policy is enabled. */
		enabled: FormControl<boolean | null | undefined>,

		/** Name of the Dashboard branding policy. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationBrandingPolicyReturnFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPolicyReturnFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationBrandingPolicyReturnAdminSettings {

		/** Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'. */
		appliesTo?: GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null;

		/**
		 * If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
		 * entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
		 * networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
		 * specify an array of tag names.
		 */
		values?: Array<string>;
	}
	export interface UpdateOrganizationBrandingPolicyReturnAdminSettingsFormProperties {

		/** Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'. */
		appliesTo: FormControl<GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null | undefined>,
	}
	export function CreateUpdateOrganizationBrandingPolicyReturnAdminSettingsFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPolicyReturnAdminSettingsFormProperties>({
			appliesTo: new FormControl<GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationBrandingPolicyReturnCustomLogo {

		/** Whether or not there is a custom logo enabled. */
		enabled?: boolean | null;

		/** Properties of the image. */
		image?: UpdateOrganizationBrandingPolicyReturnCustomLogoImage;
	}
	export interface UpdateOrganizationBrandingPolicyReturnCustomLogoFormProperties {

		/** Whether or not there is a custom logo enabled. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateOrganizationBrandingPolicyReturnCustomLogoFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPolicyReturnCustomLogoFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationBrandingPolicyReturnCustomLogoImage {

		/** Preview of the image */
		preview?: UpdateOrganizationBrandingPolicyReturnCustomLogoImagePreview;
	}
	export interface UpdateOrganizationBrandingPolicyReturnCustomLogoImageFormProperties {
	}
	export function CreateUpdateOrganizationBrandingPolicyReturnCustomLogoImageFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPolicyReturnCustomLogoImageFormProperties>({
		});

	}

	export interface UpdateOrganizationBrandingPolicyReturnCustomLogoImagePreview {

		/** Timestamp of the preview image */
		expiresAt?: Date | null;

		/** Url of the preview image */
		url?: string | null;
	}
	export interface UpdateOrganizationBrandingPolicyReturnCustomLogoImagePreviewFormProperties {

		/** Timestamp of the preview image */
		expiresAt: FormControl<Date | null | undefined>,

		/** Url of the preview image */
		url: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationBrandingPolicyReturnCustomLogoImagePreviewFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPolicyReturnCustomLogoImagePreviewFormProperties>({
			expiresAt: new FormControl<Date | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationBrandingPolicyReturnHelpSettings {

		/**
		 * The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		apiDocsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		 * of 'default or inherit', 'hide' or 'show'.
		 */
		casesSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		ciscoMerakiProductDocumentation?: string | null;

		/**
		 * The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		communitySubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		 * be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		dataProtectionRequestsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		 * listed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		firewallInfoSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		 * that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		 * and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		getHelpSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		getHelpSubtabKnowledgeBaseSearch?: string | null;

		/**
		 * The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		hardwareReplacementsSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		 * customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpTab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		 * and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpWidget?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		newFeaturesSubtab?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		 * organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		smForums?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;

		/**
		 * The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		supportContactInfo?: string | null;

		/**
		 * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		 * whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		universalSearchKnowledgeBaseSearch?: GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null;
	}
	export interface UpdateOrganizationBrandingPolicyReturnHelpSettingsFormProperties {

		/**
		 * The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		apiDocsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		 * of 'default or inherit', 'hide' or 'show'.
		 */
		casesSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		ciscoMerakiProductDocumentation: FormControl<string | null | undefined>,

		/**
		 * The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		communitySubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		 * be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		dataProtectionRequestsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		 * listed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		firewallInfoSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		 * that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		 * and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		getHelpSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		getHelpSubtabKnowledgeBaseSearch: FormControl<string | null | undefined>,

		/**
		 * The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		 * 'default or inherit', 'hide' or 'show'.
		 */
		hardwareReplacementsSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		 * customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpTab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		 * and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		helpWidget: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		newFeaturesSubtab: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		 * organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		smForums: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,

		/**
		 * The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		 */
		supportContactInfo: FormControl<string | null | undefined>,

		/**
		 * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		 * whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		 */
		universalSearchKnowledgeBaseSearch: FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>,
	}
	export function CreateUpdateOrganizationBrandingPolicyReturnHelpSettingsFormGroup() {
		return new FormGroup<UpdateOrganizationBrandingPolicyReturnHelpSettingsFormProperties>({
			apiDocsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			casesSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			ciscoMerakiProductDocumentation: new FormControl<string | null | undefined>(undefined),
			communitySubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			dataProtectionRequestsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			firewallInfoSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			getHelpSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			getHelpSubtabKnowledgeBaseSearch: new FormControl<string | null | undefined>(undefined),
			hardwareReplacementsSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			helpTab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			helpWidget: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			newFeaturesSubtab: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			smForums: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
			supportContactInfo: new FormControl<string | null | undefined>(undefined),
			universalSearchKnowledgeBaseSearch: new FormControl<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationCameraCustomAnalyticsArtifactPostBody {

		/** Unique name of the artifact */
		name?: string | null;
	}
	export interface CreateOrganizationCameraCustomAnalyticsArtifactPostBodyFormProperties {

		/** Unique name of the artifact */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationCameraCustomAnalyticsArtifactPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationCameraCustomAnalyticsArtifactPostBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationCameraOnboardingStatusesPutBody {

		/** Serial of camera */
		serial?: string | null;

		/** Note whether credentials were sent successfully */
		wirelessCredentialsSent?: boolean | null;
	}
	export interface UpdateOrganizationCameraOnboardingStatusesPutBodyFormProperties {

		/** Serial of camera */
		serial: FormControl<string | null | undefined>,

		/** Note whether credentials were sent successfully */
		wirelessCredentialsSent: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateOrganizationCameraOnboardingStatusesPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationCameraOnboardingStatusesPutBodyFormProperties>({
			serial: new FormControl<string | null | undefined>(undefined),
			wirelessCredentialsSent: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationCellularGatewayUplinkStatusesReturn {

		/** Last reported time for the device */
		lastReportedAt?: Date | null;

		/** Device model */
		model?: string | null;

		/** Network Id */
		networkId?: string | null;

		/** Serial number of the device */
		serial?: string | null;

		/** Uplinks info */
		GetOrganizationCellularGatewayUplinkStatusesReturnUplinks?: Array<GetOrganizationCellularGatewayUplinkStatusesReturnUplinks>;
	}
	export interface GetOrganizationCellularGatewayUplinkStatusesReturnFormProperties {

		/** Last reported time for the device */
		lastReportedAt: FormControl<Date | null | undefined>,

		/** Device model */
		model: FormControl<string | null | undefined>,

		/** Network Id */
		networkId: FormControl<string | null | undefined>,

		/** Serial number of the device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationCellularGatewayUplinkStatusesReturnFormGroup() {
		return new FormGroup<GetOrganizationCellularGatewayUplinkStatusesReturnFormProperties>({
			lastReportedAt: new FormControl<Date | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationCellularGatewayUplinkStatusesReturnUplinks {

		/** Access Point Name */
		apn?: string | null;

		/** Connection Type */
		connectionType?: string | null;

		/** Primary DNS IP */
		dns1?: string | null;

		/** Secondary DNS IP */
		dns2?: string | null;

		/** Gateway IP */
		gateway?: string | null;

		/** Integrated Circuit Card Identification Number */
		iccid?: string | null;

		/** Uplink interface */
		interface?: string | null;

		/** Uplink IP */
		ip?: string | null;

		/** Uplink model */
		model?: string | null;

		/** Network Provider */
		provider?: string | null;

		/** Public IP */
		publicIp?: string | null;

		/** Tower Signal Status */
		signalStat?: GetOrganizationCellularGatewayUplinkStatusesReturnUplinksSignalStat;

		/** Signal Type */
		signalType?: string | null;

		/** Uplink status */
		status?: string | null;
	}
	export interface GetOrganizationCellularGatewayUplinkStatusesReturnUplinksFormProperties {

		/** Access Point Name */
		apn: FormControl<string | null | undefined>,

		/** Connection Type */
		connectionType: FormControl<string | null | undefined>,

		/** Primary DNS IP */
		dns1: FormControl<string | null | undefined>,

		/** Secondary DNS IP */
		dns2: FormControl<string | null | undefined>,

		/** Gateway IP */
		gateway: FormControl<string | null | undefined>,

		/** Integrated Circuit Card Identification Number */
		iccid: FormControl<string | null | undefined>,

		/** Uplink interface */
		interface: FormControl<string | null | undefined>,

		/** Uplink IP */
		ip: FormControl<string | null | undefined>,

		/** Uplink model */
		model: FormControl<string | null | undefined>,

		/** Network Provider */
		provider: FormControl<string | null | undefined>,

		/** Public IP */
		publicIp: FormControl<string | null | undefined>,

		/** Signal Type */
		signalType: FormControl<string | null | undefined>,

		/** Uplink status */
		status: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationCellularGatewayUplinkStatusesReturnUplinksFormGroup() {
		return new FormGroup<GetOrganizationCellularGatewayUplinkStatusesReturnUplinksFormProperties>({
			apn: new FormControl<string | null | undefined>(undefined),
			connectionType: new FormControl<string | null | undefined>(undefined),
			dns1: new FormControl<string | null | undefined>(undefined),
			dns2: new FormControl<string | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			iccid: new FormControl<string | null | undefined>(undefined),
			interface: new FormControl<string | null | undefined>(undefined),
			ip: new FormControl<string | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
			provider: new FormControl<string | null | undefined>(undefined),
			publicIp: new FormControl<string | null | undefined>(undefined),
			signalType: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationCellularGatewayUplinkStatusesReturnUplinksSignalStat {

		/** Reference Signal Received Power */
		rsrp?: string | null;

		/** Reference Signal Received Quality */
		rsrq?: string | null;
	}
	export interface GetOrganizationCellularGatewayUplinkStatusesReturnUplinksSignalStatFormProperties {

		/** Reference Signal Received Power */
		rsrp: FormControl<string | null | undefined>,

		/** Reference Signal Received Quality */
		rsrq: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationCellularGatewayUplinkStatusesReturnUplinksSignalStatFormGroup() {
		return new FormGroup<GetOrganizationCellularGatewayUplinkStatusesReturnUplinksSignalStatFormProperties>({
			rsrp: new FormControl<string | null | undefined>(undefined),
			rsrq: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ClaimIntoOrganizationPostBody {

		/** The licenses that should be claimed */
		ClaimIntoOrganizationPostBodyLicenses?: Array<ClaimIntoOrganizationPostBodyLicenses>;

		/** The numbers of the orders that should be claimed */
		orders?: Array<string>;

		/** The serials of the devices that should be claimed */
		serials?: Array<string>;
	}
	export interface ClaimIntoOrganizationPostBodyFormProperties {
	}
	export function CreateClaimIntoOrganizationPostBodyFormGroup() {
		return new FormGroup<ClaimIntoOrganizationPostBodyFormProperties>({
		});

	}

	export interface ClaimIntoOrganizationPostBodyLicenses {

		/**
		 * The key of the license
		 * Required
		 */
		key: string;

		/** Either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. This parameter is legacy and does not apply to organizations with per-device licensing enabled. */
		mode?: ClaimIntoOrganizationPostBodyLicensesMode | null;
	}
	export interface ClaimIntoOrganizationPostBodyLicensesFormProperties {

		/**
		 * The key of the license
		 * Required
		 */
		key: FormControl<string | null | undefined>,

		/** Either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. This parameter is legacy and does not apply to organizations with per-device licensing enabled. */
		mode: FormControl<ClaimIntoOrganizationPostBodyLicensesMode | null | undefined>,
	}
	export function CreateClaimIntoOrganizationPostBodyLicensesFormGroup() {
		return new FormGroup<ClaimIntoOrganizationPostBodyLicensesFormProperties>({
			key: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			mode: new FormControl<ClaimIntoOrganizationPostBodyLicensesMode | null | undefined>(undefined),
		});

	}

	export enum ClaimIntoOrganizationPostBodyLicensesMode { addDevices = 'addDevices', renew = 'renew' }

	export interface GetOrganizationClientsBandwidthUsageHistoryReturn {

		/** Downloaded data, in mbps. */
		downstream?: number | null;

		/** Total bandwidth usage, in mbps. */
		total?: number | null;

		/** Timestamp for the bandwidth usage snapshot. */
		ts?: Date | null;

		/** Uploaded data, in mbps. */
		upstream?: number | null;
	}
	export interface GetOrganizationClientsBandwidthUsageHistoryReturnFormProperties {

		/** Downloaded data, in mbps. */
		downstream: FormControl<number | null | undefined>,

		/** Total bandwidth usage, in mbps. */
		total: FormControl<number | null | undefined>,

		/** Timestamp for the bandwidth usage snapshot. */
		ts: FormControl<Date | null | undefined>,

		/** Uploaded data, in mbps. */
		upstream: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationClientsBandwidthUsageHistoryReturnFormGroup() {
		return new FormGroup<GetOrganizationClientsBandwidthUsageHistoryReturnFormProperties>({
			downstream: new FormControl<number | null | undefined>(undefined),
			total: new FormControl<number | null | undefined>(undefined),
			ts: new FormControl<Date | null | undefined>(undefined),
			upstream: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationClientsOverviewReturn {

		/** Client count information */
		counts?: GetOrganizationClientsOverviewReturnCounts;

		/** Usage information of all clients across organization */
		usage?: GetOrganizationClientsOverviewReturnUsage;
	}
	export interface GetOrganizationClientsOverviewReturnFormProperties {
	}
	export function CreateGetOrganizationClientsOverviewReturnFormGroup() {
		return new FormGroup<GetOrganizationClientsOverviewReturnFormProperties>({
		});

	}

	export interface GetOrganizationClientsOverviewReturnCounts {

		/** Total number of clients with data usage in organization */
		total?: number | null;
	}
	export interface GetOrganizationClientsOverviewReturnCountsFormProperties {

		/** Total number of clients with data usage in organization */
		total: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationClientsOverviewReturnCountsFormGroup() {
		return new FormGroup<GetOrganizationClientsOverviewReturnCountsFormProperties>({
			total: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationClientsOverviewReturnUsage {

		/** Average data usage (in kb) of each client in organization */
		average?: number | null;

		/** Overall data usage of all clients across organization */
		overall?: GetOrganizationClientsOverviewReturnUsageOverall;
	}
	export interface GetOrganizationClientsOverviewReturnUsageFormProperties {

		/** Average data usage (in kb) of each client in organization */
		average: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationClientsOverviewReturnUsageFormGroup() {
		return new FormGroup<GetOrganizationClientsOverviewReturnUsageFormProperties>({
			average: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationClientsOverviewReturnUsageOverall {

		/** Downstream data usage (in kb) of all clients across organization */
		downstream?: number | null;

		/** Total data usage (in kb) of all clients across organization */
		total?: number | null;

		/** Upstream data usage (in kb) of all clients across organization */
		upstream?: number | null;
	}
	export interface GetOrganizationClientsOverviewReturnUsageOverallFormProperties {

		/** Downstream data usage (in kb) of all clients across organization */
		downstream: FormControl<number | null | undefined>,

		/** Total data usage (in kb) of all clients across organization */
		total: FormControl<number | null | undefined>,

		/** Upstream data usage (in kb) of all clients across organization */
		upstream: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationClientsOverviewReturnUsageOverallFormGroup() {
		return new FormGroup<GetOrganizationClientsOverviewReturnUsageOverallFormProperties>({
			downstream: new FormControl<number | null | undefined>(undefined),
			total: new FormControl<number | null | undefined>(undefined),
			upstream: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CloneOrganizationPostBody {

		/**
		 * The name of the new organization
		 * Required
		 */
		name: string;
	}
	export interface CloneOrganizationPostBodyFormProperties {

		/**
		 * The name of the new organization
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCloneOrganizationPostBodyFormGroup() {
		return new FormGroup<CloneOrganizationPostBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateOrganizationConfigTemplatePostBody {

		/** The ID of the network or config template to copy configuration from */
		copyFromNetworkId?: string | null;

		/**
		 * The name of the configuration template
		 * Required
		 */
		name: string;

		/** The timezone of the configuration template. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article</a>. Not applicable if copying from existing network or template */
		timeZone?: string | null;
	}
	export interface CreateOrganizationConfigTemplatePostBodyFormProperties {

		/** The ID of the network or config template to copy configuration from */
		copyFromNetworkId: FormControl<string | null | undefined>,

		/**
		 * The name of the configuration template
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/** The timezone of the configuration template. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article</a>. Not applicable if copying from existing network or template */
		timeZone: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationConfigTemplatePostBodyFormGroup() {
		return new FormGroup<CreateOrganizationConfigTemplatePostBodyFormProperties>({
			copyFromNetworkId: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			timeZone: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationConfigTemplatePutBody {

		/** The name of the configuration template */
		name?: string | null;

		/** The timezone of the configuration template. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a> */
		timeZone?: string | null;
	}
	export interface UpdateOrganizationConfigTemplatePutBodyFormProperties {

		/** The name of the configuration template */
		name: FormControl<string | null | undefined>,

		/** The timezone of the configuration template. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a> */
		timeZone: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationConfigTemplatePutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationConfigTemplatePutBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			timeZone: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationConfigTemplateSwitchProfilesReturn {

		/** Switch model */
		model?: string | null;

		/** Switch profile name */
		name?: string | null;

		/** Switch profile id */
		switchProfileId?: string | null;
	}
	export interface GetOrganizationConfigTemplateSwitchProfilesReturnFormProperties {

		/** Switch model */
		model: FormControl<string | null | undefined>,

		/** Switch profile name */
		name: FormControl<string | null | undefined>,

		/** Switch profile id */
		switchProfileId: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationConfigTemplateSwitchProfilesReturnFormGroup() {
		return new FormGroup<GetOrganizationConfigTemplateSwitchProfilesReturnFormProperties>({
			model: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			switchProfileId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationConfigTemplateSwitchProfilePortsReturn {

		/** The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber?: number | null;

		/** The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType?: GetDeviceSwitchPortsReturnAccessPolicyType | null;

		/** The VLANs allowed on the switch profile port. Only applicable to trunk ports. */
		allowedVlans?: string | null;

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted?: boolean | null;

		/** The status of the switch profile port. */
		enabled?: boolean | null;

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled?: boolean | null;

		/** The isolation status of the switch profile port. */
		isolationEnabled?: boolean | null;

		/** The link speed for the switch profile port. */
		linkNegotiation?: string | null;

		/** Available link speeds for the switch profile port. */
		linkNegotiationCapabilities?: Array<string>;

		/** Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'. */
		macAllowList?: Array<string>;

		/** The name of the switch profile port. */
		name?: string | null;

		/** The PoE status of the switch profile port. */
		poeEnabled?: boolean | null;

		/** The identifier of the switch profile port. */
		portId?: string | null;

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId?: string | null;

		/** Profile attributes */
		profile?: GetOrganizationConfigTemplateSwitchProfilePortsReturnProfile;

		/** The rapid spanning tree protocol status. */
		rstpEnabled?: boolean | null;

		/** The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowList?: Array<string>;

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit?: number | null;

		/** The storm control status of the switch profile port. */
		stormControlEnabled?: boolean | null;

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard?: GetDeviceSwitchPortsReturnStpGuard | null;

		/** The list of tags of the switch profile port. */
		tags?: Array<string>;

		/** The type of the switch profile port ('trunk' or 'access'). */
		type?: GetDeviceSwitchPortsReturnType | null;

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld?: GetDeviceSwitchPortsReturnUdld | null;

		/** The VLAN of the switch profile port. A null value will clear the value set for trunk ports. */
		vlan?: number | null;

		/** The voice VLAN of the switch profile port. Only applicable to access ports. */
		voiceVlan?: number | null;
	}
	export interface GetOrganizationConfigTemplateSwitchProfilePortsReturnFormProperties {

		/** The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber: FormControl<number | null | undefined>,

		/** The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType: FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>,

		/** The VLANs allowed on the switch profile port. Only applicable to trunk ports. */
		allowedVlans: FormControl<string | null | undefined>,

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted: FormControl<boolean | null | undefined>,

		/** The status of the switch profile port. */
		enabled: FormControl<boolean | null | undefined>,

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled: FormControl<boolean | null | undefined>,

		/** The isolation status of the switch profile port. */
		isolationEnabled: FormControl<boolean | null | undefined>,

		/** The link speed for the switch profile port. */
		linkNegotiation: FormControl<string | null | undefined>,

		/** The name of the switch profile port. */
		name: FormControl<string | null | undefined>,

		/** The PoE status of the switch profile port. */
		poeEnabled: FormControl<boolean | null | undefined>,

		/** The identifier of the switch profile port. */
		portId: FormControl<string | null | undefined>,

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId: FormControl<string | null | undefined>,

		/** The rapid spanning tree protocol status. */
		rstpEnabled: FormControl<boolean | null | undefined>,

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit: FormControl<number | null | undefined>,

		/** The storm control status of the switch profile port. */
		stormControlEnabled: FormControl<boolean | null | undefined>,

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard: FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>,

		/** The type of the switch profile port ('trunk' or 'access'). */
		type: FormControl<GetDeviceSwitchPortsReturnType | null | undefined>,

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld: FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>,

		/** The VLAN of the switch profile port. A null value will clear the value set for trunk ports. */
		vlan: FormControl<number | null | undefined>,

		/** The voice VLAN of the switch profile port. Only applicable to access ports. */
		voiceVlan: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationConfigTemplateSwitchProfilePortsReturnFormGroup() {
		return new FormGroup<GetOrganizationConfigTemplateSwitchProfilePortsReturnFormProperties>({
			accessPolicyNumber: new FormControl<number | null | undefined>(undefined),
			accessPolicyType: new FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			daiTrusted: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			flexibleStackingEnabled: new FormControl<boolean | null | undefined>(undefined),
			isolationEnabled: new FormControl<boolean | null | undefined>(undefined),
			linkNegotiation: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			poeEnabled: new FormControl<boolean | null | undefined>(undefined),
			portId: new FormControl<string | null | undefined>(undefined),
			portScheduleId: new FormControl<string | null | undefined>(undefined),
			rstpEnabled: new FormControl<boolean | null | undefined>(undefined),
			stickyMacAllowListLimit: new FormControl<number | null | undefined>(undefined),
			stormControlEnabled: new FormControl<boolean | null | undefined>(undefined),
			stpGuard: new FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>(undefined),
			type: new FormControl<GetDeviceSwitchPortsReturnType | null | undefined>(undefined),
			udld: new FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
			voiceVlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationConfigTemplateSwitchProfilePortsReturnProfile {

		/** When enabled, override this port's configuration with a port profile. */
		enabled?: boolean | null;

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id?: string | null;

		/** When enabled, the IName of the profile. */
		iname?: string | null;
	}
	export interface GetOrganizationConfigTemplateSwitchProfilePortsReturnProfileFormProperties {

		/** When enabled, override this port's configuration with a port profile. */
		enabled: FormControl<boolean | null | undefined>,

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id: FormControl<string | null | undefined>,

		/** When enabled, the IName of the profile. */
		iname: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationConfigTemplateSwitchProfilePortsReturnProfileFormGroup() {
		return new FormGroup<GetOrganizationConfigTemplateSwitchProfilePortsReturnProfileFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			iname: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationConfigTemplateSwitchProfilePortReturn {

		/** The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber?: number | null;

		/** The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType?: GetDeviceSwitchPortsReturnAccessPolicyType | null;

		/** The VLANs allowed on the switch profile port. Only applicable to trunk ports. */
		allowedVlans?: string | null;

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted?: boolean | null;

		/** The status of the switch profile port. */
		enabled?: boolean | null;

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled?: boolean | null;

		/** The isolation status of the switch profile port. */
		isolationEnabled?: boolean | null;

		/** The link speed for the switch profile port. */
		linkNegotiation?: string | null;

		/** Available link speeds for the switch profile port. */
		linkNegotiationCapabilities?: Array<string>;

		/** Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'. */
		macAllowList?: Array<string>;

		/** The name of the switch profile port. */
		name?: string | null;

		/** The PoE status of the switch profile port. */
		poeEnabled?: boolean | null;

		/** The identifier of the switch profile port. */
		portId?: string | null;

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId?: string | null;

		/** Profile attributes */
		profile?: GetOrganizationConfigTemplateSwitchProfilePortReturnProfile;

		/** The rapid spanning tree protocol status. */
		rstpEnabled?: boolean | null;

		/** The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowList?: Array<string>;

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit?: number | null;

		/** The storm control status of the switch profile port. */
		stormControlEnabled?: boolean | null;

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard?: GetDeviceSwitchPortsReturnStpGuard | null;

		/** The list of tags of the switch profile port. */
		tags?: Array<string>;

		/** The type of the switch profile port ('trunk' or 'access'). */
		type?: GetDeviceSwitchPortsReturnType | null;

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld?: GetDeviceSwitchPortsReturnUdld | null;

		/** The VLAN of the switch profile port. A null value will clear the value set for trunk ports. */
		vlan?: number | null;

		/** The voice VLAN of the switch profile port. Only applicable to access ports. */
		voiceVlan?: number | null;
	}
	export interface GetOrganizationConfigTemplateSwitchProfilePortReturnFormProperties {

		/** The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber: FormControl<number | null | undefined>,

		/** The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType: FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>,

		/** The VLANs allowed on the switch profile port. Only applicable to trunk ports. */
		allowedVlans: FormControl<string | null | undefined>,

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted: FormControl<boolean | null | undefined>,

		/** The status of the switch profile port. */
		enabled: FormControl<boolean | null | undefined>,

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled: FormControl<boolean | null | undefined>,

		/** The isolation status of the switch profile port. */
		isolationEnabled: FormControl<boolean | null | undefined>,

		/** The link speed for the switch profile port. */
		linkNegotiation: FormControl<string | null | undefined>,

		/** The name of the switch profile port. */
		name: FormControl<string | null | undefined>,

		/** The PoE status of the switch profile port. */
		poeEnabled: FormControl<boolean | null | undefined>,

		/** The identifier of the switch profile port. */
		portId: FormControl<string | null | undefined>,

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId: FormControl<string | null | undefined>,

		/** The rapid spanning tree protocol status. */
		rstpEnabled: FormControl<boolean | null | undefined>,

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit: FormControl<number | null | undefined>,

		/** The storm control status of the switch profile port. */
		stormControlEnabled: FormControl<boolean | null | undefined>,

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard: FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>,

		/** The type of the switch profile port ('trunk' or 'access'). */
		type: FormControl<GetDeviceSwitchPortsReturnType | null | undefined>,

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld: FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>,

		/** The VLAN of the switch profile port. A null value will clear the value set for trunk ports. */
		vlan: FormControl<number | null | undefined>,

		/** The voice VLAN of the switch profile port. Only applicable to access ports. */
		voiceVlan: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationConfigTemplateSwitchProfilePortReturnFormGroup() {
		return new FormGroup<GetOrganizationConfigTemplateSwitchProfilePortReturnFormProperties>({
			accessPolicyNumber: new FormControl<number | null | undefined>(undefined),
			accessPolicyType: new FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			daiTrusted: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			flexibleStackingEnabled: new FormControl<boolean | null | undefined>(undefined),
			isolationEnabled: new FormControl<boolean | null | undefined>(undefined),
			linkNegotiation: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			poeEnabled: new FormControl<boolean | null | undefined>(undefined),
			portId: new FormControl<string | null | undefined>(undefined),
			portScheduleId: new FormControl<string | null | undefined>(undefined),
			rstpEnabled: new FormControl<boolean | null | undefined>(undefined),
			stickyMacAllowListLimit: new FormControl<number | null | undefined>(undefined),
			stormControlEnabled: new FormControl<boolean | null | undefined>(undefined),
			stpGuard: new FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>(undefined),
			type: new FormControl<GetDeviceSwitchPortsReturnType | null | undefined>(undefined),
			udld: new FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
			voiceVlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationConfigTemplateSwitchProfilePortReturnProfile {

		/** When enabled, override this port's configuration with a port profile. */
		enabled?: boolean | null;

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id?: string | null;

		/** When enabled, the IName of the profile. */
		iname?: string | null;
	}
	export interface GetOrganizationConfigTemplateSwitchProfilePortReturnProfileFormProperties {

		/** When enabled, override this port's configuration with a port profile. */
		enabled: FormControl<boolean | null | undefined>,

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id: FormControl<string | null | undefined>,

		/** When enabled, the IName of the profile. */
		iname: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationConfigTemplateSwitchProfilePortReturnProfileFormGroup() {
		return new FormGroup<GetOrganizationConfigTemplateSwitchProfilePortReturnProfileFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			iname: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationConfigTemplateSwitchProfilePortPutBody {

		/** The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber?: number | null;

		/** The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType?: GetDeviceSwitchPortsReturnAccessPolicyType | null;

		/** The VLANs allowed on the switch profile port. Only applicable to trunk ports. */
		allowedVlans?: string | null;

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted?: boolean | null;

		/** The status of the switch profile port. */
		enabled?: boolean | null;

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled?: boolean | null;

		/** The isolation status of the switch profile port. */
		isolationEnabled?: boolean | null;

		/** The link speed for the switch profile port. */
		linkNegotiation?: string | null;

		/** Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'. */
		macAllowList?: Array<string>;

		/** The name of the switch profile port. */
		name?: string | null;

		/** The PoE status of the switch profile port. */
		poeEnabled?: boolean | null;

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId?: string | null;

		/** Profile attributes */
		profile?: UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyProfile;

		/** The rapid spanning tree protocol status. */
		rstpEnabled?: boolean | null;

		/** The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowList?: Array<string>;

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit?: number | null;

		/** The storm control status of the switch profile port. */
		stormControlEnabled?: boolean | null;

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard?: GetDeviceSwitchPortsReturnStpGuard | null;

		/** The list of tags of the switch profile port. */
		tags?: Array<string>;

		/** The type of the switch profile port ('trunk' or 'access'). */
		type?: GetDeviceSwitchPortsReturnType | null;

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld?: GetDeviceSwitchPortsReturnUdld | null;

		/** The VLAN of the switch profile port. A null value will clear the value set for trunk ports. */
		vlan?: number | null;

		/** The voice VLAN of the switch profile port. Only applicable to access ports. */
		voiceVlan?: number | null;
	}
	export interface UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyFormProperties {

		/** The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber: FormControl<number | null | undefined>,

		/** The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType: FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>,

		/** The VLANs allowed on the switch profile port. Only applicable to trunk ports. */
		allowedVlans: FormControl<string | null | undefined>,

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted: FormControl<boolean | null | undefined>,

		/** The status of the switch profile port. */
		enabled: FormControl<boolean | null | undefined>,

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled: FormControl<boolean | null | undefined>,

		/** The isolation status of the switch profile port. */
		isolationEnabled: FormControl<boolean | null | undefined>,

		/** The link speed for the switch profile port. */
		linkNegotiation: FormControl<string | null | undefined>,

		/** The name of the switch profile port. */
		name: FormControl<string | null | undefined>,

		/** The PoE status of the switch profile port. */
		poeEnabled: FormControl<boolean | null | undefined>,

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId: FormControl<string | null | undefined>,

		/** The rapid spanning tree protocol status. */
		rstpEnabled: FormControl<boolean | null | undefined>,

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit: FormControl<number | null | undefined>,

		/** The storm control status of the switch profile port. */
		stormControlEnabled: FormControl<boolean | null | undefined>,

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard: FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>,

		/** The type of the switch profile port ('trunk' or 'access'). */
		type: FormControl<GetDeviceSwitchPortsReturnType | null | undefined>,

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld: FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>,

		/** The VLAN of the switch profile port. A null value will clear the value set for trunk ports. */
		vlan: FormControl<number | null | undefined>,

		/** The voice VLAN of the switch profile port. Only applicable to access ports. */
		voiceVlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateOrganizationConfigTemplateSwitchProfilePortPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyFormProperties>({
			accessPolicyNumber: new FormControl<number | null | undefined>(undefined),
			accessPolicyType: new FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			daiTrusted: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			flexibleStackingEnabled: new FormControl<boolean | null | undefined>(undefined),
			isolationEnabled: new FormControl<boolean | null | undefined>(undefined),
			linkNegotiation: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			poeEnabled: new FormControl<boolean | null | undefined>(undefined),
			portScheduleId: new FormControl<string | null | undefined>(undefined),
			rstpEnabled: new FormControl<boolean | null | undefined>(undefined),
			stickyMacAllowListLimit: new FormControl<number | null | undefined>(undefined),
			stormControlEnabled: new FormControl<boolean | null | undefined>(undefined),
			stpGuard: new FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>(undefined),
			type: new FormControl<GetDeviceSwitchPortsReturnType | null | undefined>(undefined),
			udld: new FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
			voiceVlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyProfile {

		/** When enabled, override this port's configuration with a port profile. */
		enabled?: boolean | null;

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id?: string | null;

		/** When enabled, the IName of the profile. */
		iname?: string | null;
	}
	export interface UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyProfileFormProperties {

		/** When enabled, override this port's configuration with a port profile. */
		enabled: FormControl<boolean | null | undefined>,

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id: FormControl<string | null | undefined>,

		/** When enabled, the IName of the profile. */
		iname: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationConfigTemplateSwitchProfilePortPutBodyProfileFormGroup() {
		return new FormGroup<UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyProfileFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			iname: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationConfigTemplateSwitchProfilePortReturn {

		/** The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber?: number | null;

		/** The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType?: GetDeviceSwitchPortsReturnAccessPolicyType | null;

		/** The VLANs allowed on the switch profile port. Only applicable to trunk ports. */
		allowedVlans?: string | null;

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted?: boolean | null;

		/** The status of the switch profile port. */
		enabled?: boolean | null;

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled?: boolean | null;

		/** The isolation status of the switch profile port. */
		isolationEnabled?: boolean | null;

		/** The link speed for the switch profile port. */
		linkNegotiation?: string | null;

		/** Available link speeds for the switch profile port. */
		linkNegotiationCapabilities?: Array<string>;

		/** Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'. */
		macAllowList?: Array<string>;

		/** The name of the switch profile port. */
		name?: string | null;

		/** The PoE status of the switch profile port. */
		poeEnabled?: boolean | null;

		/** The identifier of the switch profile port. */
		portId?: string | null;

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId?: string | null;

		/** Profile attributes */
		profile?: UpdateOrganizationConfigTemplateSwitchProfilePortReturnProfile;

		/** The rapid spanning tree protocol status. */
		rstpEnabled?: boolean | null;

		/** The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowList?: Array<string>;

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit?: number | null;

		/** The storm control status of the switch profile port. */
		stormControlEnabled?: boolean | null;

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard?: GetDeviceSwitchPortsReturnStpGuard | null;

		/** The list of tags of the switch profile port. */
		tags?: Array<string>;

		/** The type of the switch profile port ('trunk' or 'access'). */
		type?: GetDeviceSwitchPortsReturnType | null;

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld?: GetDeviceSwitchPortsReturnUdld | null;

		/** The VLAN of the switch profile port. A null value will clear the value set for trunk ports. */
		vlan?: number | null;

		/** The voice VLAN of the switch profile port. Only applicable to access ports. */
		voiceVlan?: number | null;
	}
	export interface UpdateOrganizationConfigTemplateSwitchProfilePortReturnFormProperties {

		/** The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'. */
		accessPolicyNumber: FormControl<number | null | undefined>,

		/** The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType: FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>,

		/** The VLANs allowed on the switch profile port. Only applicable to trunk ports. */
		allowedVlans: FormControl<string | null | undefined>,

		/** If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic. */
		daiTrusted: FormControl<boolean | null | undefined>,

		/** The status of the switch profile port. */
		enabled: FormControl<boolean | null | undefined>,

		/** For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled. */
		flexibleStackingEnabled: FormControl<boolean | null | undefined>,

		/** The isolation status of the switch profile port. */
		isolationEnabled: FormControl<boolean | null | undefined>,

		/** The link speed for the switch profile port. */
		linkNegotiation: FormControl<string | null | undefined>,

		/** The name of the switch profile port. */
		name: FormControl<string | null | undefined>,

		/** The PoE status of the switch profile port. */
		poeEnabled: FormControl<boolean | null | undefined>,

		/** The identifier of the switch profile port. */
		portId: FormControl<string | null | undefined>,

		/** The ID of the port schedule. A value of null will clear the port schedule. */
		portScheduleId: FormControl<string | null | undefined>,

		/** The rapid spanning tree protocol status. */
		rstpEnabled: FormControl<boolean | null | undefined>,

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit: FormControl<number | null | undefined>,

		/** The storm control status of the switch profile port. */
		stormControlEnabled: FormControl<boolean | null | undefined>,

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard: FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>,

		/** The type of the switch profile port ('trunk' or 'access'). */
		type: FormControl<GetDeviceSwitchPortsReturnType | null | undefined>,

		/** The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only. */
		udld: FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>,

		/** The VLAN of the switch profile port. A null value will clear the value set for trunk ports. */
		vlan: FormControl<number | null | undefined>,

		/** The voice VLAN of the switch profile port. Only applicable to access ports. */
		voiceVlan: FormControl<number | null | undefined>,
	}
	export function CreateUpdateOrganizationConfigTemplateSwitchProfilePortReturnFormGroup() {
		return new FormGroup<UpdateOrganizationConfigTemplateSwitchProfilePortReturnFormProperties>({
			accessPolicyNumber: new FormControl<number | null | undefined>(undefined),
			accessPolicyType: new FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			daiTrusted: new FormControl<boolean | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			flexibleStackingEnabled: new FormControl<boolean | null | undefined>(undefined),
			isolationEnabled: new FormControl<boolean | null | undefined>(undefined),
			linkNegotiation: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			poeEnabled: new FormControl<boolean | null | undefined>(undefined),
			portId: new FormControl<string | null | undefined>(undefined),
			portScheduleId: new FormControl<string | null | undefined>(undefined),
			rstpEnabled: new FormControl<boolean | null | undefined>(undefined),
			stickyMacAllowListLimit: new FormControl<number | null | undefined>(undefined),
			stormControlEnabled: new FormControl<boolean | null | undefined>(undefined),
			stpGuard: new FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>(undefined),
			type: new FormControl<GetDeviceSwitchPortsReturnType | null | undefined>(undefined),
			udld: new FormControl<GetDeviceSwitchPortsReturnUdld | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
			voiceVlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationConfigTemplateSwitchProfilePortReturnProfile {

		/** When enabled, override this port's configuration with a port profile. */
		enabled?: boolean | null;

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id?: string | null;

		/** When enabled, the IName of the profile. */
		iname?: string | null;
	}
	export interface UpdateOrganizationConfigTemplateSwitchProfilePortReturnProfileFormProperties {

		/** When enabled, override this port's configuration with a port profile. */
		enabled: FormControl<boolean | null | undefined>,

		/** When enabled, the ID of the port profile used to override the port's configuration. */
		id: FormControl<string | null | undefined>,

		/** When enabled, the IName of the profile. */
		iname: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationConfigTemplateSwitchProfilePortReturnProfileFormGroup() {
		return new FormGroup<UpdateOrganizationConfigTemplateSwitchProfilePortReturnProfileFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			iname: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationDevicesTagsFilterType { withAllTags = 'withAllTags', withAnyTags = 'withAnyTags' }

	export interface GetOrganizationDevicesReturn {

		/** Physical address of the device */
		address?: string | null;

		/** Firmware version of the device */
		firmware?: string | null;

		/** LAN IP address of the device */
		lanIp?: string | null;

		/** Latitude of the device */
		lat?: number | null;

		/** Longitude of the device */
		lng?: number | null;

		/** MAC address of the device */
		mac?: string | null;

		/** Model of the device */
		model?: string | null;

		/** Name of the device */
		name?: string | null;

		/** ID of the network the device belongs to */
		networkId?: string | null;

		/** Notes for the device, limited to 255 characters */
		notes?: string | null;

		/** Product type of the device */
		productType?: string | null;

		/** Serial number of the device */
		serial?: string | null;

		/** List of tags assigned to the device */
		tags?: Array<string>;
	}
	export interface GetOrganizationDevicesReturnFormProperties {

		/** Physical address of the device */
		address: FormControl<string | null | undefined>,

		/** Firmware version of the device */
		firmware: FormControl<string | null | undefined>,

		/** LAN IP address of the device */
		lanIp: FormControl<string | null | undefined>,

		/** Latitude of the device */
		lat: FormControl<number | null | undefined>,

		/** Longitude of the device */
		lng: FormControl<number | null | undefined>,

		/** MAC address of the device */
		mac: FormControl<string | null | undefined>,

		/** Model of the device */
		model: FormControl<string | null | undefined>,

		/** Name of the device */
		name: FormControl<string | null | undefined>,

		/** ID of the network the device belongs to */
		networkId: FormControl<string | null | undefined>,

		/** Notes for the device, limited to 255 characters */
		notes: FormControl<string | null | undefined>,

		/** Product type of the device */
		productType: FormControl<string | null | undefined>,

		/** Serial number of the device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationDevicesReturnFormGroup() {
		return new FormGroup<GetOrganizationDevicesReturnFormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			firmware: new FormControl<string | null | undefined>(undefined),
			lanIp: new FormControl<string | null | undefined>(undefined),
			lat: new FormControl<number | null | undefined>(undefined),
			lng: new FormControl<number | null | undefined>(undefined),
			mac: new FormControl<string | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationDevicesAvailabilitiesReturn {

		/** The device MAC address. */
		mac?: string | null;

		/** The device name. */
		name?: string | null;

		/** Network info. */
		network?: GetOrganizationDevicesAvailabilitiesReturnNetwork;

		/** Device product type. */
		productType?: GetOrganizationDevicesAvailabilitiesReturnProductType | null;

		/** The device serial number. */
		serial?: string | null;

		/** Status of the device. Possible values are: online, alerting, offline, dormant. */
		status?: GetOrganizationDevicesAvailabilitiesReturnStatus | null;

		/** List of custom tags for the device. */
		tags?: Array<string>;
	}
	export interface GetOrganizationDevicesAvailabilitiesReturnFormProperties {

		/** The device MAC address. */
		mac: FormControl<string | null | undefined>,

		/** The device name. */
		name: FormControl<string | null | undefined>,

		/** Device product type. */
		productType: FormControl<GetOrganizationDevicesAvailabilitiesReturnProductType | null | undefined>,

		/** The device serial number. */
		serial: FormControl<string | null | undefined>,

		/** Status of the device. Possible values are: online, alerting, offline, dormant. */
		status: FormControl<GetOrganizationDevicesAvailabilitiesReturnStatus | null | undefined>,
	}
	export function CreateGetOrganizationDevicesAvailabilitiesReturnFormGroup() {
		return new FormGroup<GetOrganizationDevicesAvailabilitiesReturnFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<GetOrganizationDevicesAvailabilitiesReturnProductType | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<GetOrganizationDevicesAvailabilitiesReturnStatus | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationDevicesAvailabilitiesReturnNetwork {

		/** ID for the network containing the device. */
		id?: string | null;
	}
	export interface GetOrganizationDevicesAvailabilitiesReturnNetworkFormProperties {

		/** ID for the network containing the device. */
		id: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationDevicesAvailabilitiesReturnNetworkFormGroup() {
		return new FormGroup<GetOrganizationDevicesAvailabilitiesReturnNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationDevicesAvailabilitiesReturnProductType { appliance = 'appliance', camera = 'camera', cellularGateway = 'cellularGateway', sensor = 'sensor', switch = 'switch', systemsManager = 'systemsManager', wireless = 'wireless' }

	export enum GetOrganizationDevicesAvailabilitiesReturnStatus { alerting = 'alerting', dormant = 'dormant', offline = 'offline', online = 'online' }

	export interface GetOrganizationDevicesPowerModulesStatusesByDeviceReturn {

		/** The device MAC address. */
		mac?: string | null;

		/** The device name. */
		name?: string | null;

		/** Network info. */
		network?: GetOrganizationDevicesPowerModulesStatusesByDeviceReturnNetwork;

		/** Device product type. */
		productType?: GetOrganizationDevicesAvailabilitiesReturnProductType | null;

		/** The device serial number. */
		serial?: string | null;

		/** Information for the device's AC power supplies. */
		GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlots?: Array<GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlots>;

		/** List of custom tags for the device. */
		tags?: Array<string>;
	}
	export interface GetOrganizationDevicesPowerModulesStatusesByDeviceReturnFormProperties {

		/** The device MAC address. */
		mac: FormControl<string | null | undefined>,

		/** The device name. */
		name: FormControl<string | null | undefined>,

		/** Device product type. */
		productType: FormControl<GetOrganizationDevicesAvailabilitiesReturnProductType | null | undefined>,

		/** The device serial number. */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationDevicesPowerModulesStatusesByDeviceReturnFormGroup() {
		return new FormGroup<GetOrganizationDevicesPowerModulesStatusesByDeviceReturnFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<GetOrganizationDevicesAvailabilitiesReturnProductType | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationDevicesPowerModulesStatusesByDeviceReturnNetwork {

		/** ID for the network that the device is associated with. */
		id?: string | null;
	}
	export interface GetOrganizationDevicesPowerModulesStatusesByDeviceReturnNetworkFormProperties {

		/** ID for the network that the device is associated with. */
		id: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationDevicesPowerModulesStatusesByDeviceReturnNetworkFormGroup() {
		return new FormGroup<GetOrganizationDevicesPowerModulesStatusesByDeviceReturnNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlots {

		/** The power supply unit model. */
		model?: string | null;

		/** Which slot the AC power supply occupies. Possible values are: 0, 1, 2. */
		number?: GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsNumber;

		/** The power supply unit serial number. */
		serial?: string | null;

		/** Status of the power supply unit. Possible values are: connected, not connected, powering. */
		status?: GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsStatus | null;
	}
	export interface GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsFormProperties {

		/** The power supply unit model. */
		model: FormControl<string | null | undefined>,

		/** Which slot the AC power supply occupies. Possible values are: 0, 1, 2. */
		number: FormControl<GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsNumber | null | undefined>,

		/** The power supply unit serial number. */
		serial: FormControl<string | null | undefined>,

		/** Status of the power supply unit. Possible values are: connected, not connected, powering. */
		status: FormControl<GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsStatus | null | undefined>,
	}
	export function CreateGetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsFormGroup() {
		return new FormGroup<GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsFormProperties>({
			model: new FormControl<string | null | undefined>(undefined),
			number: new FormControl<GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsNumber | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsStatus | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsNumber { _0 = 0, _1 = 1, _2 = 2 }

	export enum GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsStatus { connected = 'connected', 'not connected' = 'not connected', powering = 'powering' }

	export interface GetOrganizationDevicesStatusesReturn {

		/** Components */
		components?: GetOrganizationDevicesStatusesReturnComponents;

		/** IP Gateway */
		gateway?: string | null;

		/** IP Type */
		ipType?: string | null;

		/** LAN IP Address */
		lanIp?: string | null;

		/** Device Last Reported Location */
		lastReportedAt?: string | null;

		/** MAC Address */
		mac?: string | null;

		/** Model */
		model?: string | null;

		/** Device Name */
		name?: string | null;

		/** Network ID */
		networkId?: string | null;

		/** Primary DNS */
		primaryDns?: string | null;

		/** Product Type */
		productType?: string | null;

		/** Public IP Address */
		publicIp?: string | null;

		/** Secondary DNS */
		secondaryDns?: string | null;

		/** Device Serial Number */
		serial?: string | null;

		/** Device Status */
		status?: string | null;

		/** Tags */
		tags?: Array<string>;
	}
	export interface GetOrganizationDevicesStatusesReturnFormProperties {

		/** IP Gateway */
		gateway: FormControl<string | null | undefined>,

		/** IP Type */
		ipType: FormControl<string | null | undefined>,

		/** LAN IP Address */
		lanIp: FormControl<string | null | undefined>,

		/** Device Last Reported Location */
		lastReportedAt: FormControl<string | null | undefined>,

		/** MAC Address */
		mac: FormControl<string | null | undefined>,

		/** Model */
		model: FormControl<string | null | undefined>,

		/** Device Name */
		name: FormControl<string | null | undefined>,

		/** Network ID */
		networkId: FormControl<string | null | undefined>,

		/** Primary DNS */
		primaryDns: FormControl<string | null | undefined>,

		/** Product Type */
		productType: FormControl<string | null | undefined>,

		/** Public IP Address */
		publicIp: FormControl<string | null | undefined>,

		/** Secondary DNS */
		secondaryDns: FormControl<string | null | undefined>,

		/** Device Serial Number */
		serial: FormControl<string | null | undefined>,

		/** Device Status */
		status: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationDevicesStatusesReturnFormGroup() {
		return new FormGroup<GetOrganizationDevicesStatusesReturnFormProperties>({
			gateway: new FormControl<string | null | undefined>(undefined),
			ipType: new FormControl<string | null | undefined>(undefined),
			lanIp: new FormControl<string | null | undefined>(undefined),
			lastReportedAt: new FormControl<string | null | undefined>(undefined),
			mac: new FormControl<string | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			primaryDns: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<string | null | undefined>(undefined),
			publicIp: new FormControl<string | null | undefined>(undefined),
			secondaryDns: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationDevicesStatusesReturnComponents {

		/** Power Supplies */
		powerSupplies?: Array<string>;
	}
	export interface GetOrganizationDevicesStatusesReturnComponentsFormProperties {
	}
	export function CreateGetOrganizationDevicesStatusesReturnComponentsFormGroup() {
		return new FormGroup<GetOrganizationDevicesStatusesReturnComponentsFormProperties>({
		});

	}

	export interface GetOrganizationDevicesStatusesOverviewReturn {

		/** counts */
		counts?: GetOrganizationDevicesStatusesOverviewReturnCounts;
	}
	export interface GetOrganizationDevicesStatusesOverviewReturnFormProperties {
	}
	export function CreateGetOrganizationDevicesStatusesOverviewReturnFormGroup() {
		return new FormGroup<GetOrganizationDevicesStatusesOverviewReturnFormProperties>({
		});

	}

	export interface GetOrganizationDevicesStatusesOverviewReturnCounts {

		/** byStatus */
		byStatus?: GetOrganizationDevicesStatusesOverviewReturnCountsByStatus;
	}
	export interface GetOrganizationDevicesStatusesOverviewReturnCountsFormProperties {
	}
	export function CreateGetOrganizationDevicesStatusesOverviewReturnCountsFormGroup() {
		return new FormGroup<GetOrganizationDevicesStatusesOverviewReturnCountsFormProperties>({
		});

	}

	export interface GetOrganizationDevicesStatusesOverviewReturnCountsByStatus {

		/** alerting count */
		alerting?: number | null;

		/** dormant count */
		dormant?: number | null;

		/** offline count */
		offline?: number | null;

		/** online count */
		online?: number | null;
	}
	export interface GetOrganizationDevicesStatusesOverviewReturnCountsByStatusFormProperties {

		/** alerting count */
		alerting: FormControl<number | null | undefined>,

		/** dormant count */
		dormant: FormControl<number | null | undefined>,

		/** offline count */
		offline: FormControl<number | null | undefined>,

		/** online count */
		online: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationDevicesStatusesOverviewReturnCountsByStatusFormGroup() {
		return new FormGroup<GetOrganizationDevicesStatusesOverviewReturnCountsByStatusFormProperties>({
			alerting: new FormControl<number | null | undefined>(undefined),
			dormant: new FormControl<number | null | undefined>(undefined),
			offline: new FormControl<number | null | undefined>(undefined),
			online: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationDevicesUplinksAddressesByDeviceReturn {

		/** The device MAC address. */
		mac?: string | null;

		/** The device name. */
		name?: string | null;

		/** Network info. */
		network?: GetOrganizationDevicesUplinksAddressesByDeviceReturnNetwork;

		/** Device product type. */
		productType?: GetOrganizationDevicesAvailabilitiesReturnProductType | null;

		/** The device serial number. */
		serial?: string | null;

		/** List of custom tags for the device. */
		tags?: Array<string>;

		/** List of device uplink addresses information. */
		GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinks?: Array<GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinks>;
	}
	export interface GetOrganizationDevicesUplinksAddressesByDeviceReturnFormProperties {

		/** The device MAC address. */
		mac: FormControl<string | null | undefined>,

		/** The device name. */
		name: FormControl<string | null | undefined>,

		/** Device product type. */
		productType: FormControl<GetOrganizationDevicesAvailabilitiesReturnProductType | null | undefined>,

		/** The device serial number. */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationDevicesUplinksAddressesByDeviceReturnFormGroup() {
		return new FormGroup<GetOrganizationDevicesUplinksAddressesByDeviceReturnFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<GetOrganizationDevicesAvailabilitiesReturnProductType | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationDevicesUplinksAddressesByDeviceReturnNetwork {

		/** ID for the network containing the device. */
		id?: string | null;
	}
	export interface GetOrganizationDevicesUplinksAddressesByDeviceReturnNetworkFormProperties {

		/** ID for the network containing the device. */
		id: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationDevicesUplinksAddressesByDeviceReturnNetworkFormGroup() {
		return new FormGroup<GetOrganizationDevicesUplinksAddressesByDeviceReturnNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinks {

		/** Available addresses for the interface. */
		GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddresses?: Array<GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddresses>;

		/** Interface for the device uplink. Available options are: cellular, man1, man2, wan1, wan2 */
		interface?: GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksInterface | null;
	}
	export interface GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksFormProperties {

		/** Interface for the device uplink. Available options are: cellular, man1, man2, wan1, wan2 */
		interface: FormControl<GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksInterface | null | undefined>,
	}
	export function CreateGetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksFormGroup() {
		return new FormGroup<GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksFormProperties>({
			interface: new FormControl<GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksInterface | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddresses {

		/** Device uplink address. */
		address?: string | null;

		/** Indicates how the device uplink address is assigned. Available options are: static, dynamic. */
		assignmentMode?: GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null;

		/** Device uplink gateway address. */
		gateway?: string | null;

		/** Type of address for the device uplink. Available options are: ipv4, ipv6. */
		protocol?: GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesProtocol | null;

		/** Public interface information. */
		public?: GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesPublic;
	}
	export interface GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesFormProperties {

		/** Device uplink address. */
		address: FormControl<string | null | undefined>,

		/** Indicates how the device uplink address is assigned. Available options are: static, dynamic. */
		assignmentMode: FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>,

		/** Device uplink gateway address. */
		gateway: FormControl<string | null | undefined>,

		/** Type of address for the device uplink. Available options are: ipv4, ipv6. */
		protocol: FormControl<GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesProtocol | null | undefined>,
	}
	export function CreateGetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesFormGroup() {
		return new FormGroup<GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesFormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			assignmentMode: new FormControl<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			protocol: new FormControl<GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesProtocol | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesProtocol { ipv4 = 'ipv4', ipv6 = 'ipv6' }

	export interface GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesPublic {

		/** The device uplink public IP address. */
		address?: string | null;
	}
	export interface GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesPublicFormProperties {

		/** The device uplink public IP address. */
		address: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesPublicFormGroup() {
		return new FormGroup<GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesPublicFormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksInterface { cellular = 'cellular', man1 = 'man1', man2 = 'man2', wan1 = 'wan1', wan2 = 'wan2' }

	export interface GetOrganizationDevicesUplinksLossAndLatencyReturn {

		/** IP address of uplink */
		ip?: string | null;

		/** Network ID */
		networkId?: string | null;

		/** Serial of MX device */
		serial?: string | null;

		/** Loss and latency timeseries data */
		GetOrganizationDevicesUplinksLossAndLatencyReturnTimeSeries?: Array<GetOrganizationDevicesUplinksLossAndLatencyReturnTimeSeries>;

		/** Uplink interface (wan1, wan2, or cellular) */
		uplink?: string | null;
	}
	export interface GetOrganizationDevicesUplinksLossAndLatencyReturnFormProperties {

		/** IP address of uplink */
		ip: FormControl<string | null | undefined>,

		/** Network ID */
		networkId: FormControl<string | null | undefined>,

		/** Serial of MX device */
		serial: FormControl<string | null | undefined>,

		/** Uplink interface (wan1, wan2, or cellular) */
		uplink: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationDevicesUplinksLossAndLatencyReturnFormGroup() {
		return new FormGroup<GetOrganizationDevicesUplinksLossAndLatencyReturnFormProperties>({
			ip: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			uplink: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationDevicesUplinksLossAndLatencyReturnTimeSeries {

		/** Latency in milliseconds */
		latencyMs?: number | null;

		/** Loss percentage */
		lossPercent?: number | null;

		/** Timestamp for this data point */
		ts?: Date | null;
	}
	export interface GetOrganizationDevicesUplinksLossAndLatencyReturnTimeSeriesFormProperties {

		/** Latency in milliseconds */
		latencyMs: FormControl<number | null | undefined>,

		/** Loss percentage */
		lossPercent: FormControl<number | null | undefined>,

		/** Timestamp for this data point */
		ts: FormControl<Date | null | undefined>,
	}
	export function CreateGetOrganizationDevicesUplinksLossAndLatencyReturnTimeSeriesFormGroup() {
		return new FormGroup<GetOrganizationDevicesUplinksLossAndLatencyReturnTimeSeriesFormProperties>({
			latencyMs: new FormControl<number | null | undefined>(undefined),
			lossPercent: new FormControl<number | null | undefined>(undefined),
			ts: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationEarlyAccessFeaturesOptInPostBody {

		/** A list of network IDs to apply the opt-in to */
		limitScopeToNetworks?: Array<string>;

		/**
		 * Short name of the early access feature
		 * Required
		 */
		shortName: string;
	}
	export interface CreateOrganizationEarlyAccessFeaturesOptInPostBodyFormProperties {

		/**
		 * Short name of the early access feature
		 * Required
		 */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationEarlyAccessFeaturesOptInPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationEarlyAccessFeaturesOptInPostBodyFormProperties>({
			shortName: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateOrganizationEarlyAccessFeaturesOptInPutBody {

		/** A list of network IDs to apply the opt-in to */
		limitScopeToNetworks?: Array<string>;
	}
	export interface UpdateOrganizationEarlyAccessFeaturesOptInPutBodyFormProperties {
	}
	export function CreateUpdateOrganizationEarlyAccessFeaturesOptInPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationEarlyAccessFeaturesOptInPutBodyFormProperties>({
		});

	}

	export interface GetOrganizationFirmwareUpgradesReturn {

		/** Timestamp when upgrade completed. Null if status pending. */
		completedAt?: string | null;

		/** ID of the upgrade's starting version */
		fromVersion?: GetOrganizationFirmwareUpgradesReturnFromVersion;

		/** Network of the upgrade */
		network?: GetOrganizationFirmwareUpgradesReturnNetwork;

		/** product upgraded [wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor] */
		productType?: string | null;

		/** Status of upgrade event: [Cancelled, Completed] */
		status?: string | null;

		/** Scheduled start time */
		time?: Date | null;

		/** ID of the upgrade's target version */
		toVersion?: GetOrganizationFirmwareUpgradesReturnToVersion;

		/** The upgrade batch */
		upgradeBatchId?: string | null;

		/** The upgrade */
		upgradeId?: string | null;
	}
	export interface GetOrganizationFirmwareUpgradesReturnFormProperties {

		/** Timestamp when upgrade completed. Null if status pending. */
		completedAt: FormControl<string | null | undefined>,

		/** product upgraded [wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor] */
		productType: FormControl<string | null | undefined>,

		/** Status of upgrade event: [Cancelled, Completed] */
		status: FormControl<string | null | undefined>,

		/** Scheduled start time */
		time: FormControl<Date | null | undefined>,

		/** The upgrade batch */
		upgradeBatchId: FormControl<string | null | undefined>,

		/** The upgrade */
		upgradeId: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationFirmwareUpgradesReturnFormGroup() {
		return new FormGroup<GetOrganizationFirmwareUpgradesReturnFormProperties>({
			completedAt: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<string | null | undefined>(undefined),
			time: new FormControl<Date | null | undefined>(undefined),
			upgradeBatchId: new FormControl<string | null | undefined>(undefined),
			upgradeId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationFirmwareUpgradesReturnFromVersion {

		/** Firmware version ID */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetOrganizationFirmwareUpgradesReturnFromVersionFormProperties {

		/** Firmware version ID */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationFirmwareUpgradesReturnFromVersionFormGroup() {
		return new FormGroup<GetOrganizationFirmwareUpgradesReturnFromVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationFirmwareUpgradesReturnNetwork {

		/** ID of network */
		id?: string | null;

		/** The network */
		name?: string | null;
	}
	export interface GetOrganizationFirmwareUpgradesReturnNetworkFormProperties {

		/** ID of network */
		id: FormControl<string | null | undefined>,

		/** The network */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationFirmwareUpgradesReturnNetworkFormGroup() {
		return new FormGroup<GetOrganizationFirmwareUpgradesReturnNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationFirmwareUpgradesReturnToVersion {

		/** Firmware version ID */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: Date | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetOrganizationFirmwareUpgradesReturnToVersionFormProperties {

		/** Firmware version ID */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<Date | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationFirmwareUpgradesReturnToVersionFormGroup() {
		return new FormGroup<GetOrganizationFirmwareUpgradesReturnToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<Date | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationFirmwareUpgradesByDeviceReturn {

		/** Status of the device upgrade */
		deviceStatus?: string | null;

		/** Name assigned to the device */
		name?: string | null;

		/** Serial of the device */
		serial?: string | null;

		/** The devices upgrade details and status */
		upgrade?: GetOrganizationFirmwareUpgradesByDeviceReturnUpgrade;
	}
	export interface GetOrganizationFirmwareUpgradesByDeviceReturnFormProperties {

		/** Status of the device upgrade */
		deviceStatus: FormControl<string | null | undefined>,

		/** Name assigned to the device */
		name: FormControl<string | null | undefined>,

		/** Serial of the device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationFirmwareUpgradesByDeviceReturnFormGroup() {
		return new FormGroup<GetOrganizationFirmwareUpgradesByDeviceReturnFormProperties>({
			deviceStatus: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationFirmwareUpgradesByDeviceReturnUpgrade {

		/** The initial version of the device */
		fromVersion?: GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeFromVersion;

		/** ID of the upgrade */
		id?: string | null;

		/** Staged upgrade */
		staged?: GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStaged;

		/** Status of the upgrade */
		status?: string | null;

		/** Start time of the upgrade */
		time?: string | null;

		/** Version the device is upgrading to */
		toVersion?: GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeToVersion;

		/** ID of the upgrade batch */
		upgradeBatchId?: string | null;
	}
	export interface GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeFormProperties {

		/** ID of the upgrade */
		id: FormControl<string | null | undefined>,

		/** Status of the upgrade */
		status: FormControl<string | null | undefined>,

		/** Start time of the upgrade */
		time: FormControl<string | null | undefined>,

		/** ID of the upgrade batch */
		upgradeBatchId: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationFirmwareUpgradesByDeviceReturnUpgradeFormGroup() {
		return new FormGroup<GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<string | null | undefined>(undefined),
			time: new FormControl<string | null | undefined>(undefined),
			upgradeBatchId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeFromVersion {

		/** ID of the initial firmware version */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: string | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeFromVersionFormProperties {

		/** ID of the initial firmware version */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<string | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationFirmwareUpgradesByDeviceReturnUpgradeFromVersionFormGroup() {
		return new FormGroup<GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeFromVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<string | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStaged {

		/** The staged upgrade group */
		group?: GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStagedGroup;
	}
	export interface GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStagedFormProperties {
	}
	export function CreateGetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStagedFormGroup() {
		return new FormGroup<GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStagedFormProperties>({
		});

	}

	export interface GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStagedGroup {

		/** Id of the staged upgrade group */
		id?: string | null;
	}
	export interface GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStagedGroupFormProperties {

		/** Id of the staged upgrade group */
		id: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStagedGroupFormGroup() {
		return new FormGroup<GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStagedGroupFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeToVersion {

		/** ID of the initial firmware version */
		id?: string | null;

		/** Release date of the firmware version */
		releaseDate?: string | null;

		/** Release type of the firmware version */
		releaseType?: string | null;

		/** Firmware version short name */
		shortName?: string | null;
	}
	export interface GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeToVersionFormProperties {

		/** ID of the initial firmware version */
		id: FormControl<string | null | undefined>,

		/** Release date of the firmware version */
		releaseDate: FormControl<string | null | undefined>,

		/** Release type of the firmware version */
		releaseType: FormControl<string | null | undefined>,

		/** Firmware version short name */
		shortName: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationFirmwareUpgradesByDeviceReturnUpgradeToVersionFormGroup() {
		return new FormGroup<GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeToVersionFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			releaseDate: new FormControl<string | null | undefined>(undefined),
			releaseType: new FormControl<string | null | undefined>(undefined),
			shortName: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationInsightApplicationsReturn {

		/** Application identifier */
		applicationId?: string | null;

		/** Application name */
		name?: string | null;

		/** Thresholds defined by a user or Meraki models for each application */
		thresholds?: GetOrganizationInsightApplicationsReturnThresholds;
	}
	export interface GetOrganizationInsightApplicationsReturnFormProperties {

		/** Application identifier */
		applicationId: FormControl<string | null | undefined>,

		/** Application name */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationInsightApplicationsReturnFormGroup() {
		return new FormGroup<GetOrganizationInsightApplicationsReturnFormProperties>({
			applicationId: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationInsightApplicationsReturnThresholds {

		/** Threshold for each network */
		GetOrganizationInsightApplicationsReturnThresholdsByNetwork?: Array<GetOrganizationInsightApplicationsReturnThresholdsByNetwork>;

		/** Threshold type (static or smart) */
		type?: string | null;
	}
	export interface GetOrganizationInsightApplicationsReturnThresholdsFormProperties {

		/** Threshold type (static or smart) */
		type: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationInsightApplicationsReturnThresholdsFormGroup() {
		return new FormGroup<GetOrganizationInsightApplicationsReturnThresholdsFormProperties>({
			type: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationInsightApplicationsReturnThresholdsByNetwork {

		/** Number of useful information bits delivered over a network per unit of time */
		goodput?: number | null;

		/** Network identifier */
		networkId?: string | null;

		/** Duration of the response, in milliseconds */
		responseDuration?: number | null;
	}
	export interface GetOrganizationInsightApplicationsReturnThresholdsByNetworkFormProperties {

		/** Number of useful information bits delivered over a network per unit of time */
		goodput: FormControl<number | null | undefined>,

		/** Network identifier */
		networkId: FormControl<string | null | undefined>,

		/** Duration of the response, in milliseconds */
		responseDuration: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationInsightApplicationsReturnThresholdsByNetworkFormGroup() {
		return new FormGroup<GetOrganizationInsightApplicationsReturnThresholdsByNetworkFormProperties>({
			goodput: new FormControl<number | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			responseDuration: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationInsightMonitoredMediaServersReturn {

		/** The IP address (IPv4 only) or hostname of the media server to monitor */
		address?: string | null;

		/** Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead */
		bestEffortMonitoringEnabled?: boolean | null;

		/** Monitored media server id */
		id?: string | null;

		/** The name of the VoIP provider */
		name?: string | null;
	}
	export interface GetOrganizationInsightMonitoredMediaServersReturnFormProperties {

		/** The IP address (IPv4 only) or hostname of the media server to monitor */
		address: FormControl<string | null | undefined>,

		/** Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead */
		bestEffortMonitoringEnabled: FormControl<boolean | null | undefined>,

		/** Monitored media server id */
		id: FormControl<string | null | undefined>,

		/** The name of the VoIP provider */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationInsightMonitoredMediaServersReturnFormGroup() {
		return new FormGroup<GetOrganizationInsightMonitoredMediaServersReturnFormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			bestEffortMonitoringEnabled: new FormControl<boolean | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationInsightMonitoredMediaServerPostBody {

		/**
		 * The IP address (IPv4 only) or hostname of the media server to monitor
		 * Required
		 */
		address: string;

		/** Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead. */
		bestEffortMonitoringEnabled?: boolean | null;

		/**
		 * The name of the VoIP provider
		 * Required
		 */
		name: string;
	}
	export interface CreateOrganizationInsightMonitoredMediaServerPostBodyFormProperties {

		/**
		 * The IP address (IPv4 only) or hostname of the media server to monitor
		 * Required
		 */
		address: FormControl<string | null | undefined>,

		/** Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead. */
		bestEffortMonitoringEnabled: FormControl<boolean | null | undefined>,

		/**
		 * The name of the VoIP provider
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationInsightMonitoredMediaServerPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationInsightMonitoredMediaServerPostBodyFormProperties>({
			address: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			bestEffortMonitoringEnabled: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateOrganizationInsightMonitoredMediaServerPutBody {

		/** The IP address (IPv4 only) or hostname of the media server to monitor */
		address?: string | null;

		/** Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead. */
		bestEffortMonitoringEnabled?: boolean | null;

		/** The name of the VoIP provider */
		name?: string | null;
	}
	export interface UpdateOrganizationInsightMonitoredMediaServerPutBodyFormProperties {

		/** The IP address (IPv4 only) or hostname of the media server to monitor */
		address: FormControl<string | null | undefined>,

		/** Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead. */
		bestEffortMonitoringEnabled: FormControl<boolean | null | undefined>,

		/** The name of the VoIP provider */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationInsightMonitoredMediaServerPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationInsightMonitoredMediaServerPutBodyFormProperties>({
			address: new FormControl<string | null | undefined>(undefined),
			bestEffortMonitoringEnabled: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ClaimIntoOrganizationInventoryPostBody {

		/** The licenses that should be claimed */
		ClaimIntoOrganizationInventoryPostBodyLicenses?: Array<ClaimIntoOrganizationInventoryPostBodyLicenses>;

		/** The numbers of the orders that should be claimed */
		orders?: Array<string>;

		/** The serials of the devices that should be claimed */
		serials?: Array<string>;
	}
	export interface ClaimIntoOrganizationInventoryPostBodyFormProperties {
	}
	export function CreateClaimIntoOrganizationInventoryPostBodyFormGroup() {
		return new FormGroup<ClaimIntoOrganizationInventoryPostBodyFormProperties>({
		});

	}

	export interface ClaimIntoOrganizationInventoryPostBodyLicenses {

		/**
		 * The key of the license
		 * Required
		 */
		key: string;

		/** Co-term licensing only: either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. Does not apply to organizations using per-device licensing model. */
		mode?: ClaimIntoOrganizationPostBodyLicensesMode | null;
	}
	export interface ClaimIntoOrganizationInventoryPostBodyLicensesFormProperties {

		/**
		 * The key of the license
		 * Required
		 */
		key: FormControl<string | null | undefined>,

		/** Co-term licensing only: either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. Does not apply to organizations using per-device licensing model. */
		mode: FormControl<ClaimIntoOrganizationPostBodyLicensesMode | null | undefined>,
	}
	export function CreateClaimIntoOrganizationInventoryPostBodyLicensesFormGroup() {
		return new FormGroup<ClaimIntoOrganizationInventoryPostBodyLicensesFormProperties>({
			key: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			mode: new FormControl<ClaimIntoOrganizationPostBodyLicensesMode | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationInventoryDevicesUsedState { unused = 'unused', used = 'used' }

	export interface GetOrganizationInventoryDevicesReturn {

		/** Claimed time of the device */
		claimedAt?: Date | null;

		/** License expiration date of the device */
		licenseExpirationDate?: Date | null;

		/** MAC address of the device */
		mac?: string | null;

		/** Model type of the device */
		model?: string | null;

		/** Name of the device */
		name?: string | null;

		/** Network Id of the device */
		networkId?: string | null;

		/** Order number of the device */
		orderNumber?: string | null;

		/** Product type of the device */
		productType?: string | null;

		/** Serial number of the device */
		serial?: string | null;

		/** Device tags */
		tags?: Array<string>;
	}
	export interface GetOrganizationInventoryDevicesReturnFormProperties {

		/** Claimed time of the device */
		claimedAt: FormControl<Date | null | undefined>,

		/** License expiration date of the device */
		licenseExpirationDate: FormControl<Date | null | undefined>,

		/** MAC address of the device */
		mac: FormControl<string | null | undefined>,

		/** Model type of the device */
		model: FormControl<string | null | undefined>,

		/** Name of the device */
		name: FormControl<string | null | undefined>,

		/** Network Id of the device */
		networkId: FormControl<string | null | undefined>,

		/** Order number of the device */
		orderNumber: FormControl<string | null | undefined>,

		/** Product type of the device */
		productType: FormControl<string | null | undefined>,

		/** Serial number of the device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationInventoryDevicesReturnFormGroup() {
		return new FormGroup<GetOrganizationInventoryDevicesReturnFormProperties>({
			claimedAt: new FormControl<Date | null | undefined>(undefined),
			licenseExpirationDate: new FormControl<Date | null | undefined>(undefined),
			mac: new FormControl<string | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			orderNumber: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationInventoryDeviceReturn {

		/** Claimed time of the device */
		claimedAt?: Date | null;

		/** License expiration date of the device */
		licenseExpirationDate?: Date | null;

		/** MAC address of the device */
		mac?: string | null;

		/** Model type of the device */
		model?: string | null;

		/** Name of the device */
		name?: string | null;

		/** Network Id of the device */
		networkId?: string | null;

		/** Order number of the device */
		orderNumber?: string | null;

		/** Product type of the device */
		productType?: string | null;

		/** Serial number of the device */
		serial?: string | null;

		/** Device tags */
		tags?: Array<string>;
	}
	export interface GetOrganizationInventoryDeviceReturnFormProperties {

		/** Claimed time of the device */
		claimedAt: FormControl<Date | null | undefined>,

		/** License expiration date of the device */
		licenseExpirationDate: FormControl<Date | null | undefined>,

		/** MAC address of the device */
		mac: FormControl<string | null | undefined>,

		/** Model type of the device */
		model: FormControl<string | null | undefined>,

		/** Name of the device */
		name: FormControl<string | null | undefined>,

		/** Network Id of the device */
		networkId: FormControl<string | null | undefined>,

		/** Order number of the device */
		orderNumber: FormControl<string | null | undefined>,

		/** Product type of the device */
		productType: FormControl<string | null | undefined>,

		/** Serial number of the device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationInventoryDeviceReturnFormGroup() {
		return new FormGroup<GetOrganizationInventoryDeviceReturnFormProperties>({
			claimedAt: new FormControl<Date | null | undefined>(undefined),
			licenseExpirationDate: new FormControl<Date | null | undefined>(undefined),
			mac: new FormControl<string | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			orderNumber: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringExportEventPostBody {

		/**
		 * The type of log event this is recording, e.g. download or opening a banner
		 * Required
		 */
		logEvent: string;

		/** Used to describe if this event was the result of a redirect. E.g. a query param if an info banner is being used */
		request?: string | null;

		/** The name of the onboarding distro being downloaded */
		targetOS?: string | null;

		/**
		 * A JavaScript UTC datetime stamp for when the even occurred
		 * Required
		 */
		timestamp: number;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringExportEventPostBodyFormProperties {

		/**
		 * The type of log event this is recording, e.g. download or opening a banner
		 * Required
		 */
		logEvent: FormControl<string | null | undefined>,

		/** Used to describe if this event was the result of a redirect. E.g. a query param if an info banner is being used */
		request: FormControl<string | null | undefined>,

		/** The name of the onboarding distro being downloaded */
		targetOS: FormControl<string | null | undefined>,

		/**
		 * A JavaScript UTC datetime stamp for when the even occurred
		 * Required
		 */
		timestamp: FormControl<number | null | undefined>,
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringExportEventPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringExportEventPostBodyFormProperties>({
			logEvent: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			request: new FormControl<string | null | undefined>(undefined),
			targetOS: new FormControl<string | null | undefined>(undefined),
			timestamp: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetOrganizationInventoryOnboardingCloudMonitoringImportsReturn {

		/** Represents the details of an imported device. */
		device?: GetOrganizationInventoryOnboardingCloudMonitoringImportsReturnDevice;

		/** Database ID for the new entity entry. */
		importId?: string | null;
	}
	export interface GetOrganizationInventoryOnboardingCloudMonitoringImportsReturnFormProperties {

		/** Database ID for the new entity entry. */
		importId: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationInventoryOnboardingCloudMonitoringImportsReturnFormGroup() {
		return new FormGroup<GetOrganizationInventoryOnboardingCloudMonitoringImportsReturnFormProperties>({
			importId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationInventoryOnboardingCloudMonitoringImportsReturnDevice {

		/** Whether or not the device was successfully created in dashboard. */
		created?: boolean | null;

		/** Represents the current state of importing the device. */
		status?: string | null;

		/** The url to the device details page within dashboard. */
		url?: string | null;
	}
	export interface GetOrganizationInventoryOnboardingCloudMonitoringImportsReturnDeviceFormProperties {

		/** Whether or not the device was successfully created in dashboard. */
		created: FormControl<boolean | null | undefined>,

		/** Represents the current state of importing the device. */
		status: FormControl<string | null | undefined>,

		/** The url to the device details page within dashboard. */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationInventoryOnboardingCloudMonitoringImportsReturnDeviceFormGroup() {
		return new FormGroup<GetOrganizationInventoryOnboardingCloudMonitoringImportsReturnDeviceFormProperties>({
			created: new FormControl<boolean | null | undefined>(undefined),
			status: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBody {

		/**
		 * A set of device imports to commit
		 * Required
		 */
		CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBodyDevices: Array<CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBodyDevices>;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBodyFormProperties {
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringImportPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBodyFormProperties>({
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBodyDevices {

		/**
		 * Import ID from the Import operation
		 * Required
		 */
		deviceId: string;

		/**
		 * Network Id
		 * Required
		 */
		networkId: string;

		/**
		 * Device UDI certificate
		 * Required
		 */
		udi: string;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBodyDevicesFormProperties {

		/**
		 * Import ID from the Import operation
		 * Required
		 */
		deviceId: FormControl<string | null | undefined>,

		/**
		 * Network Id
		 * Required
		 */
		networkId: FormControl<string | null | undefined>,

		/**
		 * Device UDI certificate
		 * Required
		 */
		udi: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringImportPostBodyDevicesFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBodyDevicesFormProperties>({
			deviceId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			networkId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			udi: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum GetOrganizationInventoryOnboardingCloudMonitoringNetworksDeviceType { switch = 'switch', wireless_controller = 'wireless_controller' }

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBody {

		/**
		 * A set of devices to import (or update)
		 * Required
		 */
		CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevices: Array<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevices>;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyFormProperties {
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyFormProperties>({
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevices {

		/**
		 * Device SUDI certificate
		 * Required
		 */
		sudi: string;

		/** TLS Related Parameters */
		tunnel?: CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesTunnel;

		/** User parameters */
		user?: CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesUser;

		/** VTY Related Parameters */
		vty?: CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVty;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesFormProperties {

		/**
		 * Device SUDI certificate
		 * Required
		 */
		sudi: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesFormProperties>({
			sudi: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesTunnel {

		/** Name of the configured TLS certificate */
		certificateName?: string | null;

		/** Number of the vlan expected to be used to connect to the cloud */
		localInterface?: number | null;

		/** Number of the configured Loopback Interface used for TLS overlay */
		loopbackNumber?: number | null;

		/** Name of the configured TLS tunnel */
		name?: string | null;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesTunnelFormProperties {

		/** Name of the configured TLS certificate */
		certificateName: FormControl<string | null | undefined>,

		/** Number of the vlan expected to be used to connect to the cloud */
		localInterface: FormControl<number | null | undefined>,

		/** Number of the configured Loopback Interface used for TLS overlay */
		loopbackNumber: FormControl<number | null | undefined>,

		/** Name of the configured TLS tunnel */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesTunnelFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesTunnelFormProperties>({
			certificateName: new FormControl<string | null | undefined>(undefined),
			localInterface: new FormControl<number | null | undefined>(undefined),
			loopbackNumber: new FormControl<number | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesUser {

		/** The name of the device user for Meraki monitoring */
		username?: string | null;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesUserFormProperties {

		/** The name of the device user for Meraki monitoring */
		username: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesUserFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesUserFormProperties>({
			username: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVty {

		/** AccessList details */
		accessList?: CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessList;

		/** VTY AAA authentication */
		authentication?: CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthentication;

		/** VTY AAA authorization */
		authorization?: CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorization;

		/** Ending line VTY number */
		endLineNumber?: number | null;

		/** SSH rotary number */
		rotaryNumber?: number | null;

		/** Starting line VTY number */
		startLineNumber?: number | null;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyFormProperties {

		/** Ending line VTY number */
		endLineNumber: FormControl<number | null | undefined>,

		/** SSH rotary number */
		rotaryNumber: FormControl<number | null | undefined>,

		/** Starting line VTY number */
		startLineNumber: FormControl<number | null | undefined>,
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyFormProperties>({
			endLineNumber: new FormControl<number | null | undefined>(undefined),
			rotaryNumber: new FormControl<number | null | undefined>(undefined),
			startLineNumber: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessList {

		/** VTY in ACL */
		vtyIn?: CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyIn;

		/** VTY out ACL */
		vtyOut?: CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyOut;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListFormProperties {
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListFormProperties>({
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyIn {

		/** Name */
		name?: string | null;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyInFormProperties {

		/** Name */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyInFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyInFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyOut {

		/** Name */
		name?: string | null;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyOutFormProperties {

		/** Name */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyOutFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyOutFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthentication {

		/** Group Details */
		group?: CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthenticationGroup;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthenticationFormProperties {
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthenticationFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthenticationFormProperties>({
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthenticationGroup {

		/** Group Name */
		name?: string | null;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthenticationGroupFormProperties {

		/** Group Name */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthenticationGroupFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthenticationGroupFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorization {

		/** Group Details */
		group?: CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorizationGroup;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorizationFormProperties {
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorizationFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorizationFormProperties>({
		});

	}

	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorizationGroup {

		/** Group Name */
		name?: string | null;
	}
	export interface CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorizationGroupFormProperties {

		/** Group Name */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorizationGroupFormGroup() {
		return new FormGroup<CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorizationGroupFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface ReleaseFromOrganizationInventoryPostBody {

		/** Serials of the devices that should be released */
		serials?: Array<string>;
	}
	export interface ReleaseFromOrganizationInventoryPostBodyFormProperties {
	}
	export function CreateReleaseFromOrganizationInventoryPostBodyFormGroup() {
		return new FormGroup<ReleaseFromOrganizationInventoryPostBodyFormProperties>({
		});

	}

	export enum GetOrganizationLicensesState { active = 'active', expired = 'expired', expiring = 'expiring', recentlyQueued = 'recentlyQueued', unused = 'unused', unusedActive = 'unusedActive' }

	export interface GetOrganizationLicensesReturn {

		/** The date the license started burning */
		activationDate?: string | null;

		/** The date the license was claimed into the organization */
		claimDate?: string | null;

		/** Serial number of the device the license is assigned to */
		deviceSerial?: string | null;

		/** The duration of the individual license */
		durationInDays?: number | null;

		/** The date the license will expire */
		expirationDate?: string | null;

		/** The id of the head license this license is queued behind. If there is no head license, it returns nil. */
		headLicenseId?: string | null;

		/** License ID */
		id?: string | null;

		/** License key */
		licenseKey?: string | null;

		/** License type */
		licenseType?: string | null;

		/** ID of the network the license is assigned to */
		networkId?: string | null;

		/** Order number */
		orderNumber?: string | null;

		/** DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device. */
		GetOrganizationLicensesReturnPermanentlyQueuedLicenses?: Array<GetOrganizationLicensesReturnPermanentlyQueuedLicenses>;

		/** The number of seats of the license. Only applicable to SM licenses. */
		seatCount?: number | null;

		/** The state of the license. All queued licenses have a status of `recentlyQueued`. */
		state?: GetOrganizationLicensesState | null;

		/** The duration of the license plus all permanently queued licenses associated with it */
		totalDurationInDays?: number | null;
	}
	export interface GetOrganizationLicensesReturnFormProperties {

		/** The date the license started burning */
		activationDate: FormControl<string | null | undefined>,

		/** The date the license was claimed into the organization */
		claimDate: FormControl<string | null | undefined>,

		/** Serial number of the device the license is assigned to */
		deviceSerial: FormControl<string | null | undefined>,

		/** The duration of the individual license */
		durationInDays: FormControl<number | null | undefined>,

		/** The date the license will expire */
		expirationDate: FormControl<string | null | undefined>,

		/** The id of the head license this license is queued behind. If there is no head license, it returns nil. */
		headLicenseId: FormControl<string | null | undefined>,

		/** License ID */
		id: FormControl<string | null | undefined>,

		/** License key */
		licenseKey: FormControl<string | null | undefined>,

		/** License type */
		licenseType: FormControl<string | null | undefined>,

		/** ID of the network the license is assigned to */
		networkId: FormControl<string | null | undefined>,

		/** Order number */
		orderNumber: FormControl<string | null | undefined>,

		/** The number of seats of the license. Only applicable to SM licenses. */
		seatCount: FormControl<number | null | undefined>,

		/** The state of the license. All queued licenses have a status of `recentlyQueued`. */
		state: FormControl<GetOrganizationLicensesState | null | undefined>,

		/** The duration of the license plus all permanently queued licenses associated with it */
		totalDurationInDays: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationLicensesReturnFormGroup() {
		return new FormGroup<GetOrganizationLicensesReturnFormProperties>({
			activationDate: new FormControl<string | null | undefined>(undefined),
			claimDate: new FormControl<string | null | undefined>(undefined),
			deviceSerial: new FormControl<string | null | undefined>(undefined),
			durationInDays: new FormControl<number | null | undefined>(undefined),
			expirationDate: new FormControl<string | null | undefined>(undefined),
			headLicenseId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			licenseKey: new FormControl<string | null | undefined>(undefined),
			licenseType: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			orderNumber: new FormControl<string | null | undefined>(undefined),
			seatCount: new FormControl<number | null | undefined>(undefined),
			state: new FormControl<GetOrganizationLicensesState | null | undefined>(undefined),
			totalDurationInDays: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationLicensesReturnPermanentlyQueuedLicenses {

		/** The duration of the individual license */
		durationInDays?: number | null;

		/** Permanently queued license ID */
		id?: string | null;

		/** License key */
		licenseKey?: string | null;

		/** License type */
		licenseType?: string | null;

		/** Order number */
		orderNumber?: string | null;
	}
	export interface GetOrganizationLicensesReturnPermanentlyQueuedLicensesFormProperties {

		/** The duration of the individual license */
		durationInDays: FormControl<number | null | undefined>,

		/** Permanently queued license ID */
		id: FormControl<string | null | undefined>,

		/** License key */
		licenseKey: FormControl<string | null | undefined>,

		/** License type */
		licenseType: FormControl<string | null | undefined>,

		/** Order number */
		orderNumber: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationLicensesReturnPermanentlyQueuedLicensesFormGroup() {
		return new FormGroup<GetOrganizationLicensesReturnPermanentlyQueuedLicensesFormProperties>({
			durationInDays: new FormControl<number | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			licenseKey: new FormControl<string | null | undefined>(undefined),
			licenseType: new FormControl<string | null | undefined>(undefined),
			orderNumber: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface AssignOrganizationLicensesSeatsPostBody {

		/**
		 * The ID of the SM license to assign seats from
		 * Required
		 */
		licenseId: string;

		/**
		 * The ID of the SM network to assign the seats to
		 * Required
		 */
		networkId: string;

		/**
		 * The number of seats to assign to the SM network. Must be less than or equal to the total number of seats of the license
		 * Required
		 */
		seatCount: number;
	}
	export interface AssignOrganizationLicensesSeatsPostBodyFormProperties {

		/**
		 * The ID of the SM license to assign seats from
		 * Required
		 */
		licenseId: FormControl<string | null | undefined>,

		/**
		 * The ID of the SM network to assign the seats to
		 * Required
		 */
		networkId: FormControl<string | null | undefined>,

		/**
		 * The number of seats to assign to the SM network. Must be less than or equal to the total number of seats of the license
		 * Required
		 */
		seatCount: FormControl<number | null | undefined>,
	}
	export function CreateAssignOrganizationLicensesSeatsPostBodyFormGroup() {
		return new FormGroup<AssignOrganizationLicensesSeatsPostBodyFormProperties>({
			licenseId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			networkId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			seatCount: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface AssignOrganizationLicensesSeatsReturn {

		/** Resulting licenses from the move */
		AssignOrganizationLicensesSeatsReturnResultingLicenses?: Array<AssignOrganizationLicensesSeatsReturnResultingLicenses>;
	}
	export interface AssignOrganizationLicensesSeatsReturnFormProperties {
	}
	export function CreateAssignOrganizationLicensesSeatsReturnFormGroup() {
		return new FormGroup<AssignOrganizationLicensesSeatsReturnFormProperties>({
		});

	}

	export interface AssignOrganizationLicensesSeatsReturnResultingLicenses {

		/** The date the license started burning */
		activationDate?: string | null;

		/** The date the license was claimed into the organization */
		claimDate?: string | null;

		/** Serial number of the device the license is assigned to */
		deviceSerial?: string | null;

		/** The duration of the individual license */
		durationInDays?: number | null;

		/** The date the license will expire */
		expirationDate?: string | null;

		/** The id of the head license this license is queued behind. If there is no head license, it returns nil. */
		headLicenseId?: string | null;

		/** License ID */
		id?: string | null;

		/** License key */
		licenseKey?: string | null;

		/** License type */
		licenseType?: string | null;

		/** ID of the network the license is assigned to */
		networkId?: string | null;

		/** Order number */
		orderNumber?: string | null;

		/** DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device. */
		AssignOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicenses?: Array<AssignOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicenses>;

		/** The number of seats of the license. Only applicable to SM licenses. */
		seatCount?: number | null;

		/** The state of the license. All queued licenses have a status of `recentlyQueued`. */
		state?: GetOrganizationLicensesState | null;

		/** The duration of the license plus all permanently queued licenses associated with it */
		totalDurationInDays?: number | null;
	}
	export interface AssignOrganizationLicensesSeatsReturnResultingLicensesFormProperties {

		/** The date the license started burning */
		activationDate: FormControl<string | null | undefined>,

		/** The date the license was claimed into the organization */
		claimDate: FormControl<string | null | undefined>,

		/** Serial number of the device the license is assigned to */
		deviceSerial: FormControl<string | null | undefined>,

		/** The duration of the individual license */
		durationInDays: FormControl<number | null | undefined>,

		/** The date the license will expire */
		expirationDate: FormControl<string | null | undefined>,

		/** The id of the head license this license is queued behind. If there is no head license, it returns nil. */
		headLicenseId: FormControl<string | null | undefined>,

		/** License ID */
		id: FormControl<string | null | undefined>,

		/** License key */
		licenseKey: FormControl<string | null | undefined>,

		/** License type */
		licenseType: FormControl<string | null | undefined>,

		/** ID of the network the license is assigned to */
		networkId: FormControl<string | null | undefined>,

		/** Order number */
		orderNumber: FormControl<string | null | undefined>,

		/** The number of seats of the license. Only applicable to SM licenses. */
		seatCount: FormControl<number | null | undefined>,

		/** The state of the license. All queued licenses have a status of `recentlyQueued`. */
		state: FormControl<GetOrganizationLicensesState | null | undefined>,

		/** The duration of the license plus all permanently queued licenses associated with it */
		totalDurationInDays: FormControl<number | null | undefined>,
	}
	export function CreateAssignOrganizationLicensesSeatsReturnResultingLicensesFormGroup() {
		return new FormGroup<AssignOrganizationLicensesSeatsReturnResultingLicensesFormProperties>({
			activationDate: new FormControl<string | null | undefined>(undefined),
			claimDate: new FormControl<string | null | undefined>(undefined),
			deviceSerial: new FormControl<string | null | undefined>(undefined),
			durationInDays: new FormControl<number | null | undefined>(undefined),
			expirationDate: new FormControl<string | null | undefined>(undefined),
			headLicenseId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			licenseKey: new FormControl<string | null | undefined>(undefined),
			licenseType: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			orderNumber: new FormControl<string | null | undefined>(undefined),
			seatCount: new FormControl<number | null | undefined>(undefined),
			state: new FormControl<GetOrganizationLicensesState | null | undefined>(undefined),
			totalDurationInDays: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface AssignOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicenses {

		/** The duration of the individual license */
		durationInDays?: number | null;

		/** Permanently queued license ID */
		id?: string | null;

		/** License key */
		licenseKey?: string | null;

		/** License type */
		licenseType?: string | null;

		/** Order number */
		orderNumber?: string | null;
	}
	export interface AssignOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicensesFormProperties {

		/** The duration of the individual license */
		durationInDays: FormControl<number | null | undefined>,

		/** Permanently queued license ID */
		id: FormControl<string | null | undefined>,

		/** License key */
		licenseKey: FormControl<string | null | undefined>,

		/** License type */
		licenseType: FormControl<string | null | undefined>,

		/** Order number */
		orderNumber: FormControl<string | null | undefined>,
	}
	export function CreateAssignOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicensesFormGroup() {
		return new FormGroup<AssignOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicensesFormProperties>({
			durationInDays: new FormControl<number | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			licenseKey: new FormControl<string | null | undefined>(undefined),
			licenseType: new FormControl<string | null | undefined>(undefined),
			orderNumber: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface MoveOrganizationLicensesPostBody {

		/**
		 * The ID of the organization to move the licenses to
		 * Required
		 */
		destOrganizationId: string;

		/**
		 * A list of IDs of licenses to move to the new organization
		 * Required
		 */
		licenseIds: Array<string>;
	}
	export interface MoveOrganizationLicensesPostBodyFormProperties {

		/**
		 * The ID of the organization to move the licenses to
		 * Required
		 */
		destOrganizationId: FormControl<string | null | undefined>,
	}
	export function CreateMoveOrganizationLicensesPostBodyFormGroup() {
		return new FormGroup<MoveOrganizationLicensesPostBodyFormProperties>({
			destOrganizationId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface MoveOrganizationLicensesReturn {

		/** The ID of the organization to move the licenses to */
		destOrganizationId?: string | null;

		/** A list of IDs of licenses to move to the new organization */
		licenseIds?: Array<string>;
	}
	export interface MoveOrganizationLicensesReturnFormProperties {

		/** The ID of the organization to move the licenses to */
		destOrganizationId: FormControl<string | null | undefined>,
	}
	export function CreateMoveOrganizationLicensesReturnFormGroup() {
		return new FormGroup<MoveOrganizationLicensesReturnFormProperties>({
			destOrganizationId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface MoveOrganizationLicensesSeatsPostBody {

		/**
		 * The ID of the organization to move the SM seats to
		 * Required
		 */
		destOrganizationId: string;

		/**
		 * The ID of the SM license to move the seats from
		 * Required
		 */
		licenseId: string;

		/**
		 * The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
		 * Required
		 */
		seatCount: number;
	}
	export interface MoveOrganizationLicensesSeatsPostBodyFormProperties {

		/**
		 * The ID of the organization to move the SM seats to
		 * Required
		 */
		destOrganizationId: FormControl<string | null | undefined>,

		/**
		 * The ID of the SM license to move the seats from
		 * Required
		 */
		licenseId: FormControl<string | null | undefined>,

		/**
		 * The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
		 * Required
		 */
		seatCount: FormControl<number | null | undefined>,
	}
	export function CreateMoveOrganizationLicensesSeatsPostBodyFormGroup() {
		return new FormGroup<MoveOrganizationLicensesSeatsPostBodyFormProperties>({
			destOrganizationId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			licenseId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			seatCount: new FormControl<number | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface MoveOrganizationLicensesSeatsReturn {

		/** The ID of the organization to move the SM seats to */
		destOrganizationId?: string | null;

		/** The ID of the SM license to move the seats from */
		licenseId?: string | null;

		/** The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license */
		seatCount?: number | null;
	}
	export interface MoveOrganizationLicensesSeatsReturnFormProperties {

		/** The ID of the organization to move the SM seats to */
		destOrganizationId: FormControl<string | null | undefined>,

		/** The ID of the SM license to move the seats from */
		licenseId: FormControl<string | null | undefined>,

		/** The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license */
		seatCount: FormControl<number | null | undefined>,
	}
	export function CreateMoveOrganizationLicensesSeatsReturnFormGroup() {
		return new FormGroup<MoveOrganizationLicensesSeatsReturnFormProperties>({
			destOrganizationId: new FormControl<string | null | undefined>(undefined),
			licenseId: new FormControl<string | null | undefined>(undefined),
			seatCount: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface RenewOrganizationLicensesSeatsPostBody {

		/**
		 * The ID of the SM license to renew. This license must already be assigned to an SM network
		 * Required
		 */
		licenseIdToRenew: string;

		/**
		 * The SM license to use to renew the seats on 'licenseIdToRenew'. This license must have at least as many seats available as there are seats on 'licenseIdToRenew'
		 * Required
		 */
		unusedLicenseId: string;
	}
	export interface RenewOrganizationLicensesSeatsPostBodyFormProperties {

		/**
		 * The ID of the SM license to renew. This license must already be assigned to an SM network
		 * Required
		 */
		licenseIdToRenew: FormControl<string | null | undefined>,

		/**
		 * The SM license to use to renew the seats on 'licenseIdToRenew'. This license must have at least as many seats available as there are seats on 'licenseIdToRenew'
		 * Required
		 */
		unusedLicenseId: FormControl<string | null | undefined>,
	}
	export function CreateRenewOrganizationLicensesSeatsPostBodyFormGroup() {
		return new FormGroup<RenewOrganizationLicensesSeatsPostBodyFormProperties>({
			licenseIdToRenew: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			unusedLicenseId: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface RenewOrganizationLicensesSeatsReturn {

		/** Resulting licenses from the move */
		RenewOrganizationLicensesSeatsReturnResultingLicenses?: Array<RenewOrganizationLicensesSeatsReturnResultingLicenses>;
	}
	export interface RenewOrganizationLicensesSeatsReturnFormProperties {
	}
	export function CreateRenewOrganizationLicensesSeatsReturnFormGroup() {
		return new FormGroup<RenewOrganizationLicensesSeatsReturnFormProperties>({
		});

	}

	export interface RenewOrganizationLicensesSeatsReturnResultingLicenses {

		/** The date the license started burning */
		activationDate?: string | null;

		/** The date the license was claimed into the organization */
		claimDate?: string | null;

		/** Serial number of the device the license is assigned to */
		deviceSerial?: string | null;

		/** The duration of the individual license */
		durationInDays?: number | null;

		/** The date the license will expire */
		expirationDate?: string | null;

		/** The id of the head license this license is queued behind. If there is no head license, it returns nil. */
		headLicenseId?: string | null;

		/** License ID */
		id?: string | null;

		/** License key */
		licenseKey?: string | null;

		/** License type */
		licenseType?: string | null;

		/** ID of the network the license is assigned to */
		networkId?: string | null;

		/** Order number */
		orderNumber?: string | null;

		/** DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device. */
		RenewOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicenses?: Array<RenewOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicenses>;

		/** The number of seats of the license. Only applicable to SM licenses. */
		seatCount?: number | null;

		/** The state of the license. All queued licenses have a status of `recentlyQueued`. */
		state?: GetOrganizationLicensesState | null;

		/** The duration of the license plus all permanently queued licenses associated with it */
		totalDurationInDays?: number | null;
	}
	export interface RenewOrganizationLicensesSeatsReturnResultingLicensesFormProperties {

		/** The date the license started burning */
		activationDate: FormControl<string | null | undefined>,

		/** The date the license was claimed into the organization */
		claimDate: FormControl<string | null | undefined>,

		/** Serial number of the device the license is assigned to */
		deviceSerial: FormControl<string | null | undefined>,

		/** The duration of the individual license */
		durationInDays: FormControl<number | null | undefined>,

		/** The date the license will expire */
		expirationDate: FormControl<string | null | undefined>,

		/** The id of the head license this license is queued behind. If there is no head license, it returns nil. */
		headLicenseId: FormControl<string | null | undefined>,

		/** License ID */
		id: FormControl<string | null | undefined>,

		/** License key */
		licenseKey: FormControl<string | null | undefined>,

		/** License type */
		licenseType: FormControl<string | null | undefined>,

		/** ID of the network the license is assigned to */
		networkId: FormControl<string | null | undefined>,

		/** Order number */
		orderNumber: FormControl<string | null | undefined>,

		/** The number of seats of the license. Only applicable to SM licenses. */
		seatCount: FormControl<number | null | undefined>,

		/** The state of the license. All queued licenses have a status of `recentlyQueued`. */
		state: FormControl<GetOrganizationLicensesState | null | undefined>,

		/** The duration of the license plus all permanently queued licenses associated with it */
		totalDurationInDays: FormControl<number | null | undefined>,
	}
	export function CreateRenewOrganizationLicensesSeatsReturnResultingLicensesFormGroup() {
		return new FormGroup<RenewOrganizationLicensesSeatsReturnResultingLicensesFormProperties>({
			activationDate: new FormControl<string | null | undefined>(undefined),
			claimDate: new FormControl<string | null | undefined>(undefined),
			deviceSerial: new FormControl<string | null | undefined>(undefined),
			durationInDays: new FormControl<number | null | undefined>(undefined),
			expirationDate: new FormControl<string | null | undefined>(undefined),
			headLicenseId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			licenseKey: new FormControl<string | null | undefined>(undefined),
			licenseType: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			orderNumber: new FormControl<string | null | undefined>(undefined),
			seatCount: new FormControl<number | null | undefined>(undefined),
			state: new FormControl<GetOrganizationLicensesState | null | undefined>(undefined),
			totalDurationInDays: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface RenewOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicenses {

		/** The duration of the individual license */
		durationInDays?: number | null;

		/** Permanently queued license ID */
		id?: string | null;

		/** License key */
		licenseKey?: string | null;

		/** License type */
		licenseType?: string | null;

		/** Order number */
		orderNumber?: string | null;
	}
	export interface RenewOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicensesFormProperties {

		/** The duration of the individual license */
		durationInDays: FormControl<number | null | undefined>,

		/** Permanently queued license ID */
		id: FormControl<string | null | undefined>,

		/** License key */
		licenseKey: FormControl<string | null | undefined>,

		/** License type */
		licenseType: FormControl<string | null | undefined>,

		/** Order number */
		orderNumber: FormControl<string | null | undefined>,
	}
	export function CreateRenewOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicensesFormGroup() {
		return new FormGroup<RenewOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicensesFormProperties>({
			durationInDays: new FormControl<number | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			licenseKey: new FormControl<string | null | undefined>(undefined),
			licenseType: new FormControl<string | null | undefined>(undefined),
			orderNumber: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationLicenseReturn {

		/** The date the license started burning */
		activationDate?: string | null;

		/** The date the license was claimed into the organization */
		claimDate?: string | null;

		/** Serial number of the device the license is assigned to */
		deviceSerial?: string | null;

		/** The duration of the individual license */
		durationInDays?: number | null;

		/** The date the license will expire */
		expirationDate?: string | null;

		/** The id of the head license this license is queued behind. If there is no head license, it returns nil. */
		headLicenseId?: string | null;

		/** License ID */
		id?: string | null;

		/** License key */
		licenseKey?: string | null;

		/** License type */
		licenseType?: string | null;

		/** ID of the network the license is assigned to */
		networkId?: string | null;

		/** Order number */
		orderNumber?: string | null;

		/** DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device. */
		GetOrganizationLicenseReturnPermanentlyQueuedLicenses?: Array<GetOrganizationLicenseReturnPermanentlyQueuedLicenses>;

		/** The number of seats of the license. Only applicable to SM licenses. */
		seatCount?: number | null;

		/** The state of the license. All queued licenses have a status of `recentlyQueued`. */
		state?: GetOrganizationLicensesState | null;

		/** The duration of the license plus all permanently queued licenses associated with it */
		totalDurationInDays?: number | null;
	}
	export interface GetOrganizationLicenseReturnFormProperties {

		/** The date the license started burning */
		activationDate: FormControl<string | null | undefined>,

		/** The date the license was claimed into the organization */
		claimDate: FormControl<string | null | undefined>,

		/** Serial number of the device the license is assigned to */
		deviceSerial: FormControl<string | null | undefined>,

		/** The duration of the individual license */
		durationInDays: FormControl<number | null | undefined>,

		/** The date the license will expire */
		expirationDate: FormControl<string | null | undefined>,

		/** The id of the head license this license is queued behind. If there is no head license, it returns nil. */
		headLicenseId: FormControl<string | null | undefined>,

		/** License ID */
		id: FormControl<string | null | undefined>,

		/** License key */
		licenseKey: FormControl<string | null | undefined>,

		/** License type */
		licenseType: FormControl<string | null | undefined>,

		/** ID of the network the license is assigned to */
		networkId: FormControl<string | null | undefined>,

		/** Order number */
		orderNumber: FormControl<string | null | undefined>,

		/** The number of seats of the license. Only applicable to SM licenses. */
		seatCount: FormControl<number | null | undefined>,

		/** The state of the license. All queued licenses have a status of `recentlyQueued`. */
		state: FormControl<GetOrganizationLicensesState | null | undefined>,

		/** The duration of the license plus all permanently queued licenses associated with it */
		totalDurationInDays: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationLicenseReturnFormGroup() {
		return new FormGroup<GetOrganizationLicenseReturnFormProperties>({
			activationDate: new FormControl<string | null | undefined>(undefined),
			claimDate: new FormControl<string | null | undefined>(undefined),
			deviceSerial: new FormControl<string | null | undefined>(undefined),
			durationInDays: new FormControl<number | null | undefined>(undefined),
			expirationDate: new FormControl<string | null | undefined>(undefined),
			headLicenseId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			licenseKey: new FormControl<string | null | undefined>(undefined),
			licenseType: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			orderNumber: new FormControl<string | null | undefined>(undefined),
			seatCount: new FormControl<number | null | undefined>(undefined),
			state: new FormControl<GetOrganizationLicensesState | null | undefined>(undefined),
			totalDurationInDays: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationLicenseReturnPermanentlyQueuedLicenses {

		/** The duration of the individual license */
		durationInDays?: number | null;

		/** Permanently queued license ID */
		id?: string | null;

		/** License key */
		licenseKey?: string | null;

		/** License type */
		licenseType?: string | null;

		/** Order number */
		orderNumber?: string | null;
	}
	export interface GetOrganizationLicenseReturnPermanentlyQueuedLicensesFormProperties {

		/** The duration of the individual license */
		durationInDays: FormControl<number | null | undefined>,

		/** Permanently queued license ID */
		id: FormControl<string | null | undefined>,

		/** License key */
		licenseKey: FormControl<string | null | undefined>,

		/** License type */
		licenseType: FormControl<string | null | undefined>,

		/** Order number */
		orderNumber: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationLicenseReturnPermanentlyQueuedLicensesFormGroup() {
		return new FormGroup<GetOrganizationLicenseReturnPermanentlyQueuedLicensesFormProperties>({
			durationInDays: new FormControl<number | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			licenseKey: new FormControl<string | null | undefined>(undefined),
			licenseType: new FormControl<string | null | undefined>(undefined),
			orderNumber: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationLicensePutBody {

		/** The serial number of the device to assign this license to. Set this to  null to unassign the license. If a different license is already active on the device, this parameter will control queueing/dequeuing this license. */
		deviceSerial?: string | null;
	}
	export interface UpdateOrganizationLicensePutBodyFormProperties {

		/** The serial number of the device to assign this license to. Set this to  null to unassign the license. If a different license is already active on the device, this parameter will control queueing/dequeuing this license. */
		deviceSerial: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationLicensePutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationLicensePutBodyFormProperties>({
			deviceSerial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationLicenseReturn {

		/** The date the license started burning */
		activationDate?: string | null;

		/** The date the license was claimed into the organization */
		claimDate?: string | null;

		/** Serial number of the device the license is assigned to */
		deviceSerial?: string | null;

		/** The duration of the individual license */
		durationInDays?: number | null;

		/** The date the license will expire */
		expirationDate?: string | null;

		/** The id of the head license this license is queued behind. If there is no head license, it returns nil. */
		headLicenseId?: string | null;

		/** License ID */
		id?: string | null;

		/** License key */
		licenseKey?: string | null;

		/** License type */
		licenseType?: string | null;

		/** ID of the network the license is assigned to */
		networkId?: string | null;

		/** Order number */
		orderNumber?: string | null;

		/** DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device. */
		UpdateOrganizationLicenseReturnPermanentlyQueuedLicenses?: Array<UpdateOrganizationLicenseReturnPermanentlyQueuedLicenses>;

		/** The number of seats of the license. Only applicable to SM licenses. */
		seatCount?: number | null;

		/** The state of the license. All queued licenses have a status of `recentlyQueued`. */
		state?: GetOrganizationLicensesState | null;

		/** The duration of the license plus all permanently queued licenses associated with it */
		totalDurationInDays?: number | null;
	}
	export interface UpdateOrganizationLicenseReturnFormProperties {

		/** The date the license started burning */
		activationDate: FormControl<string | null | undefined>,

		/** The date the license was claimed into the organization */
		claimDate: FormControl<string | null | undefined>,

		/** Serial number of the device the license is assigned to */
		deviceSerial: FormControl<string | null | undefined>,

		/** The duration of the individual license */
		durationInDays: FormControl<number | null | undefined>,

		/** The date the license will expire */
		expirationDate: FormControl<string | null | undefined>,

		/** The id of the head license this license is queued behind. If there is no head license, it returns nil. */
		headLicenseId: FormControl<string | null | undefined>,

		/** License ID */
		id: FormControl<string | null | undefined>,

		/** License key */
		licenseKey: FormControl<string | null | undefined>,

		/** License type */
		licenseType: FormControl<string | null | undefined>,

		/** ID of the network the license is assigned to */
		networkId: FormControl<string | null | undefined>,

		/** Order number */
		orderNumber: FormControl<string | null | undefined>,

		/** The number of seats of the license. Only applicable to SM licenses. */
		seatCount: FormControl<number | null | undefined>,

		/** The state of the license. All queued licenses have a status of `recentlyQueued`. */
		state: FormControl<GetOrganizationLicensesState | null | undefined>,

		/** The duration of the license plus all permanently queued licenses associated with it */
		totalDurationInDays: FormControl<number | null | undefined>,
	}
	export function CreateUpdateOrganizationLicenseReturnFormGroup() {
		return new FormGroup<UpdateOrganizationLicenseReturnFormProperties>({
			activationDate: new FormControl<string | null | undefined>(undefined),
			claimDate: new FormControl<string | null | undefined>(undefined),
			deviceSerial: new FormControl<string | null | undefined>(undefined),
			durationInDays: new FormControl<number | null | undefined>(undefined),
			expirationDate: new FormControl<string | null | undefined>(undefined),
			headLicenseId: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			licenseKey: new FormControl<string | null | undefined>(undefined),
			licenseType: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			orderNumber: new FormControl<string | null | undefined>(undefined),
			seatCount: new FormControl<number | null | undefined>(undefined),
			state: new FormControl<GetOrganizationLicensesState | null | undefined>(undefined),
			totalDurationInDays: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationLicenseReturnPermanentlyQueuedLicenses {

		/** The duration of the individual license */
		durationInDays?: number | null;

		/** Permanently queued license ID */
		id?: string | null;

		/** License key */
		licenseKey?: string | null;

		/** License type */
		licenseType?: string | null;

		/** Order number */
		orderNumber?: string | null;
	}
	export interface UpdateOrganizationLicenseReturnPermanentlyQueuedLicensesFormProperties {

		/** The duration of the individual license */
		durationInDays: FormControl<number | null | undefined>,

		/** Permanently queued license ID */
		id: FormControl<string | null | undefined>,

		/** License key */
		licenseKey: FormControl<string | null | undefined>,

		/** License type */
		licenseType: FormControl<string | null | undefined>,

		/** Order number */
		orderNumber: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationLicenseReturnPermanentlyQueuedLicensesFormGroup() {
		return new FormGroup<UpdateOrganizationLicenseReturnPermanentlyQueuedLicensesFormProperties>({
			durationInDays: new FormControl<number | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			licenseKey: new FormControl<string | null | undefined>(undefined),
			licenseType: new FormControl<string | null | undefined>(undefined),
			orderNumber: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationLicensingCotermLicensesReturn {

		/** When the license was claimed into the organization */
		claimedAt?: Date | null;

		/** The counts of the license by model type */
		GetOrganizationLicensingCotermLicensesReturnCounts?: Array<GetOrganizationLicensingCotermLicensesReturnCounts>;

		/** The duration (term length) of the license, measured in days */
		duration?: number | null;

		/** The editions of the license for each relevant product type */
		GetOrganizationLicensingCotermLicensesReturnEditions?: Array<GetOrganizationLicensingCotermLicensesReturnEditions>;

		/** Flag to indicate if the license is expired */
		expired?: boolean | null;

		/** Flag to indicated that the license is invalidated */
		invalidated?: boolean | null;

		/** When the license was invalidated. Will be null for active licenses */
		invalidatedAt?: Date | null;

		/** The key of the license */
		key?: string | null;

		/** The operation mode of the license when it was claimed */
		mode?: ClaimIntoOrganizationPostBodyLicensesMode | null;

		/** The ID of the organization that the license is claimed in */
		organizationId?: string | null;

		/** When the license's term began (approximately the date when the license was created) */
		startedAt?: Date | null;
	}
	export interface GetOrganizationLicensingCotermLicensesReturnFormProperties {

		/** When the license was claimed into the organization */
		claimedAt: FormControl<Date | null | undefined>,

		/** The duration (term length) of the license, measured in days */
		duration: FormControl<number | null | undefined>,

		/** Flag to indicate if the license is expired */
		expired: FormControl<boolean | null | undefined>,

		/** Flag to indicated that the license is invalidated */
		invalidated: FormControl<boolean | null | undefined>,

		/** When the license was invalidated. Will be null for active licenses */
		invalidatedAt: FormControl<Date | null | undefined>,

		/** The key of the license */
		key: FormControl<string | null | undefined>,

		/** The operation mode of the license when it was claimed */
		mode: FormControl<ClaimIntoOrganizationPostBodyLicensesMode | null | undefined>,

		/** The ID of the organization that the license is claimed in */
		organizationId: FormControl<string | null | undefined>,

		/** When the license's term began (approximately the date when the license was created) */
		startedAt: FormControl<Date | null | undefined>,
	}
	export function CreateGetOrganizationLicensingCotermLicensesReturnFormGroup() {
		return new FormGroup<GetOrganizationLicensingCotermLicensesReturnFormProperties>({
			claimedAt: new FormControl<Date | null | undefined>(undefined),
			duration: new FormControl<number | null | undefined>(undefined),
			expired: new FormControl<boolean | null | undefined>(undefined),
			invalidated: new FormControl<boolean | null | undefined>(undefined),
			invalidatedAt: new FormControl<Date | null | undefined>(undefined),
			key: new FormControl<string | null | undefined>(undefined),
			mode: new FormControl<ClaimIntoOrganizationPostBodyLicensesMode | null | undefined>(undefined),
			organizationId: new FormControl<string | null | undefined>(undefined),
			startedAt: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationLicensingCotermLicensesReturnCounts {

		/** The number of counts the license contains of this model */
		count?: number | null;

		/** The license model type */
		model?: string | null;
	}
	export interface GetOrganizationLicensingCotermLicensesReturnCountsFormProperties {

		/** The number of counts the license contains of this model */
		count: FormControl<number | null | undefined>,

		/** The license model type */
		model: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationLicensingCotermLicensesReturnCountsFormGroup() {
		return new FormGroup<GetOrganizationLicensingCotermLicensesReturnCountsFormProperties>({
			count: new FormControl<number | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationLicensingCotermLicensesReturnEditions {

		/** The name of the license edition */
		edition?: string | null;

		/** The product type of the license edition */
		productType?: string | null;
	}
	export interface GetOrganizationLicensingCotermLicensesReturnEditionsFormProperties {

		/** The name of the license edition */
		edition: FormControl<string | null | undefined>,

		/** The product type of the license edition */
		productType: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationLicensingCotermLicensesReturnEditionsFormGroup() {
		return new FormGroup<GetOrganizationLicensingCotermLicensesReturnEditionsFormProperties>({
			edition: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface MoveOrganizationLicensingCotermLicensesPostBody {

		/**
		 * Destination data for the license move
		 * Required
		 */
		destination: MoveOrganizationLicensingCotermLicensesPostBodyDestination;

		/**
		 * The list of licenses to move
		 * Required
		 */
		MoveOrganizationLicensingCotermLicensesPostBodyLicenses: Array<MoveOrganizationLicensingCotermLicensesPostBodyLicenses>;
	}
	export interface MoveOrganizationLicensingCotermLicensesPostBodyFormProperties {
	}
	export function CreateMoveOrganizationLicensingCotermLicensesPostBodyFormGroup() {
		return new FormGroup<MoveOrganizationLicensingCotermLicensesPostBodyFormProperties>({
		});

	}

	export interface MoveOrganizationLicensingCotermLicensesPostBodyDestination {

		/** The claim mode of the moved license */
		mode?: ClaimIntoOrganizationPostBodyLicensesMode | null;

		/** The organization to move the license to */
		organizationId?: string | null;
	}
	export interface MoveOrganizationLicensingCotermLicensesPostBodyDestinationFormProperties {

		/** The claim mode of the moved license */
		mode: FormControl<ClaimIntoOrganizationPostBodyLicensesMode | null | undefined>,

		/** The organization to move the license to */
		organizationId: FormControl<string | null | undefined>,
	}
	export function CreateMoveOrganizationLicensingCotermLicensesPostBodyDestinationFormGroup() {
		return new FormGroup<MoveOrganizationLicensingCotermLicensesPostBodyDestinationFormProperties>({
			mode: new FormControl<ClaimIntoOrganizationPostBodyLicensesMode | null | undefined>(undefined),
			organizationId: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface MoveOrganizationLicensingCotermLicensesPostBodyLicenses {

		/**
		 * The counts to move from the license by model type
		 * Required
		 */
		MoveOrganizationLicensingCotermLicensesPostBodyLicensesCounts: Array<MoveOrganizationLicensingCotermLicensesPostBodyLicensesCounts>;

		/**
		 * The license key to move counts from
		 * Required
		 */
		key: string;
	}
	export interface MoveOrganizationLicensingCotermLicensesPostBodyLicensesFormProperties {

		/**
		 * The license key to move counts from
		 * Required
		 */
		key: FormControl<string | null | undefined>,
	}
	export function CreateMoveOrganizationLicensingCotermLicensesPostBodyLicensesFormGroup() {
		return new FormGroup<MoveOrganizationLicensingCotermLicensesPostBodyLicensesFormProperties>({
			key: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface MoveOrganizationLicensingCotermLicensesPostBodyLicensesCounts {

		/**
		 * The number of counts to move
		 * Required
		 */
		count: number;

		/**
		 * The license model type to move counts of
		 * Required
		 */
		model: string;
	}
	export interface MoveOrganizationLicensingCotermLicensesPostBodyLicensesCountsFormProperties {

		/**
		 * The number of counts to move
		 * Required
		 */
		count: FormControl<number | null | undefined>,

		/**
		 * The license model type to move counts of
		 * Required
		 */
		model: FormControl<string | null | undefined>,
	}
	export function CreateMoveOrganizationLicensingCotermLicensesPostBodyLicensesCountsFormGroup() {
		return new FormGroup<MoveOrganizationLicensingCotermLicensesPostBodyLicensesCountsFormProperties>({
			count: new FormControl<number | null | undefined>(undefined, [Validators.required]),
			model: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface MoveOrganizationLicensingCotermLicensesReturn {

		/** Newly moved licenses created in the destination organization of the license move operation */
		MoveOrganizationLicensingCotermLicensesReturnMovedLicenses?: Array<MoveOrganizationLicensingCotermLicensesReturnMovedLicenses>;

		/** Remainder licenses created in the source organization as a result of moving a subset of the counts of a license */
		MoveOrganizationLicensingCotermLicensesReturnRemainderLicenses?: Array<MoveOrganizationLicensingCotermLicensesReturnRemainderLicenses>;
	}
	export interface MoveOrganizationLicensingCotermLicensesReturnFormProperties {
	}
	export function CreateMoveOrganizationLicensingCotermLicensesReturnFormGroup() {
		return new FormGroup<MoveOrganizationLicensingCotermLicensesReturnFormProperties>({
		});

	}

	export interface MoveOrganizationLicensingCotermLicensesReturnMovedLicenses {

		/** When the license was claimed into the organization */
		claimedAt?: Date | null;

		/** The counts of the license by model type */
		MoveOrganizationLicensingCotermLicensesReturnMovedLicensesCounts?: Array<MoveOrganizationLicensingCotermLicensesReturnMovedLicensesCounts>;

		/** The duration (term length) of the license, measured in days */
		duration?: number | null;

		/** The editions of the license for each relevant product type */
		MoveOrganizationLicensingCotermLicensesReturnMovedLicensesEditions?: Array<MoveOrganizationLicensingCotermLicensesReturnMovedLicensesEditions>;

		/** Flag to indicate if the license is expired */
		expired?: boolean | null;

		/** Flag to indicated that the license is invalidated */
		invalidated?: boolean | null;

		/** When the license was invalidated. Will be null for active licenses */
		invalidatedAt?: Date | null;

		/** The key of the license */
		key?: string | null;

		/** The operation mode of the license when it was claimed */
		mode?: ClaimIntoOrganizationPostBodyLicensesMode | null;

		/** The ID of the organization that the license is claimed in */
		organizationId?: string | null;

		/** When the license's term began (approximately the date when the license was created) */
		startedAt?: Date | null;
	}
	export interface MoveOrganizationLicensingCotermLicensesReturnMovedLicensesFormProperties {

		/** When the license was claimed into the organization */
		claimedAt: FormControl<Date | null | undefined>,

		/** The duration (term length) of the license, measured in days */
		duration: FormControl<number | null | undefined>,

		/** Flag to indicate if the license is expired */
		expired: FormControl<boolean | null | undefined>,

		/** Flag to indicated that the license is invalidated */
		invalidated: FormControl<boolean | null | undefined>,

		/** When the license was invalidated. Will be null for active licenses */
		invalidatedAt: FormControl<Date | null | undefined>,

		/** The key of the license */
		key: FormControl<string | null | undefined>,

		/** The operation mode of the license when it was claimed */
		mode: FormControl<ClaimIntoOrganizationPostBodyLicensesMode | null | undefined>,

		/** The ID of the organization that the license is claimed in */
		organizationId: FormControl<string | null | undefined>,

		/** When the license's term began (approximately the date when the license was created) */
		startedAt: FormControl<Date | null | undefined>,
	}
	export function CreateMoveOrganizationLicensingCotermLicensesReturnMovedLicensesFormGroup() {
		return new FormGroup<MoveOrganizationLicensingCotermLicensesReturnMovedLicensesFormProperties>({
			claimedAt: new FormControl<Date | null | undefined>(undefined),
			duration: new FormControl<number | null | undefined>(undefined),
			expired: new FormControl<boolean | null | undefined>(undefined),
			invalidated: new FormControl<boolean | null | undefined>(undefined),
			invalidatedAt: new FormControl<Date | null | undefined>(undefined),
			key: new FormControl<string | null | undefined>(undefined),
			mode: new FormControl<ClaimIntoOrganizationPostBodyLicensesMode | null | undefined>(undefined),
			organizationId: new FormControl<string | null | undefined>(undefined),
			startedAt: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface MoveOrganizationLicensingCotermLicensesReturnMovedLicensesCounts {

		/** The number of counts the license contains of this model */
		count?: number | null;

		/** The license model type */
		model?: string | null;
	}
	export interface MoveOrganizationLicensingCotermLicensesReturnMovedLicensesCountsFormProperties {

		/** The number of counts the license contains of this model */
		count: FormControl<number | null | undefined>,

		/** The license model type */
		model: FormControl<string | null | undefined>,
	}
	export function CreateMoveOrganizationLicensingCotermLicensesReturnMovedLicensesCountsFormGroup() {
		return new FormGroup<MoveOrganizationLicensingCotermLicensesReturnMovedLicensesCountsFormProperties>({
			count: new FormControl<number | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface MoveOrganizationLicensingCotermLicensesReturnMovedLicensesEditions {

		/** The name of the license edition */
		edition?: string | null;

		/** The product type of the license edition */
		productType?: string | null;
	}
	export interface MoveOrganizationLicensingCotermLicensesReturnMovedLicensesEditionsFormProperties {

		/** The name of the license edition */
		edition: FormControl<string | null | undefined>,

		/** The product type of the license edition */
		productType: FormControl<string | null | undefined>,
	}
	export function CreateMoveOrganizationLicensingCotermLicensesReturnMovedLicensesEditionsFormGroup() {
		return new FormGroup<MoveOrganizationLicensingCotermLicensesReturnMovedLicensesEditionsFormProperties>({
			edition: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface MoveOrganizationLicensingCotermLicensesReturnRemainderLicenses {

		/** When the license was claimed into the organization */
		claimedAt?: Date | null;

		/** The counts of the license by model type */
		MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesCounts?: Array<MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesCounts>;

		/** The duration (term length) of the license, measured in days */
		duration?: number | null;

		/** The editions of the license for each relevant product type */
		MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesEditions?: Array<MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesEditions>;

		/** Flag to indicate if the license is expired */
		expired?: boolean | null;

		/** Flag to indicated that the license is invalidated */
		invalidated?: boolean | null;

		/** When the license was invalidated. Will be null for active licenses */
		invalidatedAt?: Date | null;

		/** The key of the license */
		key?: string | null;

		/** The operation mode of the license when it was claimed */
		mode?: ClaimIntoOrganizationPostBodyLicensesMode | null;

		/** The ID of the organization that the license is claimed in */
		organizationId?: string | null;

		/** When the license's term began (approximately the date when the license was created) */
		startedAt?: Date | null;
	}
	export interface MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesFormProperties {

		/** When the license was claimed into the organization */
		claimedAt: FormControl<Date | null | undefined>,

		/** The duration (term length) of the license, measured in days */
		duration: FormControl<number | null | undefined>,

		/** Flag to indicate if the license is expired */
		expired: FormControl<boolean | null | undefined>,

		/** Flag to indicated that the license is invalidated */
		invalidated: FormControl<boolean | null | undefined>,

		/** When the license was invalidated. Will be null for active licenses */
		invalidatedAt: FormControl<Date | null | undefined>,

		/** The key of the license */
		key: FormControl<string | null | undefined>,

		/** The operation mode of the license when it was claimed */
		mode: FormControl<ClaimIntoOrganizationPostBodyLicensesMode | null | undefined>,

		/** The ID of the organization that the license is claimed in */
		organizationId: FormControl<string | null | undefined>,

		/** When the license's term began (approximately the date when the license was created) */
		startedAt: FormControl<Date | null | undefined>,
	}
	export function CreateMoveOrganizationLicensingCotermLicensesReturnRemainderLicensesFormGroup() {
		return new FormGroup<MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesFormProperties>({
			claimedAt: new FormControl<Date | null | undefined>(undefined),
			duration: new FormControl<number | null | undefined>(undefined),
			expired: new FormControl<boolean | null | undefined>(undefined),
			invalidated: new FormControl<boolean | null | undefined>(undefined),
			invalidatedAt: new FormControl<Date | null | undefined>(undefined),
			key: new FormControl<string | null | undefined>(undefined),
			mode: new FormControl<ClaimIntoOrganizationPostBodyLicensesMode | null | undefined>(undefined),
			organizationId: new FormControl<string | null | undefined>(undefined),
			startedAt: new FormControl<Date | null | undefined>(undefined),
		});

	}

	export interface MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesCounts {

		/** The number of counts the license contains of this model */
		count?: number | null;

		/** The license model type */
		model?: string | null;
	}
	export interface MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesCountsFormProperties {

		/** The number of counts the license contains of this model */
		count: FormControl<number | null | undefined>,

		/** The license model type */
		model: FormControl<string | null | undefined>,
	}
	export function CreateMoveOrganizationLicensingCotermLicensesReturnRemainderLicensesCountsFormGroup() {
		return new FormGroup<MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesCountsFormProperties>({
			count: new FormControl<number | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesEditions {

		/** The name of the license edition */
		edition?: string | null;

		/** The product type of the license edition */
		productType?: string | null;
	}
	export interface MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesEditionsFormProperties {

		/** The name of the license edition */
		edition: FormControl<string | null | undefined>,

		/** The product type of the license edition */
		productType: FormControl<string | null | undefined>,
	}
	export function CreateMoveOrganizationLicensingCotermLicensesReturnRemainderLicensesEditionsFormGroup() {
		return new FormGroup<MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesEditionsFormProperties>({
			edition: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationLoginSecurityReturn {

		/** Number of consecutive failed login attempts after which users' accounts will be locked. */
		accountLockoutAttempts?: number | null;

		/** Details for indicating whether organization will restrict access to API (but not Dashboard) to certain IP addresses. */
		apiAuthentication?: GetOrganizationLoginSecurityReturnApiAuthentication;

		/** Boolean indicating whether users' Dashboard accounts will be locked out after a specified number of consecutive failed login attempts. */
		enforceAccountLockout?: boolean | null;

		/** Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords. */
		enforceDifferentPasswords?: boolean | null;

		/** Boolean indicating whether users will be logged out after being idle for the specified number of minutes. */
		enforceIdleTimeout?: boolean | null;

		/** Boolean indicating whether organization will restrict access to Dashboard (including the API) from certain IP addresses. */
		enforceLoginIpRanges?: boolean | null;

		/** Boolean indicating whether users are forced to change their password every X number of days. */
		enforcePasswordExpiration?: boolean | null;

		/** Boolean indicating whether users will be forced to choose strong passwords for their accounts. Strong passwords are at least 8 characters that contain 3 of the following: number, uppercase letter, lowercase letter, and symbol */
		enforceStrongPasswords?: boolean | null;

		/** Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to Dashboard. This code will be sent to their mobile phone via SMS, or can be generated by the authenticator application. */
		enforceTwoFactorAuth?: boolean | null;

		/** Number of minutes users can remain idle before being logged out of their accounts. */
		idleTimeoutMinutes?: number | null;

		/** List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets. */
		loginIpRanges?: Array<string>;

		/** Number of recent passwords that new password must be distinct from. */
		numDifferentPasswords?: number | null;

		/** Number of days after which users will be forced to change their password. */
		passwordExpirationDays?: number | null;
	}
	export interface GetOrganizationLoginSecurityReturnFormProperties {

		/** Number of consecutive failed login attempts after which users' accounts will be locked. */
		accountLockoutAttempts: FormControl<number | null | undefined>,

		/** Boolean indicating whether users' Dashboard accounts will be locked out after a specified number of consecutive failed login attempts. */
		enforceAccountLockout: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords. */
		enforceDifferentPasswords: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users will be logged out after being idle for the specified number of minutes. */
		enforceIdleTimeout: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether organization will restrict access to Dashboard (including the API) from certain IP addresses. */
		enforceLoginIpRanges: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users are forced to change their password every X number of days. */
		enforcePasswordExpiration: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users will be forced to choose strong passwords for their accounts. Strong passwords are at least 8 characters that contain 3 of the following: number, uppercase letter, lowercase letter, and symbol */
		enforceStrongPasswords: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to Dashboard. This code will be sent to their mobile phone via SMS, or can be generated by the authenticator application. */
		enforceTwoFactorAuth: FormControl<boolean | null | undefined>,

		/** Number of minutes users can remain idle before being logged out of their accounts. */
		idleTimeoutMinutes: FormControl<number | null | undefined>,

		/** Number of recent passwords that new password must be distinct from. */
		numDifferentPasswords: FormControl<number | null | undefined>,

		/** Number of days after which users will be forced to change their password. */
		passwordExpirationDays: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationLoginSecurityReturnFormGroup() {
		return new FormGroup<GetOrganizationLoginSecurityReturnFormProperties>({
			accountLockoutAttempts: new FormControl<number | null | undefined>(undefined),
			enforceAccountLockout: new FormControl<boolean | null | undefined>(undefined),
			enforceDifferentPasswords: new FormControl<boolean | null | undefined>(undefined),
			enforceIdleTimeout: new FormControl<boolean | null | undefined>(undefined),
			enforceLoginIpRanges: new FormControl<boolean | null | undefined>(undefined),
			enforcePasswordExpiration: new FormControl<boolean | null | undefined>(undefined),
			enforceStrongPasswords: new FormControl<boolean | null | undefined>(undefined),
			enforceTwoFactorAuth: new FormControl<boolean | null | undefined>(undefined),
			idleTimeoutMinutes: new FormControl<number | null | undefined>(undefined),
			numDifferentPasswords: new FormControl<number | null | undefined>(undefined),
			passwordExpirationDays: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationLoginSecurityReturnApiAuthentication {

		/** Details for API-only IP restrictions. */
		ipRestrictionsForKeys?: GetOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeys;
	}
	export interface GetOrganizationLoginSecurityReturnApiAuthenticationFormProperties {
	}
	export function CreateGetOrganizationLoginSecurityReturnApiAuthenticationFormGroup() {
		return new FormGroup<GetOrganizationLoginSecurityReturnApiAuthenticationFormProperties>({
		});

	}

	export interface GetOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeys {

		/** Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges. */
		enabled?: boolean | null;

		/** List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets. */
		ranges?: Array<string>;
	}
	export interface GetOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeysFormProperties {

		/** Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeysFormGroup() {
		return new FormGroup<GetOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeysFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationLoginSecurityPutBody {

		/** Number of consecutive failed login attempts after which users' accounts will be locked. */
		accountLockoutAttempts?: number | null;

		/** Details for indicating whether organization will restrict access to API (but not Dashboard) to certain IP addresses. */
		apiAuthentication?: UpdateOrganizationLoginSecurityPutBodyApiAuthentication;

		/** Boolean indicating whether users' Dashboard accounts will be locked out after a specified number of consecutive failed login attempts. */
		enforceAccountLockout?: boolean | null;

		/** Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords. */
		enforceDifferentPasswords?: boolean | null;

		/** Boolean indicating whether users will be logged out after being idle for the specified number of minutes. */
		enforceIdleTimeout?: boolean | null;

		/** Boolean indicating whether organization will restrict access to Dashboard (including the API) from certain IP addresses. */
		enforceLoginIpRanges?: boolean | null;

		/** Boolean indicating whether users are forced to change their password every X number of days. */
		enforcePasswordExpiration?: boolean | null;

		/** Boolean indicating whether users will be forced to choose strong passwords for their accounts. Strong passwords are at least 8 characters that contain 3 of the following: number, uppercase letter, lowercase letter, and symbol */
		enforceStrongPasswords?: boolean | null;

		/** Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to Dashboard. This code will be sent to their mobile phone via SMS, or can be generated by the authenticator application. */
		enforceTwoFactorAuth?: boolean | null;

		/** Number of minutes users can remain idle before being logged out of their accounts. */
		idleTimeoutMinutes?: number | null;

		/** List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets. */
		loginIpRanges?: Array<string>;

		/** Number of recent passwords that new password must be distinct from. */
		numDifferentPasswords?: number | null;

		/** Number of days after which users will be forced to change their password. */
		passwordExpirationDays?: number | null;
	}
	export interface UpdateOrganizationLoginSecurityPutBodyFormProperties {

		/** Number of consecutive failed login attempts after which users' accounts will be locked. */
		accountLockoutAttempts: FormControl<number | null | undefined>,

		/** Boolean indicating whether users' Dashboard accounts will be locked out after a specified number of consecutive failed login attempts. */
		enforceAccountLockout: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords. */
		enforceDifferentPasswords: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users will be logged out after being idle for the specified number of minutes. */
		enforceIdleTimeout: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether organization will restrict access to Dashboard (including the API) from certain IP addresses. */
		enforceLoginIpRanges: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users are forced to change their password every X number of days. */
		enforcePasswordExpiration: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users will be forced to choose strong passwords for their accounts. Strong passwords are at least 8 characters that contain 3 of the following: number, uppercase letter, lowercase letter, and symbol */
		enforceStrongPasswords: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to Dashboard. This code will be sent to their mobile phone via SMS, or can be generated by the authenticator application. */
		enforceTwoFactorAuth: FormControl<boolean | null | undefined>,

		/** Number of minutes users can remain idle before being logged out of their accounts. */
		idleTimeoutMinutes: FormControl<number | null | undefined>,

		/** Number of recent passwords that new password must be distinct from. */
		numDifferentPasswords: FormControl<number | null | undefined>,

		/** Number of days after which users will be forced to change their password. */
		passwordExpirationDays: FormControl<number | null | undefined>,
	}
	export function CreateUpdateOrganizationLoginSecurityPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationLoginSecurityPutBodyFormProperties>({
			accountLockoutAttempts: new FormControl<number | null | undefined>(undefined),
			enforceAccountLockout: new FormControl<boolean | null | undefined>(undefined),
			enforceDifferentPasswords: new FormControl<boolean | null | undefined>(undefined),
			enforceIdleTimeout: new FormControl<boolean | null | undefined>(undefined),
			enforceLoginIpRanges: new FormControl<boolean | null | undefined>(undefined),
			enforcePasswordExpiration: new FormControl<boolean | null | undefined>(undefined),
			enforceStrongPasswords: new FormControl<boolean | null | undefined>(undefined),
			enforceTwoFactorAuth: new FormControl<boolean | null | undefined>(undefined),
			idleTimeoutMinutes: new FormControl<number | null | undefined>(undefined),
			numDifferentPasswords: new FormControl<number | null | undefined>(undefined),
			passwordExpirationDays: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationLoginSecurityPutBodyApiAuthentication {

		/** Details for API-only IP restrictions. */
		ipRestrictionsForKeys?: UpdateOrganizationLoginSecurityPutBodyApiAuthenticationIpRestrictionsForKeys;
	}
	export interface UpdateOrganizationLoginSecurityPutBodyApiAuthenticationFormProperties {
	}
	export function CreateUpdateOrganizationLoginSecurityPutBodyApiAuthenticationFormGroup() {
		return new FormGroup<UpdateOrganizationLoginSecurityPutBodyApiAuthenticationFormProperties>({
		});

	}

	export interface UpdateOrganizationLoginSecurityPutBodyApiAuthenticationIpRestrictionsForKeys {

		/** Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges. */
		enabled?: boolean | null;

		/** List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets. */
		ranges?: Array<string>;
	}
	export interface UpdateOrganizationLoginSecurityPutBodyApiAuthenticationIpRestrictionsForKeysFormProperties {

		/** Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateOrganizationLoginSecurityPutBodyApiAuthenticationIpRestrictionsForKeysFormGroup() {
		return new FormGroup<UpdateOrganizationLoginSecurityPutBodyApiAuthenticationIpRestrictionsForKeysFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationLoginSecurityReturn {

		/** Number of consecutive failed login attempts after which users' accounts will be locked. */
		accountLockoutAttempts?: number | null;

		/** Details for indicating whether organization will restrict access to API (but not Dashboard) to certain IP addresses. */
		apiAuthentication?: UpdateOrganizationLoginSecurityReturnApiAuthentication;

		/** Boolean indicating whether users' Dashboard accounts will be locked out after a specified number of consecutive failed login attempts. */
		enforceAccountLockout?: boolean | null;

		/** Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords. */
		enforceDifferentPasswords?: boolean | null;

		/** Boolean indicating whether users will be logged out after being idle for the specified number of minutes. */
		enforceIdleTimeout?: boolean | null;

		/** Boolean indicating whether organization will restrict access to Dashboard (including the API) from certain IP addresses. */
		enforceLoginIpRanges?: boolean | null;

		/** Boolean indicating whether users are forced to change their password every X number of days. */
		enforcePasswordExpiration?: boolean | null;

		/** Boolean indicating whether users will be forced to choose strong passwords for their accounts. Strong passwords are at least 8 characters that contain 3 of the following: number, uppercase letter, lowercase letter, and symbol */
		enforceStrongPasswords?: boolean | null;

		/** Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to Dashboard. This code will be sent to their mobile phone via SMS, or can be generated by the authenticator application. */
		enforceTwoFactorAuth?: boolean | null;

		/** Number of minutes users can remain idle before being logged out of their accounts. */
		idleTimeoutMinutes?: number | null;

		/** List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets. */
		loginIpRanges?: Array<string>;

		/** Number of recent passwords that new password must be distinct from. */
		numDifferentPasswords?: number | null;

		/** Number of days after which users will be forced to change their password. */
		passwordExpirationDays?: number | null;
	}
	export interface UpdateOrganizationLoginSecurityReturnFormProperties {

		/** Number of consecutive failed login attempts after which users' accounts will be locked. */
		accountLockoutAttempts: FormControl<number | null | undefined>,

		/** Boolean indicating whether users' Dashboard accounts will be locked out after a specified number of consecutive failed login attempts. */
		enforceAccountLockout: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords. */
		enforceDifferentPasswords: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users will be logged out after being idle for the specified number of minutes. */
		enforceIdleTimeout: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether organization will restrict access to Dashboard (including the API) from certain IP addresses. */
		enforceLoginIpRanges: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users are forced to change their password every X number of days. */
		enforcePasswordExpiration: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users will be forced to choose strong passwords for their accounts. Strong passwords are at least 8 characters that contain 3 of the following: number, uppercase letter, lowercase letter, and symbol */
		enforceStrongPasswords: FormControl<boolean | null | undefined>,

		/** Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to Dashboard. This code will be sent to their mobile phone via SMS, or can be generated by the authenticator application. */
		enforceTwoFactorAuth: FormControl<boolean | null | undefined>,

		/** Number of minutes users can remain idle before being logged out of their accounts. */
		idleTimeoutMinutes: FormControl<number | null | undefined>,

		/** Number of recent passwords that new password must be distinct from. */
		numDifferentPasswords: FormControl<number | null | undefined>,

		/** Number of days after which users will be forced to change their password. */
		passwordExpirationDays: FormControl<number | null | undefined>,
	}
	export function CreateUpdateOrganizationLoginSecurityReturnFormGroup() {
		return new FormGroup<UpdateOrganizationLoginSecurityReturnFormProperties>({
			accountLockoutAttempts: new FormControl<number | null | undefined>(undefined),
			enforceAccountLockout: new FormControl<boolean | null | undefined>(undefined),
			enforceDifferentPasswords: new FormControl<boolean | null | undefined>(undefined),
			enforceIdleTimeout: new FormControl<boolean | null | undefined>(undefined),
			enforceLoginIpRanges: new FormControl<boolean | null | undefined>(undefined),
			enforcePasswordExpiration: new FormControl<boolean | null | undefined>(undefined),
			enforceStrongPasswords: new FormControl<boolean | null | undefined>(undefined),
			enforceTwoFactorAuth: new FormControl<boolean | null | undefined>(undefined),
			idleTimeoutMinutes: new FormControl<number | null | undefined>(undefined),
			numDifferentPasswords: new FormControl<number | null | undefined>(undefined),
			passwordExpirationDays: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationLoginSecurityReturnApiAuthentication {

		/** Details for API-only IP restrictions. */
		ipRestrictionsForKeys?: UpdateOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeys;
	}
	export interface UpdateOrganizationLoginSecurityReturnApiAuthenticationFormProperties {
	}
	export function CreateUpdateOrganizationLoginSecurityReturnApiAuthenticationFormGroup() {
		return new FormGroup<UpdateOrganizationLoginSecurityReturnApiAuthenticationFormProperties>({
		});

	}

	export interface UpdateOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeys {

		/** Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges. */
		enabled?: boolean | null;

		/** List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets. */
		ranges?: Array<string>;
	}
	export interface UpdateOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeysFormProperties {

		/** Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeysFormGroup() {
		return new FormGroup<UpdateOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeysFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationNetworksReturn {

		/** Enrollment string for the network */
		enrollmentString?: string | null;

		/** Network ID */
		id?: string | null;

		/** If the network is bound to a config template */
		isBoundToConfigTemplate?: boolean | null;

		/** Network name */
		name?: string | null;

		/** Notes for the network */
		notes?: string | null;

		/** Organization ID */
		organizationId?: string | null;

		/** List of the product types that the network supports */
		productTypes?: Array<string>;

		/** Network tags */
		tags?: Array<string>;

		/** Timezone of the network */
		timeZone?: string | null;

		/** URL to the network Dashboard UI */
		url?: string | null;
	}
	export interface GetOrganizationNetworksReturnFormProperties {

		/** Enrollment string for the network */
		enrollmentString: FormControl<string | null | undefined>,

		/** Network ID */
		id: FormControl<string | null | undefined>,

		/** If the network is bound to a config template */
		isBoundToConfigTemplate: FormControl<boolean | null | undefined>,

		/** Network name */
		name: FormControl<string | null | undefined>,

		/** Notes for the network */
		notes: FormControl<string | null | undefined>,

		/** Organization ID */
		organizationId: FormControl<string | null | undefined>,

		/** Timezone of the network */
		timeZone: FormControl<string | null | undefined>,

		/** URL to the network Dashboard UI */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationNetworksReturnFormGroup() {
		return new FormGroup<GetOrganizationNetworksReturnFormProperties>({
			enrollmentString: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isBoundToConfigTemplate: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
			organizationId: new FormControl<string | null | undefined>(undefined),
			timeZone: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationNetworkPostBody {

		/** The ID of the network to copy configuration from. Other provided parameters will override the copied configuration, except type which must match this network's type exactly. */
		copyFromNetworkId?: string | null;

		/**
		 * The name of the new network
		 * Required
		 */
		name: string;

		/** Add any notes or additional information about this network here. */
		notes?: string | null;

		/**
		 * The product type(s) of the new network. If more than one type is included, the network will be a combined network.
		 * Required
		 */
		productTypes: Array<GetOrganizationDevicesAvailabilitiesReturnProductType>;

		/** A list of tags to be applied to the network */
		tags?: Array<string>;

		/** The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a> */
		timeZone?: string | null;
	}
	export interface CreateOrganizationNetworkPostBodyFormProperties {

		/** The ID of the network to copy configuration from. Other provided parameters will override the copied configuration, except type which must match this network's type exactly. */
		copyFromNetworkId: FormControl<string | null | undefined>,

		/**
		 * The name of the new network
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/** Add any notes or additional information about this network here. */
		notes: FormControl<string | null | undefined>,

		/** The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a> */
		timeZone: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationNetworkPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationNetworkPostBodyFormProperties>({
			copyFromNetworkId: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			notes: new FormControl<string | null | undefined>(undefined),
			timeZone: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CombineOrganizationNetworksPostBody {

		/** A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. All networks that are part of this combined network will have their enrollment string appended by '-network_type'. If left empty, all exisitng enrollment strings will be deleted. */
		enrollmentString?: string | null;

		/**
		 * The name of the combined network
		 * Required
		 */
		name: string;

		/**
		 * A list of the network IDs that will be combined. If an ID of a combined network is included in this list, the other networks in the list will be grouped into that network
		 * Required
		 */
		networkIds: Array<string>;
	}
	export interface CombineOrganizationNetworksPostBodyFormProperties {

		/** A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. All networks that are part of this combined network will have their enrollment string appended by '-network_type'. If left empty, all exisitng enrollment strings will be deleted. */
		enrollmentString: FormControl<string | null | undefined>,

		/**
		 * The name of the combined network
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCombineOrganizationNetworksPostBodyFormGroup() {
		return new FormGroup<CombineOrganizationNetworksPostBodyFormProperties>({
			enrollmentString: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CombineOrganizationNetworksReturn {

		/** Network after the combination */
		resultingNetwork?: CombineOrganizationNetworksReturnResultingNetwork;
	}
	export interface CombineOrganizationNetworksReturnFormProperties {
	}
	export function CreateCombineOrganizationNetworksReturnFormGroup() {
		return new FormGroup<CombineOrganizationNetworksReturnFormProperties>({
		});

	}

	export interface CombineOrganizationNetworksReturnResultingNetwork {

		/** Enrollment string for the network */
		enrollmentString?: string | null;

		/** Network ID */
		id?: string | null;

		/** If the network is bound to a config template */
		isBoundToConfigTemplate?: boolean | null;

		/** Network name */
		name?: string | null;

		/** Notes for the network */
		notes?: string | null;

		/** Organization ID */
		organizationId?: string | null;

		/** List of the product types that the network supports */
		productTypes?: Array<string>;

		/** Network tags */
		tags?: Array<string>;

		/** Timezone of the network */
		timeZone?: string | null;

		/** URL to the network Dashboard UI */
		url?: string | null;
	}
	export interface CombineOrganizationNetworksReturnResultingNetworkFormProperties {

		/** Enrollment string for the network */
		enrollmentString: FormControl<string | null | undefined>,

		/** Network ID */
		id: FormControl<string | null | undefined>,

		/** If the network is bound to a config template */
		isBoundToConfigTemplate: FormControl<boolean | null | undefined>,

		/** Network name */
		name: FormControl<string | null | undefined>,

		/** Notes for the network */
		notes: FormControl<string | null | undefined>,

		/** Organization ID */
		organizationId: FormControl<string | null | undefined>,

		/** Timezone of the network */
		timeZone: FormControl<string | null | undefined>,

		/** URL to the network Dashboard UI */
		url: FormControl<string | null | undefined>,
	}
	export function CreateCombineOrganizationNetworksReturnResultingNetworkFormGroup() {
		return new FormGroup<CombineOrganizationNetworksReturnResultingNetworkFormProperties>({
			enrollmentString: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
			isBoundToConfigTemplate: new FormControl<boolean | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			notes: new FormControl<string | null | undefined>(undefined),
			organizationId: new FormControl<string | null | undefined>(undefined),
			timeZone: new FormControl<string | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationPolicyObjectPostBody {

		/**
		 * Category of a policy object (one of: adaptivePolicy, network)
		 * Required
		 */
		category: string;

		/** CIDR Value of a policy object (e.g. 10.11.12.1/24") */
		cidr?: string | null;

		/** Fully qualified domain name of policy object (e.g. "example.com") */
		fqdn?: string | null;

		/** The IDs of policy object groups the policy object belongs to */
		groupIds?: Array<number>;

		/** IP Address of a policy object (e.g. "1.2.3.4") */
		ip?: string | null;

		/** Mask of a policy object (e.g. "255.255.0.0") */
		mask?: string | null;

		/**
		 * Name of a policy object, unique within the organization (alphanumeric, space, dash, or underscore characters only)
		 * Required
		 */
		name: string;

		/**
		 * Type of a policy object (one of: adaptivePolicyIpv4Cidr, cidr, fqdn, ipAndMask)
		 * Required
		 */
		type: string;
	}
	export interface CreateOrganizationPolicyObjectPostBodyFormProperties {

		/**
		 * Category of a policy object (one of: adaptivePolicy, network)
		 * Required
		 */
		category: FormControl<string | null | undefined>,

		/** CIDR Value of a policy object (e.g. 10.11.12.1/24") */
		cidr: FormControl<string | null | undefined>,

		/** Fully qualified domain name of policy object (e.g. "example.com") */
		fqdn: FormControl<string | null | undefined>,

		/** IP Address of a policy object (e.g. "1.2.3.4") */
		ip: FormControl<string | null | undefined>,

		/** Mask of a policy object (e.g. "255.255.0.0") */
		mask: FormControl<string | null | undefined>,

		/**
		 * Name of a policy object, unique within the organization (alphanumeric, space, dash, or underscore characters only)
		 * Required
		 */
		name: FormControl<string | null | undefined>,

		/**
		 * Type of a policy object (one of: adaptivePolicyIpv4Cidr, cidr, fqdn, ipAndMask)
		 * Required
		 */
		type: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationPolicyObjectPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationPolicyObjectPostBodyFormProperties>({
			category: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			cidr: new FormControl<string | null | undefined>(undefined),
			fqdn: new FormControl<string | null | undefined>(undefined),
			ip: new FormControl<string | null | undefined>(undefined),
			mask: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
			type: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateOrganizationPolicyObjectsGroupPostBody {

		/** Category of a policy object group (one of: NetworkObjectGroup, GeoLocationGroup, PortObjectGroup, ApplicationGroup) */
		category?: string | null;

		/**
		 * A name for the group of network addresses, unique within the organization (alphanumeric, space, dash, or underscore characters only)
		 * Required
		 */
		name: string;

		/** A list of Policy Object ID's that this NetworkObjectGroup should be associated to (note: these ID's will replace the existing associated Policy Objects) */
		objectIds?: Array<number>;
	}
	export interface CreateOrganizationPolicyObjectsGroupPostBodyFormProperties {

		/** Category of a policy object group (one of: NetworkObjectGroup, GeoLocationGroup, PortObjectGroup, ApplicationGroup) */
		category: FormControl<string | null | undefined>,

		/**
		 * A name for the group of network addresses, unique within the organization (alphanumeric, space, dash, or underscore characters only)
		 * Required
		 */
		name: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationPolicyObjectsGroupPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationPolicyObjectsGroupPostBodyFormProperties>({
			category: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateOrganizationPolicyObjectsGroupPutBody {

		/** A name for the group of network addresses, unique within the organization (alphanumeric, space, dash, or underscore characters only) */
		name?: string | null;

		/** A list of Policy Object ID's that this NetworkObjectGroup should be associated to (note: these ID's will replace the existing associated Policy Objects) */
		objectIds?: Array<number>;
	}
	export interface UpdateOrganizationPolicyObjectsGroupPutBodyFormProperties {

		/** A name for the group of network addresses, unique within the organization (alphanumeric, space, dash, or underscore characters only) */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationPolicyObjectsGroupPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationPolicyObjectsGroupPutBodyFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationPolicyObjectPutBody {

		/** CIDR Value of a policy object (e.g. 10.11.12.1/24") */
		cidr?: string | null;

		/** Fully qualified domain name of policy object (e.g. "example.com") */
		fqdn?: string | null;

		/** The IDs of policy object groups the policy object belongs to */
		groupIds?: Array<number>;

		/** IP Address of a policy object (e.g. "1.2.3.4") */
		ip?: string | null;

		/** Mask of a policy object (e.g. "255.255.0.0") */
		mask?: string | null;

		/** Name of a policy object, unique within the organization (alphanumeric, space, dash, or underscore characters only) */
		name?: string | null;
	}
	export interface UpdateOrganizationPolicyObjectPutBodyFormProperties {

		/** CIDR Value of a policy object (e.g. 10.11.12.1/24") */
		cidr: FormControl<string | null | undefined>,

		/** Fully qualified domain name of policy object (e.g. "example.com") */
		fqdn: FormControl<string | null | undefined>,

		/** IP Address of a policy object (e.g. "1.2.3.4") */
		ip: FormControl<string | null | undefined>,

		/** Mask of a policy object (e.g. "255.255.0.0") */
		mask: FormControl<string | null | undefined>,

		/** Name of a policy object, unique within the organization (alphanumeric, space, dash, or underscore characters only) */
		name: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationPolicyObjectPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationPolicyObjectPutBodyFormProperties>({
			cidr: new FormControl<string | null | undefined>(undefined),
			fqdn: new FormControl<string | null | undefined>(undefined),
			ip: new FormControl<string | null | undefined>(undefined),
			mask: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSamlReturn {

		/** Toggle depicting if SAML SSO settings are enabled */
		enabled?: boolean | null;
	}
	export interface GetOrganizationSamlReturnFormProperties {

		/** Toggle depicting if SAML SSO settings are enabled */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationSamlReturnFormGroup() {
		return new FormGroup<GetOrganizationSamlReturnFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationSamlPutBody {

		/** Boolean for updating SAML SSO enabled settings. */
		enabled?: boolean | null;
	}
	export interface UpdateOrganizationSamlPutBodyFormProperties {

		/** Boolean for updating SAML SSO enabled settings. */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateOrganizationSamlPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationSamlPutBodyFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationSamlReturn {

		/** Toggle depicting if SAML SSO settings are enabled */
		enabled?: boolean | null;
	}
	export interface UpdateOrganizationSamlReturnFormProperties {

		/** Toggle depicting if SAML SSO settings are enabled */
		enabled: FormControl<boolean | null | undefined>,
	}
	export function CreateUpdateOrganizationSamlReturnFormGroup() {
		return new FormGroup<UpdateOrganizationSamlReturnFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSamlIdpsReturn {

		/** URL that is consuming SAML Identity Provider (IdP) */
		consumerUrl?: string | null;

		/** ID associated with the SAML Identity Provider (IdP) */
		idpId?: string | null;

		/** Dashboard will redirect users to this URL when they sign out. */
		sloLogoutUrl?: string | null;

		/** Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation. */
		x509certSha1Fingerprint?: string | null;
	}
	export interface GetOrganizationSamlIdpsReturnFormProperties {

		/** URL that is consuming SAML Identity Provider (IdP) */
		consumerUrl: FormControl<string | null | undefined>,

		/** ID associated with the SAML Identity Provider (IdP) */
		idpId: FormControl<string | null | undefined>,

		/** Dashboard will redirect users to this URL when they sign out. */
		sloLogoutUrl: FormControl<string | null | undefined>,

		/** Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation. */
		x509certSha1Fingerprint: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSamlIdpsReturnFormGroup() {
		return new FormGroup<GetOrganizationSamlIdpsReturnFormProperties>({
			consumerUrl: new FormControl<string | null | undefined>(undefined),
			idpId: new FormControl<string | null | undefined>(undefined),
			sloLogoutUrl: new FormControl<string | null | undefined>(undefined),
			x509certSha1Fingerprint: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationSamlIdpPostBody {

		/** Dashboard will redirect users to this URL when they sign out. */
		sloLogoutUrl?: string | null;

		/**
		 * Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation.
		 * Required
		 */
		x509certSha1Fingerprint: string;
	}
	export interface CreateOrganizationSamlIdpPostBodyFormProperties {

		/** Dashboard will redirect users to this URL when they sign out. */
		sloLogoutUrl: FormControl<string | null | undefined>,

		/**
		 * Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation.
		 * Required
		 */
		x509certSha1Fingerprint: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationSamlIdpPostBodyFormGroup() {
		return new FormGroup<CreateOrganizationSamlIdpPostBodyFormProperties>({
			sloLogoutUrl: new FormControl<string | null | undefined>(undefined),
			x509certSha1Fingerprint: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetOrganizationSamlIdpReturn {

		/** URL that is consuming SAML Identity Provider (IdP) */
		consumerUrl?: string | null;

		/** ID associated with the SAML Identity Provider (IdP) */
		idpId?: string | null;

		/** Dashboard will redirect users to this URL when they sign out. */
		sloLogoutUrl?: string | null;

		/** Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation. */
		x509certSha1Fingerprint?: string | null;
	}
	export interface GetOrganizationSamlIdpReturnFormProperties {

		/** URL that is consuming SAML Identity Provider (IdP) */
		consumerUrl: FormControl<string | null | undefined>,

		/** ID associated with the SAML Identity Provider (IdP) */
		idpId: FormControl<string | null | undefined>,

		/** Dashboard will redirect users to this URL when they sign out. */
		sloLogoutUrl: FormControl<string | null | undefined>,

		/** Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation. */
		x509certSha1Fingerprint: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSamlIdpReturnFormGroup() {
		return new FormGroup<GetOrganizationSamlIdpReturnFormProperties>({
			consumerUrl: new FormControl<string | null | undefined>(undefined),
			idpId: new FormControl<string | null | undefined>(undefined),
			sloLogoutUrl: new FormControl<string | null | undefined>(undefined),
			x509certSha1Fingerprint: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationSamlIdpPutBody {

		/** Dashboard will redirect users to this URL when they sign out. */
		sloLogoutUrl?: string | null;

		/** Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation. */
		x509certSha1Fingerprint?: string | null;
	}
	export interface UpdateOrganizationSamlIdpPutBodyFormProperties {

		/** Dashboard will redirect users to this URL when they sign out. */
		sloLogoutUrl: FormControl<string | null | undefined>,

		/** Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation. */
		x509certSha1Fingerprint: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationSamlIdpPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationSamlIdpPutBodyFormProperties>({
			sloLogoutUrl: new FormControl<string | null | undefined>(undefined),
			x509certSha1Fingerprint: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationSamlIdpReturn {

		/** URL that is consuming SAML Identity Provider (IdP) */
		consumerUrl?: string | null;

		/** ID associated with the SAML Identity Provider (IdP) */
		idpId?: string | null;

		/** Dashboard will redirect users to this URL when they sign out. */
		sloLogoutUrl?: string | null;

		/** Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation. */
		x509certSha1Fingerprint?: string | null;
	}
	export interface UpdateOrganizationSamlIdpReturnFormProperties {

		/** URL that is consuming SAML Identity Provider (IdP) */
		consumerUrl: FormControl<string | null | undefined>,

		/** ID associated with the SAML Identity Provider (IdP) */
		idpId: FormControl<string | null | undefined>,

		/** Dashboard will redirect users to this URL when they sign out. */
		sloLogoutUrl: FormControl<string | null | undefined>,

		/** Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation. */
		x509certSha1Fingerprint: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationSamlIdpReturnFormGroup() {
		return new FormGroup<UpdateOrganizationSamlIdpReturnFormProperties>({
			consumerUrl: new FormControl<string | null | undefined>(undefined),
			idpId: new FormControl<string | null | undefined>(undefined),
			sloLogoutUrl: new FormControl<string | null | undefined>(undefined),
			x509certSha1Fingerprint: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface CreateOrganizationSamlRolePostBody {

		/** The list of networks that the SAML administrator has privileges on */
		CreateOrganizationSamlRolePostBodyNetworks?: Array<CreateOrganizationSamlRolePostBodyNetworks>;

		/**
		 * The privilege of the SAML administrator on the organization. Can be one of 'none', 'read-only', 'full' or 'enterprise'
		 * Required
		 */
		orgAccess: CreateOrganizationAdminPostBodyOrgAccess;

		/**
		 * The role of the SAML administrator
		 * Required
		 */
		role: string;

		/** The list of tags that the SAML administrator has privleges on */
		CreateOrganizationSamlRolePostBodyTags?: Array<CreateOrganizationSamlRolePostBodyTags>;
	}
	export interface CreateOrganizationSamlRolePostBodyFormProperties {

		/**
		 * The privilege of the SAML administrator on the organization. Can be one of 'none', 'read-only', 'full' or 'enterprise'
		 * Required
		 */
		orgAccess: FormControl<CreateOrganizationAdminPostBodyOrgAccess | null | undefined>,

		/**
		 * The role of the SAML administrator
		 * Required
		 */
		role: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationSamlRolePostBodyFormGroup() {
		return new FormGroup<CreateOrganizationSamlRolePostBodyFormProperties>({
			orgAccess: new FormControl<CreateOrganizationAdminPostBodyOrgAccess | null | undefined>(undefined, [Validators.required]),
			role: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface CreateOrganizationSamlRolePostBodyNetworks {

		/**
		 * The privilege of the SAML administrator on the network. Can be one of 'full', 'read-only', 'guest-ambassador', 'monitor-only' or 'ssid-admin'
		 * Required
		 */
		access: CreateOrganizationSamlRolePostBodyNetworksAccess;

		/**
		 * The network ID
		 * Required
		 */
		id: string;
	}
	export interface CreateOrganizationSamlRolePostBodyNetworksFormProperties {

		/**
		 * The privilege of the SAML administrator on the network. Can be one of 'full', 'read-only', 'guest-ambassador', 'monitor-only' or 'ssid-admin'
		 * Required
		 */
		access: FormControl<CreateOrganizationSamlRolePostBodyNetworksAccess | null | undefined>,

		/**
		 * The network ID
		 * Required
		 */
		id: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationSamlRolePostBodyNetworksFormGroup() {
		return new FormGroup<CreateOrganizationSamlRolePostBodyNetworksFormProperties>({
			access: new FormControl<CreateOrganizationSamlRolePostBodyNetworksAccess | null | undefined>(undefined, [Validators.required]),
			id: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export enum CreateOrganizationSamlRolePostBodyNetworksAccess { full = 'full', 'guest-ambassador' = 'guest-ambassador', 'monitor-only' = 'monitor-only', 'read-only' = 'read-only', 'ssid-admin' = 'ssid-admin' }

	export interface CreateOrganizationSamlRolePostBodyTags {

		/**
		 * The privilege of the SAML administrator on the tag. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		 * Required
		 */
		access: CreateOrganizationAdminPostBodyTagsAccess;

		/**
		 * The name of the tag
		 * Required
		 */
		tag: string;
	}
	export interface CreateOrganizationSamlRolePostBodyTagsFormProperties {

		/**
		 * The privilege of the SAML administrator on the tag. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		 * Required
		 */
		access: FormControl<CreateOrganizationAdminPostBodyTagsAccess | null | undefined>,

		/**
		 * The name of the tag
		 * Required
		 */
		tag: FormControl<string | null | undefined>,
	}
	export function CreateCreateOrganizationSamlRolePostBodyTagsFormGroup() {
		return new FormGroup<CreateOrganizationSamlRolePostBodyTagsFormProperties>({
			access: new FormControl<CreateOrganizationAdminPostBodyTagsAccess | null | undefined>(undefined, [Validators.required]),
			tag: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateOrganizationSamlRolePutBody {

		/** The list of networks that the SAML administrator has privileges on */
		UpdateOrganizationSamlRolePutBodyNetworks?: Array<UpdateOrganizationSamlRolePutBodyNetworks>;

		/** The privilege of the SAML administrator on the organization. Can be one of 'none', 'read-only', 'full' or 'enterprise' */
		orgAccess?: CreateOrganizationAdminPostBodyOrgAccess | null;

		/** The role of the SAML administrator */
		role?: string | null;

		/** The list of tags that the SAML administrator has privleges on */
		UpdateOrganizationSamlRolePutBodyTags?: Array<UpdateOrganizationSamlRolePutBodyTags>;
	}
	export interface UpdateOrganizationSamlRolePutBodyFormProperties {

		/** The privilege of the SAML administrator on the organization. Can be one of 'none', 'read-only', 'full' or 'enterprise' */
		orgAccess: FormControl<CreateOrganizationAdminPostBodyOrgAccess | null | undefined>,

		/** The role of the SAML administrator */
		role: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationSamlRolePutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationSamlRolePutBodyFormProperties>({
			orgAccess: new FormControl<CreateOrganizationAdminPostBodyOrgAccess | null | undefined>(undefined),
			role: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationSamlRolePutBodyNetworks {

		/**
		 * The privilege of the SAML administrator on the network. Can be one of 'full', 'read-only', 'guest-ambassador', 'monitor-only' or 'ssid-admin'
		 * Required
		 */
		access: CreateOrganizationSamlRolePostBodyNetworksAccess;

		/**
		 * The network ID
		 * Required
		 */
		id: string;
	}
	export interface UpdateOrganizationSamlRolePutBodyNetworksFormProperties {

		/**
		 * The privilege of the SAML administrator on the network. Can be one of 'full', 'read-only', 'guest-ambassador', 'monitor-only' or 'ssid-admin'
		 * Required
		 */
		access: FormControl<CreateOrganizationSamlRolePostBodyNetworksAccess | null | undefined>,

		/**
		 * The network ID
		 * Required
		 */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationSamlRolePutBodyNetworksFormGroup() {
		return new FormGroup<UpdateOrganizationSamlRolePutBodyNetworksFormProperties>({
			access: new FormControl<CreateOrganizationSamlRolePostBodyNetworksAccess | null | undefined>(undefined, [Validators.required]),
			id: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateOrganizationSamlRolePutBodyTags {

		/**
		 * The privilege of the SAML administrator on the tag. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		 * Required
		 */
		access: CreateOrganizationAdminPostBodyTagsAccess;

		/**
		 * The name of the tag
		 * Required
		 */
		tag: string;
	}
	export interface UpdateOrganizationSamlRolePutBodyTagsFormProperties {

		/**
		 * The privilege of the SAML administrator on the tag. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		 * Required
		 */
		access: FormControl<CreateOrganizationAdminPostBodyTagsAccess | null | undefined>,

		/**
		 * The name of the tag
		 * Required
		 */
		tag: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationSamlRolePutBodyTagsFormGroup() {
		return new FormGroup<UpdateOrganizationSamlRolePutBodyTagsFormProperties>({
			access: new FormControl<CreateOrganizationAdminPostBodyTagsAccess | null | undefined>(undefined, [Validators.required]),
			tag: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface UpdateOrganizationSamlRoleReturn {

		/** ID associated with the SAML role */
		id?: string | null;

		/** The list of networks that the SAML administrator has privileges on */
		UpdateOrganizationSamlRoleReturnNetworks?: Array<UpdateOrganizationSamlRoleReturnNetworks>;

		/** The privilege of the SAML administrator on the organization */
		orgAccess?: string | null;

		/** The role of the SAML administrator */
		role?: string | null;

		/** The list of tags that the SAML administrator has privleges on */
		UpdateOrganizationSamlRoleReturnTags?: Array<UpdateOrganizationSamlRoleReturnTags>;
	}
	export interface UpdateOrganizationSamlRoleReturnFormProperties {

		/** ID associated with the SAML role */
		id: FormControl<string | null | undefined>,

		/** The privilege of the SAML administrator on the organization */
		orgAccess: FormControl<string | null | undefined>,

		/** The role of the SAML administrator */
		role: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationSamlRoleReturnFormGroup() {
		return new FormGroup<UpdateOrganizationSamlRoleReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			orgAccess: new FormControl<string | null | undefined>(undefined),
			role: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationSamlRoleReturnNetworks {

		/** The privilege of the SAML administrator on the network */
		access?: string | null;

		/** The network ID */
		id?: string | null;
	}
	export interface UpdateOrganizationSamlRoleReturnNetworksFormProperties {

		/** The privilege of the SAML administrator on the network */
		access: FormControl<string | null | undefined>,

		/** The network ID */
		id: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationSamlRoleReturnNetworksFormGroup() {
		return new FormGroup<UpdateOrganizationSamlRoleReturnNetworksFormProperties>({
			access: new FormControl<string | null | undefined>(undefined),
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationSamlRoleReturnTags {

		/** The privilege of the SAML administrator on the tag */
		access?: string | null;

		/** The name of the tag */
		tag?: string | null;
	}
	export interface UpdateOrganizationSamlRoleReturnTagsFormProperties {

		/** The privilege of the SAML administrator on the tag */
		access: FormControl<string | null | undefined>,

		/** The name of the tag */
		tag: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationSamlRoleReturnTagsFormGroup() {
		return new FormGroup<UpdateOrganizationSamlRoleReturnTagsFormProperties>({
			access: new FormControl<string | null | undefined>(undefined),
			tag: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsHistoryReturn {

		/** Reading for the 'battery' metric. This will only be present if the 'metric' property equals 'battery'. */
		battery?: GetOrganizationSensorReadingsHistoryReturnBattery;

		/** Reading for the 'button' metric. This will only be present if the 'metric' property equals 'button'. */
		button?: GetOrganizationSensorReadingsHistoryReturnButton;

		/** Reading for the 'door' metric. This will only be present if the 'metric' property equals 'door'. */
		door?: GetOrganizationSensorReadingsHistoryReturnDoor;

		/** Reading for the 'humidity' metric. This will only be present if the 'metric' property equals 'humidity'. */
		humidity?: GetOrganizationSensorReadingsHistoryReturnHumidity;

		/** Reading for the 'indoorAirQuality' metric. This will only be present if the 'metric' property equals 'indoorAirQuality'. */
		indoorAirQuality?: GetOrganizationSensorReadingsHistoryReturnIndoorAirQuality;

		/** Type of sensor reading. */
		metric?: GetOrganizationSensorReadingsHistoryReturnMetric | null;

		/** Network to which the sensor belongs. */
		network?: GetOrganizationSensorReadingsHistoryReturnNetwork;

		/** Reading for the 'noise' metric. This will only be present if the 'metric' property equals 'noise'. */
		noise?: GetOrganizationSensorReadingsHistoryReturnNoise;

		/** Reading for the 'pm25' metric. This will only be present if the 'metric' property equals 'pm25'. */
		pm25?: GetOrganizationSensorReadingsHistoryReturnPm25;

		/** Serial number of the sensor that took the reading. */
		serial?: string | null;

		/** Reading for the 'temperature' metric. This will only be present if the 'metric' property equals 'temperature'. */
		temperature?: GetOrganizationSensorReadingsHistoryReturnTemperature;

		/** Time at which the reading occurred, in ISO8601 format. */
		ts?: string | null;

		/** Reading for the 'tvoc' metric. This will only be present if the 'metric' property equals 'tvoc'. */
		tvoc?: GetOrganizationSensorReadingsHistoryReturnTvoc;

		/** Reading for the 'water' metric. This will only be present if the 'metric' property equals 'water'. */
		water?: GetOrganizationSensorReadingsHistoryReturnWater;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnFormProperties {

		/** Type of sensor reading. */
		metric: FormControl<GetOrganizationSensorReadingsHistoryReturnMetric | null | undefined>,

		/** Serial number of the sensor that took the reading. */
		serial: FormControl<string | null | undefined>,

		/** Time at which the reading occurred, in ISO8601 format. */
		ts: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnFormProperties>({
			metric: new FormControl<GetOrganizationSensorReadingsHistoryReturnMetric | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
			ts: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsHistoryReturnBattery {

		/** Remaining battery life. */
		percentage?: number | null;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnBatteryFormProperties {

		/** Remaining battery life. */
		percentage: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnBatteryFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnBatteryFormProperties>({
			percentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsHistoryReturnButton {

		/** Type of button press that occurred. */
		pressType?: GetOrganizationSensorReadingsHistoryReturnButtonPressType | null;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnButtonFormProperties {

		/** Type of button press that occurred. */
		pressType: FormControl<GetOrganizationSensorReadingsHistoryReturnButtonPressType | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnButtonFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnButtonFormProperties>({
			pressType: new FormControl<GetOrganizationSensorReadingsHistoryReturnButtonPressType | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationSensorReadingsHistoryReturnButtonPressType { long = 'long', short = 'short' }

	export interface GetOrganizationSensorReadingsHistoryReturnDoor {

		/** True if the door is open. */
		open?: boolean | null;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnDoorFormProperties {

		/** True if the door is open. */
		open: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnDoorFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnDoorFormProperties>({
			open: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsHistoryReturnHumidity {

		/** Humidity reading in %RH. */
		relativePercentage?: number | null;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnHumidityFormProperties {

		/** Humidity reading in %RH. */
		relativePercentage: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnHumidityFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnHumidityFormProperties>({
			relativePercentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsHistoryReturnIndoorAirQuality {

		/** Indoor air quality score between 0 and 100. */
		score?: number | null;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnIndoorAirQualityFormProperties {

		/** Indoor air quality score between 0 and 100. */
		score: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnIndoorAirQualityFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnIndoorAirQualityFormProperties>({
			score: new FormControl<number | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationSensorReadingsHistoryReturnMetric { battery = 'battery', button = 'button', door = 'door', humidity = 'humidity', indoorAirQuality = 'indoorAirQuality', noise = 'noise', pm25 = 'pm25', temperature = 'temperature', tvoc = 'tvoc', water = 'water' }

	export interface GetOrganizationSensorReadingsHistoryReturnNetwork {

		/** ID of the network. */
		id?: string | null;

		/** Name of the network. */
		name?: string | null;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnNetworkFormProperties {

		/** ID of the network. */
		id: FormControl<string | null | undefined>,

		/** Name of the network. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnNetworkFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsHistoryReturnNoise {

		/** Ambient noise reading. */
		ambient?: GetOrganizationSensorReadingsHistoryReturnNoiseAmbient;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnNoiseFormProperties {
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnNoiseFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnNoiseFormProperties>({
		});

	}

	export interface GetOrganizationSensorReadingsHistoryReturnNoiseAmbient {

		/** Ambient noise reading in adjusted decibels. */
		level?: number | null;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnNoiseAmbientFormProperties {

		/** Ambient noise reading in adjusted decibels. */
		level: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnNoiseAmbientFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnNoiseAmbientFormProperties>({
			level: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsHistoryReturnPm25 {

		/** PM2.5 reading in micrograms per cubic meter. */
		concentration?: number | null;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnPm25FormProperties {

		/** PM2.5 reading in micrograms per cubic meter. */
		concentration: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnPm25FormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnPm25FormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsHistoryReturnTemperature {

		/** Temperature reading in degrees Celsius. */
		celsius?: number | null;

		/** Temperature reading in degrees Fahrenheit. */
		fahrenheit?: number | null;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnTemperatureFormProperties {

		/** Temperature reading in degrees Celsius. */
		celsius: FormControl<number | null | undefined>,

		/** Temperature reading in degrees Fahrenheit. */
		fahrenheit: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnTemperatureFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnTemperatureFormProperties>({
			celsius: new FormControl<number | null | undefined>(undefined),
			fahrenheit: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsHistoryReturnTvoc {

		/** TVOC reading in micrograms per cubic meter. */
		concentration?: number | null;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnTvocFormProperties {

		/** TVOC reading in micrograms per cubic meter. */
		concentration: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnTvocFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnTvocFormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsHistoryReturnWater {

		/** True if water is detected. */
		present?: boolean | null;
	}
	export interface GetOrganizationSensorReadingsHistoryReturnWaterFormProperties {

		/** True if water is detected. */
		present: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsHistoryReturnWaterFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsHistoryReturnWaterFormProperties>({
			present: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturn {

		/** Network to which the sensor belongs. */
		network?: GetOrganizationSensorReadingsLatestReturnNetwork;

		/** Array of latest readings from the sensor. Each object represents a single reading for a single metric. */
		GetOrganizationSensorReadingsLatestReturnReadings?: Array<GetOrganizationSensorReadingsLatestReturnReadings>;

		/** Serial number of the sensor that took the readings. */
		serial?: string | null;
	}
	export interface GetOrganizationSensorReadingsLatestReturnFormProperties {

		/** Serial number of the sensor that took the readings. */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnFormProperties>({
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnNetwork {

		/** ID of the network. */
		id?: string | null;

		/** Name of the network. */
		name?: string | null;
	}
	export interface GetOrganizationSensorReadingsLatestReturnNetworkFormProperties {

		/** ID of the network. */
		id: FormControl<string | null | undefined>,

		/** Name of the network. */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnNetworkFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnReadings {

		/** Reading for the 'battery' metric. This will only be present if the 'metric' property equals 'battery'. */
		battery?: GetOrganizationSensorReadingsLatestReturnReadingsBattery;

		/** Reading for the 'button' metric. This will only be present if the 'metric' property equals 'button'. */
		button?: GetOrganizationSensorReadingsLatestReturnReadingsButton;

		/** Reading for the 'door' metric. This will only be present if the 'metric' property equals 'door'. */
		door?: GetOrganizationSensorReadingsLatestReturnReadingsDoor;

		/** Reading for the 'humidity' metric. This will only be present if the 'metric' property equals 'humidity'. */
		humidity?: GetOrganizationSensorReadingsLatestReturnReadingsHumidity;

		/** Reading for the 'indoorAirQuality' metric. This will only be present if the 'metric' property equals 'indoorAirQuality'. */
		indoorAirQuality?: GetOrganizationSensorReadingsLatestReturnReadingsIndoorAirQuality;

		/** Type of sensor reading. */
		metric?: GetOrganizationSensorReadingsHistoryReturnMetric | null;

		/** Reading for the 'noise' metric. This will only be present if the 'metric' property equals 'noise'. */
		noise?: GetOrganizationSensorReadingsLatestReturnReadingsNoise;

		/** Reading for the 'pm25' metric. This will only be present if the 'metric' property equals 'pm25'. */
		pm25?: GetOrganizationSensorReadingsLatestReturnReadingsPm25;

		/** Reading for the 'temperature' metric. This will only be present if the 'metric' property equals 'temperature'. */
		temperature?: GetOrganizationSensorReadingsLatestReturnReadingsTemperature;

		/** Time at which the reading occurred, in ISO8601 format. */
		ts?: string | null;

		/** Reading for the 'tvoc' metric. This will only be present if the 'metric' property equals 'tvoc'. */
		tvoc?: GetOrganizationSensorReadingsLatestReturnReadingsTvoc;

		/** Reading for the 'water' metric. This will only be present if the 'metric' property equals 'water'. */
		water?: GetOrganizationSensorReadingsLatestReturnReadingsWater;
	}
	export interface GetOrganizationSensorReadingsLatestReturnReadingsFormProperties {

		/** Type of sensor reading. */
		metric: FormControl<GetOrganizationSensorReadingsHistoryReturnMetric | null | undefined>,

		/** Time at which the reading occurred, in ISO8601 format. */
		ts: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnReadingsFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnReadingsFormProperties>({
			metric: new FormControl<GetOrganizationSensorReadingsHistoryReturnMetric | null | undefined>(undefined),
			ts: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnReadingsBattery {

		/** Remaining battery life. */
		percentage?: number | null;
	}
	export interface GetOrganizationSensorReadingsLatestReturnReadingsBatteryFormProperties {

		/** Remaining battery life. */
		percentage: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnReadingsBatteryFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnReadingsBatteryFormProperties>({
			percentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnReadingsButton {

		/** Type of button press that occurred. */
		pressType?: GetOrganizationSensorReadingsHistoryReturnButtonPressType | null;
	}
	export interface GetOrganizationSensorReadingsLatestReturnReadingsButtonFormProperties {

		/** Type of button press that occurred. */
		pressType: FormControl<GetOrganizationSensorReadingsHistoryReturnButtonPressType | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnReadingsButtonFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnReadingsButtonFormProperties>({
			pressType: new FormControl<GetOrganizationSensorReadingsHistoryReturnButtonPressType | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnReadingsDoor {

		/** True if the door is open. */
		open?: boolean | null;
	}
	export interface GetOrganizationSensorReadingsLatestReturnReadingsDoorFormProperties {

		/** True if the door is open. */
		open: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnReadingsDoorFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnReadingsDoorFormProperties>({
			open: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnReadingsHumidity {

		/** Humidity reading in %RH. */
		relativePercentage?: number | null;
	}
	export interface GetOrganizationSensorReadingsLatestReturnReadingsHumidityFormProperties {

		/** Humidity reading in %RH. */
		relativePercentage: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnReadingsHumidityFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnReadingsHumidityFormProperties>({
			relativePercentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnReadingsIndoorAirQuality {

		/** Indoor air quality score between 0 and 100. */
		score?: number | null;
	}
	export interface GetOrganizationSensorReadingsLatestReturnReadingsIndoorAirQualityFormProperties {

		/** Indoor air quality score between 0 and 100. */
		score: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnReadingsIndoorAirQualityFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnReadingsIndoorAirQualityFormProperties>({
			score: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnReadingsNoise {

		/** Ambient noise reading. */
		ambient?: GetOrganizationSensorReadingsLatestReturnReadingsNoiseAmbient;
	}
	export interface GetOrganizationSensorReadingsLatestReturnReadingsNoiseFormProperties {
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnReadingsNoiseFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnReadingsNoiseFormProperties>({
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnReadingsNoiseAmbient {

		/** Ambient noise reading in adjusted decibels. */
		level?: number | null;
	}
	export interface GetOrganizationSensorReadingsLatestReturnReadingsNoiseAmbientFormProperties {

		/** Ambient noise reading in adjusted decibels. */
		level: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnReadingsNoiseAmbientFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnReadingsNoiseAmbientFormProperties>({
			level: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnReadingsPm25 {

		/** PM2.5 reading in micrograms per cubic meter. */
		concentration?: number | null;
	}
	export interface GetOrganizationSensorReadingsLatestReturnReadingsPm25FormProperties {

		/** PM2.5 reading in micrograms per cubic meter. */
		concentration: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnReadingsPm25FormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnReadingsPm25FormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnReadingsTemperature {

		/** Temperature reading in degrees Celsius. */
		celsius?: number | null;

		/** Temperature reading in degrees Fahrenheit. */
		fahrenheit?: number | null;
	}
	export interface GetOrganizationSensorReadingsLatestReturnReadingsTemperatureFormProperties {

		/** Temperature reading in degrees Celsius. */
		celsius: FormControl<number | null | undefined>,

		/** Temperature reading in degrees Fahrenheit. */
		fahrenheit: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnReadingsTemperatureFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnReadingsTemperatureFormProperties>({
			celsius: new FormControl<number | null | undefined>(undefined),
			fahrenheit: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnReadingsTvoc {

		/** TVOC reading in micrograms per cubic meter. */
		concentration?: number | null;
	}
	export interface GetOrganizationSensorReadingsLatestReturnReadingsTvocFormProperties {

		/** TVOC reading in micrograms per cubic meter. */
		concentration: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnReadingsTvocFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnReadingsTvocFormProperties>({
			concentration: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSensorReadingsLatestReturnReadingsWater {

		/** True if water is detected. */
		present?: boolean | null;
	}
	export interface GetOrganizationSensorReadingsLatestReturnReadingsWaterFormProperties {

		/** True if water is detected. */
		present: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationSensorReadingsLatestReturnReadingsWaterFormGroup() {
		return new FormGroup<GetOrganizationSensorReadingsLatestReturnReadingsWaterFormProperties>({
			present: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSmApnsCertReturn {

		/** Organization APNS Certificate used by devices to communication with Apple */
		certificate?: string | null;
	}
	export interface GetOrganizationSmApnsCertReturnFormProperties {

		/** Organization APNS Certificate used by devices to communication with Apple */
		certificate: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSmApnsCertReturnFormGroup() {
		return new FormGroup<GetOrganizationSmApnsCertReturnFormProperties>({
			certificate: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSmVppAccountsReturn {

		/** The id of the VPP Account */
		id?: string | null;

		/** The VPP Account's Service Token */
		vppServiceToken?: string | null;
	}
	export interface GetOrganizationSmVppAccountsReturnFormProperties {

		/** The id of the VPP Account */
		id: FormControl<string | null | undefined>,

		/** The VPP Account's Service Token */
		vppServiceToken: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSmVppAccountsReturnFormGroup() {
		return new FormGroup<GetOrganizationSmVppAccountsReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			vppServiceToken: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSmVppAccountReturn {

		/** The id of the VPP Account */
		id?: string | null;

		/** The VPP Account's Service Token */
		vppServiceToken?: string | null;
	}
	export interface GetOrganizationSmVppAccountReturnFormProperties {

		/** The id of the VPP Account */
		id: FormControl<string | null | undefined>,

		/** The VPP Account's Service Token */
		vppServiceToken: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSmVppAccountReturnFormGroup() {
		return new FormGroup<GetOrganizationSmVppAccountReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			vppServiceToken: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface UpdateOrganizationSnmpPutBody {

		/** The list of IPv4 addresses that are allowed to access the SNMP server. */
		peerIps?: Array<string>;

		/** Boolean indicating whether SNMP version 2c is enabled for the organization. */
		v2cEnabled?: boolean | null;

		/** The SNMP version 3 authentication mode. Can be either 'MD5' or 'SHA'. */
		v3AuthMode?: UpdateOrganizationSnmpPutBodyV3AuthMode | null;

		/** The SNMP version 3 authentication password. Must be at least 8 characters if specified. */
		v3AuthPass?: string | null;

		/** Boolean indicating whether SNMP version 3 is enabled for the organization. */
		v3Enabled?: boolean | null;

		/** The SNMP version 3 privacy mode. Can be either 'DES' or 'AES128'. */
		v3PrivMode?: UpdateOrganizationSnmpPutBodyV3PrivMode | null;

		/** The SNMP version 3 privacy password. Must be at least 8 characters if specified. */
		v3PrivPass?: string | null;
	}
	export interface UpdateOrganizationSnmpPutBodyFormProperties {

		/** Boolean indicating whether SNMP version 2c is enabled for the organization. */
		v2cEnabled: FormControl<boolean | null | undefined>,

		/** The SNMP version 3 authentication mode. Can be either 'MD5' or 'SHA'. */
		v3AuthMode: FormControl<UpdateOrganizationSnmpPutBodyV3AuthMode | null | undefined>,

		/** The SNMP version 3 authentication password. Must be at least 8 characters if specified. */
		v3AuthPass: FormControl<string | null | undefined>,

		/** Boolean indicating whether SNMP version 3 is enabled for the organization. */
		v3Enabled: FormControl<boolean | null | undefined>,

		/** The SNMP version 3 privacy mode. Can be either 'DES' or 'AES128'. */
		v3PrivMode: FormControl<UpdateOrganizationSnmpPutBodyV3PrivMode | null | undefined>,

		/** The SNMP version 3 privacy password. Must be at least 8 characters if specified. */
		v3PrivPass: FormControl<string | null | undefined>,
	}
	export function CreateUpdateOrganizationSnmpPutBodyFormGroup() {
		return new FormGroup<UpdateOrganizationSnmpPutBodyFormProperties>({
			v2cEnabled: new FormControl<boolean | null | undefined>(undefined),
			v3AuthMode: new FormControl<UpdateOrganizationSnmpPutBodyV3AuthMode | null | undefined>(undefined),
			v3AuthPass: new FormControl<string | null | undefined>(undefined),
			v3Enabled: new FormControl<boolean | null | undefined>(undefined),
			v3PrivMode: new FormControl<UpdateOrganizationSnmpPutBodyV3PrivMode | null | undefined>(undefined),
			v3PrivPass: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum UpdateOrganizationSnmpPutBodyV3AuthMode { MD5 = 'MD5', SHA = 'SHA' }

	export enum UpdateOrganizationSnmpPutBodyV3PrivMode { AES128 = 'AES128', DES = 'DES' }

	export interface GetOrganizationSummaryTopAppliancesByUtilizationReturn {

		/** Mac address of the appliance */
		mac?: string | null;

		/** Model of the appliance */
		model?: string | null;

		/** Name of the appliance */
		name?: string | null;

		/** Network info */
		network?: GetOrganizationSummaryTopAppliancesByUtilizationReturnNetwork;

		/** Serial number of the appliance */
		serial?: string | null;

		/** Utilization of the appliance */
		utilization?: GetOrganizationSummaryTopAppliancesByUtilizationReturnUtilization;
	}
	export interface GetOrganizationSummaryTopAppliancesByUtilizationReturnFormProperties {

		/** Mac address of the appliance */
		mac: FormControl<string | null | undefined>,

		/** Model of the appliance */
		model: FormControl<string | null | undefined>,

		/** Name of the appliance */
		name: FormControl<string | null | undefined>,

		/** Serial number of the appliance */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopAppliancesByUtilizationReturnFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopAppliancesByUtilizationReturnFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopAppliancesByUtilizationReturnNetwork {

		/** Network id */
		id?: string | null;

		/** Network name */
		name?: string | null;
	}
	export interface GetOrganizationSummaryTopAppliancesByUtilizationReturnNetworkFormProperties {

		/** Network id */
		id: FormControl<string | null | undefined>,

		/** Network name */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopAppliancesByUtilizationReturnNetworkFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopAppliancesByUtilizationReturnNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopAppliancesByUtilizationReturnUtilization {

		/** Average utilization of the appliance */
		average?: GetOrganizationSummaryTopAppliancesByUtilizationReturnUtilizationAverage;
	}
	export interface GetOrganizationSummaryTopAppliancesByUtilizationReturnUtilizationFormProperties {
	}
	export function CreateGetOrganizationSummaryTopAppliancesByUtilizationReturnUtilizationFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopAppliancesByUtilizationReturnUtilizationFormProperties>({
		});

	}

	export interface GetOrganizationSummaryTopAppliancesByUtilizationReturnUtilizationAverage {

		/** Average percentage utilization of the appliance */
		percentage?: number | null;
	}
	export interface GetOrganizationSummaryTopAppliancesByUtilizationReturnUtilizationAverageFormProperties {

		/** Average percentage utilization of the appliance */
		percentage: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopAppliancesByUtilizationReturnUtilizationAverageFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopAppliancesByUtilizationReturnUtilizationAverageFormProperties>({
			percentage: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopClientsByUsageReturn {

		/** ID of client */
		id?: string | null;

		/** MAC address of client */
		mac?: string | null;

		/** Name of client */
		name?: string | null;
		network?: GetOrganizationSummaryTopClientsByUsageReturnNetwork;

		/** Data usage information */
		usage?: GetOrganizationSummaryTopClientsByUsageReturnUsage;
	}
	export interface GetOrganizationSummaryTopClientsByUsageReturnFormProperties {

		/** ID of client */
		id: FormControl<string | null | undefined>,

		/** MAC address of client */
		mac: FormControl<string | null | undefined>,

		/** Name of client */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopClientsByUsageReturnFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopClientsByUsageReturnFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			mac: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopClientsByUsageReturnNetwork {

		/** ID of network */
		id?: string | null;

		/** Name of network */
		name?: string | null;
	}
	export interface GetOrganizationSummaryTopClientsByUsageReturnNetworkFormProperties {

		/** ID of network */
		id: FormControl<string | null | undefined>,

		/** Name of network */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopClientsByUsageReturnNetworkFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopClientsByUsageReturnNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopClientsByUsageReturnUsage {

		/** Downstream data usage by client */
		downstream?: number | null;

		/** Percentage of total data usage by client */
		percentage?: number | null;

		/** Total data usage by client */
		total?: number | null;

		/** Upstream data usage by client */
		upstream?: number | null;
	}
	export interface GetOrganizationSummaryTopClientsByUsageReturnUsageFormProperties {

		/** Downstream data usage by client */
		downstream: FormControl<number | null | undefined>,

		/** Percentage of total data usage by client */
		percentage: FormControl<number | null | undefined>,

		/** Total data usage by client */
		total: FormControl<number | null | undefined>,

		/** Upstream data usage by client */
		upstream: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopClientsByUsageReturnUsageFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopClientsByUsageReturnUsageFormProperties>({
			downstream: new FormControl<number | null | undefined>(undefined),
			percentage: new FormControl<number | null | undefined>(undefined),
			total: new FormControl<number | null | undefined>(undefined),
			upstream: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopClientsManufacturersByUsageReturn {

		/** Clients info */
		clients?: GetOrganizationSummaryTopClientsManufacturersByUsageReturnClients;

		/** Name of the manufacturer */
		name?: string | null;

		/** Clients usage */
		usage?: GetOrganizationSummaryTopClientsManufacturersByUsageReturnUsage;
	}
	export interface GetOrganizationSummaryTopClientsManufacturersByUsageReturnFormProperties {

		/** Name of the manufacturer */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopClientsManufacturersByUsageReturnFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopClientsManufacturersByUsageReturnFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopClientsManufacturersByUsageReturnClients {

		/** Counts of clients */
		counts?: GetOrganizationSummaryTopClientsManufacturersByUsageReturnClientsCounts;
	}
	export interface GetOrganizationSummaryTopClientsManufacturersByUsageReturnClientsFormProperties {
	}
	export function CreateGetOrganizationSummaryTopClientsManufacturersByUsageReturnClientsFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopClientsManufacturersByUsageReturnClientsFormProperties>({
		});

	}

	export interface GetOrganizationSummaryTopClientsManufacturersByUsageReturnClientsCounts {

		/** Total counts of clients */
		total?: number | null;
	}
	export interface GetOrganizationSummaryTopClientsManufacturersByUsageReturnClientsCountsFormProperties {

		/** Total counts of clients */
		total: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopClientsManufacturersByUsageReturnClientsCountsFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopClientsManufacturersByUsageReturnClientsCountsFormProperties>({
			total: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopClientsManufacturersByUsageReturnUsage {

		/** Downstream data usage by client */
		downstream?: number | null;

		/** Total data usage by client */
		total?: number | null;

		/** Upstream data usage by client */
		upstream?: number | null;
	}
	export interface GetOrganizationSummaryTopClientsManufacturersByUsageReturnUsageFormProperties {

		/** Downstream data usage by client */
		downstream: FormControl<number | null | undefined>,

		/** Total data usage by client */
		total: FormControl<number | null | undefined>,

		/** Upstream data usage by client */
		upstream: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopClientsManufacturersByUsageReturnUsageFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopClientsManufacturersByUsageReturnUsageFormProperties>({
			downstream: new FormControl<number | null | undefined>(undefined),
			total: new FormControl<number | null | undefined>(undefined),
			upstream: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopDevicesByUsageReturn {

		/** Clients */
		clients?: GetOrganizationSummaryTopDevicesByUsageReturnClients;

		/** Mac address of the device */
		mac?: string | null;

		/** Model of the device */
		model?: string | null;

		/** Name of the device */
		name?: string | null;

		/** Network info */
		network?: GetOrganizationSummaryTopDevicesByUsageReturnNetwork;

		/** Product type of the device */
		productType?: string | null;

		/** Serial number of the device */
		serial?: string | null;

		/** Data usage of the device */
		usage?: GetOrganizationSummaryTopDevicesByUsageReturnUsage;
	}
	export interface GetOrganizationSummaryTopDevicesByUsageReturnFormProperties {

		/** Mac address of the device */
		mac: FormControl<string | null | undefined>,

		/** Model of the device */
		model: FormControl<string | null | undefined>,

		/** Name of the device */
		name: FormControl<string | null | undefined>,

		/** Product type of the device */
		productType: FormControl<string | null | undefined>,

		/** Serial number of the device */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopDevicesByUsageReturnFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopDevicesByUsageReturnFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			productType: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopDevicesByUsageReturnClients {

		/** Counts of clients */
		counts?: GetOrganizationSummaryTopDevicesByUsageReturnClientsCounts;
	}
	export interface GetOrganizationSummaryTopDevicesByUsageReturnClientsFormProperties {
	}
	export function CreateGetOrganizationSummaryTopDevicesByUsageReturnClientsFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopDevicesByUsageReturnClientsFormProperties>({
		});

	}

	export interface GetOrganizationSummaryTopDevicesByUsageReturnClientsCounts {

		/** Total counts of clients */
		total?: number | null;
	}
	export interface GetOrganizationSummaryTopDevicesByUsageReturnClientsCountsFormProperties {

		/** Total counts of clients */
		total: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopDevicesByUsageReturnClientsCountsFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopDevicesByUsageReturnClientsCountsFormProperties>({
			total: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopDevicesByUsageReturnNetwork {

		/** Network id */
		id?: string | null;

		/** Network name */
		name?: string | null;
	}
	export interface GetOrganizationSummaryTopDevicesByUsageReturnNetworkFormProperties {

		/** Network id */
		id: FormControl<string | null | undefined>,

		/** Network name */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopDevicesByUsageReturnNetworkFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopDevicesByUsageReturnNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopDevicesByUsageReturnUsage {

		/** Data usage of the device by percentage */
		percentage?: number | null;

		/** Total data usage of the device */
		total?: number | null;
	}
	export interface GetOrganizationSummaryTopDevicesByUsageReturnUsageFormProperties {

		/** Data usage of the device by percentage */
		percentage: FormControl<number | null | undefined>,

		/** Total data usage of the device */
		total: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopDevicesByUsageReturnUsageFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopDevicesByUsageReturnUsageFormProperties>({
			percentage: new FormControl<number | null | undefined>(undefined),
			total: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopDevicesModelsByUsageReturn {

		/** Total number of devices per model */
		count?: number | null;

		/** The device model */
		model?: string | null;

		/** Usage info in megabytes */
		usage?: GetOrganizationSummaryTopDevicesModelsByUsageReturnUsage;
	}
	export interface GetOrganizationSummaryTopDevicesModelsByUsageReturnFormProperties {

		/** Total number of devices per model */
		count: FormControl<number | null | undefined>,

		/** The device model */
		model: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopDevicesModelsByUsageReturnFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopDevicesModelsByUsageReturnFormProperties>({
			count: new FormControl<number | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopDevicesModelsByUsageReturnUsage {

		/** Average usage in megabytes */
		average?: number | null;

		/** Total usage in megabytes */
		total?: number | null;
	}
	export interface GetOrganizationSummaryTopDevicesModelsByUsageReturnUsageFormProperties {

		/** Average usage in megabytes */
		average: FormControl<number | null | undefined>,

		/** Total usage in megabytes */
		total: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopDevicesModelsByUsageReturnUsageFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopDevicesModelsByUsageReturnUsageFormProperties>({
			average: new FormControl<number | null | undefined>(undefined),
			total: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopSsidsByUsageReturn {

		/** Clients info of the SSID */
		clients?: GetOrganizationSummaryTopSsidsByUsageReturnClients;

		/** Name of the SSID */
		name?: string | null;

		/** Date usage of the SSID, in megabytes */
		usage?: GetOrganizationSummaryTopSsidsByUsageReturnUsage;
	}
	export interface GetOrganizationSummaryTopSsidsByUsageReturnFormProperties {

		/** Name of the SSID */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopSsidsByUsageReturnFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopSsidsByUsageReturnFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopSsidsByUsageReturnClients {

		/** Counts of the clients */
		counts?: GetOrganizationSummaryTopSsidsByUsageReturnClientsCounts;
	}
	export interface GetOrganizationSummaryTopSsidsByUsageReturnClientsFormProperties {
	}
	export function CreateGetOrganizationSummaryTopSsidsByUsageReturnClientsFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopSsidsByUsageReturnClientsFormProperties>({
		});

	}

	export interface GetOrganizationSummaryTopSsidsByUsageReturnClientsCounts {

		/** Total counts of the clients */
		total?: number | null;
	}
	export interface GetOrganizationSummaryTopSsidsByUsageReturnClientsCountsFormProperties {

		/** Total counts of the clients */
		total: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopSsidsByUsageReturnClientsCountsFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopSsidsByUsageReturnClientsCountsFormProperties>({
			total: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopSsidsByUsageReturnUsage {

		/** Downstream usage of the SSID */
		downstream?: number | null;

		/** Percentage usage of the SSID */
		percentage?: number | null;

		/** Total usage of the SSID */
		total?: number | null;

		/** Upstream usage of the SSID */
		upstream?: number | null;
	}
	export interface GetOrganizationSummaryTopSsidsByUsageReturnUsageFormProperties {

		/** Downstream usage of the SSID */
		downstream: FormControl<number | null | undefined>,

		/** Percentage usage of the SSID */
		percentage: FormControl<number | null | undefined>,

		/** Total usage of the SSID */
		total: FormControl<number | null | undefined>,

		/** Upstream usage of the SSID */
		upstream: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopSsidsByUsageReturnUsageFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopSsidsByUsageReturnUsageFormProperties>({
			downstream: new FormControl<number | null | undefined>(undefined),
			percentage: new FormControl<number | null | undefined>(undefined),
			total: new FormControl<number | null | undefined>(undefined),
			upstream: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopSwitchesByEnergyUsageReturn {

		/** Mac address of the switch */
		mac?: string | null;

		/** Model of the switch */
		model?: string | null;

		/** Name of the switch */
		name?: string | null;

		/** Network info */
		network?: GetOrganizationSummaryTopSwitchesByEnergyUsageReturnNetwork;

		/** Energy usage of the switch */
		usage?: GetOrganizationSummaryTopSwitchesByEnergyUsageReturnUsage;
	}
	export interface GetOrganizationSummaryTopSwitchesByEnergyUsageReturnFormProperties {

		/** Mac address of the switch */
		mac: FormControl<string | null | undefined>,

		/** Model of the switch */
		model: FormControl<string | null | undefined>,

		/** Name of the switch */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopSwitchesByEnergyUsageReturnFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopSwitchesByEnergyUsageReturnFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopSwitchesByEnergyUsageReturnNetwork {

		/** Network id */
		id?: string | null;

		/** Network name */
		name?: string | null;
	}
	export interface GetOrganizationSummaryTopSwitchesByEnergyUsageReturnNetworkFormProperties {

		/** Network id */
		id: FormControl<string | null | undefined>,

		/** Network name */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopSwitchesByEnergyUsageReturnNetworkFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopSwitchesByEnergyUsageReturnNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSummaryTopSwitchesByEnergyUsageReturnUsage {

		/** Total energy usage of the switch */
		total?: number | null;
	}
	export interface GetOrganizationSummaryTopSwitchesByEnergyUsageReturnUsageFormProperties {

		/** Total energy usage of the switch */
		total: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSummaryTopSwitchesByEnergyUsageReturnUsageFormGroup() {
		return new FormGroup<GetOrganizationSummaryTopSwitchesByEnergyUsageReturnUsageFormProperties>({
			total: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface CloneOrganizationSwitchDevicesPostBody {

		/**
		 * Serial number of the source switch (must be on a network not bound to a template)
		 * Required
		 */
		sourceSerial: string;

		/**
		 * Array of serial numbers of one or more target switches (must be on a network not bound to a template)
		 * Required
		 */
		targetSerials: Array<string>;
	}
	export interface CloneOrganizationSwitchDevicesPostBodyFormProperties {

		/**
		 * Serial number of the source switch (must be on a network not bound to a template)
		 * Required
		 */
		sourceSerial: FormControl<string | null | undefined>,
	}
	export function CreateCloneOrganizationSwitchDevicesPostBodyFormGroup() {
		return new FormGroup<CloneOrganizationSwitchDevicesPostBodyFormProperties>({
			sourceSerial: new FormControl<string | null | undefined>(undefined, [Validators.required]),
		});

	}

	export interface GetOrganizationSwitchPortsBySwitchReturn {

		/** MAC address of the switch */
		mac?: string | null;

		/** Model of the switch */
		model?: string | null;

		/** Name of the switch */
		name?: string | null;

		/** The network that the switch belongs to */
		network?: GetOrganizationSwitchPortsBySwitchReturnNetwork;

		/** Ports belonging to the switch */
		GetOrganizationSwitchPortsBySwitchReturnPorts?: Array<GetOrganizationSwitchPortsBySwitchReturnPorts>;

		/** Serial of the switch */
		serial?: string | null;
	}
	export interface GetOrganizationSwitchPortsBySwitchReturnFormProperties {

		/** MAC address of the switch */
		mac: FormControl<string | null | undefined>,

		/** Model of the switch */
		model: FormControl<string | null | undefined>,

		/** Name of the switch */
		name: FormControl<string | null | undefined>,

		/** Serial of the switch */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSwitchPortsBySwitchReturnFormGroup() {
		return new FormGroup<GetOrganizationSwitchPortsBySwitchReturnFormProperties>({
			mac: new FormControl<string | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSwitchPortsBySwitchReturnNetwork {

		/** ID of the network */
		id?: string | null;

		/** Name of the network */
		name?: string | null;
	}
	export interface GetOrganizationSwitchPortsBySwitchReturnNetworkFormProperties {

		/** ID of the network */
		id: FormControl<string | null | undefined>,

		/** Name of the network */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationSwitchPortsBySwitchReturnNetworkFormGroup() {
		return new FormGroup<GetOrganizationSwitchPortsBySwitchReturnNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationSwitchPortsBySwitchReturnPorts {

		/** The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType?: GetDeviceSwitchPortsReturnAccessPolicyType | null;

		/** The VLANs allowed on the switch port. Only applicable to trunk ports. */
		allowedVlans?: string | null;

		/** The status of the switch port. */
		enabled?: boolean | null;

		/** The link speed for the switch port. */
		linkNegotiation?: string | null;

		/** The name of the switch port. */
		name?: string | null;

		/** The PoE status of the switch port. */
		poeEnabled?: boolean | null;

		/** The identifier of the switch port. */
		portId?: string | null;

		/** The rapid spanning tree protocol status. */
		rstpEnabled?: boolean | null;

		/** The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowList?: Array<string>;

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit?: number | null;

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard?: GetDeviceSwitchPortsReturnStpGuard | null;

		/** The list of tags of the switch port. */
		tags?: Array<string>;

		/** The type of the switch port ('trunk' or 'access'). */
		type?: GetDeviceSwitchPortsReturnType | null;

		/** The VLAN of the switch port. A null value will clear the value set for trunk ports. */
		vlan?: number | null;

		/** The voice VLAN of the switch port. Only applicable to access ports. */
		voiceVlan?: number | null;
	}
	export interface GetOrganizationSwitchPortsBySwitchReturnPortsFormProperties {

		/** The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'. */
		accessPolicyType: FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>,

		/** The VLANs allowed on the switch port. Only applicable to trunk ports. */
		allowedVlans: FormControl<string | null | undefined>,

		/** The status of the switch port. */
		enabled: FormControl<boolean | null | undefined>,

		/** The link speed for the switch port. */
		linkNegotiation: FormControl<string | null | undefined>,

		/** The name of the switch port. */
		name: FormControl<string | null | undefined>,

		/** The PoE status of the switch port. */
		poeEnabled: FormControl<boolean | null | undefined>,

		/** The identifier of the switch port. */
		portId: FormControl<string | null | undefined>,

		/** The rapid spanning tree protocol status. */
		rstpEnabled: FormControl<boolean | null | undefined>,

		/** The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'. */
		stickyMacAllowListLimit: FormControl<number | null | undefined>,

		/** The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard'). */
		stpGuard: FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>,

		/** The type of the switch port ('trunk' or 'access'). */
		type: FormControl<GetDeviceSwitchPortsReturnType | null | undefined>,

		/** The VLAN of the switch port. A null value will clear the value set for trunk ports. */
		vlan: FormControl<number | null | undefined>,

		/** The voice VLAN of the switch port. Only applicable to access ports. */
		voiceVlan: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationSwitchPortsBySwitchReturnPortsFormGroup() {
		return new FormGroup<GetOrganizationSwitchPortsBySwitchReturnPortsFormProperties>({
			accessPolicyType: new FormControl<GetDeviceSwitchPortsReturnAccessPolicyType | null | undefined>(undefined),
			allowedVlans: new FormControl<string | null | undefined>(undefined),
			enabled: new FormControl<boolean | null | undefined>(undefined),
			linkNegotiation: new FormControl<string | null | undefined>(undefined),
			name: new FormControl<string | null | undefined>(undefined),
			poeEnabled: new FormControl<boolean | null | undefined>(undefined),
			portId: new FormControl<string | null | undefined>(undefined),
			rstpEnabled: new FormControl<boolean | null | undefined>(undefined),
			stickyMacAllowListLimit: new FormControl<number | null | undefined>(undefined),
			stpGuard: new FormControl<GetDeviceSwitchPortsReturnStpGuard | null | undefined>(undefined),
			type: new FormControl<GetDeviceSwitchPortsReturnType | null | undefined>(undefined),
			vlan: new FormControl<number | null | undefined>(undefined),
			voiceVlan: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationUplinksStatusesReturn {

		/** Last reported time for the device */
		lastReportedAt?: Date | null;

		/** The uplink model */
		model?: string | null;

		/** Network identifier */
		networkId?: string | null;

		/** The uplink serial */
		serial?: string | null;

		/** Uplinks */
		GetOrganizationUplinksStatusesReturnUplinks?: Array<GetOrganizationUplinksStatusesReturnUplinks>;
	}
	export interface GetOrganizationUplinksStatusesReturnFormProperties {

		/** Last reported time for the device */
		lastReportedAt: FormControl<Date | null | undefined>,

		/** The uplink model */
		model: FormControl<string | null | undefined>,

		/** Network identifier */
		networkId: FormControl<string | null | undefined>,

		/** The uplink serial */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationUplinksStatusesReturnFormGroup() {
		return new FormGroup<GetOrganizationUplinksStatusesReturnFormProperties>({
			lastReportedAt: new FormControl<Date | null | undefined>(undefined),
			model: new FormControl<string | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationUplinksStatusesReturnUplinks {

		/** Access Point Name */
		apn?: string | null;

		/** Connection Type */
		connectionType?: string | null;

		/** Primary DNS IP */
		dns1?: string | null;

		/** Secondary DNS IP */
		dns2?: string | null;

		/** Gateway IP */
		gateway?: string | null;

		/** Integrated Circuit Card Identification Number */
		iccid?: string | null;

		/** Uplink interface */
		interface?: GetDeviceLossAndLatencyHistoryUplink | null;

		/** Uplink IP */
		ip?: string | null;

		/** The way in which the IP is assigned */
		ipAssignedBy?: string | null;

		/** Primary DNS IP */
		primaryDns?: string | null;

		/** Network Provider */
		provider?: string | null;

		/** Public IP */
		publicIp?: string | null;

		/** Secondary DNS IP */
		secondaryDns?: string | null;

		/** Tower Signal Status */
		signalStat?: GetOrganizationUplinksStatusesReturnUplinksSignalStat;

		/** Signal Type */
		signalType?: string | null;

		/** Uplink status */
		status?: GetOrganizationUplinksStatusesReturnUplinksStatus | null;
	}
	export interface GetOrganizationUplinksStatusesReturnUplinksFormProperties {

		/** Access Point Name */
		apn: FormControl<string | null | undefined>,

		/** Connection Type */
		connectionType: FormControl<string | null | undefined>,

		/** Primary DNS IP */
		dns1: FormControl<string | null | undefined>,

		/** Secondary DNS IP */
		dns2: FormControl<string | null | undefined>,

		/** Gateway IP */
		gateway: FormControl<string | null | undefined>,

		/** Integrated Circuit Card Identification Number */
		iccid: FormControl<string | null | undefined>,

		/** Uplink interface */
		interface: FormControl<GetDeviceLossAndLatencyHistoryUplink | null | undefined>,

		/** Uplink IP */
		ip: FormControl<string | null | undefined>,

		/** The way in which the IP is assigned */
		ipAssignedBy: FormControl<string | null | undefined>,

		/** Primary DNS IP */
		primaryDns: FormControl<string | null | undefined>,

		/** Network Provider */
		provider: FormControl<string | null | undefined>,

		/** Public IP */
		publicIp: FormControl<string | null | undefined>,

		/** Secondary DNS IP */
		secondaryDns: FormControl<string | null | undefined>,

		/** Signal Type */
		signalType: FormControl<string | null | undefined>,

		/** Uplink status */
		status: FormControl<GetOrganizationUplinksStatusesReturnUplinksStatus | null | undefined>,
	}
	export function CreateGetOrganizationUplinksStatusesReturnUplinksFormGroup() {
		return new FormGroup<GetOrganizationUplinksStatusesReturnUplinksFormProperties>({
			apn: new FormControl<string | null | undefined>(undefined),
			connectionType: new FormControl<string | null | undefined>(undefined),
			dns1: new FormControl<string | null | undefined>(undefined),
			dns2: new FormControl<string | null | undefined>(undefined),
			gateway: new FormControl<string | null | undefined>(undefined),
			iccid: new FormControl<string | null | undefined>(undefined),
			interface: new FormControl<GetDeviceLossAndLatencyHistoryUplink | null | undefined>(undefined),
			ip: new FormControl<string | null | undefined>(undefined),
			ipAssignedBy: new FormControl<string | null | undefined>(undefined),
			primaryDns: new FormControl<string | null | undefined>(undefined),
			provider: new FormControl<string | null | undefined>(undefined),
			publicIp: new FormControl<string | null | undefined>(undefined),
			secondaryDns: new FormControl<string | null | undefined>(undefined),
			signalType: new FormControl<string | null | undefined>(undefined),
			status: new FormControl<GetOrganizationUplinksStatusesReturnUplinksStatus | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationUplinksStatusesReturnUplinksSignalStat {

		/** Reference Signal Received Power */
		rsrp?: string | null;

		/** Reference Signal Received Quality */
		rsrq?: string | null;
	}
	export interface GetOrganizationUplinksStatusesReturnUplinksSignalStatFormProperties {

		/** Reference Signal Received Power */
		rsrp: FormControl<string | null | undefined>,

		/** Reference Signal Received Quality */
		rsrq: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationUplinksStatusesReturnUplinksSignalStatFormGroup() {
		return new FormGroup<GetOrganizationUplinksStatusesReturnUplinksSignalStatFormProperties>({
			rsrp: new FormControl<string | null | undefined>(undefined),
			rsrq: new FormControl<string | null | undefined>(undefined),
		});

	}

	export enum GetOrganizationUplinksStatusesReturnUplinksStatus { active = 'active', connecting = 'connecting', failed = 'failed', 'not connected' = 'not connected', ready = 'ready' }

	export enum GetOrganizationWebhooksAlertTypesProductType { appliance = 'appliance', camera = 'camera', cellularGateway = 'cellularGateway', health = 'health', platform = 'platform', sensor = 'sensor', sm = 'sm', switch = 'switch', wireless = 'wireless' }

	export interface GetOrganizationWebhooksLogsReturn {

		/** Type of alert that the webhook is delivering */
		alertType?: string | null;

		/** When the webhook log was created, in ISO8601 format */
		loggedAt?: Date | null;

		/** Network ID for the webhook log */
		networkId?: string | null;

		/** ID for the webhook log's organization */
		organizationId?: string | null;

		/** Response code from the webhook */
		responseCode?: number | null;

		/** Duration of the response, in milliseconds */
		responseDuration?: number | null;

		/** When the webhook was sent, in ISO8601 format */
		sentAt?: Date | null;

		/** URL where the webhook was sent */
		url?: string | null;
	}
	export interface GetOrganizationWebhooksLogsReturnFormProperties {

		/** Type of alert that the webhook is delivering */
		alertType: FormControl<string | null | undefined>,

		/** When the webhook log was created, in ISO8601 format */
		loggedAt: FormControl<Date | null | undefined>,

		/** Network ID for the webhook log */
		networkId: FormControl<string | null | undefined>,

		/** ID for the webhook log's organization */
		organizationId: FormControl<string | null | undefined>,

		/** Response code from the webhook */
		responseCode: FormControl<number | null | undefined>,

		/** Duration of the response, in milliseconds */
		responseDuration: FormControl<number | null | undefined>,

		/** When the webhook was sent, in ISO8601 format */
		sentAt: FormControl<Date | null | undefined>,

		/** URL where the webhook was sent */
		url: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationWebhooksLogsReturnFormGroup() {
		return new FormGroup<GetOrganizationWebhooksLogsReturnFormProperties>({
			alertType: new FormControl<string | null | undefined>(undefined),
			loggedAt: new FormControl<Date | null | undefined>(undefined),
			networkId: new FormControl<string | null | undefined>(undefined),
			organizationId: new FormControl<string | null | undefined>(undefined),
			responseCode: new FormControl<number | null | undefined>(undefined),
			responseDuration: new FormControl<number | null | undefined>(undefined),
			sentAt: new FormControl<Date | null | undefined>(undefined),
			url: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationWirelessDevicesEthernetStatusesReturn {

		/** Aggregation details object */
		aggregation?: GetOrganizationWirelessDevicesEthernetStatusesReturnAggregation;

		/** The name of the AP */
		name?: string | null;

		/** Network details object */
		network?: GetOrganizationWirelessDevicesEthernetStatusesReturnNetwork;

		/** List of port details */
		GetOrganizationWirelessDevicesEthernetStatusesReturnPorts?: Array<GetOrganizationWirelessDevicesEthernetStatusesReturnPorts>;

		/** Power details object */
		power?: GetOrganizationWirelessDevicesEthernetStatusesReturnPower;

		/** The serial number of the AP */
		serial?: string | null;
	}
	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnFormProperties {

		/** The name of the AP */
		name: FormControl<string | null | undefined>,

		/** The serial number of the AP */
		serial: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationWirelessDevicesEthernetStatusesReturnFormGroup() {
		return new FormGroup<GetOrganizationWirelessDevicesEthernetStatusesReturnFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
			serial: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnAggregation {

		/** Link Aggregation enabled flag */
		enabled?: boolean | null;

		/** Link Aggregation speed */
		speed?: number | null;
	}
	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnAggregationFormProperties {

		/** Link Aggregation enabled flag */
		enabled: FormControl<boolean | null | undefined>,

		/** Link Aggregation speed */
		speed: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationWirelessDevicesEthernetStatusesReturnAggregationFormGroup() {
		return new FormGroup<GetOrganizationWirelessDevicesEthernetStatusesReturnAggregationFormProperties>({
			enabled: new FormControl<boolean | null | undefined>(undefined),
			speed: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnNetwork {

		/** The network ID the AP is associated to */
		id?: string | null;
	}
	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnNetworkFormProperties {

		/** The network ID the AP is associated to */
		id: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationWirelessDevicesEthernetStatusesReturnNetworkFormGroup() {
		return new FormGroup<GetOrganizationWirelessDevicesEthernetStatusesReturnNetworkFormProperties>({
			id: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnPorts {

		/** Link negotiation details object for the port */
		linkNegotiation?: GetOrganizationWirelessDevicesEthernetStatusesReturnPortsLinkNegotiation;

		/** Label of the port */
		name?: string | null;

		/** PoE details object for the port */
		poe?: GetOrganizationWirelessDevicesEthernetStatusesReturnPortsPoe;
	}
	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnPortsFormProperties {

		/** Label of the port */
		name: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationWirelessDevicesEthernetStatusesReturnPortsFormGroup() {
		return new FormGroup<GetOrganizationWirelessDevicesEthernetStatusesReturnPortsFormProperties>({
			name: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnPortsLinkNegotiation {

		/** The duplex mode of the port. Can be 'full' or 'half' */
		duplex?: string | null;

		/** The speed of the port */
		speed?: number | null;
	}
	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnPortsLinkNegotiationFormProperties {

		/** The duplex mode of the port. Can be 'full' or 'half' */
		duplex: FormControl<string | null | undefined>,

		/** The speed of the port */
		speed: FormControl<number | null | undefined>,
	}
	export function CreateGetOrganizationWirelessDevicesEthernetStatusesReturnPortsLinkNegotiationFormGroup() {
		return new FormGroup<GetOrganizationWirelessDevicesEthernetStatusesReturnPortsLinkNegotiationFormProperties>({
			duplex: new FormControl<string | null | undefined>(undefined),
			speed: new FormControl<number | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnPortsPoe {

		/** The PoE Standard for the port. Can be '802.3at', '802.3af', '802.3bt', or null */
		standard?: string | null;
	}
	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnPortsPoeFormProperties {

		/** The PoE Standard for the port. Can be '802.3at', '802.3af', '802.3bt', or null */
		standard: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationWirelessDevicesEthernetStatusesReturnPortsPoeFormGroup() {
		return new FormGroup<GetOrganizationWirelessDevicesEthernetStatusesReturnPortsPoeFormProperties>({
			standard: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnPower {

		/** AC power details object */
		ac?: GetOrganizationWirelessDevicesEthernetStatusesReturnPowerAc;

		/** The PoE power mode for the AP. Can be 'full' or 'low' */
		mode?: string | null;

		/** PoE power details object */
		poe?: GetOrganizationWirelessDevicesEthernetStatusesReturnPowerPoe;
	}
	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnPowerFormProperties {

		/** The PoE power mode for the AP. Can be 'full' or 'low' */
		mode: FormControl<string | null | undefined>,
	}
	export function CreateGetOrganizationWirelessDevicesEthernetStatusesReturnPowerFormGroup() {
		return new FormGroup<GetOrganizationWirelessDevicesEthernetStatusesReturnPowerFormProperties>({
			mode: new FormControl<string | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnPowerAc {

		/** AC power connected */
		isConnected?: boolean | null;
	}
	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnPowerAcFormProperties {

		/** AC power connected */
		isConnected: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationWirelessDevicesEthernetStatusesReturnPowerAcFormGroup() {
		return new FormGroup<GetOrganizationWirelessDevicesEthernetStatusesReturnPowerAcFormProperties>({
			isConnected: new FormControl<boolean | null | undefined>(undefined),
		});

	}

	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnPowerPoe {

		/** PoE power connected */
		isConnected?: boolean | null;
	}
	export interface GetOrganizationWirelessDevicesEthernetStatusesReturnPowerPoeFormProperties {

		/** PoE power connected */
		isConnected: FormControl<boolean | null | undefined>,
	}
	export function CreateGetOrganizationWirelessDevicesEthernetStatusesReturnPowerPoeFormGroup() {
		return new FormGroup<GetOrganizationWirelessDevicesEthernetStatusesReturnPowerPoeFormProperties>({
			isConnected: new FormControl<boolean | null | undefined>(undefined),
		});

	}

}

