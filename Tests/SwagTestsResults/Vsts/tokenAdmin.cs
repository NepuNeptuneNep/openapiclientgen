//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	public class SessionToken
	{
		
		public string AccessId { get; set; }
		
		/// <summary>
		/// This is populated when user requests a compact token. The alternate token value is self describing token.
		/// </summary>
		public string AlternateToken { get; set; }
		
		public string AuthorizationId { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Claims { get; set; }
		
		public string ClientId { get; set; }
		
		public string DisplayName { get; set; }
		
		public string HostAuthorizationId { get; set; }
		
		public System.Nullable<System.Boolean> IsPublic { get; set; }
		
		public System.Nullable<System.Boolean> IsValid { get; set; }
		
		public string PublicData { get; set; }
		
		public string Scope { get; set; }
		
		public string Source { get; set; }
		
		public string[] TargetAccounts { get; set; }
		
		/// <summary>
		/// This is computed and not returned in Get queries
		/// </summary>
		public string Token { get; set; }
		
		public string UserId { get; set; }
		
		public System.Nullable<System.DateTimeOffset> ValidFrom { get; set; }
		
		public System.Nullable<System.DateTimeOffset> ValidTo { get; set; }
	}
	
	public class SessionTokenResult
	{
		
		public System.Nullable<System.Boolean> HasError { get; set; }
		
		public SessionToken SessionToken { get; set; }
		
		public System.Nullable<SessionTokenResultSessionTokenError> SessionTokenError { get; set; }
	}
	
	public enum SessionTokenResultSessionTokenError
	{
		
		none = 0,
		
		displayNameRequired = 1,
		
		invalidDisplayName = 2,
		
		invalidValidTo = 3,
		
		invalidScope = 4,
		
		userIdRequired = 5,
		
		invalidUserId = 6,
		
		invalidUserType = 7,
		
		accessDenied = 8,
		
		failedToIssueAccessToken = 9,
		
		invalidClient = 10,
		
		invalidClientType = 11,
		
		invalidClientId = 12,
		
		invalidTargetAccounts = 13,
		
		hostAuthorizationNotFound = 14,
		
		authorizationNotFound = 15,
		
		failedToUpdateAccessToken = 16,
		
		sourceNotSupported = 17,
		
		invalidSourceIP = 18,
		
		invalidSource = 19,
		
		duplicateHash = 20,
		
		sshPolicyDisabled = 21,
	}
	
	/// <summary>
	/// A paginated list of session tokens. Session tokens correspond to OAuth credentials such as personal access tokens (PATs) and other OAuth authorizations.
	/// </summary>
	public class TokenAdminPagedSessionTokens
	{
		
		/// <summary>
		/// The continuation token that can be used to retrieve the next page of session tokens, or <code>null</code> if there is no next page.
		/// </summary>
		public string ContinuationToken { get; set; }
		
		/// <summary>
		/// The list of all session tokens in the current page.
		/// </summary>
		public SessionToken[] Value { get; set; }
	}
	
	/// <summary>
	/// A request to revoke a particular delegated authorization.
	/// </summary>
	public class TokenAdminRevocation
	{
		
		/// <summary>
		/// The authorization ID of the OAuth authorization to revoke.
		/// </summary>
		public string AuthorizationId { get; set; }
	}
	
	/// <summary>
	/// A rule which is applied to disable any incoming delegated authorization which matches the given properties.
	/// </summary>
	public class TokenAdminRevocationRule
	{
		
		/// <summary>
		/// A datetime cutoff. Tokens created before this time will be rejected. This is an optional parameter. If omitted, defaults to the time at which the rule was created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedBefore { get; set; }
		
		/// <summary>
		/// A string containing a space-delimited list of OAuth scopes. A token matching any one of the scopes will be rejected. For a list of all OAuth scopes supported by Azure DevOps, see: https://docs.microsoft.com/en-us/azure/devops/integrate/get-started/authentication/oauth?view=azure-devops#scopes This is a mandatory parameter.
		/// </summary>
		public string Scopes { get; set; }
	}
	
	public partial class MyClient
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public MyClient(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Token_Get_Personal_Access_Token_Get _apis/tokenadmin/tokengetpersonalaccesstoken
		/// </summary>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>A session token containing information about corresponding a PAT.</returns>
		public async Task<SessionTokenResult> Token_Get_Personal_Access_Token_GetAsync(bool isPublic, string api_version, string requestBody)
		{
			var requestUri = "_apis/tokenadmin/tokengetpersonalaccesstoken?isPublic="+isPublic+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SessionTokenResult>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Token_Get_Personal_Access_Token_Get _apis/tokenadmin/tokengetpersonalaccesstoken
		/// </summary>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>A session token containing information about corresponding a PAT.</returns>
		public SessionTokenResult Token_Get_Personal_Access_Token_Get(bool isPublic, string api_version, string requestBody)
		{
			var requestUri = "_apis/tokenadmin/tokengetpersonalaccesstoken?isPublic="+isPublic+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = responseMessage.Content.ReadAsStream();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SessionTokenResult>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Token_Revoke_Personal_Access_Token_Revoke_Personal_Access_Token _apis/tokenadmin/tokenrevokepersonalaccesstoken
		/// </summary>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>A session token has been revoked</returns>
		public async Task Token_Revoke_Personal_Access_Token_Revoke_Personal_Access_TokenAsync(bool isPublic, string api_version, string requestBody)
		{
			var requestUri = "_apis/tokenadmin/tokenrevokepersonalaccesstoken?isPublic="+isPublic+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Token_Revoke_Personal_Access_Token_Revoke_Personal_Access_Token _apis/tokenadmin/tokenrevokepersonalaccesstoken
		/// </summary>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>A session token has been revoked</returns>
		public void Token_Revoke_Personal_Access_Token_Revoke_Personal_Access_Token(bool isPublic, string api_version, string requestBody)
		{
			var requestUri = "_apis/tokenadmin/tokenrevokepersonalaccesstoken?isPublic="+isPublic+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Lists of all the session token details of the personal access tokens (PATs) for a particular user.
		/// Personal_Access_Tokens_List {organization}/_apis/tokenadmin/personalaccesstokens/{subjectDescriptor}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="subjectDescriptor">The descriptor of the target user.</param>
		/// <param name="pageSize">The maximum number of results to return on each page.</param>
		/// <param name="continuationToken">An opaque data blob that allows the next page of data to resume immediately after where the previous page ended. The only reliable way to know if there is more data left is the presence of a continuation token.</param>
		/// <param name="isPublic">Set to false for PAT tokens and true for SSH tokens.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>An an array containing all the session token objects corresponding to the user's PATs.</returns>
		public async Task<TokenAdminPagedSessionTokens> Personal_Access_Tokens_ListAsync(string organization, string subjectDescriptor, int pageSize, string continuationToken, bool isPublic, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/tokenadmin/personalaccesstokens/"+ (subjectDescriptor==null? "" : System.Uri.EscapeDataString(subjectDescriptor))+"&pageSize="+pageSize+"&continuationToken=" + (continuationToken==null? "" : System.Uri.EscapeDataString(continuationToken))+"&isPublic="+isPublic+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TokenAdminPagedSessionTokens>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Lists of all the session token details of the personal access tokens (PATs) for a particular user.
		/// Personal_Access_Tokens_List {organization}/_apis/tokenadmin/personalaccesstokens/{subjectDescriptor}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="subjectDescriptor">The descriptor of the target user.</param>
		/// <param name="pageSize">The maximum number of results to return on each page.</param>
		/// <param name="continuationToken">An opaque data blob that allows the next page of data to resume immediately after where the previous page ended. The only reliable way to know if there is more data left is the presence of a continuation token.</param>
		/// <param name="isPublic">Set to false for PAT tokens and true for SSH tokens.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>An an array containing all the session token objects corresponding to the user's PATs.</returns>
		public TokenAdminPagedSessionTokens Personal_Access_Tokens_List(string organization, string subjectDescriptor, int pageSize, string continuationToken, bool isPublic, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/tokenadmin/personalaccesstokens/"+ (subjectDescriptor==null? "" : System.Uri.EscapeDataString(subjectDescriptor))+"&pageSize="+pageSize+"&continuationToken=" + (continuationToken==null? "" : System.Uri.EscapeDataString(continuationToken))+"&isPublic="+isPublic+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = responseMessage.Content.ReadAsStream();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TokenAdminPagedSessionTokens>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates a revocation rule to prevent the further usage of any OAuth authorizations that were created before the current point in time and which match the conditions in the rule.
		/// 
		/// Not all kinds of OAuth authorizations can be revoked directly.
		/// Some, such as self-describing session tokens, must instead by revoked by creating a rule
		/// which will be evaluated and used to reject matching OAuth credentials at authentication time.
		/// Revocation rules created through this endpoint will apply to all credentials that were issued
		/// before the datetime at which the rule was created and which match one or more additional conditions.
		/// Revocation_Rules_Create {organization}/_apis/tokenadmin/revocationrules
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The revocation rule to create. The rule must specify a space-separated list of scopes, after which preexisting OAuth authorizations that match that any of the scopes will be rejected. For a list of all OAuth scopes supported by VSTS, see: https://docs.microsoft.com/en-us/vsts/integrate/get-started/authentication/oauth?view=vsts#scopes The rule may also specify the time before which to revoke tokens.</param>
		public async Task Revocation_Rules_CreateAsync(string organization, string api_version, TokenAdminRevocationRule requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/tokenadmin/revocationrules&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates a revocation rule to prevent the further usage of any OAuth authorizations that were created before the current point in time and which match the conditions in the rule.
		/// 
		/// Not all kinds of OAuth authorizations can be revoked directly.
		/// Some, such as self-describing session tokens, must instead by revoked by creating a rule
		/// which will be evaluated and used to reject matching OAuth credentials at authentication time.
		/// Revocation rules created through this endpoint will apply to all credentials that were issued
		/// before the datetime at which the rule was created and which match one or more additional conditions.
		/// Revocation_Rules_Create {organization}/_apis/tokenadmin/revocationrules
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The revocation rule to create. The rule must specify a space-separated list of scopes, after which preexisting OAuth authorizations that match that any of the scopes will be rejected. For a list of all OAuth scopes supported by VSTS, see: https://docs.microsoft.com/en-us/vsts/integrate/get-started/authentication/oauth?view=vsts#scopes The rule may also specify the time before which to revoke tokens.</param>
		public void Revocation_Rules_Create(string organization, string api_version, TokenAdminRevocationRule requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/tokenadmin/revocationrules&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Revokes the listed OAuth authorizations.
		/// Revocations_Revoke_Authorizations {organization}/_apis/tokenadmin/revocations
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="isPublic">Set to false for PAT tokens and true for SSH tokens.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The list of objects containing the authorization IDs of the OAuth authorizations, such as session tokens retrieved by listed a users PATs, that should be revoked.</param>
		public async Task Revocations_Revoke_AuthorizationsAsync(string organization, bool isPublic, string api_version, TokenAdminRevocation[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/tokenadmin/revocations&isPublic="+isPublic+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Revokes the listed OAuth authorizations.
		/// Revocations_Revoke_Authorizations {organization}/_apis/tokenadmin/revocations
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="isPublic">Set to false for PAT tokens and true for SSH tokens.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The list of objects containing the authorization IDs of the OAuth authorizations, such as session tokens retrieved by listed a users PATs, that should be revoked.</param>
		public void Revocations_Revoke_Authorizations(string organization, bool isPublic, string api_version, TokenAdminRevocation[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/tokenadmin/revocations&isPublic="+isPublic+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
